<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>golang基础笔记（6）：结构体</title>
      <link href="/2023/02/01/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2023/02/01/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念，它通过结构体的内嵌再配合接口比一般面向对象具有更高的扩展性和灵活性。</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>Go语言中的结构体是一种自定义数据类型，它可以用来封装多个基本数据类型。结构体的英文名称叫<code>struct</code>，与C语言一样，也是通过<code>struct</code>来定义结构体。</p><p>Go语言通过结构体来实现面向对象。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>使用type和struct关键字来定义结构体，具体代码格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">city <span class="type">string</span></span><br><span class="line">age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟以往一样，相同类型字段名可以写在同一行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name, city <span class="type">string</span></span><br><span class="line">age <span class="type">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型。</p><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>当结构体实例化的时候，才会真正分配内存，且才能使用结构体的字段（类似类与对象）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例名 结构体</span><br></pre></td></tr></table></figure><h4 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h4><p>沿用我们的person结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p1 person</span><br><span class="line">p1.name = <span class="string">&quot;IceWindy&quot;</span></span><br><span class="line">p1.city = <span class="string">&quot;东莞&quot;</span></span><br><span class="line">p1.age = <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言访问结构体实例的字段，使用的是类似面向对象语言中的<code>.</code>操作符，而不是C语言中的<code>-&gt;</code>。</p><h4 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h4><p>有些时候我们仅需要临时的定义一些数据结构，这时候就可以用到匿名结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 <span class="keyword">struct</span> &#123;</span><br><span class="line">字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指针类型结构体"><a href="#指针类型结构体" class="headerlink" title="指针类型结构体"></a>指针类型结构体</h4><p>我们可以使用new关键字对结构体进行实例化，这种实例化得到的是和结构体的地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p2)     <span class="comment">//output: *main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//output: p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure><p>从终端打印的结果我们可以看出，p2是一个结构体指针。</p><p>值得注意的是，结构体指针是可以通过<code>.</code>直接访问结构体实例的字段的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2.name = <span class="string">&quot;1ce_Windy&quot;</span></span><br></pre></td></tr></table></figure><h4 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h4><p>使用<code>&amp;</code>对结构体进行取地址操作与new关键字实例化结构体是一样的效果，得到的就是一个结构体指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p3)     <span class="comment">//output: *main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p3) <span class="comment">//output: p3=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>从上面的例子我们已经看出没有初始化的结构体，内部字段均为零值。</p><h4 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a>使用键值对初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p3 := person&#123;</span><br><span class="line">name: <span class="string">&quot;IceWindy&quot;</span>,</span><br><span class="line">city: <span class="string">&quot;东莞&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//output: p3=main.person&#123;name:&quot;IceWindy&quot;, city:&quot;东莞&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><p>当某些字段暂时不需要初始值时，可以省略不写。没有指定初始值的字段的值为零值。</p><p>同样的方法也可以对<code>&amp;</code>初始化的结构体指针使用</p><h4 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a>使用值的列表初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p4 := person&#123;</span><br><span class="line"><span class="string">&quot;IceWindy&quot;</span>,</span><br><span class="line"><span class="string">&quot;东莞&quot;</span>,</span><br><span class="line"><span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p4=%#v\n&quot;</span>, p4) <span class="comment">//output: p4=main.person&#123;name:&quot;IceWindy&quot;, city:&quot;东莞&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><p>这种方法的初始化有几点需要注意</p><ul><li>必须初始化结构体内的所有字段</li><li>初始值的顺序需与结构体声明顺序一致</li><li>不能与键值对初始化方式混用</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Go语言的结构体是没有构造函数的，如果有需要我们可以自行实现。</p><p>由于<code>struct</code>的实例是值类型，如果结构体比较复杂的话，值拷贝的性能开销会很大，因此可以通过返回结构体指针的方式，减少性能开销</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *person &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">name: name,</span><br><span class="line">city: city,</span><br><span class="line">age: age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法与接收者"><a href="#方法与接收者" class="headerlink" title="方法与接收者"></a>方法与接收者</h3><p>Go语言中的方法是一种作用于特定类型变量的函数。特定类型变量被称作为<code>接收者</code>。</p><p>接收者这个概念类似于其他语言中的<code>this</code>。方法的定义格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个简单的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> personSay() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s say:Hello World\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := person&#123;</span><br><span class="line">name: <span class="string">&quot;IceWindy&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">p1.personSay()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a>指针类型的接收者</h4><p>指针类型的接收者由一个结构体的指针组成。</p><p>由于指针的特性，调用方法修改时可以修改接收者指针的任意成员变量，在方法结束后，修改都可以得以保留。这种方法更接近于其他语言中面向对象中的<code>this</code>，例如修改结构体内字段等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> SetName(name <span class="type">string</span>) &#123;</span><br><span class="line">p.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a>值类型的接收者</h4><p>当方法作用于值类型接收者时，相当于执行方法时，会克隆一份副本出来，因此任何修改都会仅针对副本，无法修改接收者变量本身</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> SetAge(age <span class="type">int8</span>) &#123;</span><br><span class="line">p.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">&quot;IceWindy&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    fmt.Println(p1.age) <span class="comment">// output:18</span></span><br><span class="line">p1.SetAge2(<span class="number">19</span>)</span><br><span class="line">    fmt.Println(p1.age) <span class="comment">// output:18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a>什么时候应该使用指针类型接收者</h4><ol><li>需要修改接收者中的值</li><li>接收者是拷贝代价比较大的大对象</li><li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li></ol><h4 id="任意类型添加方法"><a href="#任意类型添加方法" class="headerlink" title="任意类型添加方法"></a>任意类型添加方法</h4><p>不仅是结构体可以添加方法，在Go语言中，方法的接收者可以是任意类型。</p><p>举个例子，我们基于内置的<code>int</code>类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NewInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i NewInt)</span></span> SayHello() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Hello NewInt&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>不能给别的包的类型定义方法</p><h3 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h3><p>Go语言的结构体允许成员字段在声明时没有字段名只有类型。但并不是代表真正不是没有字段名，而是用类型名作为字段名，因此一个结构体中同类型的匿名字段只能有一个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">string</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := student&#123;</span><br><span class="line"><span class="string">&quot;IceWindy&quot;</span>,</span><br><span class="line"><span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s1.<span class="type">string</span>, s1.<span class="type">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h3><p>一个结构体中可以嵌套包含另一个结构体或结构体指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">person    Person</span><br><span class="line">studentID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu1 := Student&#123;</span><br><span class="line">person: Person&#123;</span><br><span class="line">name: <span class="string">&quot;IceWindy&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;,</span><br><span class="line">studentID: <span class="number">114514</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;stu1=%#v\n&quot;</span>, stu1) <span class="comment">//output: stu1=main.Student&#123;Person:main.Person&#123;name:&quot;IceWindy&quot;, age:18&#125;, studentID:114514&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌套匿名字段"><a href="#嵌套匿名字段" class="headerlink" title="嵌套匿名字段"></a>嵌套匿名字段</h4><p>上面嵌套结构体中的Person结构体也可以采用匿名字段的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Person</span><br><span class="line">studentID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu1 := Student&#123;</span><br><span class="line">Person: Person&#123;</span><br><span class="line">name: <span class="string">&quot;IceWindy&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;,</span><br><span class="line">studentID: <span class="number">114514</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;stu1=%#v\n&quot;</span>, stu1) <span class="comment">//output: stu1=main.Student&#123;Person:main.Person&#123;name:&quot;IceWindy&quot;, age:18&#125;, studentID:114514&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a>嵌套结构体的字段名冲突</h4><p>当嵌套结构体内部采用了相同的字段名，我们需要指定具体嵌套结构体的字段名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province   <span class="type">string</span></span><br><span class="line">City       <span class="type">string</span></span><br><span class="line">CreateTime <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">Account    <span class="type">string</span></span><br><span class="line">CreateTime <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="type">string</span></span><br><span class="line">Gender <span class="type">string</span></span><br><span class="line">Address</span><br><span class="line">Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">user.Name = <span class="string">&quot;IceWindy&quot;</span></span><br><span class="line">user.Gender = <span class="string">&quot;男&quot;</span></span><br><span class="line">user.Address.CreateTime = <span class="string">&quot;1145&quot;</span> </span><br><span class="line">user.Email.CreateTime = <span class="string">&quot;1145&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a>结构体的“继承”</h4><p>使用嵌套结构体的方式，可以实现其他面向对象编程语言中的继承</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> move() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Feet    <span class="type">int8</span></span><br><span class="line">    *Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> wang() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d1 := &amp;Dog&#123;</span><br><span class="line">        Feet: <span class="number">4</span>,</span><br><span class="line">        Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">            name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">    d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字段的可见性"><a href="#字段的可见性" class="headerlink" title="字段的可见性"></a>字段的可见性</h3><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p><h3 id="JSON序列化"><a href="#JSON序列化" class="headerlink" title="JSON序列化"></a>JSON序列化</h3><p>JSON序列化就是将Go语言中的数据（例如结构体实例等）转换为满足JSON格式的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">StudentID   <span class="type">int</span></span><br><span class="line">StudentName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> class <span class="keyword">struct</span> &#123;</span><br><span class="line">ClassName <span class="type">string</span></span><br><span class="line">Student   []student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newStudent</span><span class="params">(sID <span class="type">int</span>, sName <span class="type">string</span>)</span></span> student &#123;</span><br><span class="line"><span class="keyword">return</span> student&#123;</span><br><span class="line">StudentID:   sID,</span><br><span class="line">StudentName: sName,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//结构体内需要首字母大写，即对外包开放</span></span><br><span class="line">    <span class="comment">//无首字母大写的字段无法被JSON包访问</span></span><br><span class="line">c1 := class&#123;</span><br><span class="line">ClassName: <span class="string">&quot;101班&quot;</span>,</span><br><span class="line"><span class="comment">//切片需要初始化</span></span><br><span class="line">Student: <span class="built_in">make</span>([]student, <span class="number">0</span>, <span class="number">20</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">tempStu := newStudent(i, fmt.Sprintf(<span class="string">&quot;Stu%02d&quot;</span>, i))</span><br><span class="line">c1.Student = <span class="built_in">append</span>(c1.Student, tempStu)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, c1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, c1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//JSON序列化</span></span><br><span class="line">data, err := json.Marshal(c1) </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;JSON序列化失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, data)  <span class="comment">//output:[]uint8，即[]byte</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(data)) <span class="comment">//为了便于打印，需要转换为string</span></span><br><span class="line"><span class="comment">/* 经过格式化之后的结果（略作缩进）</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    &quot;ClassName&quot;:&quot;101班&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Student&quot;:[</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:0,&quot;StudentName&quot;:&quot;Stu00&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:1,&quot;StudentName&quot;:&quot;Stu01&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:2,&quot;StudentName&quot;:&quot;Stu2&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:3,&quot;StudentName&quot;:&quot;Stu03&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:4,&quot;StudentName&quot;:&quot;Stu04&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:5,&quot;StudentName&quot;:&quot;Stu05&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:6,&quot;StudentName&quot;:&quot;Stu06&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:7,&quot;StudentName&quot;:&quot;Stu07&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:8,&quot;StudentName&quot;:&quot;Stu08&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;StudentID&quot;:9,&quot;StudentName&quot;:&quot;Stu09&quot;&#125;</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//JSON反序列化:JSON字符串转换为Go语言的类型</span></span><br><span class="line">jsonStu := <span class="string">&quot;&#123;\&quot;ClassName\&quot;:\&quot;101班\&quot;,\&quot;Student\&quot;:[&#123;\&quot;StudentID\&quot;:0,\&quot;StudentName\&quot;:\&quot;Stu00\&quot;&#125;,&#123;\&quot;StudentID\&quot;:1,\&quot;StudentName\&quot;:\&quot;Stu01\&quot;&#125;]&#125;&quot;</span></span><br><span class="line">c2 := class&#123;&#125;</span><br><span class="line">    <span class="comment">//传入一个结构体指针使得可以修改结构体的内容</span></span><br><span class="line">err = json.Unmarshal([]<span class="type">byte</span>(jsonStu), &amp;c2) </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;反序列化失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, c2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体标签-Tag"><a href="#结构体标签-Tag" class="headerlink" title="结构体标签(Tag)"></a>结构体标签(Tag)</h3><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对<strong>反引号</strong>包裹起来</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`key1:&quot;value1&quot; key2:&quot;value2&quot;`</span></span><br></pre></td></tr></table></figure><p>结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间<strong>使用空格分隔</strong>，因此不要在键值之间使用空格分隔。</p><p>以下以json tag修改序列化后key的名称为例子展示Tag的作用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">ID    <span class="type">int</span>    <span class="string">`json:&quot;id&quot;`</span> <span class="comment">//通过json tag实现json序列化时得到与默认字段名不同的key</span></span><br><span class="line">Name  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Class <span class="type">string</span> <span class="comment">//默认使用字段名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := Stu&#123;</span><br><span class="line">ID:    <span class="number">1</span>,</span><br><span class="line">Name:  <span class="string">&quot;IceWindy&quot;</span>,</span><br><span class="line">Class: <span class="string">&quot;101班&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">data, err := json.Marshal(s1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;json marshal failed!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data) <span class="comment">//output:&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;IceWindy&quot;,&quot;Class&quot;:&quot;101班&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础笔记（5）：函数</title>
      <link href="/2023/01/31/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2023/01/31/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Go语言中支持函数、匿名函数和闭包。</p><p>函数在Go语言中可以作为变量、参数、返回值等等。 </p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">([参数列表])</span></span> [返回值列表] &#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>一个函数可以有0个或者多个返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在返回值列表定义返回变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="type">int</span>)</span></span> (c <span class="type">int</span>)&#123;</span><br><span class="line">    c = a+b</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">//这样做，在return处就只需要一个return即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多返回值，求商与余数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divi</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a/b, a%b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用有返回值的函数时，我们可以选择不接受它的返回值。</p><p>当我们一个函数返回值为silce时，nil可以看做是一个silce，直接返回nil即可，不需要返回一个<code>[]int&#123;&#125;</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nilFunc</span><span class="params">()</span></span> []<span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">//不需要返回[]int&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><strong>可变参数</strong></p><p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数类型前加<code>...</code>来标识。</p><p>注意：可变参数一般放在函数参数最后面。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret := sum(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">    fmt.Println(ret) <span class="comment">//output:60</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(x ...<span class="type">int</span>)</span></span> (sum <span class="type">int</span>) &#123;</span><br><span class="line">    fmt.Println(x) <span class="comment">//output:[10 20 30]</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;</span><br><span class="line">sum = sum + v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从输出的结果可以看出，可变参数x在函数体内被是视作一个int类型的切片;</p><p>但是在函数体外，可变参数不能被视作一个切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(...<span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">([]<span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line">fmt.Println(f1) <span class="comment">//output:func(...int)</span></span><br><span class="line">fmt.Println(f2) <span class="comment">//output:func([]int)</span></span><br></pre></td></tr></table></figure><p>可以看出，两种参数输出的结果是不一样的，因此我们不能直接将切片作为参数传入函数。</p><p>如果我们需要将切片传入一个可变参数的函数中，我们则需要将切片拆解为参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(sum(values...)) <span class="comment">//output:10</span></span><br></pre></td></tr></table></figure><h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num <span class="type">int</span> = <span class="number">10</span> <span class="comment">//定义全局变量num</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testGlobalVar</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(num) <span class="comment">//函数中可以访问全局变量num</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>局部变量就是仅在自己的代码块中可用的变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">localVar</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="type">int</span> = <span class="number">100</span> <span class="comment">//定义一个函数局部变量x,仅在该函数内生效</span></span><br><span class="line">fmt.Println(x)</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">        y := <span class="number">10</span></span><br><span class="line">        fmt.Println(y)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fmt.Println(y) 此时无法使用变量y</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">localVar()</span><br><span class="line"><span class="comment">//fmt.Println(x) 此时无法使用变量x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数类型与变量"><a href="#函数类型与变量" class="headerlink" title="函数类型与变量"></a>函数类型与变量</h3><h4 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h4><p>使用<code>type</code>关键字可以定义一个函数类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> calcFuncType <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure><p>上面语句定义了一个叫calcFuncType类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p><p>简而言之，凡是满足<code>接收两个int类型的参数并且返回一个int类型的返回值</code>都是calcFuncType类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x-y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面add和sub都是calcFuncType类型</p><h4 id="函数类型变量"><a href="#函数类型变量" class="headerlink" title="函数类型变量"></a>函数类型变量</h4><p>我们可以声明函数类型的变量并且为该变量赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> func1 calcFuncType</span><br><span class="line">func1 = add</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Type of func1:%T\n&quot;</span>, func1) <span class="comment">//output:Type of func1:main.calcFuncType</span></span><br><span class="line">fmt.Println(func1(<span class="number">1</span>, <span class="number">2</span>))<span class="comment">//可以像普通函数一样去调用</span></span><br><span class="line"></span><br><span class="line">func2 := sub</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Type of func2:%T\n&quot;</span>, func2) <span class="comment">//output:Type of func2:func(int, int) int</span></span><br><span class="line">fmt.Println(func2(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数分为</p><ul><li>函数作参数</li><li>函数作返回值</li></ul><h4 id="函数作参数"><a href="#函数作参数" class="headerlink" title="函数作参数"></a>函数作参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="type">int</span>/*第一第二个参数*/, op <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span><span class="comment">/*第三个参数*/</span>) <span class="type">int</span><span class="comment">/*返回值*/</span> &#123;</span><br><span class="line"><span class="keyword">return</span> op(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret1 := calc(<span class="number">10</span>, <span class="number">20</span>, add)</span><br><span class="line">ret2 := calc(<span class="number">20</span>, <span class="number">10</span>, sub)</span><br><span class="line">fmt.Println(ret1, ret2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数第一第二个参数为操作数，第三个参数为操作。</p><p>操作的函数沿用了上面例子的两个函数。</p><h4 id="函数作返回值"><a href="#函数作返回值" class="headerlink" title="函数作返回值"></a>函数作返回值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(s <span class="type">string</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> s &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> add, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> sub, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">err := errors.New(<span class="string">&quot;无法识别的操作符&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>函数内部是不能再定义一个函数的，但是匿名函数是个例外</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数)</span></span>(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数由于没有函数名，因此不能像普通函数一样调用，它需要保存到某个变量，或者立即执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存到变量</span></span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">10</span>, <span class="number">20</span>)<span class="comment">//跟普通函数一样执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//立即执行并返回值</span></span><br><span class="line">ret := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;(<span class="number">10</span>, <span class="number">20</span>)<span class="comment">//直接在后面加上实参</span></span><br><span class="line">fmt.Println(ret)</span><br></pre></td></tr></table></figure><p>匿名函数多用于实现会调函数和闭包。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包简而言之就是<code>函数+引用环境</code>。</p><p>闭包的引用环境包括了：闭包函数内部的非全局变量、常量、函数等。</p><p>下面是闭包的一个简单使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把匿名函数作为返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>+str)</span><br><span class="line">        <span class="comment">//函数体会现在内层寻找变量，找不到则会向外层找</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1 := func1() <span class="comment">//f1相当于是一个闭包，包含了匿名函数本身和外层的str</span></span><br><span class="line">f1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子非常简单，但是没能体现出闭包函数的作用。</p><p>接下来我们展示一个添加后缀名的简单函数，体会一下闭包在其中发挥的作用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addSuffixFunc</span><span class="params">(suffix <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.HasSuffix(name, suffix) &#123; <span class="comment">//检测是否有后缀</span></span><br><span class="line"><span class="keyword">return</span> name + suffix <span class="comment">//suffix为外层函数定义的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">addJPG := addSuffixFunc(<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">fmt.Println(addJPG(<span class="string">&quot;Hello&quot;</span>)) <span class="comment">//output:Hello.jpg</span></span><br><span class="line">addMP3 := addSuffixFunc(<span class="string">&quot;.mp3&quot;</span>)</span><br><span class="line">fmt.Println(addMP3(<span class="string">&quot;World&quot;</span>)) <span class="comment">//output:World.mp3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一个更复杂一点的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddSub</span><span class="params">(base <span class="type">int</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>) &#123;</span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">base += i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">base -= i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, s := AddSub(<span class="number">100</span>)</span><br><span class="line">ret1 := a(<span class="number">100</span>) <span class="comment">//base = 100(base)+100(i)</span></span><br><span class="line">fmt.Println(ret1) <span class="comment">//output:200</span></span><br><span class="line">ret2 := s(<span class="number">150</span>) <span class="comment">//base = 200(base)-150(i)</span></span><br><span class="line">fmt.Println(ret2) <span class="comment">//output:50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延迟处理defer"><a href="#延迟处理defer" class="headerlink" title="延迟处理defer"></a>延迟处理defer</h3><p>defer关键字可以让后面跟随的语句进行延迟处理。多个defer遵循栈的顺序，即先进后出的顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>Go语言中return语句在底层并不是原子操作，它分为给返回值赋值和RET指令两部。而defer语句的执行实际便是在赋值完成后，RET之前，即先完成计算然后压入栈后等待返回。</p><p>由于是将返回值提前压入栈，后续对给返回值赋值的变量作出任何修改都不会对返回值发生任何影响。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">10</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;(x)</span><br><span class="line">x++</span><br></pre></td></tr></table></figure><p>defer延迟调用的特性往往会用在处理资源释放问题上：资源清理、文件关闭、解锁及记录时间等。</p><p>推荐文章：<a href="https://blog.csdn.net/m0_46251547/article/details/123762669">https://blog.csdn.net/m0_46251547/article/details/123762669</a></p><p><strong>defer有关面试题</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="type">string</span>, a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">ret := a + b</span><br><span class="line">fmt.Println(index, a, b, ret)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">1</span></span><br><span class="line">y := <span class="number">2</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">&quot;AA&quot;</span>, x, calc(<span class="string">&quot;A&quot;</span>, x, y))</span><br><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">&quot;BB&quot;</span>, x, calc(<span class="string">&quot;B&quot;</span>, x, y))</span><br><span class="line">y = <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果是什么？</p><p>答案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A 1 2 3</span><br><span class="line">B 10 2 12</span><br><span class="line">BB 10 12 22</span><br><span class="line">AA 1 3 4</span><br></pre></td></tr></table></figure><p>由于defer注册要延迟执行的函数时<strong>该函数所有的参数都需要确定其值</strong>，因此执行步骤如下</p><ol><li>执行<code>calc(&quot;A&quot;, x, y)</code></li><li>将<code>calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))</code>压入栈</li><li>执行<code>calc(&quot;B&quot;, x, y)</code></li><li>将<code>calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))</code>压入栈</li><li><code>calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))</code>出栈</li><li><code>calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))</code>出栈</li></ol><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><table><thead><tr><th align="center">内置函数</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">close</td><td align="center">主要用来关闭channel</td></tr><tr><td align="center">len</td><td align="center">用来求长度，比如string、array、slice、map、channel</td></tr><tr><td align="center">new</td><td align="center">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td></tr><tr><td align="center">make</td><td align="center">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td></tr><tr><td align="center">append</td><td align="center">用来追加元素到数组、slice中</td></tr><tr><td align="center">panic和recover</td><td align="center">用来做错误处理</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础笔记（4）：Map</title>
      <link href="/2023/01/28/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9AMap/"/>
      <url>/2023/01/28/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9AMap/</url>
      
        <content type="html"><![CDATA[<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map是Go语言中提供的映射关系的容器类数据结构，其内部使用散列表(hash)实现。</p><p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p><h3 id="构建map"><a href="#构建map" class="headerlink" title="构建map"></a>构建map</h3><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[KeyType]ValueType</span><br></pre></td></tr></table></figure><h4 id="make"><a href="#make" class="headerlink" title="make()"></a>make()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType,[<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure><p>cap为可选参数</p><h4 id="使用字面值"><a href="#使用字面值" class="headerlink" title="使用字面值"></a>使用字面值</h4><p>map支持在声明的时候填充元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[KeyType]ValueType&#123;</span><br><span class="line">    <span class="string">&quot;Key1&quot;</span>:value1,</span><br><span class="line">    <span class="string">&quot;Key2&quot;</span>:value2,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大括号内也可以为空</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>通过使用空接口，可以在同一个map中存储不同类型的value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="comment">//string</span></span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,   <span class="comment">//int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><h4 id="追加键值对"><a href="#追加键值对" class="headerlink" title="追加键值对"></a>追加键值对</h4><p>直接通过键+值的方式就可以追加一堆键值对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m[<span class="string">&quot;李四&quot;</span>] = <span class="number">20</span></span><br><span class="line">m[<span class="string">&quot;王五&quot;</span>] = <span class="number">22</span></span><br></pre></td></tr></table></figure><h4 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h4><p>Go语言在通过Key访问键值对时，会返回两个值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br></pre></td></tr></table></figure><p>value是key所对的值，<code>ok</code>是该值是否存在，为一个bool</p><p>若值不存在，则value会得到一个0值，且ok会得到false</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scoreMap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;张三&quot;</span> : <span class="number">90</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> v, ok := scoreMap[<span class="string">&quot;张三&quot;</span>]; ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;查无此人&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历map"><a href="#遍历map" class="headerlink" title="遍历map"></a>遍历map</h4><p>Go语言中使用<code>for range</code>遍历map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scoreMap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line"><span class="string">&quot;张三&quot;</span>: <span class="number">90</span>,</span><br><span class="line"><span class="string">&quot;李四&quot;</span>: <span class="number">95</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">fmt.Print(k + <span class="string">&quot; &quot;</span>)</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> scoreMap &#123; <span class="comment">//只遍历value</span></span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>由于map本身的性质，因此遍历的顺序与添加键值对的顺序无关</p><p>有没有办法指定顺序遍历呢？是可以的。</p><h4 id="指定顺序遍历"><a href="#指定顺序遍历" class="headerlink" title="指定顺序遍历"></a>指定顺序遍历</h4><p>具体步骤：</p><ol><li>构建一个切片，将key存入</li><li>对切片排序</li><li>按照切片中key的顺序遍历map</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.构建一个切片, 并将key存入</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">200</span>)</span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">keys = <span class="built_in">append</span>(keys, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.对切片进行排序</span></span><br><span class="line">sort.Strings(keys)</span><br><span class="line"><span class="comment">//3.按照切片中key的顺序遍历map</span></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">fmt.Println(key, scoreMap[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改值"><a href="#修改值" class="headerlink" title="修改值"></a>修改值</h4><p>分为两种情况</p><ul><li><p>一般情况下，直接用下标访问修改即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] += <span class="number">10</span></span><br></pre></td></tr></table></figure></li><li><p>如果值是一个结构体等复杂结构，就不能直接修改下标访问到的结构体中的内部值，<strong>需要重新构建一个新的结构体，重新给map赋值</strong></p></li></ul><h4 id="删除键值对"><a href="#删除键值对" class="headerlink" title="删除键值对"></a>删除键值对</h4><p>使用<code>delete()</code>内建函数从map中删除一组键值对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>, key)</span><br></pre></td></tr></table></figure><p>map为要删除键值对的map，key为所对的键，例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(scoreMap, <span class="string">&quot;张三&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="切片相关"><a href="#切片相关" class="headerlink" title="切片相关"></a>切片相关</h3><h4 id="元素为map类型的切片"><a href="#元素为map类型的切片" class="headerlink" title="元素为map类型的切片"></a>元素为map类型的切片</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.切片的初始化</span></span><br><span class="line"><span class="comment">//构建了一个长度容量为3的切片，只完成了切片的初始化，map均为nil值</span></span><br><span class="line"><span class="keyword">var</span> mapSlice = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">//2.map的初始化</span></span><br><span class="line">mapSlice[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">//3.即可正常对mapSlice追加键值对</span></span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">&quot;张三&quot;</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(mapSlice)</span><br></pre></td></tr></table></figure><h4 id="值为切片类型的map"><a href="#值为切片类型的map" class="headerlink" title="值为切片类型的map"></a>值为切片类型的map</h4><p>构建一个各个国家包含的城市的map：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.map的初始化，没有完成切片的初始化</span></span><br><span class="line"><span class="keyword">var</span> sliceMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line"><span class="comment">//2.切片初始化</span></span><br><span class="line">key := <span class="string">&quot;中国&quot;</span></span><br><span class="line">sliceMap[key] = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">8</span>) <span class="comment">//长度0,容量8的</span></span><br><span class="line"><span class="comment">//3.添加元素，测试</span></span><br><span class="line">sliceMap[key] = <span class="built_in">append</span>(sliceMap[key], <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>)</span><br><span class="line">fmt.Println(sliceMap)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础笔记（3）：数组、切片</title>
      <link href="/2023/01/27/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87/"/>
      <url>/2023/01/27/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>与大多数语言中的数组都类似，Go语言的数组也是<strong>从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化</strong>。但是实际上，Go中的数组并不常用，而常用为切片。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="基础写法"><a href="#基础写法" class="headerlink" title="基础写法"></a>基础写法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="type">int</span>                        <span class="comment">//数组会初始化为int类型的零值</span></span><br><span class="line"><span class="keyword">var</span> numArray = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;                 <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line"><span class="keyword">var</span> cityArray = [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125; <span class="comment">//使用指定的初始值完成初始化</span></span><br></pre></td></tr></table></figure><h4 id="编译器判断长度"><a href="#编译器判断长度" class="headerlink" title="编译器判断长度"></a>编译器判断长度</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numArray = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> cityArray = [...]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="指定索引值"><a href="#指定索引值" class="headerlink" title="指定索引值"></a>指定索引值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := [...]<span class="type">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure><p>定义了一个含有 100 个元素的数组 <code>r</code>，最后一个元素被初始化为 -1，其它元素都是用 0 初始化</p><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p>与大多数语言一样，Go语言遍历的方式主要分为两种方法：for和for range</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">fmt.Println(a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：for range遍历</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> a &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h3><p>Go语言的数组是值类型，并不是引用类型。这导致Go语言与C、Java不同的是，Go的数组<strong>赋值和传参会复制整个数组</strong>。因此传参或是赋值，得到的新数组是原数组的一个副本，修改新数组并不会导致原数组发生变化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeArray</span><span class="params">(x [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">changeArray(a) <span class="comment">//在changeArray中修改的是a的副本x</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[10 20 30]，原数组无变化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 </li><li>在Go语言中，数组的长度也是类型的一部分，也就意味着在函数的形参处，数组长度必须要确定，这导致了<strong>输入数组的长度必须是相同的</strong>，使得数组有很多局限性</li></ol><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>前面我们提到，数组在函数形参初输入数组长度必须是相同，这导致数组有很多局限性</p><p>Go语言提供了一种非常灵活的，拥有相同类型元素的可变长度的序列——切片（Slice）。切片的概念类似于“动态数组”，它是基于数组类型做的一层封装，支持自动扩容。</p><p>切片是一个引用类型，因此从数组中得到的切片修改元素值时，原数组也会发生变化，修改原数组时，切片也会变化。切片一般用于快速地操作一块数据集合。</p><p>它的内部结构包括<code>地址</code>、<code>长度</code>、<code>容量</code>。</p><h3 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h3><p><strong>长度与容量</strong></p><p>正如上文所言，切片拥有长度和容量，这与其他语言中的数组类似。</p><p>我们可以通过内置的len()函数求得长度，通过内置的cap()函数求得容量。</p><h4 id="声明的基本语法"><a href="#声明的基本语法" class="headerlink" title="声明的基本语法"></a>声明的基本语法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 []类型</span><br></pre></td></tr></table></figure><h4 id="切片表达式构造切片"><a href="#切片表达式构造切片" class="headerlink" title="切片表达式构造切片"></a>切片表达式构造切片</h4><p>切片表达式可以从字符串、数组、指向数组或切片的指针构造子字符串或切片。</p><p>它具有两种形式：</p><ol><li>指定low和high两个索引界限值的简单形式——<code>low:high</code></li><li>除了low和high索引界限值外还指定容量的完整形式——<code>low:high:max</code></li></ol><p><strong>简单形式</strong></p><p>我们通过表达式中的low和high就可以确定数组中的索引范围，为一个左包含，右不包含。得到的切片长度为<code>high-low</code>，容量等于切片的底层数组的容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Printf(<span class="string">&quot;s:%v len(s):%v cap(s):%v\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"><span class="comment">//s:[2 3] len(s):2 cap(s):4</span></span><br></pre></td></tr></table></figure><p>在切片表达式中，我们可以省略任何索引：</p><ul><li>省略low为从0开始</li><li>省略high为到切片操作数的长度</li></ul><p><strong>注意</strong>：对于切片再切片，high上线边界为原切片的容量cap(a)，而不是长度。</p><p><strong>完整形式</strong></p><p>对于数组，指向数组的指针，或切片（不支持字符串）支持完整切片表达式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low:high:max]</span><br></pre></td></tr></table></figure><p>该表达式会构建一个与<code>a[low:high]</code>同类型、同长度、同元素，但是容量会被设置为<code>max-low</code>的切片。</p><p>在完整切片表达式中，只有第一个索引值<code>low</code>可以省略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">t := a[<span class="number">1</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="string">&quot;t:%v len(t):%v cap(t):%v\n&quot;</span>, t, <span class="built_in">len</span>(t), <span class="built_in">cap</span>(t))</span><br><span class="line"><span class="comment">//t:[2 3] len(t):2 cap(t):4</span></span><br></pre></td></tr></table></figure><h4 id="make-函数构造切片"><a href="#make-函数构造切片" class="headerlink" title="make()函数构造切片"></a>make()函数构造切片</h4><p>切片表达式都是基于现有数组来创建的切片，如果我们需要动态的创建一个切片，则我们需要用到内置的<code>make()</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, size, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p>其中，T为切片的元素类型，size为元素长度，cap为容量</p><p>可以只指定长度，也开也长度容量都指定</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">uint32</span>)</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">uint32</span>, <span class="number">1</span>)</span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="type">uint32</span>, <span class="number">1</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="切片的性质"><a href="#切片的性质" class="headerlink" title="切片的性质"></a>切片的性质</h4><p><strong>判断切片是否为空</strong></p><p>要检查切片是否为空，请使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p><p>没有底层数组的切片值为<code>nil</code>，一个nil切片长度和容量都为0，但是长度和容量都为0的切片不一定是nil：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span>         <span class="comment">//len(s1)=0;cap(s1)=0;s1==nil</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;&#125;        <span class="comment">//len(s2)=0;cap(s2)=0;s2!=nil</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) <span class="comment">//len(s3)=0;cap(s3)=0;s3!=nil</span></span><br></pre></td></tr></table></figure><p>因此，要判断一个切片是否为空，要使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断</p><p><strong>切片不能直接相互比较</strong></p><p>切片之间是不能直接相互比较的，我们不能使用<code>==</code>判断两个切片是否含有相同的元素。</p><p>切片唯一合法的比较操作是和<code>nil</code>比较。若要比较，则只能通过枚举比较的方式进行比较。</p><p>对于<code>[]byte</code>，可以使用标准库提供的<code>bytes.Equal</code>函数比较。</p><h3 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h3><p>切片的本质是对底层数组的封装。它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p><p>例子：数组<code>a := [8]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</code>，切片<code>s1 := a[:5]</code>，相应示意图如下：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202301281540207.png" alt="slice_01"></p><p>切片<code>s2 := a[3:6]</code>，相应示意图如下：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202301281544254.png" alt="slice_02"></p><h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>通过<code>append()</code>函数可以向切片的底层数组中追加元素，可以添加0个或多个元素，并且切片的底层数组会自动扩容。</p><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要<strong>用原变量接收append函数的返回值</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">uint32</span>, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// 3 4</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// 6 8</span></span><br></pre></td></tr></table></figure><p>如果需要追加其他切片或数组，可以在需添加的切片后面<code>...</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">append</span>(s, s1...)</span><br></pre></td></tr></table></figure><h4 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h4><p>切片遍历与数组遍历是相同的，支持：</p><ul><li>索引遍历<code>for</code></li><li><code>for index, value := range s</code></li></ul><h4 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h4><p>通过下标指定即可修改。</p><p>注意：在使用for range时，不能通过直接修改遍历所使用的变量，因为range赋值得到的变量是一份副本，并不是引用。例如：<code>for k,v:= range s</code>，只能通过修改s[k]，而不能直接修改v。</p><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>截取需要留下部分的，在赋值给原切片即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s[:<span class="number">2</span>], s[<span class="number">3</span>:]...)</span><br></pre></td></tr></table></figure><h4 id="切片拷贝"><a href="#切片拷贝" class="headerlink" title="切片拷贝"></a>切片拷贝</h4><p><strong>引用拷贝</strong></p><p>直接使用<code>=</code>操作符赋值的拷贝，新切片得到的是引用拷贝，原切片与新切片所指向的底层数组为同一个数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>) <span class="comment">//[0 0 0]</span></span><br><span class="line">s2 := s1             <span class="comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span></span><br><span class="line">s2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(s1)  <span class="comment">//[100 0 0]</span></span><br><span class="line">fmt.Println(s2)   <span class="comment">//[100 0 0]</span></span><br></pre></td></tr></table></figure><p><strong>值拷贝</strong></p><p>如果我们需要拷贝一个值相同的切片，则我们需要用到<code>copy()</code>函数，该函数可以将原数组切片复制到新的数组切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(newSlice, oldSlice)</span><br></pre></td></tr></table></figure><p>如果两个数组切片不一样大，则会按照较小的一个数组切片的元素个数进行赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; </span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(s2, s1) <span class="comment">// 只会复制s1的前3个元素到s2中 </span></span><br><span class="line"><span class="built_in">copy</span>(s1, s2) <span class="comment">// 只会复制s2的3个元素到s1的前3个位置</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础笔记（2）：程序结构</title>
      <link href="/2023/01/18/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
      <url>/2023/01/18/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><p>从每个语言学习的开始讲起：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello golang&quot;</span>)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>每个Go程序都是由包构成，每个项目都是从<code>main</code>包作为入口的。</p><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>使用<code>import</code>语句导入包，在<code>Hello World</code>程序中，我们导入了<code>fmt</code>包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure><p>常常的，我们在写程序时都会遇到需要导入多个包的情况，在Golang中，我们有两种形式导入多个包：</p><p>第一种是多个import</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br></pre></td></tr></table></figure><p>我们还可以选择将多个包用括号括起来在一个import中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>值得注意的一点：**<code>import</code>语句只对当前文件有效**</p><h3 id="导出名"><a href="#导出名" class="headerlink" title="导出名"></a>导出名</h3><p>在Java中，我们用<code>public</code>和<code>private</code>关键词来标记一个方法是包外是否可用的。</p><p>而在Go中，使用了首字母大小写来表示这个，大写字母则代表public的。例如在我们的第一个程序中的Println就是一个以大写字母开头的。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>新建一个hello在目录下，并在下面新建一个Sayhello.go文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello golang&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;No Hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将mian.go修改为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;golang_basic/hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hello.SayHello()</span><br><span class="line">    hello.noHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对其运行会发现报错了，因为noHello并不是一个可以在包外调用的函数。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>如果你在使用一些智能的IDE，在输入func进行补全的时候，你会发现func的模板与我们学过的语言都不同的地方，它在参数列表后面，会有一个可以填入的地方</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202301181804873.png" alt="image-20230118180440834"></p><p>这是因为go的函数声明与其它的语言稍微有些不同</p><h3 id="声明模板"><a href="#声明模板" class="headerlink" title="声明模板"></a>声明模板</h3><p>基本函数声明模板如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名 <span class="params">(参数列表)</span></span> (返回值列表)&#123;</span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line"><span class="keyword">return</span> 返回值列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它相较其它大多数语言，Go多了一个返回值列表</p><p>Go在函数声明上还有一个不同的点就是Go的参数是名称在前，类型在后</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于上面的例子，参数的类型是相同的，所以我们可以将其类型写在一起</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多值返回"><a href="#多值返回" class="headerlink" title="多值返回"></a>多值返回</h3><p>Go语言支持多个返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h3><p>在返回值列表中，我们可以将返回值命名。我们在给返回值赋值后，可以在最后使用一个return就可以返回所有定义的返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">ans = x + y</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="声明、初始化"><a href="#声明、初始化" class="headerlink" title="声明、初始化"></a>声明、初始化</h3><p>在前面我们提到go的函数内参数是名称在前，类型在后的，变量的声明也不例外</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br></pre></td></tr></table></figure><p>类型与表达式可以省略一个;</p><ul><li>类型省略则会根据表达式自动推断类型</li><li>表达式省略则会自动初始化该变量为该类型的零值</li></ul><p>前面我们提到Go语言支持多值返回，因此一组变量也可以通过接受函数返回值进行初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b = swap(a, b)</span><br></pre></td></tr></table></figure><p>在接受的时候，我们可以通过下划线抛弃我们不需要的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, _ = swap(a, b)</span><br></pre></td></tr></table></figure><p>声明也可以像import一样，用括号括起来</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="短声明"><a href="#短声明" class="headerlink" title="短声明"></a>短声明</h3><p>短声明<code>:=</code>相当于是一个省略类型的声明语句，可以替代var使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 := 表达式</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b := swap(a, b)</span><br></pre></td></tr></table></figure><p>符号</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>Go语言的赋值与大多数语言（C，Java…)的赋值都类似</p><p>相较于C、Java一类，Go语言加入了一个比较“摩登”的赋值，元祖赋值，一个例子就是上马的接受函数的多变量初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure><p>这使得交换两个变量的值不再需要一个中间存储值，这极大便利了变量的交换，减少了不少逻辑上思考的步骤</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>Go语言的指针与C语言中的指针使用的方法大致相同，也都是通过<code>*</code>、<code>&amp;</code>来对地址进行操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 *类型</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a *<span class="type">int</span>        <span class="comment">//指向整型</span></span><br><span class="line"><span class="keyword">var</span> b *<span class="type">float32</span>    <span class="comment">//指向浮点型</span></span><br><span class="line"></span><br><span class="line">c := <span class="number">1</span></span><br><span class="line">d := &amp;c           <span class="comment">//我们也可以通过短声明来创建</span></span><br></pre></td></tr></table></figure><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>当一个指针定义后没有分配给任何变量时，他的值为<code>nil</code></p><p>nil 指针也称为空指针</p><p>nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="type">int8</span>  <span class="type">int16</span>  <span class="type">int32</span>  <span class="type">int64</span> <span class="comment">//有符号整型</span></span><br><span class="line"><span class="type">uint</span> <span class="type">uint8</span> <span class="type">uint16</span> <span class="type">uint32</span> <span class="type">uint64</span> <span class="type">uintptr</span> <span class="comment">//无符号整型</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="comment">//类似uint8</span></span><br><span class="line"></span><br><span class="line"><span class="type">rune</span> <span class="comment">//类似int32</span></span><br><span class="line"></span><br><span class="line"><span class="type">float32</span> <span class="type">float64</span> <span class="comment">//单精度浮点 双精度浮点</span></span><br><span class="line"></span><br><span class="line"><span class="type">complex64</span> <span class="type">complex128</span> <span class="comment">//实数和虚数</span></span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Go语言<code>不提供类型自动转换</code>，只可以通过<code>T(v)</code>的方式将值v转换为类型T</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="type">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="type">uint</span> = <span class="type">uint</span>(f)</span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类似于define，在编译的时候会全部替换掉</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DataTYPE = <span class="type">string</span></span><br></pre></td></tr></table></figure><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>可以基于已有类型定义初新的类型，互相可以强制转换，可以添加类型自己的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> newtype <span class="type">string</span></span><br></pre></td></tr></table></figure><h2 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于是省略了小括号</p><p>注意：大括号为必须存在的</p><p>在Go语言中，是<code>没有while</code>的，while可以用省略起始条件和后置语句的for替代</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而无限循环则为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-range"><a href="#for-range" class="headerlink" title="for range"></a>for range</h3><p><code>for range</code>类似于<code>for in</code>。在Go语言中，我们可以使用<code>for range</code>遍历数组、切片、字符串、map及通道（channel）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123; <span class="comment">//在数组中，key代表下标，value为对应的值</span></span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，key和value都是可以省略的</p><p>如果我们想只读取一个参数，我们可以有两种形式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> oldMap</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> oldMap</span><br></pre></td></tr></table></figure><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sqrt(-x) + <span class="string">&quot;i&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprint(math.Sqrt(x))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Sprint()的作用相当于是拼接字符串</span></span><br></pre></td></tr></table></figure><p>Go语言允许在条件表达式之前，执行一个语句</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>v</code>的作用域是在if这个代码块内的</p><p>else与else if的用法也很简单</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> _, _ = fmt.Scan(&amp;a); a &gt; <span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;a &gt; 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a == <span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;a = 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;a &lt; 10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>对比 C 的 <code>switch</code>，更新了以下几点：</p><ul><li><p><code>case</code> 现在不一定要是常量，也可以是表达式</p></li><li><p>每个分支都是默认 <code>break</code> 的，如果你不想跳出，可以以 <code>fallthrough</code> 语句结束</p></li><li><p>支持多条件匹配</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>举个完整的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;Go run on &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;OS X&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;GNU/Linux&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, os)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202301262157237.png" alt="image-20230126215725209"></p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p><code>defer</code> 语句会将函数推迟到外层函数返回之后执行</p><p>推迟调用的函数其参数会立即求值，但会被压入栈中，直到外层函数返回时才会按照后进先出的顺序出栈</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202301262211498.png" alt="image-20230126221101474"></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础笔记（1）：环境配置</title>
      <link href="/2023/01/18/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/01/18/golang%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Golang安装"><a href="#Golang安装" class="headerlink" title="Golang安装"></a>Golang安装</h2><p>Go语言支持大部分常见系统与处理器架构：</p><ul><li>Linux</li><li>MacOS</li><li>Windows</li><li>…</li></ul><p>我们可以前往Golang的官方网站<a href="https://go.dev/dl/">下载</a>对应安装包或者二进制包</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202301181520285.png" alt="image-20230118152006239"></p><p>本文以Linux平台作为演示，类Unix使用二进制包安装的流程大致相同</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202301281449255.png" alt="image-20230128144902213"></p><p>步骤大致如下</p><ol><li><p>下载二进制包 go1.x.x.linux-amd64.tar.gz</p></li><li><p>进入保存的文件夹，将二进制包解压到&#x2F;usr&#x2F;local目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -C /usr/local -xzf go1.x.x.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>将&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin目录添加到PATH环境变量下：</p><p>直接使用命令只能临时添加，因此我们选用编辑终端的配置文件，首先我们需要确定自己的终端配置文件是哪个</p><p>我是zsh终端，因此我们需要修改~&#x2F;.zshrc，将命令添加到该文件末尾（最好做上注释）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#golang</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/go/bin</span><br></pre></td></tr></table></figure></li><li><p>测试</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202301181541611.png" alt="image-20230118154146591"></p><p>安装完成！</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础笔记（3）：基本数据类型</title>
      <link href="/2023/01/09/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/01/09/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><p>在上个笔记中，我们提及了Python中的六个标准的数据类型：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><h2 id="Number-数字"><a href="#Number-数字" class="headerlink" title="Number 数字"></a>Number 数字</h2><p>Python3 支持 <strong>int、float、bool、complex（复数）</strong>。</p><p>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p><p>在 <code>Python3.6+</code> 中书写很大的数时，可以在任意位置加入下划线，使数字更清晰易读，但是请注意Python3中的数字是<strong>没有限制大小的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">universe_age= <span class="number">14_000_000_000</span></span><br></pre></td></tr></table></figure><p>bool 是 int 的子类，True 和 False 可以和数字相加， <code>True==1、False==0</code> 会返回<code>True</code>，但可以通过<code>is</code>来判断类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>而其他三种则为三种不同的数值类型</p><h3 id="三种数"><a href="#三种数" class="headerlink" title="三种数"></a>三种数</h3><ol><li><strong>整型( <code>int</code> )</strong> ： 通常被称为整型或整数</li><li><strong>浮点型( <code>float</code> )</strong> ： 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示 <code>2.5e2</code></li><li><strong>复数( <code>complex</code> )</strong> ： 复数由实数部分和虚数部分构成，可以用 <code>a + bj</code>,或者 <code>complex(a,b)</code> 表示，<code>a</code> 和 <code>b</code> 都将以浮点型存储</li></ol><h3 id="互相转换"><a href="#互相转换" class="headerlink" title="互相转换"></a>互相转换</h3><ul><li><strong><code>int(x)</code></strong> 将<code>x</code>转换为一个整数。</li><li><strong><code>float(x)</code></strong> 将<code>x</code>转换到一个浮点数。</li><li><strong><code>complex(x)</code></strong> 将<code>x</code>转换到一个复数，实数部分为 <code>x</code>，虚数部分为 <code>0</code></li><li><strong><code>complex(x, y)</code></strong> 将 <code>x</code> 和 <code>y</code> 转换到一个复数，实数部分为 <code>x</code>，虚数部分为 <code>y</code></li></ul><h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><p>常见的有七种：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> + <span class="number">4</span>  <span class="comment"># 加法</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4.3</span> - <span class="number">2</span> <span class="comment"># 减法</span></span><br><span class="line"><span class="number">2.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">7</span>  <span class="comment"># 乘法</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> / <span class="number">4</span>  <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> // <span class="number">4</span> <span class="comment"># 除法，得到一个整数</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span> <span class="comment"># 取余</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">5</span> <span class="comment"># 乘方</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure><h3 id="二、八、十六进制"><a href="#二、八、十六进制" class="headerlink" title="二、八、十六进制"></a>二、八、十六进制</h3><h4 id="表示法"><a href="#表示法" class="headerlink" title="表示法"></a>表示法</h4><ul><li>二进制 ： <code>b</code>；<code>0b110011</code></li><li>八进制： <code>o</code>；<code>0o56432</code></li><li>十六进制： <code>x</code>；<code>0xF765A</code></li></ul><h4 id="互相转换-1"><a href="#互相转换-1" class="headerlink" title="互相转换"></a>互相转换</h4><ul><li><strong><code>int(&quot;x&quot;, y)</code></strong> 将x转换为y进制</li><li><strong><code>bin(x)</code></strong> 将x转换为二进制</li><li><strong><code>hex(x)</code></strong> 将x转换为十六进制</li><li><strong><code>oct(x)</code></strong> 将x转换为八进制</li></ul><h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h2><p>Python中的字符串用单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来，同时使用反斜杠<code>\</code>转义特殊字符。</p><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>字符串的截取的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量[头下标:尾下标]</span><br></pre></td></tr></table></figure><p>下标值以 0 为开始值，-1 为从末尾的开始位置。</p><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p>Python使用反斜杠<code>\</code>转义特殊字符</p><p>如果要使反斜杠不发生转义，则可以在字符串前加<code>r</code>，表示原始字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;hello\nworld&#x27;</span>)</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r&#x27;hello\nworld&#x27;</span>)</span><br><span class="line">hello\nworld</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>字符串可以用+运算符连接在一起，用*运算符重复</li><li>Python中的字符串不能改变，不能向一个索引位置赋值，例如<code>word[0] = &#39;m&#39;</code>会导致错误</li></ol><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><h4 id="格式符"><a href="#格式符" class="headerlink" title="%格式符"></a><code>%</code>格式符</h4><p>与大多数语言的<code>printf()</code>类似，但是他是以%后接的形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;今天是%d月%d日,天气%s&quot;</span> % (<span class="number">1</span>, <span class="number">10</span>, <span class="string">&quot;阴&quot;</span>)</span><br><span class="line"><span class="string">&#x27;今天是3月5日,天气阴&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a><code>format</code>方法</h4><p>format方法有三种格式化方式</p><ul><li><p>按位置顺序填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hw = <span class="string">&quot;hello &#123;&#125;&#123;&#125;&#123;&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(hw.<span class="built_in">format</span>(<span class="string">&quot;wo&quot;</span>,<span class="string">&quot;rl&quot;</span>,<span class="string">&quot;d!&quot;</span>))</span><br></pre></td></tr></table></figure></li><li><p>按索引值填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hw = <span class="string">&quot;hello &#123;2&#125;&#123;0&#125;&#123;1&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(hw.<span class="built_in">format</span>(<span class="string">&quot;d!&quot;</span>,<span class="string">&quot;wo&quot;</span>,<span class="string">&quot;rl&quot;</span>))</span><br></pre></td></tr></table></figure></li><li><p>按照关键词填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hw = <span class="string">&quot;hello &#123;a&#125;&#123;b&#125;&#123;c&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(hw.<span class="built_in">format</span>(<span class="string">&quot;wo&quot;</span>,<span class="string">&quot;rl&quot;</span>,<span class="string">&quot;d!&quot;</span>))</span><br></pre></td></tr></table></figure></li></ul><h4 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a><code>f-string</code></h4><p>f-string称之为字面量格式化字符串，类似于JS框架中的<code>&#123;&#123; var &#125;&#125;</code>。</p><p>它以<code>f</code>开头，后面跟着字符串，字符串中的表达式用大括号<code>&#123;&#125;</code>包起来，它会将变量或表达式计算后的值替换进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;Hello <span class="subst">&#123;name&#125;</span>&#x27;</span>  <span class="comment"># 替换变量</span></span><br><span class="line"><span class="string">&#x27;Hello Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;<span class="number">1</span>+<span class="number">2</span>&#125;</span>&#x27;</span>         <span class="comment"># 使用表达式</span></span><br><span class="line"><span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;w[<span class="string">&quot;name&quot;</span>]&#125;</span>: <span class="subst">&#123;w[<span class="string">&quot;url&quot;</span>]&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">&#x27;Runoob: www.runoob.com&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h3><p>下表实例变量 <code>a</code> 值为字符串 <code>&quot;Hello&quot;</code>，<code>b</code> 变量值为 <code>&quot;Python&quot;</code></p><table><thead><tr><th>操作符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td><code>+</code></td><td>字符串连接</td><td><code>a + b</code> 输出结果： <code>HelloPython</code></td></tr><tr><td><code>*</code></td><td>重复输出字符串</td><td><code>a*2</code> 输出结果：<code>HelloHello</code></td></tr><tr><td><code>[]</code></td><td>通过索引获取字符串中字符</td><td><code>a[1]</code> 输出结果 <code>e</code></td></tr><tr><td><code>[ : ]</code></td><td>截取字符串</td><td><code>a[1:4]</code> 输出结果 <code>ell</code></td></tr><tr><td><code>in</code></td><td>成员运算符 - 如果字符串中包含给定的字符返回 <code>True</code></td><td><code>&#39;H&#39; in a</code> 输出结果 <code>True</code></td></tr><tr><td><code>not in</code></td><td>成员运算符 - 如果字符串中不包含给定的字符返回 <code>True</code></td><td><code>&#39;M&#39; not in a</code> 输出结果 <code>True</code></td></tr><tr><td><code>==</code>、<code>!=</code></td><td>两个字符串是否完全相等</td><td><code>a!=b</code> 输出结果 <code>True</code></td></tr><tr><td><code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code> 、<code>&lt;=</code></td><td>依次比较<code>ACSII码</code></td><td><code>a&lt;b</code> 输出结果 <code>True</code></td></tr></tbody></table><h2 id="List-列表"><a href="#List-列表" class="headerlink" title="List 列表"></a>List 列表</h2><p>List（列表） 是 Python 中使用最频繁的数据类型。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><p>列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><h3 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h3><p>使用中括号 <code>[]</code> 将各个元素括起来即可，元素类型可不相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>]</span><br><span class="line">diffList = [ <span class="string">&#x27;abc&#x27;</span>, <span class="number">123</span>, [<span class="string">&#x27;456&#x27;</span>]]</span><br></pre></td></tr></table></figure><h3 id="列表截取"><a href="#列表截取" class="headerlink" title="列表截取"></a>列表截取</h3><p>列表截取的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量[头下标:尾下标]</span><br></pre></td></tr></table></figure><p>索引值以 <strong>0</strong> 为开始值，**-1** 为从末尾的开始位置，留空为直到最前或者最后一个元素。</p><h3 id="列表操作符"><a href="#列表操作符" class="headerlink" title="列表操作符"></a>列表操作符</h3><ul><li><p>组合 <code>+</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] + [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]) <span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></li><li><p>重复 ‘*’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] * <span class="number">2</span>) <span class="comment"># [1, 2, 3, 1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p>判断是否存在列表中 <code>in / not in</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="number">3</span> <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span> (<span class="number">3</span> <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="函数与方法"><a href="#函数与方法" class="headerlink" title="函数与方法"></a>函数与方法</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul><li><code>len(list)</code> 列表元素个数</li><li><code>max(list)</code> 返回列表元素最大值</li><li><code>min(list)</code> 返回列表元素最小值</li><li><code>list(seq)</code> 将元组转换为列表</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><strong>增加</strong></p><ul><li><code>list.append(obj)</code> 在列表末尾添加新的对象</li><li><code>list.extend(seq)</code> 在列表末尾追加另一个序列中的多个值</li><li><code>list.insert(index, obj)</code> 将对象插入列表</li></ul><p><strong>删除</strong></p><ul><li><code>list.pop(index)</code> 移除列表中的一个元素，默认是最后一个，并返回值（栈的pop）</li><li><code>list.remove(obj)</code> 移除列表中该对象的第一个匹配值 </li><li><code>list.clear()</code> 清空列表</li></ul><p><strong>查找</strong></p><ul><li><code>list.index(obj)</code> 查找该对象的第一个匹配值的索引位置</li></ul><p><strong>修改</strong></p><ul><li><code>list.reverse()</code> 反向列表中的元素</li><li><code>list.sort(key=Nome, reverse=False)</code> 对列表排序</li><li>直接根据索引修改</li></ul><p><strong>统计与复制</strong></p><ul><li><code>list.count(obj)</code> 统计对象出现的次数</li><li><code>list.copy()</code> 复制列表</li></ul><h2 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple 元组"></a>Tuple 元组</h2><p>元组与列表类似，区别在于元组的元素不能修改。</p><h3 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h3><p>元组写在小括号 <strong>()</strong> 里，元素之间用逗号隔开</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = (<span class="string">&#x27;abc&#x27;</span>, <span class="number">123</span>, (<span class="number">456</span>,))</span><br></pre></td></tr></table></figure><p>元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取。</p><p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p><h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><ul><li><p>string、list 和 tuple 都属于 sequence（序列）</p></li><li><p>构造包含只有一个元素的元组需要在后面添加逗号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="number">123</span>,)</span><br></pre></td></tr></table></figure></li><li><p>元组也可以使用+操作符进行拼接</p></li></ul><h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h2><p>Python中的集合与数学概念的集合类似，集合中的每一个元素都是独一无二的，是一个<strong>无序不重复</strong>元素的序列；</p><p>由于集合是无序的，因此它不会以特定的顺序储存元素，遍历里面的元素所提取出来的元素的顺序也是不定的。</p><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><p>创建集合有两种方法</p><ul><li><p>使用大括号 <code>&#123;&#125;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> = &#123;var1, var2, ...&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>set()</code>函数</p><p>该函数可以将其他类型转换为集合或者创建一个空集合。由于<code>&#123; &#125;</code>是用于创建一个空的字典的，所以空集合只能通过set()来创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">set</span>(<span class="string">&quot;12345&quot;</span>) <span class="comment"># 字符串转集合</span></span><br><span class="line">b = <span class="built_in">set</span>([<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>]) <span class="comment"># 列表转集合</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># [&#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><p>集合的运算与数学中的运算类似</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202301111518317.png" alt="img"></p><p>在python中提供了多种运算符与方法进行集合的运算</p><table><thead><tr><th>运算符 &#x2F; 方法</th><th>描述</th></tr></thead><tbody><tr><td><code>S &amp; T</code> 或 <code>S.intersaction(T)</code></td><td><strong>交集</strong>。返回一个新集合,包括同时在集合 S 和 T 中的元素</td></tr><tr><td>&#96;S</td><td>T<code>或</code>S.union(T)&#96;</td></tr><tr><td><code>S - T</code> 或 <code>S.difference(T)</code></td><td><strong>差集</strong>。返回一个新集合,包括在集合 S 中但不在集合 T 中的元素</td></tr><tr><td><code>S ^ T</code>或 <code>s.symmetric_difference(T)</code></td><td>补集。返回一个新集合,包括集合 S 和 T 中的元素,但不包括同时在其中的元素</td></tr><tr><td><code>s &lt;= T</code> 或 <code>S.issubset(T)</code></td><td><strong>判断子集</strong>。如果 S 与 T 相同或 S 是 T 的子集,返回 True ,否则返回 False 。可以用 S &lt; T 判断 S 是否是 T 的真子集</td></tr><tr><td><code>S &gt;= Т</code> 或 <code>S.issuperset(T)</code></td><td><strong>判断超集</strong>。如果 S 与 T 相同或 S 是 T 的超集,返回 True ,否则返回 False 。可以用 S &gt; T 判断 S 是否是 T 的真超集</td></tr></tbody></table><h3 id="集合其他内置方法"><a href="#集合其他内置方法" class="headerlink" title="集合其他内置方法"></a>集合其他内置方法</h3><p><strong>统计元素个数</strong></p><ul><li><code>set.len()</code></li></ul><p><strong>添加</strong></p><ul><li><code>set.add(obj, ...)</code> 将单个元素添加至集合中</li><li><code>set.update(seq, ...)</code> 添加一个序列（列表、元组、字典）</li></ul><p><strong>删除</strong></p><ul><li><code>set.remove(obj)</code> 移除一个元素，找不到时会报错</li><li><code>set.discard(obj)</code> 移除一个元素，但是找不到时不会报错</li><li><code>set.pop()</code> 随机移除一个元素，并返回他的值</li><li><code>set.clear()</code> 清空集合</li></ul><p><strong>复制</strong></p><ul><li><code>set.copy()</code></li></ul><p><strong>判断是否存在</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">in</span> s</span><br></pre></td></tr></table></figure><h2 id="Dictionary-字典"><a href="#Dictionary-字典" class="headerlink" title="Dictionary 字典"></a>Dictionary 字典</h2><p>字典是一种依靠<strong>键值对</strong>存储数据的容器类模型</p><h3 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h3><p>字典的每个键值<code>key=&gt;value</code>对用冒号<code>:</code>分割，每个对之间用逗号<code>,</code>分割，整个字典包括在花括号<code>&#123;&#125;</code>中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;IceWindy&#x27;</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.icewindy.cn&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>一般而言，为了让代码更可读，我们会写成多行的形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;IceWindy&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.icewindy.cn&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问字典"><a href="#访问字典" class="headerlink" title="访问字典"></a>访问字典</h3><h4 id="key-x3D-gt-value"><a href="#key-x3D-gt-value" class="headerlink" title="key&#x3D;&gt;value"></a>key&#x3D;&gt;value</h4><ul><li><p>直接使用key当索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">personInfo = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="string">&#x27;hobby&#x27;</span>: [<span class="string">&#x27;reading&#x27;</span>, <span class="string">&#x27;running&#x27;</span>, <span class="string">&#x27;swimming&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(personInfo[<span class="string">&#x27;name&#x27;</span>]) <span class="comment"># Tom</span></span><br><span class="line"><span class="built_in">print</span>(personInfo[<span class="string">&#x27;age&#x27;</span>]) <span class="comment"># 18</span></span><br><span class="line"><span class="built_in">print</span>(personInfo[<span class="string">&#x27;hobby&#x27;</span>]) <span class="comment"># [&#x27;reading&#x27;, &#x27;running&#x27;, &#x27;swimming&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>get()</code></p><p><code>get()</code>的第一个参数是要查询的键，第二个参数是键不存在时返回的默认值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">personInfo = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;student&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">job = personInfo.get(<span class="string">&#x27;job&#x27;</span>, <span class="string">&quot;Tom didn&#x27;t have a job yet!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(job) <span class="comment"># student</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> personInfo[<span class="string">&#x27;job&#x27;</span>]</span><br><span class="line">job = personInfo.get(<span class="string">&#x27;job&#x27;</span>, <span class="string">&quot;Tom didn&#x27;t have a job yet!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(job) <span class="comment"># Tom didn&#x27;t have a job yet!</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>使用<code>for...in dict.items()/key()/values()</code>即可遍历，后面的三个方法分别是遍历key与value，key，value的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key , value <span class="keyword">in</span> favoriteLanguages.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Key: &#x27;</span>+key+<span class="string">&#x27; Value: &#x27;</span>+value)</span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> favoriteLanguages.values():</span><br><span class="line">    <span class="built_in">print</span>(language)</span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> favoriteLanguages.values():</span><br><span class="line">    <span class="built_in">print</span>(language)</span><br></pre></td></tr></table></figure><h3 id="改变字典"><a href="#改变字典" class="headerlink" title="改变字典"></a>改变字典</h3><h4 id="添加、修改"><a href="#添加、修改" class="headerlink" title="添加、修改"></a>添加、修改</h4><p>添加与修改的方式都一样，通过<code>字典名[键]=值</code>的方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">favoriteLanguages = &#123;</span><br><span class="line">    <span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sarch&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">favoriteLanguages[<span class="string">&#x27;mike&#x27;</span>] = <span class="string">&#x27;java&#x27;</span> <span class="comment">#添加</span></span><br><span class="line">favoriteLanguages[<span class="string">&#x27;jen&#x27;</span>] = <span class="string">&#x27;java&#x27;</span> <span class="comment">#修改</span></span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除一对键值对的方式通过<code>del 字典名[键]</code>方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> favoriteLanguages[<span class="string">&#x27;jen&#x27;</span>] </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础笔记（2）：基础语法</title>
      <link href="/2023/01/05/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/01/05/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>Python中的标识符规则与大多数语言都类似：</p><ul><li>第一个字符必须是字母表中字母或下划线 <strong>_</strong> 。</li><li>标识符的其他的部分由字母、数字和下划线组成。</li><li>标识符对大小写敏感。</li><li>在Python3中非ASCII标识符也受允许，例如中文</li></ul><p>与其他语言不同的是，Python中标识符前后的下划线是具有特殊含义的，起着Java等语言中public等关键词的作用：</p><ul><li><p>单下划线开头 _var</p><p>说明是仅供内部使用的方法变量，举个例子</p><p>首先创建一个test.py模块，包含了一个带下划线和不带下划线的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;NO Hello&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着我们去引用这个模块，并分别调用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202301062053313.png" alt="image-20230106205354270"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">_func()</span><br></pre></td></tr></table></figure><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202301062054431.png" alt="image-20230106205451409" style="zoom:80%;" /><p>这时候它告诉我们 _func 没有定义，它只能被模块内部使用。</p></li></ul><h2 id="简单输入输出"><a href="#简单输入输出" class="headerlink" title="简单输入输出"></a>简单输入输出</h2><p>使用<code>input()</code>与<code>print()</code>实现在命令行窗口简单输入输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入内容：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你输入的内容是：&quot;</span>，<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><p>与其他语言不同的是，<code>print()</code>默认是换行输出的，如果需要实现不换行，则需要额外多一个参数<code>end=&quot;&quot;</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>Python与其他语言相比最大的特色之一就是以缩进标识代码结构，而不使用大括号、分号等。</p><p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;False&quot;</span>)</span><br></pre></td></tr></table></figure><p>以下代码最后一行语句缩进数的空格数不一致，会导致运行错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span> (<span class="string">&quot;False&quot;</span>)    <span class="comment"># 缩进不一致，会导致运行错误</span></span><br></pre></td></tr></table></figure><p>不要混用制表符Tab与空格，虽然他们有时候看起来是一样的，但是在Python看起来，他们是不一样的缩进，因此也会让程序无法正常运行。</p><p>Python也可也在同一行显示多段代码，使用分号<code>;</code>即可达到该效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys; x = <span class="string">&#x27;runoob&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>函数之间或者类的方法之间用空格分割，表示为一段新的代码的开始，类与函数入口也用一行空格分割，以分辨开始。</p><p>空格作为分割虽然不是Python语法的一部分，即使不使用空格，解释器也不会出错，但是IDE会给出提示，而且这在划分两段不同功能或含义的方式，可以便于日后代码的维护或者重构。</p><h3 id="一句话分多行"><a href="#一句话分多行" class="headerlink" title="一句话分多行"></a>一句话分多行</h3><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以在行末使用续行符（反斜杠<code>\</code>）来实现多行语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure><p>在 <code>[]</code>, <code>&#123;&#125;</code>, 或 <code>()</code> 中的多行语句，不需要使用反斜杠 <code>\</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="引入模块和函数"><a href="#引入模块和函数" class="headerlink" title="引入模块和函数"></a>引入模块和函数</h2><p>在 Python 用 <code>import</code> 或者 <code>from...import</code> 来导入相应的模块</p><ul><li>将整个模块导入，格式为： <code>import somemodule</code></li><li>从某个模块中导入某个函数,格式为： <code>from somemodule import somefunction</code></li><li>从某个模块中导入多个函数,格式为： <code>from somemodule import firstfunc, secondfunc, thirdfunc</code></li><li>将某个模块中的全部函数导入，格式为： <code>from somemodule import *</code></li></ul><h2 id="变量与赋值"><a href="#变量与赋值" class="headerlink" title="变量与赋值"></a>变量与赋值</h2><p>python中，每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><p>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p><h3 id="单个变量赋值"><a href="#单个变量赋值" class="headerlink" title="单个变量赋值"></a>单个变量赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">counter = <span class="number">100</span>          <span class="comment"># 整型变量</span></span><br><span class="line">miles   = <span class="number">1000.0</span>       <span class="comment"># 浮点型变量</span></span><br><span class="line">name    = <span class="string">&quot;HelloWorld&quot;</span>     <span class="comment"># 字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (counter)</span><br><span class="line"><span class="built_in">print</span> (miles)</span><br><span class="line"><span class="built_in">print</span> (name)</span><br></pre></td></tr></table></figure><h3 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;HelloWorld&quot;</span></span><br></pre></td></tr></table></figure><h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><p>Python3 中有六个标准的数据类型：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><p>Python3 的六个标准数据类型中，分为两种数据，一种为只能被整体重新赋值的“不可变数据”，另外一种是可以改变其中一部分的“可变数据”：</p><ul><li><strong>不可变数据（3 个）：</strong> Number（数字）、String（字符串）、Tuple（元组）</li><li><strong>可变数据（3 个）：</strong> List（列表）、Dictionary（字典）、Set（集合）</li></ul><h3 id="判断变量的对象类型"><a href="#判断变量的对象类型" class="headerlink" title="判断变量的对象类型"></a>判断变量的对象类型</h3><h4 id="使用-type-来查询"><a href="#使用-type-来查询" class="headerlink" title="使用 type() 来查询"></a>使用 <code>type()</code> 来查询</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="literal">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(b), <span class="built_in">type</span>(c), <span class="built_in">type</span>(d))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;bool&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;complex&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="使用-isinstance-来判断"><a href="#使用-isinstance-来判断" class="headerlink" title="使用 isinstance() 来判断"></a>使用 <code>isinstance()</code> 来判断</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">111</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(a, <span class="built_in">int</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="判断与循环"><a href="#判断与循环" class="headerlink" title="判断与循环"></a>判断与循环</h2><h3 id="If"><a href="#If" class="headerlink" title="If"></a>If</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;condition_1&gt;:</span><br><span class="line">    &lt;statement_1&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;condition_2&gt;:</span><br><span class="line">    &lt;statement_2&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statement_3&gt;</span><br></pre></td></tr></table></figure><h3 id="For"><a href="#For" class="headerlink" title="For"></a>For</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure><p><code>break</code> 和 <code>continue</code> 在 <code>for</code> 中有效，<code>else</code> 为可选</p><h3 id="While"><a href="#While" class="headerlink" title="While"></a>While</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;condition&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure><p><code>break</code> 和<code>continue</code> 在 <code>While</code> 中有效，<code>else</code> 为可选</p>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础笔记（1）：简介、环境部署</title>
      <link href="/2023/01/03/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E7%AE%80%E4%BB%8B%E3%80%81%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/01/03/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E7%AE%80%E4%BB%8B%E3%80%81%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="Python简介"><a href="#Python简介" class="headerlink" title="Python简介"></a>Python简介</h2><p>Python是一门解释性语言，简单易学，上手容易。</p><p>因此作为一门胶水语言，在许多非计算机专业都有广泛学习。为了可以编写一些简单的脚本，学习Python还是有一定的必要性的。</p><p>本笔记基本内容为根据</p><ul><li>Python3</li><li>菜鸟教程 <a href="https://www.runoob.com/python3/python3-tutorial.html">Python3 教程 | 菜鸟教程 (runoob.com)</a></li><li>NX的博客 <a href="https://www.nickxu.top/tags/Python/">Python | NX の 博客 (nickxu.top)</a></li></ul><p>所编写。</p><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><p>前往官网<a href="https://www.python.org/">Python.org</a>下载最新的Python安装包，按流程安装。</p><p>在代码编辑器上有两个推荐，一个是VSCode，一个是Pycharm：</p><p>VSCode在拓展应用商店安装Python插件与Code Runner插件即可</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202301050111564.png" alt="image-20230105011136451"></p><p>Pycharm的配置与安装不再赘述，向导非常详细，遵循向导即可</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202301050113086.png" alt="image-20230105011313028"></p><p>当然，作为一个解释型语言，我们也可以在命令行中进行交互式的编程，但是这种方式并不是很常用。</p>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust基础笔记（1）：基础结构</title>
      <link href="/2022/12/04/Rust%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/"/>
      <url>/2022/12/04/Rust%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>此笔记为在学习Rust圣经《The Rust Programming Language》时记录的笔记，为基础学习</p><p>中文版书籍：<a href="https://kaisery.github.io/trpl-zh-cn/title-page.html">Rust 程序设计语言 - Rust 程序设计语言 简体中文版 (kaisery.github.io)</a></p><p>安装过程不再赘述，可直接参考Rust官方网站的安装过程</p><p>官方网站地址：<a href="https://www.rust-lang.org/">Rust Programming Language (rust-lang.org)</a></p><p>本人开发环境为：</p><ul><li>ManjaroWSL2</li><li>Clion</li></ul><p>学习Rust纯属为个人一时兴起，本笔记随时弃坑。</p><h2 id="一个简单的Rust程序"><a href="#一个简单的Rust程序" class="headerlink" title="一个简单的Rust程序"></a>一个简单的Rust程序</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess:&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line.&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Your guessed: &#123;guess&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202212050122081.png" alt="image-20221205012227933"></p><p>这个程序的逻辑很简单，就是处理用户的输入，把用户的输入进行输出。</p><p>但是这个程序拥有了Rust程序的基本结构，我们从上直下解析这个程序：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br></pre></td></tr></table></figure><p>为了获取的用户输入，我们需要导入输入输出库(input &#x2F; output)，即<code>io</code>库。<code>io</code>库来自于标准库，即<code>std</code>。这个操作类似于c语言的<code>include</code>，或者是Java的<code>import</code>。</p><p>在默认的情况下，Rust会自动导入部分标准库到每个程序作用域，这部分被称为<code>预导入</code>，若我们所需要用的不在其中，则需要我们手动使用<code>use</code>显式导入。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br></pre></td></tr></table></figure><p><code>fn</code>用于声明新函数，main函数是程序的入口点。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Please input your guess:&quot;</span>);</span><br></pre></td></tr></table></figure><p>在这里<code>println!</code>用于在屏幕中打印字符串。</p><p><strong>注意：</strong>它并不是一个函数，而是一个宏，<code>!</code>的基本上都是宏。</p><p><strong>使用变量存储值</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = String::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure><p>在这里我们创建了一个空的字符串变量用于存储输入，我们注意到，与很多常见的编程语言不同，我们申明用了两个关键词<code>let mut</code>：</p><p>这是因为Rust中，<code>变量默认是不可变的</code>，因此我们如果使用<code>let guess</code>的话，会使得<code>guess</code>类似其他编程语言中的常量一样，不可变，因此我们还要通过<code>mut</code>关键词使得变量可变。</p><p><code>=</code>是在告诉Rust，我们想将某个值<code>绑定</code>在变量上。因此我们将<code>String::new()</code>的结果绑定到了<code>guess</code>上，它的结果是一个<code>String</code>的新实例。</p><p><code>::new()</code>注意，这里的new()并不是String的特定函数，而是一个跟Java静态方法一样的<code>关联函数</code>。在这里<code>::</code>就表明了new是String的关联函数。new函数是<code>创建类型实例的惯用函数</code>。</p><p><strong>接受输入与异常处理</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">   .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">   .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line.&quot;</span>);</span><br></pre></td></tr></table></figure><p>现在我们调用一开始导入的<code>io</code>库中的函数接受用户的输入，我们使用了<code>stdin</code>函数，<code>stdin</code>函数返回了一个<code>std::io::Stdin</code>的实例，这是终端标准输入句柄类型。</p><p><code>.read_line(&amp;mut guess)</code>调用了<code>read_line</code>方法，从句柄中获取到用户的一行输入，并将其<code>追加</code>到参数中，因为我们传入的参数应该是可变的。</p><p><code>&amp;</code>代表了<strong>引用</strong>，它使得程序中不同处的代码可以访问同一处的数据。它与变量相同，默认都是不可变，因此我们需要将其写成<code>&amp;mut guess</code>以使其可变。</p><p><code>.expect(&quot;Failed to read line.&quot;)</code>的作用就是异常处理。<code>read_line</code>会返回一个<code>Result</code>类型，<code>Result</code>是一个枚举类型，其中包含了<code>Ok</code>与<code>Err</code>，分别代表操作成功与失败。</p><p><code>Result</code>类型的实例拥有一个expect方法，若<code>Result</code>实例的值为<code>Err</code>，expect方法会导致程序崩溃，并显示expect中传入的值，若<code>Result</code>实例的值为<code>Ok</code>，则会原样返回<code>Ok</code>中的值。</p><p><strong>占位符打印值</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Your guessed: &#123;guess&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>这行代码打印了保存在guess变量中用户输入的值。里面的<code>&#123;&#125;</code>为一个预留给变量类的占位符号，我们除了把变量直接写在<code>&#123;&#125;</code>中，我们还可以在双引号的外面按顺序写值，这个跟c类似，应该不陌生：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure><p>第一个占位符使用第一个值，第二个占用符使用第二个值…以此类推。</p><h2 id="引入Crate实现更多功能"><a href="#引入Crate实现更多功能" class="headerlink" title="引入Crate实现更多功能"></a>引入Crate实现更多功能</h2><p><code>Crate</code>是一个Rust代码包，是Rust在编译时最小的代码单位，它有两种形式，<code>二进制Crate</code>和<code>库Crate</code>：</p><p><code>二进制Crate</code>是一个可执行的程序，比如我们写的<code>一个简单的Rust程序</code>。它们必须要一个<code>main函数</code>来确定程序的入口；</p><p><code>库Crate</code>与其他编程语言中的<code>library</code>概念一致，包含了可以被其他程序使用的代码，它们提供了一些诸如函数之类的东西，使得其他项目能够使用。它们并不能自执行。</p><hr><p>上面我们介绍了<code>Crate</code>，下面我们要用到一个外部的<code>库Crate</code>来完善我们的程序。</p><p><code>一个简单的Rust程序</code>编写了一个让用户输入，然后程序输出用户的输入的程序，从<code>println!</code>的内容我们可以看出我们并不是想做出一个这么简单的程序，我们是想让用户来猜我们的神秘数字。</p><p>为了生成一个随机的神秘数字，我们需要用到随机数，Rust标准库中尚未包含随机数的功能，但是我们可以引入包含随机数功能的<code>rand</code>库Crate。</p><p>我们需要去修改<em>Cargo.toml</em>文件，引入一个<code>rand</code>引用，现在我们将下面一行添加到<code>[dependencies]</code>下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.8.3&quot;</span></span><br></pre></td></tr></table></figure><p>现在我们不修改任何代码，构建项目，我们会发现Cargo帮我们下载了<code>rand</code>和它依赖的一系列库Crate，Cargo会帮我们检测需要新增的Crate和我们是否修改了代码，并帮我完成下载与构建。</p><p>在<em>Cargo.toml</em>中的依赖版本信息，并不是指定某一个版本，而是一个区间——一个大于等于0.8.3且小于0.9.0的版本。</p><p>为了我们的构建结果是<strong>可以被任何人复刻</strong>的，<em>Cargo.lock</em>文件会帮助每个人的Cargo只会使用指定的依赖版本，除非手动去指定其他版本。我们会将<em>Cargo.lock</em>纳入版本控制中，以保证每个人都可以复刻这个构建结果。</p><p>在<strong>确实</strong>需要更新Crate的版本时，我们还可以通过<code>Cargo update</code>忽视<em>Cargo.lock</em>文件，并重新计算符合<em>Cargo.toml</em>声明的最新版本，将其更新且写入到<em>Cargo.lock</em>文件中。</p><hr><p>让我们开始使用<code>rand</code>来生成一个随机数字，修改我们的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..=<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The secret number is: &#123;&#125;&quot;</span>, secret_number);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;guess&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们依旧是从上往下看我们新增的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rng;</span><br></pre></td></tr></table></figure><p>这里导入了属于rand包里的一个<code>trait</code>——<code>Rng</code>。<code>trait</code>概念类似于其他语言中的接口，里面会定义很多方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..=<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>这里调用了<code>rand::thread_rng()</code>函数，提供</p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim自用使用指南</title>
      <link href="/2022/11/18/vim%E8%87%AA%E7%94%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2022/11/18/vim%E8%87%AA%E7%94%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="vim模式"><a href="#vim模式" class="headerlink" title="vim模式"></a>vim模式</h2><p>vim主要分为几种模式：<code>普通、命令、插入、可视</code></p><p>其中普通模式是vim启动时默认的模式，非普通模式之间的切换，需要回到普通模式才能进行切换。</p><ul><li><p>普通模式 –&gt; 插入模式：通过<code>i、a、o</code>等进入</p><p><code>i</code>在光标前插入        <code>I</code>在行首插入</p><p><code>o</code>在下一行插入        <code>O</code>在上一行插入</p><p><code>a</code>在光标后插入        <code>A</code>在行尾插入</p></li><li><p>插入模式 –&gt; 普通模式：通过<code>ESC</code>退出插入模式</p><p>由于<code>ESC</code>键较远，往往的我们会映射一些键作为<code>ESC</code>，例如<code>j j</code>、<code>CapsLock</code>等，这个可以根据个人喜好来进行映射</p></li><li><p>普通模式 –&gt; 可视模式：通过<code>v</code>进入</p></li><li><p>可视模式 –&gt; 普通模式：通过<code>ESC</code>或者再按一边<code>v</code>退出</p></li><li><p>普通模式 –&gt; 命令模式：通过<code>:</code>进入</p></li><li><p>命令模式 –&gt; 普通模式：命令以回车结束运行，或者通过<code>ESC</code>退出</p></li></ul><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><p>vim的光标移动均是在普通模式下移动的</p><p>以<code>字符</code>为单位（类似方向键）的光标移动是使用<code>hjkl</code>进行移动</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211181323643.png" alt="image-20221118132303565"></p><p>以<code>单词</code>为单位的移动</p><ul><li><code>w</code>(word)跳到下一个单词的开头</li><li><code>b</code>(begin)跳到本单词或上一个单词开头</li><li><code>e</code>(end)跳到本单词或下一个单词的结尾</li><li><code>ge</code>跳到上一个单词的结尾</li></ul><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211181342981.png" alt="image-20221118134249940"></p><p>以<code>行</code>为单位的移动</p><ul><li><code>0</code>跳到行首</li><li><code>^</code>跳到行首开始的第一个非空字符</li><li><code>$</code>跳到行尾</li><li><code>gg</code>跳到第一行</li><li><code>G</code>跳到最后一行</li></ul><p><code>跳转</code>到同一行下一个指定字符    <code>&#123;char&#125;</code>为<strong>一个</strong>字符</p><ul><li><code>f&#123;char&#125;</code>光标跳到下个<code>&#123;char&#125;</code></li><li><code>F&#123;char&#125;</code>光标跳到上个<code>&#123;char&#125;</code></li><li><code>t&#123;char&#125;</code>光标跳到下个<code>&#123;char&#125;</code>前一个字符的位置 &#x2F;&#x2F;不常用</li><li><code>T&#123;char&#125;</code>光标跳到上个<code>&#123;char&#125;</code>的后一个字符的位置 &#x2F;&#x2F;不常用</li><li><code>;</code>重复上次跳转操作</li><li><code>,</code>反向查找上次的查找命令</li></ul><h2 id="操作符与动作"><a href="#操作符与动作" class="headerlink" title="操作符与动作"></a>操作符与动作</h2><p>操作符也是在普通模式下进行使用。</p><p><code>操作符</code>是在告诉vim我们要干什么</p><p>主要有四个操作符：</p><ul><li><p><code>d</code>(delete)    删除</p><p><code>dd</code>删除一行 <code>ndd</code>删除n行，n为数字</p></li><li><p><code>c</code>(change)    修改（删除并进入插入模式）</p><p><code>cc</code>删除一行并进入插入模式 <code>ncc</code>删除n行并进入插入模式，n为数字</p></li><li><p><code>y</code>(yank)    复制</p><p><code>yy</code>复制一行</p></li><li><p><code>v</code>(visual)    选中并进入<code>VISUAL</code>(可视)模式</p></li></ul><p><code>动作</code>是告诉vim我们要怎么做，在使用操作符后，我们在的字符处的光标会变成半高的符号，接下来我们加上<code>动作</code>，注意：再键入一次的<code>d</code>也是一个动作</p><p>动作同样是有<code>i</code>和<code>a</code>两个，它们实际上代表的意思是<code>inner</code>和<code>around</code></p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211190123728.png" alt="image-20221119012302660"></p><p>它们主要的区别是<code>包含(i)与不包含(a)两边的符号</code></p><p>一些<strong>常见</strong>的<code>动作motion</code></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iw  :  当前单词</span><br><span class="line">aw  :  当前单词及一个空格</span><br><span class="line">iW  :  当前字符串</span><br><span class="line">aW  :  当前字符串及一个空格</span><br><span class="line">is  :  当前句子</span><br><span class="line">as  :  当前句子及一个空格</span><br><span class="line">ip  :  当前段落</span><br><span class="line">ap  :  当前段落及一个空行</span><br></pre></td></tr></table></figure><p> 以<code>d</code>(delete)操作符常用的示例有</p><ul><li><code>diw</code>删除当前单词</li><li><code>di( / dib</code>删除当前小括号内的所有内容 注：<code>b是(的替代</code></li><li><code>da&#123; / daB</code>删除当前包括大括号在内的所有内容 注：<code>B是&#123;的替代</code></li><li><code>df&#123;char&#125;</code>删除当前直到{char}处的内容</li><li><code>d^ / d$</code>删除当前直到开头(^) &#x2F; 结尾处($)的内容</li><li><code>die</code>删除整个文件的内容</li><li><code>dit</code>删除一个HTML标签内的全部内容</li></ul><p>一些额外的补充</p><ul><li><code>p</code>(paste)粘贴</li><li><code>u</code>(undo)撤回一个操作符+动作</li></ul><p>上面讲的主要是<code>d、c、y</code>三个操作符，这三个操作符比较相似，接下来我们说<code>v</code></p><p><code>v</code>操作符是进入一个选择的模式，可以快速进入选择模式，进入后可以在后面添加我们的动作，如<code>d</code>删除选中的，<code>iw</code>选中一个单词等等</p><h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><p>大小写转换比较简单</p><ul><li><code>~</code>将光标下的字母改变大小写</li><li><code>&#123;n&#125;~</code>将光标位置开始的{n}个字母改变大小写</li><li><code>g~~</code>改变当前行字母的大小写</li><li><code>gUU</code>将当前行的字母改成大写</li><li><code>guu</code>将当前行的字母改成小写</li><li><code>gUiw(gUaw)</code>将光标下的单词改成大写</li><li><code>guiw(guaw)</code>将光标下的单词改成小写</li></ul><p>大小写转换也可以配合<code>v</code>操作符一起使用，在<code>v</code>操作符选中后，再使用<code>U</code>转换为大写，或者使用<code>u</code>转换为小写</p><h2 id="开发Tips"><a href="#开发Tips" class="headerlink" title="开发Tips"></a>开发Tips</h2><ul><li><p><code>gd</code>(goto definition)查看函数实现</p></li><li><p><code>gh</code>(goto hover)类似于鼠标悬浮查看的效果</p></li><li><p><code>gt</code>往后跳转标签页    <code>gT</code>往前跳转标签页    <code>&#123;n&#125;gt</code>跳转到第{n}个标签页</p></li><li><p><code>ctrl+0</code>跳转到资源管理器侧边栏，其他数字代表不同页面</p><p><code>space</code>展开文件夹、打开文件</p></li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="Easymotion"><a href="#Easymotion" class="headerlink" title="Easymotion"></a>Easymotion</h3><p><code>easymotion</code>是vim的一个插件，在vscode的vim插件默认自带了这个插件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;vim.easymotion&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>通过这个来开启，在默认给出的配置文件，该插件是启用的</p><p>这个插件增加了<strong>快速跳转</strong>的功能，通过<code>&lt;leader&gt;</code>加上一些动作来完成操作，在vscode的vim的默认配置文件中，<code>&lt;leader&gt;</code>的默认指定为<code>&lt;space&gt;</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;vim.leader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s&quot;</span></span><br></pre></td></tr></table></figure><p>我们通过这个可以修改<code>&lt;leader&gt;</code>使用的按键，使用快速跳转模式后，都会出现类似的界面</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211191904810.png" alt="image-20221119190436775" style="zoom:50%;" /><p>以上示例是在使用<code>&lt;leader&gt;&lt;leader&gt;b</code>出现的界面，我们按下我们想跳转位置的有颜色的字母即可跳转到对应位置</p><p>它的具体用法有以下几种</p><ul><li><p><strong>前后位置跳转</strong></p><p><code>&lt;leader&gt;&lt;leader&gt;w</code>(word)当前光标<strong>后面</strong>位置的单词开头</p><p><code>&lt;leader&gt;&lt;leader&gt;b</code>(back)当前光标<strong>前面</strong>位置的单词开头</p></li><li><p><strong>搜索跳转</strong></p><p><code>&lt;leader&gt;&lt;leader&gt;s&#123;char&#125;</code>(search)搜索全部{char}的位置</p><p><code>&lt;leader&gt;&lt;leader&gt;f&#123;char&#125;</code>搜索当前光标<strong>后面</strong>全部{char}的位置</p><p><code>&lt;leader&gt;&lt;leader&gt;F&#123;char&#125;</code>搜索当前光标<strong>前面</strong>全部{char}的位置</p></li></ul><p>还有很多种用法，可以前往官方提供的文档进行查看</p><p><strong>在实际使用中</strong>，<code>&lt;leader&gt;&lt;leader&gt;w/b</code>已经涵盖了大部分场景，几乎用不上其他用法</p><h3 id="vim-surround"><a href="#vim-surround" class="headerlink" title="vim-surround"></a>vim-surround</h3><p>这个插件的主要作用是对含括类符号（<code>&#123;&#125;、（）、&quot;&quot;等</code>）添加了动作 <code>s</code>–&gt;<code>surround</code>(环绕)</p><ul><li><p><code>ds&#123;char&#125;</code>删除两边的{char}</p></li><li><p><code>cs&#123;char1&#125;&#123;char2&#125;</code>将两边的{char1}替换为{char2}</p></li><li><p><code>ys&#123;motion&#125;&#123;char&#125;</code>在动作{motion}选中的部分两端添加{char}</p></li><li><p><code>S&#123;char&#125;</code>在v模式下用{char}括起来选中的</p></li><li><p><code>gs&#123;char&#125;</code>在v模式下用{char}括起来选中的，括号内文本做新一行</p><p>例：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello world!` =&gt;</span><br><span class="line">`Hello &#123;`</span><br><span class="line">  `world`</span><br><span class="line">`&#125;!</span><br></pre></td></tr></table></figure></li></ul><h2 id="建议参考文档、视频"><a href="#建议参考文档、视频" class="headerlink" title="建议参考文档、视频"></a>建议参考文档、视频</h2><p><a href="https://github.com/ahrencode/Miscellaneous/blob/master/vim-cheatsheet.pdf">https://github.com/ahrencode/Miscellaneous/blob/master/vim-cheatsheet.pdf</a></p><p><a href="https://www.bilibili.com/video/BV1z541177Jy/">指尖飞舞：vscode + vim 高效开发（系列视频）_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Web开发基础（5）：盒模型</title>
      <link href="/2022/11/17/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%EF%BC%9A%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/11/17/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%EF%BC%9A%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>所有的HTML元素都可以看作如下图的盒子</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211160154006.png" alt="image-20221116015359980"></p><p>margin:外边距    border:边框    padding:内边距</p><p>CSS盒模型本身是一个盒子，封装HTML元素</p><p>它包括了四个属性，<strong>外边距</strong>、<strong>边框</strong>、<strong>内边距</strong>、<strong>内容</strong>，通过设定盒子的四个属性，我们做到布局与设计网页</p><p>当我们指定一个元素CSS的宽度width和高度heigh属性的时候，我们设定的是<strong>内容</strong>部分的宽度和高度。一个完整的元素的，应当还<strong>包括了内边距，边框和外边距</strong></p><p>因此，一个元素的<strong>宽度的计算公式</strong>应该是</p><p><code>宽度 + 左内边距 + 右内边距 + 左边框 + 右边框 + 左外边距 + 右外边距</code></p><p>而一个元素的<strong>高度的计算公式</strong>为</p><p><code>高度 + 顶部内边距 + 底部内边距 + 上边框 + 下边框 + 上外边距 + 下外边距</code></p><h3 id="边框border"><a href="#边框border" class="headerlink" title="边框border"></a>边框border</h3><p><code>border</code>这个属性实际上是<code>border-width</code>、<code>border-style</code>、<code>border-color</code>的简写属性，即<code>粗细、样式、颜色</code>三个属性</p><p>粗细的设置就是使用<code>px、rem</code>等等用于粗细上的值来设定边框粗细</p><p>样式的值可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style">border-style - CSS（层叠样式表） | MDN (mozilla.org)</a>中的表格，在简写状态下，边框只能四边均为一种样式</p><p>颜色的值可以使用颜色名字(red)、RGB值(rgb(255,0,0))、指定的16进制值(#ff0000)</p><p><strong>单独设置各边：</strong></p><p>上述的三个值均可以单独一行设置，可以指定边进行变化</p><p>它们指定上下左右的方式为<code>border-边-属性</code></p><p>属性对应的便是<code>width</code>、<code>style</code>、<code>color</code></p><p>边的可以有</p><ul><li>top - 上边</li><li>right - 右边</li><li>bottom - 下边</li><li>left - 左边</li></ul><p>它们均有简写的方式，可以具有1-4个值</p><ul><li>一个值时，作用于<code>所有边框</code></li><li>两个值时，依次作用于<code>上下边</code>、<code>左右边</code></li><li>三个值时，依次作用于<code>上边</code>、<code>左右边</code>、<code>下边</code></li><li>四个值时，依次作用于<code>上边</code>、<code>右边</code>、<code>下边</code>、<code>左边</code>，即顺时针</li></ul><h3 id="内边距padding-外边距margin"><a href="#内边距padding-外边距margin" class="headerlink" title="内边距padding 外边距margin"></a>内边距padding 外边距margin</h3><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211171815667.png" alt="image-20221117181527620"></p><p>内边距和外边距跟边框很相似，同样具有上下左右，也同样遵循简写的方式</p><ul><li>一个值时，作用于<code>所有边框</code></li><li>两个值时，依次作用于<code>上下边</code>、<code>左右边</code></li><li>三个值时，依次作用于<code>上边</code>、<code>左右边</code>、<code>下边</code></li><li>四个值时，依次作用于<code>上边</code>、<code>右边</code>、<code>下边</code>、<code>左边</code>，即顺时针</li></ul><p>通过外边距，我们可以实现<code>居中</code>的效果：</p><p>外边距可以设定为auto值，这样就可以做到居中的效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto</span><br></pre></td></tr></table></figure><p>上面css语句的意思是讲上下外边距设置为0，左右边距设置为居中</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web三板斧 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发基础（4）：层次选择器(组合器)、浮动</title>
      <link href="/2022/11/12/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%EF%BC%9A%E5%B1%82%E6%AC%A1%E9%80%89%E6%8B%A9%E5%99%A8(%E7%BB%84%E5%90%88%E5%99%A8)%E3%80%81%E6%B5%AE%E5%8A%A8/"/>
      <url>/2022/11/12/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%EF%BC%9A%E5%B1%82%E6%AC%A1%E9%80%89%E6%8B%A9%E5%99%A8(%E7%BB%84%E5%90%88%E5%99%A8)%E3%80%81%E6%B5%AE%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="层次选择器-x2F-组合器"><a href="#层次选择器-x2F-组合器" class="headerlink" title="层次选择器  &#x2F;  组合器"></a>层次选择器  &#x2F;  组合器</h2><p>除了基础选择器，我们还可以用层级选择器，或者叫组合器</p><p>由于HTML文档大体上呈现一种层次的结构：<code>html文档 --&gt; body --&gt; 各级标签...</code></p><p>我们就可以利用这种层次的关系来对HTML文档格式化</p><p>示例文档：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>s1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>h3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>h3&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>s2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>四<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>初始样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后代组合器"><a href="#后代组合器" class="headerlink" title="后代组合器"></a>后代组合器</h3><p><code> &quot; &quot;</code>（空格）组合器选择前一个元素的后代元素。语法<code>A B</code>，将匹配位于A元素之内任意位置的B元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#9999cc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211171526773.png" alt="image-20221117152654747"></p><h3 id="直接后代组合器"><a href="#直接后代组合器" class="headerlink" title="直接后代组合器"></a>直接后代组合器</h3><p><code>&gt;</code>组合器选择前一个元素的<code>直接后代</code>元素。语法<code>A &gt; B</code>，将仅选择位于A次级的B元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#9999cc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211171527018.png" alt="image-20221117152713996"></p><h3 id="一般兄弟组合器"><a href="#一般兄弟组合器" class="headerlink" title="一般兄弟组合器"></a>一般兄弟组合器</h3><p><code>~</code>组合器选择后一个元素在前一个元素后面的任意位置，并拥有同一父元素。语法<code>A ~ B</code>，将选择在同一父元素下，A元素后的所有B元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> ~ <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#9999cc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211171527825.png" alt="image-20221117152726797"></p><h3 id="紧邻兄弟组合器"><a href="#紧邻兄弟组合器" class="headerlink" title="紧邻兄弟组合器"></a>紧邻兄弟组合器</h3><p><code>+</code>组合器选择相邻元素，并拥有同一父元素。语法<code>A + B</code>，将选择同一父元素下，紧邻A的B元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> + <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#9999cc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211171527246.png" alt="image-20221117152737210"></p><h2 id="浮动-float"><a href="#浮动-float" class="headerlink" title="浮动 float"></a>浮动 float</h2><p><strong>参考文章：</strong></p><p><a href="https://www.cnblogs.com/iyangyuan/archive/2013/03/27/2983813.html">经验分享：CSS浮动(float,clear)通俗讲解 - 杨元 - 博客园 (cnblogs.com)</a></p><p>float可以键入的值</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>元素向左浮动</td></tr><tr><td>right</td><td>元素向右浮动</td></tr><tr><td>none</td><td>默认值。元素不浮动</td></tr><tr><td>inherit</td><td>从父元素继承float的值</td></tr></tbody></table><h3 id="浮动的理解"><a href="#浮动的理解" class="headerlink" title="浮动的理解"></a>浮动的理解</h3><p>div为块级元素，在默认情况下，div会在页面独占一行，自上而下的排列，也就是文档的<strong>标准流</strong></p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211151810667.png" alt="image-20221115181012615"></p><p>如上，我们发现box3、box4虽然看起来可以在一行内放下，但是box4依旧不会排在box3后面，因为标准流中的div元素会在页面中独立一行</p><p>如果我们需要在一行内显示多个div元素来达到布局的效果，那么标准流很明显无法满足这个要求，这里我们就需要用到<strong>浮动</strong></p><p><strong>浮动可以理解为让某个div元素脱离标准流，漂浮在标准流之上，和标准流不是一个层次</strong></p><p>假如我们这时候让box2<strong>向左浮动（float:left）</strong>，会出现这样的情况</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211151846159.png" alt="image-20221115184611117"></p><p>box3被box2挡住了一部分。因为box2<strong>脱离了标准流</strong>，而box1、box3、box4依然存在标准流中，因此box3、box4自动向上移动，到达了box2原本所在的位置，形成新的标准流</p><p>如果我们将box2<strong>向右浮动（float:right）</strong>，就会出现这种效果</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211151851581.png" alt="image-20221115185103550"></p><p>很显然验证了我们上面的说法。</p><p>如果我们将多个盒子都进行浮动，那出现的效果会是怎么样的呢？</p><p>我们将box2、box3都向左浮动：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211152002728.png" alt="image-20221115200224687"></p><p>box3接在了box2后面，box4上移到了box1下面与box1形成新的标准流。</p><p>如果我们尝试不将相邻的两个box都设置为浮动，会出现什么情况？将box2和box4都设置为向左浮动，会出现这种情况：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211152057181.png" alt="image-20221115205730142"></p><p>box4没有上移与box2相接，接在了box3的<strong>下面</strong>，我们再来看看将box2和box4设置为向右浮动：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211152058413.png" alt="image-20221115205852383"></p><p>得到了上面的图的分离版本，因此我们可以得到一个<strong>结论</strong>：</p><blockquote><p>假如某个div元素A是浮动的，如果A元素上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。</p><p>div的顺序是HTML代码中div的顺序决定的。</p><p>靠近页面边缘的一端是前，远离页面边缘的一端是后。</p></blockquote><p>为了更清晰明了，我将其分了一下点</p><ul><li><p>A为浮动的div元素</p></li><li><p>A的上一个div元素B是浮动，则A会<strong>跟随C后</strong></p></li><li><p>A的上一个div元素C是标准流中的元素，则A<strong>顶部与C的底部在同一平面</strong></p></li><li><p><strong>div的顺序</strong>是由div在<strong>HTML文档中顺序</strong>决定</p></li><li><p><strong>跟随的顺序</strong>是根据距离网页边缘判断，<strong>靠近网页边缘为前，远离网页边缘为后</strong></p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211152114278.png" alt="image-20221115211406244"></p></li></ul><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>通过上面的内容，我们可以简单理解为，在标准流中，元素是竖向排列的，在浮动中，元素是横向排列的</p><p>而<strong>清除浮动</strong>可以理解为<strong>打破横向排列</strong></p><p>清除浮动的属性是<code>clear</code></p><p>clear可以填入的属性有</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认值，不清除浮动</td></tr><tr><td>left</td><td>不允许左边有浮动对象</td></tr><tr><td>right</td><td>不允许右边有浮动对象</td></tr><tr><td>both</td><td>不允许左右边有浮动对象</td></tr></tbody></table><p>对于清除浮动这个属性，有一个<strong>非常重要的特性</strong>：</p><p><strong>这个属性只能影响使用清除元素的本身，不能影响其他元素</strong></p><p>如何理解这句话呢？</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211160107384.png" alt="image-20221116010753322"></p><p>有两个浮动的box，若我们想让box2排列在box1下面，就像box1无浮动，box2浮动那样，按照我们看到文档的一般想法，是在box1上使用<code>clear:right</code>，以此来达到“不允许右边有浮动对象”的效果</p><p>但是，我们提到了只能<strong>影响本身</strong>的这个特性，因此我们需要在box2本身去使用clear属性，让box2<code>clear:left</code>，不允许其左边有浮动属性，迫使box2下移一行：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211160117407.png" alt="image-20221116011750381"></p><p>以上就是浮动的基本的概念了</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web三板斧 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发基础（3）：CSS文本、链接、表格、伪类选择器</title>
      <link href="/2022/11/09/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%EF%BC%9ACSS%E6%96%87%E6%9C%AC%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E8%A1%A8%E6%A0%BC%E3%80%81%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2022/11/09/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%EF%BC%9ACSS%E6%96%87%E6%9C%AC%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E8%A1%A8%E6%A0%BC%E3%80%81%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="文本-text"><a href="#文本-text" class="headerlink" title="文本 text"></a>文本 text</h2><h3 id="颜色-color"><a href="#颜色-color" class="headerlink" title="颜色 color"></a>颜色 color</h3><p>color是一个非常常用的css指定，在body选择器中指定的color，将会成为页面默认的文本颜色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">color</span>:<span class="number">#00ff00</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.ex</span> &#123;<span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>);&#125;</span><br></pre></td></tr></table></figure><h3 id="对齐方式-text-align"><a href="#对齐方式-text-align" class="headerlink" title="对齐方式 text-align"></a>对齐方式 text-align</h3><p>该属性可以设定文本的水平对齐方式。</p><p>文本可以<strong>居中center</strong>、<strong>对齐到左left</strong>或<strong>右right</strong>、<strong>两端对齐justify</strong></p><p>两端对齐就是每一行都展开为宽度相等，左右边距都是对齐（如杂志和报纸）</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211092226128.png" alt="image-20221109222638064"></p><h3 id="文本修饰-text-decoration"><a href="#文本修饰-text-decoration" class="headerlink" title="文本修饰 text-decoration"></a>文本修饰 text-decoration</h3><p>该属性用于设置文本的<strong>上划线（overline）</strong>、<strong>下划线（underline）</strong>、<strong>划去（line-through）</strong>以及<strong>删除链接的下划线（none）</strong>等修饰</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211092252640.png" alt="image-20221109225246612"></p><h3 id="文本转换-text-transform"><a href="#文本转换-text-transform" class="headerlink" title="文本转换 text-transform"></a>文本转换 text-transform</h3><p>该属性用于设置一个文本的大写或者小写字母</p><p>可用于所有字句变成<strong>大写（uppercase）</strong>或<strong>小写（lowercase）</strong>字母，或<strong>每个单词的首字母大写（capitalize）</strong>。</p><h3 id="文本缩进-text-indent"><a href="#文本缩进-text-indent" class="headerlink" title="文本缩进 text-indent"></a>文本缩进 text-indent</h3><p>该属性可以指定文本第一行缩进的大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">text-indent</span>:<span class="number">50px</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接有四个状态</p><ul><li>a:link - 一般情况，未访问过的链接</li><li>a:visited - 用户已经访问过的链接</li><li>a:hover - 用户的光标悬停在链接上时</li><li>a:active - 被点击的那一刻</li></ul><p>这四个状态都可以单独设定样式，状态的样式设置有一定的顺序规矩：</p><ul><li>a:hover 必须跟在 a:link 和 a:visited后面</li><li>a:active 必须跟在 a:hover后面</li></ul><p>常见的样式设置有<strong>文本修饰（text-decoration）</strong>、<strong>背景颜色（background-color）</strong>、<strong>字体大小（font-size）</strong>等等，基本上文本修饰可以使用的，在链接上都可以使用。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h3 id="边框-border"><a href="#边框-border" class="headerlink" title="边框 border"></a>边框 border</h3><p>该属性可以设置边框的相关属性，<strong>厚度</strong>、<strong>边框样式（连续、分段等）</strong>、<strong>颜色</strong>等</p><p>他们可以写在同一个定义中，以空格分开，也可以分开几个定义</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span>;</span><br><span class="line"><span class="attribute">border</span>: solid;</span><br><span class="line"><span class="attribute">border</span>: black;</span><br></pre></td></tr></table></figure><p>值的顺序无关紧要</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211100116142.png" alt="image-20221110011604103"></p><h3 id="单个边框-border-collapse"><a href="#单个边框-border-collapse" class="headerlink" title="单个边框 border-collapse"></a>单个边框 border-collapse</h3><p>该属性可以将默认两个边框的折叠成一个边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">border-collapse</span>:collapse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span>,<span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211100115969.png" alt="image-20221110011549930"></p><h3 id="宽度和高度-width、height"><a href="#宽度和高度-width、height" class="headerlink" title="宽度和高度 width、height"></a>宽度和高度 width、height</h3><p>该属性值与文字值类似，可以用百分数或者是像素等等来表示宽度或者高度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">th</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文字对齐-text-align、vertical-alig"><a href="#文字对齐-text-align、vertical-alig" class="headerlink" title="文字对齐 text-align、vertical-alig"></a>文字对齐 text-align、vertical-alig</h3><p>该属性用于设置表格中的文本对齐与垂直属性</p><p>水平对齐属性 <code>text-align</code>可以设置<strong>居中center</strong>、<strong>对齐到左left</strong>或<strong>右right</strong></p><p>垂直对齐属性<code>vertical-alig</code>设置垂直对齐，比如<strong>顶部top</strong>，<strong>底部bottom</strong>或<strong>中间middle</strong></p><h3 id="表格单元格大小-padding"><a href="#表格单元格大小-padding" class="headerlink" title="表格单元格大小 padding"></a>表格单元格大小 padding</h3><p>该属性用于控制单元格大小</p><p>padding可以接受1-4个值：</p><ul><li>当只指定<strong>一个</strong>值时，该值会统一应用到<strong>全部四个边</strong>的内边距上。</li><li>指定<strong>两个</strong>值时，第一个值会应用于<strong>上边和下边</strong>的内边距，第二个值应用于<strong>左边和右边</strong>。</li><li>指定<strong>三个</strong>值时，第一个值应用于<strong>上边</strong>，第二个值应用于<strong>右边和左边</strong>，第三个则应用于<strong>下边</strong>的内边距。</li><li>指定<strong>四个</strong>值时，依次（顺时针方向）作为<strong>上边</strong>，<strong>右边</strong>，<strong>下边</strong>，和<strong>左边</strong>的内边距。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 应用于所有边 */</span></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上边下边 | 左边右边 */</span></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">5%</span> <span class="number">10%</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上边 | 左边右边 | 下边 */</span></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">1em</span> <span class="number">2em</span> <span class="number">2em</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上边 | 右边 | 下边 | 左边 */</span></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">1em</span> <span class="number">0</span> <span class="number">2em</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局值 */</span></span><br><span class="line"><span class="attribute">padding</span>: inherit;</span><br><span class="line"><span class="attribute">padding</span>: initial;</span><br><span class="line"><span class="attribute">padding</span>: unset;</span><br></pre></td></tr></table></figure><h3 id="颜色-background-color、color"><a href="#颜色-background-color、color" class="headerlink" title="颜色 background-color、color"></a>颜色 background-color、color</h3><p><code>background-color</code>用于设定表格的背景颜色</p><p><code>color</code>用于设定表格内的文本颜色</p><p>下面例子分别设定了</p><ul><li>表格的间距、样式、颜色</li><li>表头的背景颜色和文本颜色</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span>, <span class="selector-tag">td</span>, <span class="selector-tag">th</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">th</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:green;</span><br><span class="line">    <span class="attribute">color</span>:white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211112127271.png" alt="image-20221111212727215"></p><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>伪类：专门用来表现元素的一种特殊状态</p><p>实际上，我们在上面就有一种伪类选择器，即链接的四种状态</p><p>常用的伪类选择器</p><ul><li><p>超链接伪类 <code>&lt;a&gt;</code></p><p><code>a:visited</code>已被访问</p><p><code>a:link</code>未访问</p><p><code>a:hover</code>悬停</p><p><code>a:active</code>点击瞬间</p></li><li><p>表单 </p><p><code>:focus</code>获得焦点</p></li><li><p>:first-child</p><p>选择元素的第一个子元素，如列表第一个元素</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web三板斧 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发基础（2）：CSS选择器、字体、背景</title>
      <link href="/2022/10/20/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%EF%BC%9ACSS%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%81%E5%AD%97%E4%BD%93%E3%80%81%E8%83%8C%E6%99%AF/"/>
      <url>/2022/10/20/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%EF%BC%9ACSS%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%81%E5%AD%97%E4%BD%93%E3%80%81%E8%83%8C%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS简介"><a href="#CSS简介" class="headerlink" title="CSS简介"></a>CSS简介</h2><p>CSS (Cascading Style Sheets，层叠样式表），是一种用来为<strong>结构化文档</strong>（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言</p><h2 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h2><p>CSS主要由两个主要部分组成：选择器与一条或多条声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123;属性:值;...&#125;</span><br></pre></td></tr></table></figure><p>选择器是需要更改样式的HTML元素</p><p>每条声明由一个属性和一个值组成</p><p>属性是需要设置的样式属性，属性与值间用冒号隔开</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>如果需要在HTML元素中设置CSS样式，一般来说我们可以在元素中设置<code>id</code>和<code>class</code>标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;text1&quot;</span>&gt;</span>text1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text2&quot;</span>&gt;</span>text2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>id选择器可以为标有特定id的HTML代码指定特定的样式</p><p>在CSS中id选择器以<code>#</code>就开头来定义</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#text1</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器"></a>class选择器</h3><p>class选择器可以用于描述一组元素的样式，class与id选择器不同处在于class选择器可以在多个元素中使用</p><p>在CSS中id选择器以<code>.</code>开头为定义，以下例子为应用在所有<code>text2</code>类的HTML元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text2</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以指定某个元素使用class选择器，以下实例中即让p元素使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.text2</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><p>通配符选择器可以选取页面中所有的元素（标签）</p><p>在CSS中，它使用<code>*</code>来定义</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通配符选择器不需要调用，会自动给所有元素使用样式</p><p>一般而言只有在特殊情况下才会使用，例如清楚所有的元素标签的内外边距</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分组选择器"><a href="#分组选择器" class="headerlink" title="分组选择器"></a>分组选择器</h3><p>使用<code>,</code>可以将不同的选择器组合在一起，它选择所有能被列表中的任意一个选择器选中的节点。语法<code>A, B</code>，A、B为不同选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>, <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS使用"><a href="#CSS使用" class="headerlink" title="CSS使用"></a>CSS使用</h2><p>插入CSS的方法有三种</p><ul><li>外部样式表</li><li>内部样式表</li><li>内联样式</li></ul><h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><p>如果样式表需要应用在多个页面的时候，外部样式表就是最理想的选择</p><p>通过在HTML文档头部使用<code>&lt;link&gt;</code>标签可以连接到样式表文件<code>xxx.css</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器在渲染输出的时候会将<code>style.css</code>文件读取并格式化文档</p><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>当某个文档需要特殊样式时，就可以用到内部样式表</p><p>通过在HTML文档头部使用<code>&lt;style&gt;</code>标签在文档头部可以定义内部样式表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>:<span class="number">20px</span>;&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><p>内联样式这种方法，一般会用仅需要在一个元素上应用一次的情况。由于内联样式要将央视哦与内容混在一起，会丢失样式表本有的优势，所以这种方式需要慎用</p><p>通过在标签内使用<code>style</code>属性，可以在标签中使用CSS样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:red;margin-left:20px&quot;</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多重样式"><a href="#多重样式" class="headerlink" title="多重样式"></a>多重样式</h3><p>如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。 </p><p>一般情况下，多重样式的优先级为</p><p>内联样式 &gt; 内部样式表 &gt; 外部样式表 &gt; 浏览器默认样式</p><p>外部样式表</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">8pt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部样式表</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:right</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">20pt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>h3最终得到的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"><span class="attribute">text-align</span><span class="selector-pseudo">:right</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">20pt</span>;</span><br></pre></td></tr></table></figure><h2 id="字体-Font"><a href="#字体-Font" class="headerlink" title="字体 Font"></a>字体 Font</h2><h3 id="字体系列-font-family"><a href="#字体系列-font-family" class="headerlink" title="字体系列 font-family"></a>字体系列 font-family</h3><p>font-family 属性设置文本的字体，例如设置为宋体、黑体等</p><p>如果字体系列的名称超过一个字或者一个单词，它必须用引号，如Font Family：”宋体”。</p><p>font-family 属性应该设置几个字体名称作为一种”后备”机制，如果浏览器不支持第一种字体，他将尝试下一种字体。<a href="https://www.runoob.com/cssref/css-websafe-fonts.html">CSS Web安全字体 | 菜鸟教程 (runoob.com)</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-family</span>:<span class="string">&quot;Times New Roman&quot;</span>, Times, serif&#125;</span><br></pre></td></tr></table></figure><h3 id="字体样式-font-style"><a href="#字体样式-font-style" class="headerlink" title="字体样式 font-style"></a>字体样式 font-style</h3><p>该属性用于指定斜体文字的样式属性</p><p>这个属性有三个值：</p><ul><li>normal - 正常</li><li>italic - 以斜体字显示的文字</li><li>oblique - 文字向一边倾斜（与斜体非常类似）</li></ul><p>因为不是所有的字体都有斜体，italic 是使用文字的斜体，oblique 是让没有斜体属性的文字倾斜</p><p>oblique是可以设定字体倾斜的角度<code>font-style: oblique 40deg;</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.normal</span> &#123;<span class="attribute">font-style</span>:normal;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.italic</span> &#123;<span class="attribute">font-style</span>:italic;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.oblique</span> &#123;<span class="attribute">font-style</span>:oblique;&#125;</span><br></pre></td></tr></table></figure><h3 id="字体大小-font-size"><a href="#字体大小-font-size" class="headerlink" title="字体大小 font-size"></a>字体大小 font-size</h3><p>该属性用于设置文本的大小，合理管理文字的大小，在网页设计中是非常重要的</p><p>字体大小的值可以是相对大小或绝对大小，也可以是个固定的值，还可以是个基于父元素的百分比值</p><p>相对大小</p><ul><li>相对于周围的元素来设置大小</li><li>允许用户在浏览器种改变文字大小</li></ul><p>绝对大小</p><ul><li>设定一个指定大小的文本</li><li>不允许用户在浏览器中改变文本大小</li><li>确定了输出的物理尺寸时绝对大小很有用</li></ul><h4 id="绝对大小"><a href="#绝对大小" class="headerlink" title="绝对大小"></a>绝对大小</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font-size</span>: xx-small;</span><br><span class="line"><span class="attribute">font-size</span>: x-small;</span><br><span class="line"><span class="attribute">font-size</span>: small;</span><br><span class="line"><span class="attribute">font-size</span>: medium;</span><br><span class="line"><span class="attribute">font-size</span>: large;</span><br><span class="line"><span class="attribute">font-size</span>: x-large;</span><br><span class="line"><span class="attribute">font-size</span>: xx-large;</span><br></pre></td></tr></table></figure><h4 id="相对大小"><a href="#相对大小" class="headerlink" title="相对大小"></a>相对大小</h4><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>smaller</td><td>把 font-size 设置为比父元素更小的尺寸。</td></tr><tr><td>larger</td><td>把 font-size 设置为比父元素更大的尺寸。</td></tr></tbody></table><h4 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h4><p>像素(px)是网页中最常用的单位，同样的，我们也可以通过px作为固定值来设定我们字体的大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;&#125;</span><br></pre></td></tr></table></figure><p>如果你不指定一个字体大小，默认大小和普通文本段落一样，为16px(1em)</p><h3 id="字体粗细-font-weight"><a href="#字体粗细-font-weight" class="headerlink" title="字体粗细 font-weight"></a>字体粗细 font-weight</h3><p>该属性用于设定字体的粗细</p><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">normal</td><td align="left">默认值。定义标准的字符。</td></tr><tr><td align="left">bold</td><td align="left">定义粗体字符。</td></tr><tr><td align="left">bolder</td><td align="left">定义更粗的字符。</td></tr><tr><td align="left">lighter</td><td align="left">定义更细的字符。</td></tr><tr><td align="left">100、200、300…900</td><td align="left">定义由细到粗的字符。400 等同于 normal，而 700 等同于 bold。</td></tr><tr><td align="left">inherit</td><td align="left">规定应该从父元素继承字体的粗细。</td></tr></tbody></table><h2 id="背景-Background"><a href="#背景-Background" class="headerlink" title="背景 Background"></a>背景 Background</h2><h3 id="背景颜色-background-color"><a href="#背景颜色-background-color" class="headerlink" title="背景颜色 background-color"></a>背景颜色 background-color</h3><p>该属性定义了元素的背景颜色</p><p>颜色的值可以用以下方法定义：</p><ul><li>十六进制 例：“#ff0000”</li><li>RGB 例：“rgb(255,0,0)”</li><li>颜色名称 例：“red”</li></ul><p>页面的背景颜色使用在body的选择器上</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>:red;&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;h1-h6&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code>等等标签都可以通过自己的选择器调整各自的背景颜色</p><h3 id="背景图片-backgroud-image"><a href="#背景图片-backgroud-image" class="headerlink" title="背景图片 backgroud-image"></a>背景图片 backgroud-image</h3><p>该属性定义了元素的背景图像，默认情况背景图像会平铺重复显示，覆盖整个元素实体</p><p>同样的，页面的背景图片设置也在body的选择器上</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;backgroud-image:<span class="built_in">url</span>(<span class="string">&#x27;xxx.jpg&#x27;</span>);&#125;</span><br></pre></td></tr></table></figure><h4 id="平铺方式-background-repeat"><a href="#平铺方式-background-repeat" class="headerlink" title="平铺方式 background-repeat"></a>平铺方式 background-repeat</h4><p>我们可以通过<code>background-repeat</code>属性设置平铺方式</p><p>水平平铺</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    backgroud-image:<span class="built_in">url</span>(<span class="string">&#x27;xxx.jpg&#x27;</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>:repeat-x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不平铺</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    backgroud-image:<span class="built_in">url</span>(<span class="string">&#x27;xxx.jpg&#x27;</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图像定位-background-position"><a href="#图像定位-background-position" class="headerlink" title="图像定位 background-position"></a>图像定位 background-position</h4><p>我们还可以通过<code>background-position</code>改变图像在背景的位置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">&#x27;img_tree.png&#x27;</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span><span class="selector-pseudo">:right</span> <span class="attribute">top</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简写属性"><a href="#简写属性" class="headerlink" title="简写属性"></a>简写属性</h4><p>由于背景需要通过多个属性来控制，为了简化这些属性的代码，我们可以将其合并为同一个属性中</p><p>当使用简写属性时，属性值的顺序为：</p><ul><li>background-color</li><li>background-image</li><li>background-repeat</li><li>background-attachment</li><li>background-position</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">background</span>:<span class="number">#ffffff</span> <span class="built_in">url</span>(<span class="string">&#x27;img_tree.png&#x27;</span>) no-repeat right top;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web三板斧 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Server笔记（1）</title>
      <link href="/2022/10/12/SQLServer%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
      <url>/2022/10/12/SQLServer%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>该笔记的所观看的视频为<a href="https://www.youtube.com/user/waspec">Timothy Liu</a>的”SQL速通”</p><p>所使用的数据库为微软官方提供的学习用数据库：<a href="https://learn.microsoft.com/en-us/sql/samples/adventureworks-install-configure?view=sql-server-ver16&tabs=ssms">AdventureWorks sample databases - SQL Server | Microsoft Learn</a></p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li><p>数据库管理系统 Database Management System <strong>DBMS</strong></p></li><li><p>DBMS客户端 Client&#x2F;Server C&#x2F;S架构</p><p>客户端：与数据库管理系统交互的程序，分为两种图形和命令行，而SQL Server的客户端就是SQL Server Management Studio <strong>SSMS</strong></p><p>服务器：正在运行的数据库管理系统，一个服务器可以为多个客户端提供服务</p></li><li><p>数据库：真正存放数据的地方；数据的存储结构针对速度与安全性进行了优化</p><p>数据库的类型有多种，如关系型数据库、文档型数据库等，而SQL Server就是一种关系型数据库，<strong>关系型数据库</strong>是建立在关系模型基础上的数据库，常用在对数据的完整性要求比较高的场景，比如银行系统、销售系统等。<strong>文档型数据库</strong>是一种非关系型数据库，数据作为单条记录保存在数据库，主要应用在大数据处理、应用与分析方面，比如购物应用与页面的广告展示记录系统等。关系型数据库与文档型数据库并不是相对立的，而是互补而成的，关系型数据库存放经过处理后的文档型数据库，而文档型数据库可以存大量未经处理的数据。</p></li><li><p>查询（query）</p><table><thead><tr><th>英文</th><th>中文</th></tr></thead><tbody><tr><td>C:Create</td><td>增</td></tr><tr><td>R:Read</td><td>查</td></tr><tr><td>U:Update</td><td>改</td></tr><tr><td>D:Delete</td><td>删</td></tr></tbody></table></li></ul><h2 id="查询基础"><a href="#查询基础" class="headerlink" title="查询基础"></a>查询基础</h2><h3 id="查询的过程"><a href="#查询的过程" class="headerlink" title="查询的过程"></a>查询的过程</h3><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210141908072.png" alt="image-20221014190839018" style="zoom: 67%;" /><p><strong>树立思想</strong></p><ol><li>除了关注结果，还需要<strong>关注性能</strong></li><li>随时准备应对错误、排查原因</li></ol><h3 id="SELECT语法定义"><a href="#SELECT语法定义" class="headerlink" title="SELECT语法定义"></a>SELECT语法定义</h3><p>SELECT语句是SQL查询中最核心的语句。其呈现一种嵌套的形态，各级语法元素层层展开：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210151713461.png" alt="image-20221015171333331"></p><p>问题一：表示三种可能 整个表达式不出现、AC、BC</p><p>问题二：最简形式即<code>SELECT &lt;select_list&gt;</code></p><p><code>&lt;select_list&gt;</code>可以让服务器运行的一个运算，例如<code>SELECT 100+100</code>则会让服务器运行<code>100 + 100</code>这个运算，然后返回运算后的结果到客户端：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210160138557.png" alt="image-20221016013805527"></p><p>我们在这个运算中，也可以加入设定自变量，通过<code>DECLARE @变量名 数据类型 = 初始值</code>可以声明一个变量。</p><p>问题三：在语法定义中，会出现一个套一个的操作，例如：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210160253123.png" alt="image-20221016025343088"></p><p>这种属于是直接的套娃，还有一种是间接的套娃：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210160256954.png" alt="image-20221016025618921"></p><p><code>&lt;table_source&gt;</code>表示的是一张“源表格”，“源表格”除了数据库原生的表格，还可以将<code>SELECT语句</code>查询的结果作为一个“源表格”，提供在<code>&lt;table_source&gt;</code>中使用。我们使用<code>AS</code>关键词可以声明一个新的“源表格”：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210160302803.png" alt="image-20221016030218768"></p><p>这种嵌套的方式，可以称之为递归。在<code>SELECT语句</code>的定义中是存在递归的解释的。</p><h2 id="SELECT具体使用"><a href="#SELECT具体使用" class="headerlink" title="SELECT具体使用"></a>SELECT具体使用</h2><h3 id="From子句基础用法"><a href="#From子句基础用法" class="headerlink" title="From子句基础用法"></a>From子句基础用法</h3><p>From涉及到“数据从何而来”的问题。</p><p>From子句最重要的部分是<code>&lt;table_source&gt;</code>，即数据源，一个From子句可以带有多个<code>&lt;table_source&gt;</code>，多个可以产生<strong>正交组合</strong>。正交组合就是将两个表的数据取出来进行两两组合（笛卡尔乘积）。</p><p><code>&lt;table_source&gt;</code>也具有非常丰富的展开，这里暂时仅解释两个基础的用法</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210172311504.png" alt="image-20221017231151461"></p><p><code>&lt;joined_table&gt;</code>与<code>&lt;pivoted_table&gt;</code>也是非常重要的用法，这四个用法，是From最重要四个用法。</p><h4 id="table-or-view-name"><a href="#table-or-view-name" class="headerlink" title="table_or_view_name"></a><code>table_or_view_name</code></h4><p><strong>表<code>table</code>的概念：</strong></p><p>表并不是我们看见的执行结果所出现的“表格”，“表格”是对表的抽象逻辑的具体化。</p><ol><li><p>表是数据库存储数据的地方，而且<strong>所有的数据</strong>都是存储在表中。</p></li><li><p>在表里面，是以行和列的<strong>逻辑</strong>进行存储的，行是表里”唯一”的一条数据记录，列是表里所有记录某一个字段的所有记录</p><p>行的”唯一性”由<strong>主键</strong>来保证，当我们在设计表的时候，我们需要通过某行某列的组合保证行的唯一性。</p></li></ol><p><strong>视图<code>view</code>的概念：</strong></p><ol><li>视图是一张由<strong>查询query</strong>定义出来的<strong>虚拟表virtual table</strong></li><li>可以将其视作查看一组数据的时候的<strong>过滤器filter</strong></li></ol><h4 id="derived-table"><a href="#derived-table" class="headerlink" title="derived_table"></a><code>derived_table</code></h4><ol><li><code>derived_table</code>是来自于数据库的一个<strong>子查询</strong></li><li>其用于作为其他查询的数据输入</li><li><code>derived_table</code>与<code>view</code>可以相互转换，当<code>derived_table</code>比较常用于作为其他查询的数据输入的时候，我们可以将其固化为一个<code>view</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发基础（1）：参考文档或教程、HTML</title>
      <link href="/2022/08/30/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E6%88%96%E6%95%99%E7%A8%8B%E3%80%81HTML/"/>
      <url>/2022/08/30/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E6%88%96%E6%95%99%E7%A8%8B%E3%80%81HTML/</url>
      
        <content type="html"><![CDATA[<h2 id="参考文档or教程"><a href="#参考文档or教程" class="headerlink" title="参考文档or教程"></a>参考文档or教程</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web">Web 开发技术 | MDN (mozilla.org)</a></p><p><a href="https://www.runoob.com/html/html-tutorial.html">HTML 教程 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://www.runoob.com/css/css-tutorial.html">CSS 教程 | 菜鸟教程 (runoob.com)</a></p><h2 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h2><p>HTML是一个标记语言，不是一个编程语言。HTML 使用标记标签来描述网页，HTML 文档包含了HTML标签及文本内容。</p><p>HTML标签是HTML所使用的标记，是由尖括号所包围的关键词，如<code>&lt;head&gt;</code>等。HTML标签是成对出现的，第一个标签是开始标签，第二个标签是结束标签。HTML元素就是HTML标签所涵盖的内容。</p><p>HTML的网页结构：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202208301605882.png" alt="image-20220830160532846"></p><p>一个完整HTML网页：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>first html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>HHHHHELLO WORLD<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在vscode中，我们新建一个html文件时，我们可以通过英文的<code>!</code>＋回车快速生成html文档的基本结构</p><p>在JB系软件中，可以通过<code>html:5</code>+tab快速生成</p><h2 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li>HTML 元素以<strong>开始标签</strong>起始</li><li>HTML 元素以<strong>结束标签</strong>终止</li><li><strong>元素的内容</strong>是开始标签与结束标签之间的内容</li><li>某些 HTML 元素具有<strong>空内容</strong></li><li>空元素<strong>在开始标签中进行关闭</strong>（以开始标签的结束而结束）</li><li>大多数 HTML 元素可拥有<strong>属性</strong></li></ul><p>大部分HTML元素都可以嵌套。</p><h3 id="基本结构标签"><a href="#基本结构标签" class="headerlink" title="基本结构标签"></a>基本结构标签</h3><ul><li><p><code>&lt;html&gt;&lt;/html&gt;</code> HTML标签</p><p>根标签，是页面中最大的标签</p></li><li><p><code>&lt;head&gt;&lt;/head&gt;</code> 文档的头部</p><p>注意在head标签中必须设定title标签</p><p><code>&lt;title&gt;&lt;title&gt;</code>设定网页的标题</p></li><li><p><code>&lt;body&gt;&lt;/body&gt;</code> 文档的主体</p><p>包含着HTML文档的所有内容，页面显示的内容都会放在body内</p></li></ul><h3 id="文档类型声明标签"><a href="#文档类型声明标签" class="headerlink" title="文档类型声明标签"></a>文档类型声明标签</h3><ul><li><p><code>&lt;!DOCTYPE&gt;</code>文档类型声明</p><p>声明HTML的版本，这句代码需要放在HTML文档的最前面</p></li><li><p><code>lang = </code>定义当前文档显示的语言</p><p>作用是给搜索引擎和浏览器作提示作用，并不是限制文档所使用的语言</p></li><li><p><code>&lt;mate charset= &quot;XXXX&quot;&gt;</code> 规定HTML文档使用的字符编码</p><p>一般情况下都是用UTF-8，避免出现乱码现象</p></li></ul><h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><ul><li><p>标题标签 <code>&lt;h1&gt;-&lt;h6&gt;</code> 有大到小递减</p></li><li><p>段落标签<code>&lt;p&gt;&lt;/p&gt;</code> 定义段落，可以将网页分割成多个段落</p><p>特性：会根据浏览器窗口自动换行</p></li><li><p>换行标签<code>&lt;br/&gt;</code> 手动换行 单标签</p></li><li><p>文本格式化标签</p><table><thead><tr><th>语义</th><th>标签</th></tr></thead><tbody><tr><td>加粗</td><td><strong></strong>或<b></b></td></tr><tr><td>倾斜</td><td><em></em>或<i></i></td></tr><tr><td>删除线</td><td><del></del>或<s></s></td></tr><tr><td>下划线</td><td><ins></ins>或<u></u></td></tr></tbody></table></li><li><p><code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>标签</p><p>这两个标签本身是没有含义，是作为一个盒子的存在，用于存储内容</p><p>特点：</p><ol><li><code>&lt;div&gt;</code>一行只能放一个，该标签独占一行，相当于是一种大盒子</li><li><code>&lt;span&gt;</code>一行可以放置多个，相当于是一种小盒子</li></ol></li><li><p>图像标签<code>&lt;img src = &quot;图像URL&quot; /&gt;</code> 单标签</p><p>图像标签有以下属性可以设置：</p><table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>src</td><td>图片路径</td><td>必须属性，用于指定图像文件的路径和文件名</td></tr><tr><td>alt</td><td>文本</td><td>替换文本。图片不能显示时的文字</td></tr><tr><td>title</td><td>文本</td><td>提示文本。鼠标放在图像上显示的文字</td></tr><tr><td>width</td><td>像素</td><td>宽度</td></tr><tr><td>height</td><td>像素</td><td>高度</td></tr><tr><td>border</td><td>像素</td><td>边框的粗细</td></tr></tbody></table><p>图像标签注意点：</p><ol><li>图像标签可以拥有多个属性，必须写在标签名的后面</li><li>属性之间不分先后顺序，标签名与属性、属性与属性之间以空格隔开</li><li>属性采用键值对的格式，即<code>key = &quot;value&quot;</code></li></ol><p>相对路径的含义：</p><table><thead><tr><th>相对路径含义</th><th>符号</th></tr></thead><tbody><tr><td>同一级路径</td><td></td></tr><tr><td>下一级路径</td><td>&#x2F;</td></tr><tr><td>上一级路径</td><td>..&#x2F;</td></tr></tbody></table></li><li><p>超链接标签 <code>&lt;a href = &quot;跳转目标&quot; target = &quot;目标窗口弹出方式&quot;&gt;文本或者图像&lt;/a&gt;</code></p><p>作用是从一个页面链接到另外一个页面</p><p><code>target</code>默认为<code>_self</code>，<code>_blank</code>为在新窗口中打开的方式</p><p>在<code>文本或者图像</code>的位置，我们可以填入文本，或者是图像标签之类的各种网页元素</p><p><code>href</code>跳转目标：</p><ol><li><p>外部链接</p></li><li><p>网站内部的其他网页</p></li><li><p>空链接</p></li><li><p>下载链接：文件所在的路径</p></li><li><p>锚点链接：点击链接可以快速定位到页面的某个位置</p><p>找到目标位置的标签，在内部添加一个<code>id = &quot;名字&quot;</code>，在<code>href</code>属性中设置为<code>#名字</code>即可</p></li></ol></li><li><p>注释 <code>&lt;!-- 注释语句 --&gt;</code></p></li></ul><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>在HTML中，空格等特殊字符我们需要借助特殊的标记进行表示</p><p>常用的特殊字符：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209160127388.png" alt="image-20220916012707314"></p><p>详细请参考<a href="https://www.runoob.com/tags/ref-entities.html">HTML ISO-8859-1 参考手册 | 菜鸟教程 (runoob.com)</a></p><h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h2><p>表格的主要作用是显示、展示数据</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>表格主要由三组标签组成，<code>&lt;table&gt;</code>、<code>&lt;tr&gt;</code>、<code>&lt;td&gt;</code></p><ul><li><code>&lt;table&gt;</code>用于定义表格的标签 </li><li><code>&lt;tr&gt;</code>用于定义表格的行</li><li><code>&lt;td&gt;</code> <code>table date</code> 即单元格</li><li>三组标签呈现<code>&lt;td&gt; -&gt; &lt;tr&gt; -&gt; &lt;table&gt;</code>的嵌套关系</li></ul><p>表格的基本例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>17<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209161037616.png" alt="image-20220916103701582"></p><h3 id="表头单元格标签"><a href="#表头单元格标签" class="headerlink" title="表头单元格标签"></a>表头单元格标签</h3><p><code>&lt;th&gt;</code> 即table head</p><p>表格的第一行一般都是作为表头使用，因此<code>&lt;th&gt;</code>标签可以使得里面的文本内容加粗居中显示，以此表示表头</p><p>注意：这是个单元格大小的标签，与<code>&lt;td&gt;</code>类似</p><h3 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h3><p>实际开发中并不常用，实际开发中表格属性往往通过CSS来设置</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209161303070.png" alt="image-20220916130347019"></p><h3 id="表格结构标签"><a href="#表格结构标签" class="headerlink" title="表格结构标签"></a>表格结构标签</h3><p>为了更好的表示表格，可以将被表格分割成表格头部和表格主体两大部分</p><p>在表格标签中，分别用：<code>&lt;thead&gt;</code>表示表格的头部区域、<code>&lt;tbody&gt;</code>表示表格的主体区域</p><p>这两个结构标签位于<code>&lt;table&gt;</code>下面，在<code>&lt;tr&gt;</code>之上</p><p>注意：<code>&lt;thead&gt;</code>的属性与表格总的属性是分隔的，需要额外设置</p><h3 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h3><p>特殊情况下，我们需要用到多个单元格合并成一个单元格，例：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209161313160.png" alt="image-20220916131341116"></p><p>这种情况下，<code>个人简历</code>和<code>图片</code>就用到了合并单元格</p><p><strong>合并单元格的方式：</strong></p><ul><li>跨行合并：rowspan&#x3D;”合并单元格的个数”</li><li>跨列合并：colspan&#x3D;”合并单元格的个数”</li></ul><p>合并的代码需要写到目标单元格上：</p><ul><li>跨行：最上侧单元格为目标单元格</li><li>跨列：最左侧单元格为目标单元格</li></ul><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209161325942.png" alt="image-20220916132536909"></p><p>举个实现上图的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><p>跟表格标签不同，列表最主要是用来<strong>布局</strong></p><p>列表的特点是整齐、整洁、有序，且作为布局会更加自由和方便</p><p>列表主要分为三大类：无序列表、有序列表、自定义列表</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209161550863.png" alt="image-20220916155000749"></p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p> <code>&lt;ul&gt;</code>标签表示无序列表，列表项使用<code>&lt;li&gt;</code>定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>one<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>three<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>four<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>five<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>&lt;li&gt;</code>里相当于是一个容器，可以容纳任何内容</p><p>无序列表有自己的样式属性，但是在实际使用中，我们往往使用CSS进行设置</p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p><code>&lt;ol&gt;</code>标签表示有序列表，列表项用<code>&lt;li&gt;</code>定义</p><p>与无序列表类似<code>&lt;li&gt;</code>里相当于是一个容器，可以容纳任何内容，且有序列表有自己的样式属性，但开发中更常用CSS进行设置样式</p><h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h3><p>开发中自定义列表常用于对术语或名词进行解释和描述，自定义列表的列表项前面没有任何项目符号</p><p><code>&lt;dl&gt;</code>标签用于表示自定义列表，<code>&lt;dt&gt;</code>用于表示项目&#x2F;名字，<code>&lt;dd&gt;</code>用于表示详细描述</p><p><code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>的关系类似于表头和单元格的关系</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>关注我们<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>bilibili<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>联系我们<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>数量都是没有限制的，比较常用的是一个<code>&lt;dt&gt;</code>对应多个<code>&lt;dd&gt;</code></p><h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><p>表单常用在注册等场景下使用，常用于收集用户的信息和相关数据</p><p>在HTML中，一个完整的表单一般由三部分组成，<strong>表单域、表单控件（表单元素）、提示信息</strong></p><h3 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h3><p>表单域即包含整个表单元素的区域，<code>&lt;form&gt;</code>标签用于定义表单域，以实现用户信息的收集及传递</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;提交方式&quot;</span> <span class="attr">name</span>=<span class="string">&quot;表单域名称&quot;</span>&gt;</span></span><br><span class="line">表单控件与其他元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>url地址：用于接收并处理表单数据的服务器程序的url地址</p><p>提交方式：可用的取值为，<code>get</code>与<code>post</code>，在我的另外一篇文章（渗透测试（1））中提及两者区别</p><p>名称：用于指定表单的名称，以区分不同表单</p><h3 id="表单控件"><a href="#表单控件" class="headerlink" title="表单控件"></a>表单控件</h3><p>表单控件可用按照使用的方式分为以下几种类型</p><ul><li><p>input输入表单元素</p><p><code>&lt;input&gt;</code>标签可以让用户输入数据，注意，他是一个单标签</p><p>在<code>&lt;input&gt;</code>标签中，包含一个必填的属性<code>type</code>属性，根据不同的属性，输入的字段拥有很多种形式（文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）</p><p><code>type</code>具体可以取得值可以见下表：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209170203818.png" alt="image-20220917020311733"></p><p>除了<code>type</code>属性以外，<code>&lt;input&gt;</code>还提供其他属性以供设置，其常用的其他属性如下：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209170219563.png" alt="image-20220917021924503"></p><p>其中<code>name</code>值，在用<code>radio</code>实现多选一的时候，必须让多个按钮有同一个<code>name</code>值，才能实现多选一的效果，否则会出现可以多选的问题。复选按钮<code>&lt;checkbox&gt;</code>也同样需要有相同的<code>name</code>值</p><p><code>value</code>属性对于不同<code>type</code>类型，用法也不同：</p><ul><li>对于 <code>button</code>、<code>reset</code>、<code>submit</code> 类型 - 定义按钮上的文本</li><li>对于 <code>text</code>、<code>password</code>、<code>hidden</code> 类型 - 定义输入字段的初始（默认）值</li><li>对于 <code>checkbox</code>、<code>radio</code>、<code>image</code> 类型 - 定义与 input 元素相关的值，当提交表单时该值会发送到表单的 action URL。</li></ul></li><li><p>select下拉表单元素</p><p>下拉表单常用于选择分类之类的地方</p><p>我们可以使用<code>&lt;select&gt;</code>标签控件定义下拉列表，具体的列表选项我们可以使用<code>&lt;option&gt;</code>来进行列出</p><p>在<code>&lt;select&gt;</code>标签应当至少含有一对<code>&lt;option&gt;</code>标签，在<code>&lt;option&gt;</code>标签中设置属性<code>selected = &quot;selected&quot;</code>时会使得当前选项成为默认选项</p></li><li><p>textarea文本域元素</p><p>与<code>&lt;input&gt;</code>标签的 <code>text</code>相类似，都是作为让用户输入文字表单的地方，但是这个文本域元素能提供更大的输入空间，一般用于让用户输入自我介绍等内容的地方，可以理解为大号的 <code>text</code></p><p>这个标签带有两个属性，<code>rows</code>和<code>cols</code>，<code>rows</code>是用于调整每行中的字符数，<code>cols</code>是用于调整显示的行数，但是我们在开发中很少会使用，因为一般都是使用CSS进行大小的调控</p><p>在标签中间填入的内容是用于定义输入字段的初始（默认）值</p></li></ul><h3 id="lt-label-gt-标签"><a href="#lt-label-gt-标签" class="headerlink" title="&lt;label&gt;标签"></a><code>&lt;label&gt;</code>标签</h3><p><code>&lt;label&gt;</code>标签并不属于表单标签，但是常常用于表单中，可以使得用户不比精准点中表单也可以选中选项</p><p><code>&lt;label&gt;</code>标签用于绑定一个表单元素，当点击<code>&lt;label&gt;</code>标签内的元素时，浏览器会自动将焦点（即光标）转向对应的表单元素上，增加用户体验</p><p>绑定的方式是设置<code>for</code>属性，并在表单元素上设定<code>id</code>属性，通过<code>for</code>绑定<code>id</code>属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web三板斧 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试学习（1）：概述、信息收集</title>
      <link href="/2022/08/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%EF%BC%9A%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/08/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%EF%BC%9A%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="渗透测试基本流程"><a href="#渗透测试基本流程" class="headerlink" title="渗透测试基本流程"></a>渗透测试基本流程</h2><ol><li>确定目标</li><li>信息收集</li><li>漏洞探寻</li><li>漏洞分析</li><li>漏洞利用</li><li>信息整理</li><li>形成报告</li></ol><h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>HTTP请求方式有七种，常用get、post</p><p>get请求 请求参数在url地址中，url有长度限制</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209052334587.png" alt="image-20220905233435518"></p><p>post请求 请求参数在请求体中，无大小限制</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209052334088.png" alt="image-20220905233446026"></p><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>Host：请求主机域名&#x2F;ip地址</p><p>User-Agent：提供浏览器的版本信息，供服务器解决浏览器兼容问题</p><p>Accept：传输文件类型（text&#x2F;html，application&#x2F;xhtml+xml，application&#x2F;xml）</p><p>Referer：跳转前的地址，可以用于统计用户来源和防止盗链</p><p>Accept-Encoding：浏览器申明自己可接收的编码方法</p><p>Accept-Language：浏览器申明自己可接收的语言</p><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><ol><li><p><strong>响应行</strong></p><p>协议及版本 响应状态码 状态码描述</p><p>例子：HTTP&#x2F;1.1 200 OK</p><p><strong>响应状态码详解：</strong></p><ul><li>1xx：服务器接受浏览器信息未完成，发送1xx状态码</li><li>2xx：成功，200</li><li>3xx：重定向，302，304（访问缓存）</li><li>4xx：客户端错误，404（没有找到对应资源），405（请求方法不被允许）</li><li>5xx：服务器错误，500（服务器内部出现异常）</li></ul><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209060033315.png" alt="image-20220906003345245"></p></li><li><p><strong>响应头</strong></p></li><li><p><strong>响应空行</strong></p><p>即一个空行</p></li><li><p><strong>响应体</strong></p><p>即网页的内容</p></li></ol><h2 id="前期信息收集"><a href="#前期信息收集" class="headerlink" title="前期信息收集"></a>前期信息收集</h2><p>信息收集是指通过各种方式获取所需要的信息</p><p>信息包括目标站点ip、中间件、脚本语言、端口、邮箱等，包括资产收集但不限于资产收集</p><p>信息收集的意义</p><ul><li>渗透测试成功的保障</li><li>更多的暴露面</li><li>更大的可能性</li></ul><p>信息收集的分类</p><ul><li><p>主动信息收集</p><p>通过直接对网站进行操作、扫描等，这种是有网络流量经过目标服务器的信息收集方式</p></li><li><p>被动信息收集</p><p>基于公开的渠道，如搜索引擎，在不与目标交互的情况下获取信息，并尽量避免留下痕迹</p></li></ul><p>需要收集的信息</p><ul><li>服务器信息（端口、服务、真实ip）</li><li>网站信息(网站架构[操作系统、中间件、数据库、编程语言]、指纹信息、WAF、敏感目录、敏感文件、源码泄露、旁站、C段)</li><li>域名信息(whois、 备案信息、子域名)</li><li>管理员信息(姓名、职务、生日、联系电话、邮件地址)</li><li>以上均是包括但不限于</li></ul><h3 id="域名信息收集"><a href="#域名信息收集" class="headerlink" title="域名信息收集"></a>域名信息收集</h3><p><strong>whois查询</strong></p><p>通过whois查询，我们可以收集到域名的ip及其所有者的信息</p><p>可以通过域名注册商、站长工具、命令行查询等等方式查询到whois</p><p><strong>域名备案信息</strong></p><p>在中国大陆解析网站都需要备案，备案具有网站的很多信息，同样的我们也可以通过站长工具进行查询</p><p><strong>注册人、邮箱反查</strong></p><p>通过whois获取注册人和邮箱，再通过注册人和邮箱反查域名</p><p>缺点是很多公司都是dns解析的运营商注册的，并不能很好的获取到信息</p><p><strong>子域名收集</strong></p><p>通过搜索子域名，找到主域名的其他子网站，由于主网站往往是防御做最好的，因此可以作为寻找突破口的作用</p><ol><li><p>google hacking</p><p>这是Google提供的一个信息搜集作用的语法，具体语法可以参考：</p><p><a href="https://zhuanlan.zhihu.com/p/25715992">详解GOOGLE HACK语法 - 知乎 (zhihu.com)</a></p><p>最简单的用法就是：<code>site:域名</code>，可以找到该域名的子域名</p></li><li><p>第三方web接口查询</p><p><a href="https://dnsdumpster.com/">DNSdumpster.com - dns recon and research, find and lookup dns records</a></p><p><a href="https://tool.chinaz.com/subdomain/">子域名查询 - 站长工具 (chinaz.com)</a></p></li><li><p>网络空间安全搜索引擎</p><p><a href="https://fofa.info/">网络空间测绘，网络空间安全搜索引擎，网络空间搜索引擎，安全态势感知 - FOFA网络空间测绘系统</a></p><p><a href="https://www.zoomeye.org/">首页 - 网络空间测绘,网络安全,漏洞分析,动态测绘,钟馗之眼,时空测绘,赛博测绘 - ZoomEye(“钟馗之眼”)网络空间搜索引擎</a></p><p><a href="https://www.shodan.io/">Shodan Search Engine</a></p><p>这种搜索引擎跟普通搜索引擎的区别在于，这种搜索引擎会一直对公网进行扫描，可以通过这种引擎，用被动收集信息，达到一定的主动收集方式的效果，缺点是这种引擎一般都是收费的</p></li><li><p>ssl证书查询</p><p><a href="https://crt.sh/">crt.sh | Certificate Search</a></p><p><a href="https://developers.facebook.com/tools/ct/search/">https://developers.facebook.com/tools/ct/search/</a></p><p>可以查询到https协议的网站的信息</p></li><li><p>js文件发现子域名</p><p><a href="https://github.com/Threezh1/JSFinder">Threezh1&#x2F;JSFinder: JSFinder is a tool for quickly extracting URLs and subdomains from JS files on a website. (github.com)</a></p><p>可以通过一些自动化工具来发现子域名</p></li><li><p>借助各种工具</p></li></ol><h3 id="IP信息收集"><a href="#IP信息收集" class="headerlink" title="IP信息收集"></a>IP信息收集</h3><ol><li><p><strong>ip反查域名</strong></p><p>如果渗透目标为虚拟主机，那么通过IP反查到的域名信息很有价值，因为一台物理服如果渗透目标为虚拟主机，那么通过IP反查到的域名信息很有价值，因为一台物理服务器上面可能运行多个虚拟主机。这些虚拟主机有不同的域名，但通常共用一个IP地务器上面可能运行多个虚拟主机.这些虚拟主机有不同的域名，但通常共用一个IP地址。如果你知道有哪些网站共用这台服务器，就有可能通过此台服务器上其他网站的漏洞获取服务器控制权，进而迂回获取渗透目标的权限，这种技术也称为“旁注”漏洞获取服务器控制权，进而迂回获取渗透目标的权限，这种技术也称为<strong>“旁注”</strong></p></li><li><p><strong>域名查询ip</strong></p></li><li><p><strong>判断与绕过CDN</strong></p><p>由于CDN会导致我们在查询域名对应IP时，查询到的是CDN，因此我们需要一些方法去判断和绕过CDN以获得真实IP</p><ul><li><p>多地ping</p><p>多地ping可以查看对应ip是否唯一</p></li><li><p>国外访问</p><p>通过国外访问的方式，有些网站设置CDN可能没有把国外的访问包含进去</p></li><li><p>查询子域名的IP</p><p>由于CDN收费高，很多站长仅只对主站或者流量大的子站做了CDN，而很多小旁站子站点和主站常常是在同一台服务器或者同一个C段内，因此可以通过这种方式辅助查找网站真实IP</p></li><li><p>查看phpinfo文件</p><p>如果是使用Apache HTTP Server的网站，其会内置一个phpinfo.php文件，通过访问这个文件，可以在内部找到一个参数<code>SERVER_ADDR</code>，其保存了服务器的真实地址或者内部地址</p><p>不常用，因为大部分网站管理员都会自行删除该文件使其不暴露</p></li><li><p>Mx记录邮件服务</p><p>缺陷：需要web服务器和邮件服务器在同一ip或同一c段</p></li><li><p>网络空间搜索引擎</p><p><a href="https://search.censys.io/">Censys Search</a></p></li><li><p>查询历史DNS记录</p><p><a href="https://www.dnsdb.io/zh-cn/">DNSDB</a></p><p><a href="https://viewdns.info/">ViewDNS.info - Your one source for DNS related tools!</a></p><p><a href="https://securitytrails.com/">SecurityTrails: Data Security, Threat Hunting, and Attack Surface Management Solutions for Security Teams</a></p><p><a href="https://www.ip138.com/">iP地址查询–手机号码查询归属地 | 邮政编码查询 | iP地址归属地查询 | 身份证号码验证在线查询网 (ip138.com)</a></p><p>这是一个非常实用的方式！</p></li></ul></li><li><p><strong>C段存活主机探测</strong></p><ul><li><p>Nmap</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -sP www.XXX.com/24</span><br><span class="line">nmap -sP 192.168.1.*</span><br></pre></td></tr></table></figure></li><li><p>各种扫描器</p></li></ul></li></ol><h3 id="端口信息收集"><a href="#端口信息收集" class="headerlink" title="端口信息收集"></a>端口信息收集</h3><p><strong>端口类型：</strong></p><ul><li>周知端口：众所周知的端口号，一般都用于固定分配给常用的服务，范围：0-1023</li><li>动态端口：一般不固定分配某种服务，范围：49152-65535</li><li>注册端口：用于分配给用户进程或程序，范围：1024-49151</li></ul><h4 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h4><p>一款开源的网络探测和安全审查的工具</p><p><strong>功能介绍</strong></p><ul><li>主机发现</li><li>端口发现</li><li>服务发现</li><li>检测操作系统，硬件地址，以及软件版本</li><li>检测脆弱性漏洞</li></ul><p><strong>端口状态</strong></p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209182016432.png" alt="image-20220918201629375"></p><p><strong>基础用法</strong></p><p>下面是一个经典的nmap扫描</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -A -T4 192.168.1.1</span><br></pre></td></tr></table></figure><p>-A：启用一个全面的扫描</p><p>-T4：时序选择，有T0-T5不同的六种选项，可以指定不同的速度，速度为0-5递增，但网络带宽需求增加，T5是牺牲准确度来提升速度，扫描国内网站常用为T4</p><p>目标指定的方式：</p><ul><li>单一主机扫描：192.168.1.1</li><li>子网扫描：192.168.1.1&#x2F;24</li><li>多主机扫描：192.168.1.1 192.168.100.1</li><li>主机范围扫描：192.168.1.1-100</li><li>IP列表扫描：-iL list.txt</li><li>除了指定IP以外的子网主机：192.168.1.1&#x2F;24 –exclude 192.168.1.1</li><li>除了指定文件中的IP的子网主机：192.168.1.1&#x2F;24 –excludefile list.txt</li><li>特定端口扫描：nmap -p 80,21,23 192.168.1.1</li></ul><p>一些常用的参数：</p><p>-sS：SYN扫描，半开放扫描。打开一个不完整的TCP连接，也就是不需要三次握手。优点是不需要产生任何会话，目标主机也不会记录该扫描，扫描速度快，效率高。缺点是需要最高权限执行</p><p>-sA：ACK扫描</p><p>-sP：ICMP扫描，通过PING扫描</p><p>-sT：TCP扫描，通过完整的TCP连接扫描</p><p>-Pn：扫描前不进行ping</p><p>-iL：导入扫描列表</p><p>-v&#x2F;sV：探测版本，可能会减缓扫描速度</p><p>-oG 文件名：按照nmap的格式输出文件</p><p>-O：探测操作系统版本</p><p>–script：指定脚本进行漏洞扫描</p><h3 id="网站信息收集"><a href="#网站信息收集" class="headerlink" title="网站信息收集"></a>网站信息收集</h3><h4 id="网站指纹识别"><a href="#网站指纹识别" class="headerlink" title="网站指纹识别"></a>网站指纹识别</h4><ol><li><p><strong>操作系统</strong></p><ul><li>ping判断，Windows TTL一般为128，Linux则为64。TTL大于100一般为Windows，几十的一般为Linux</li><li>nmap -O</li><li>Windows大小写不敏感，Linux大小写区分</li></ul></li><li><p><strong>网站服务 \ 容器类型</strong></p><ul><li>F12查看响应头Server字段</li><li>浏览器插件</li></ul></li><li><p><strong>脚本类型</strong></p><p>通过上面插件也可以查到脚本类型</p></li><li><p><strong>数据库类型</strong></p></li><li><p><strong>CMS识别</strong> CMS：网站内容管理</p><p>常见的CMS：dedecms（织梦）、Discuz、phpcms等</p><ul><li><p>在线识别工具</p><p><a href="http://whatweb.bugscaner.com/look/">在线指纹识别,在线cms识别小插件–在线工具 (bugscaner.com)</a></p></li><li><p>Onlinetools</p><p><a href="https://github.com/iceyhexman/onlinetools">https://github.com/iceyhexman/onlinetools</a></p></li></ul></li></ol><h4 id="敏感文件、目录"><a href="#敏感文件、目录" class="headerlink" title="敏感文件、目录"></a>敏感文件、目录</h4><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209192134826.png" alt="image-20220919213442779" style="zoom:50%;" /><p><strong>Github泄露</strong></p><p>部分开发人员将网站上传至开源网站的时候，忘记删除敏感信息。此类信息可以在Github上搜索公司的特定信息，查看是否有程序员将这些信息上传到github上</p><p><strong>.git泄露</strong></p><p>使用GitHack对其进行检索</p><p><a href="https://github.com/lijiejie/GitHack">lijiejie&#x2F;GitHack: A .git folder disclosure exploit (github.com)</a></p><p>可以通过泄露的.git文件夹下的文件，重建还原工程源代码</p><p><strong>网站备份文件</strong></p><p><a href="https://github.com/7kbstorm/7kbscan-WebPathBrute">7kbstorm&#x2F;7kbscan-WebPathBrute: 7kbscan-WebPathBrute Web路径暴力探测工具 (github.com)</a></p><p><strong>目标探测</strong></p><p><a href="https://github.com/maurosoria/dirsearch">maurosoria&#x2F;dirsearch: Web path scanner (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（11）：比较器、集合、Lambda表达式</title>
      <link href="/2022/06/07/Java%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%AF%94%E8%BE%83%E5%99%A8%E3%80%81%E9%9B%86%E5%90%88%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/06/07/Java%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%AF%94%E8%BE%83%E5%99%A8%E3%80%81%E9%9B%86%E5%90%88%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p>当我们需要实现对象的排序问题的时候，就要使用到Java的比较器。</p><p>Java实现对象排序的接口有两个：</p><ul><li>自然排序：java.lang.Comparable</li><li>定制排序：java.util.Comparator</li></ul><h3 id="自然排序"><a href="#自然排序" class="headerlink" title="自然排序"></a>自然排序</h3><p>String、包装类等都默认实现了Comparable接口，重写了comparaTo(obj)方法，因此都可以直接使用自然排序。</p><p>自定义类若想实现自然排序，我们需要去实现Comparable接口，然后重写comparaTo(obj)方法方法，重写comparaTo(obj)方法具有一定的规则：</p><p>如果当前对象this大于形参对象obj，则返回正整数；如果当前对象this小于形参对象obj，则返回负整数；如果相等，则返回0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods)&#123;<span class="comment">//判断是否为Goods类型</span></span><br><span class="line">      <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods) o;<span class="comment">//将Object类型转换为Goods类型</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(goods.name);<span class="comment">//若全部相等，则按照name进行比较</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入数据有误&quot;</span>);<span class="comment">//不是Goods类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h3><p>当元素的类没有实现Comparable接口而又不便修改代码，或是实现了Comparable接口的排序不适合当前操作，则我们可以使用Comparator的对象进行排序。</p><p>由于Comparator也是一个接口，同样需要重写方法，我们需要重写compare(Object o1, Object o2)方法，重写规则与自然排序相类似：</p><p>如果返回正整数，则代表o1大于o2；如果返回负整数，则代表o1小于o2；如果返回0，则表示o1与o2相等。</p><p>使用的方式是在调用sort()等排序方法的时候，在参数列表添加Comparator的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(goods, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line"><span class="type">Goods</span> <span class="variable">goods1</span> <span class="operator">=</span> (Goods) o1;</span><br><span class="line"><span class="type">Goods</span> <span class="variable">goods2</span> <span class="operator">=</span> (Goods) o2;</span><br><span class="line"><span class="keyword">if</span>(goods1.getName().equals(goods2.getName()))&#123;</span><br><span class="line"><span class="keyword">return</span> Double.compare(goods1.getPrice(), goods2.getPrice());</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> goods1.getName().compareTo(goods2.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入数据有误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Java集合是Java的一种容器，可以动态的把多个对象的引用放入容器中。集合与数组类似，都是Java容器，但是数组作为存储对象的容器方面具有一些弊端。</p><p><strong>数组在内存存储方式的特点：</strong></p><ol><li>数组初始化以后，长度是确定的</li><li>数组声明的类型，决定了元素初始化的类型</li></ol><p><strong>数组在存储数据方面的弊端：</strong></p><ol><li>数组初始化以后，长度不可改变，不可拓展</li><li>数组提供的属性和方法太少，不便于增删改操作，且往往效率低，而且无法直接获取存储元素的个数（只能通过遍历等方法）</li><li>数组存储的数据是有序的，可以重复的，导致存储数组的特点单一</li></ol><p>Java集合可以分为两种体系：</p><ul><li><p>Collection接口：单列数组，定义了一组对象的方法的集合</p><ul><li>List接口：元素有序、可重复的集合</li><li>Set接口：元素无序、不可重复的集合</li><li>……</li></ul><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202206161133427.png" alt="image-20220616113327310"></p></li><li><p>Map接口：双列数据，保存具有映射关系“Key-value对”的集合，类似于“函数”，一个key只能对应一个value，一个value可以有多个key</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202206161133743.png" alt="image-20220616113350677"></p></li></ul><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><h4 id="Collection接口常用的方法"><a href="#Collection接口常用的方法" class="headerlink" title="Collection接口常用的方法"></a>Collection接口常用的方法</h4><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202206211704116.png" alt="Collection常用方法"></p><h4 id="List接口：有序、可重复"><a href="#List接口：有序、可重复" class="headerlink" title="List接口：有序、可重复"></a>List接口：有序、可重复</h4><p>迭代方式：fori配合size() 与 for-each</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size()方法用于计算List的大小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++)&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (Object i : list)&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>LinkedList</strong>：链表，查询慢、增删快，无同步，线程不安全</li><li><strong>ArrayList</strong>：动态数组，查询快、删减慢，无同步，线程不安全</li><li><strong>Vector</strong>：动态数组，查询快、删减慢，同步，线程安全，但效率相较低</li></ul><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202206221706801.png" alt="这里写图片描述"></p><h4 id="Set接口：无序、不可重复"><a href="#Set接口：无序、不可重复" class="headerlink" title="Set接口：无序、不可重复"></a>Set接口：无序、不可重复</h4><p>无序性不等于随机性，无序性指的是存放的元素不是按照索引的顺序添加的，而是根据元素的哈希值决定的。</p><p>迭代方式：for-each，不可以用fori迭代。</p><ul><li><p><strong>HashSet</strong>：基于HashMap实现，Set接口的主要实现类，它不会记录插入的顺序。HashSet不是线程安全的。</p><p>添加元素的过程：</p><ol><li><p>对添加的元素计算哈希值。当添加元素为对象时，一般而言，我们都会在对象的类中重写hashCode()方法，若不重写，则Object继承下来的hashCode()的作用仅为生成一个随机数</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202206222159350.png" alt="image-20220622215950302"></p></li><li><p>取16（定义的底层数组的默认容量）的模，放入对应的位置</p></li><li><p>若遇到取模相同的，哈希值不同时，则会使用链表的方式存储，jdk7时，会使新元素替代原元素，并指向原元素，jdk8则会让原元素指向新元素</p></li><li><p>若遇到哈希值相同时，则需要equals()比较，若equals()相同则不填入，若equals()不相同，则会使用链表</p></li></ol></li><li><p><strong>LinkedHashSet</strong>：是HashSet的子类，使用链表使得迭代结果是添加顺序的。</p></li><li><p><strong>TreeSet</strong>：底层为红黑树结构存储，可以实现排序的实现类，要求放入的元素为<strong>相同类的对象</strong>。向TreeSet中添加元素，在遍历时默认会以自然排序的顺序遍历。</p><p>若我们添加的元素是对象之类的，由于没有比较的方式，则会报错，我们需要重写对象的类的compareTo()方法。自然排序实际上是实现了Comparable接口。在自然排序中，判断对象是否相等的标准为compareTo()返回是否为0，不再是equals。</p><p>而定制排序则是实现了Comparator接口，我们要使用定制排序，则需要在new TreeSet的时候，使用他的有参构造器，在参数内填入Comparator接口实现类的对象。在定制排序中，判断对象是否相等的标准为compare()返回是否为0，不再是equals。</p></li></ul><p>Set接口里没有定义新的方法。</p><p><strong>向Set接口的实现类添加的元素，一定需要重写hashCode()和equals()方法。且两个方法一定要保持规则的一致性，保证具有相等的散列码。</strong></p><h4 id="使用Iterator接口遍历"><a href="#使用Iterator接口遍历" class="headerlink" title="使用Iterator接口遍历"></a>使用Iterator接口遍历</h4><p>Iterator对象成为迭代器（设计模式的一种），主要用于遍历Collection集合中的元素。</p><p>迭代器定义：提供一种方法访问一个容器对象中各个元素，而不需要暴露该对象的内部细节。</p><p>Collection接口继承了java.lang.Iterable接口，因此它的实现类都提供了一个iterator()方法，它可以返回一个Iterable接口的对象，集合对象每次调用iterator()都会得到一个全新的迭代器对象，<strong>默认游标为第一个元素之前</strong>。</p><p>得到一个Iterable接口对象后，我们可以用Iterable的方法来获取集合内的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;<span class="comment">//hasNext()判断有无下一个元素</span></span><br><span class="line">   System.out.println(iterator.next());<span class="comment">//next()获取下一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterable有一个方法remove()，可以移除集合中的当前元素。</p><p>我们也可以使用for-each循环遍历集合，这样可以不使用Iterable接口。</p><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><h4 id="Map接口的常用方法"><a href="#Map接口的常用方法" class="headerlink" title="Map接口的常用方法"></a>Map接口的常用方法</h4><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202206261006879.png" alt="这里写图片描述"></p><h4 id="Map接口的实现类"><a href="#Map接口的实现类" class="headerlink" title="Map接口的实现类"></a>Map接口的实现类</h4><ul><li><p><strong>HashMap</strong>：作为Map的主要实现类。线程不安全，效率高。可以存储null的key和value。</p></li><li><p><strong>LinkedHashMap</strong>：HashMap的子类。添加了一个链表的机构，可以使得在遍历时，按照添加顺序遍历。对于频繁的遍历操作，可以使用这个实现类。</p></li><li><p><strong>TreeMap</strong>：可以按照添加的Key进行排序，按照自然排序或定制排序遍历，类似于TreeSet，底层实现为红黑树。</p><p>Map的特殊方法：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202206261211501.png" alt="这里写图片描述"></p></li><li><p><strong>Hashtable</strong>：最早的实现类，在Map出现之前就有。线程安全，效率低。不可以存储null的key和value。</p></li><li><p><strong>Properties</strong>：Hashtable的子类。常用于处理配置文件，key和value都是String类型。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>ArrayXxx:底层数据结构是数组，查询快，增删慢</li><li>LinkedXxx:底层数据结构是链表，查询慢，增删快</li><li>HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals()</li><li>TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序</li></ul><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda是一个匿名函数，可以理解为一段可以传递的代码。使用Lambda表达式可以使得我们的代码更加简洁。</p><p>Java的Lambda表达式本质是作为接口的实例。</p><p>使用举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未使用Lambda表达式</span></span><br><span class="line">Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Integer.compare(o1, o2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">compare1</span> <span class="operator">=</span> com1.compare(<span class="number">32</span>, <span class="number">31</span>);</span><br><span class="line">System.out.println(compare1);</span><br><span class="line"><span class="comment">//使用Lambda表达式</span></span><br><span class="line">Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; Integer.compare(o1, o2);</span><br><span class="line"><span class="type">int</span> <span class="variable">compare2</span> <span class="operator">=</span> com2.compare(<span class="number">32</span>, <span class="number">31</span>);</span><br><span class="line">System.out.println(compare2);</span><br><span class="line"><span class="comment">//使用方法引用</span></span><br><span class="line">Comparator&lt;Integer&gt; com3 = Integer::compare;</span><br><span class="line"><span class="type">int</span> <span class="variable">compare3</span> <span class="operator">=</span> com3.compare(<span class="number">32</span>, <span class="number">31</span>);</span><br><span class="line">System.out.println(compare3);</span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>首先我们看到举例代码内的主要部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(o1, o2) -&gt; Integer.compare(o1, o2)</span><br></pre></td></tr></table></figure><p><strong>格式：</strong><br>-&gt;    ：Lambda操作符 &#x2F; 箭头操作符<br>左侧：Lambda形参列表 实际上即为接口中抽象方法的形参<br>右侧：Lambda体 实际上即为实现的抽象方法的方法体</p><p>具体格式大致可分为六种情况：</p><ol><li><p><strong>无参无返回值</strong></p><p>不使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">runnable.run();</span><br></pre></td></tr></table></figure><p>使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">runnable2.run();</span><br></pre></td></tr></table></figure></li><li><p><strong>有参无返回值</strong></p><p>不使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con1 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;&gt;()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      System.out.println(s);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">con1.accept(<span class="string">&quot;114514&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con2 = (String s) -&gt; &#123;</span><br><span class="line">    System.out.println(s)</span><br><span class="line">&#125;;</span><br><span class="line">con2.accept(<span class="string">&quot;1919&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>数据类型省略 “类型推断”</strong></p><p>上面一种情况，编译器可以判断出数据类型，因此我们可以省略数据类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con3 = (s) -&gt; &#123;</span><br><span class="line">    System.out.println(s)</span><br><span class="line">&#125;;</span><br><span class="line">con3.accept(<span class="string">&quot;810&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>只需要一个参数时，可省略参数小括号</strong></p><p>上面的情况，因为只有一个参数，因此我们可以省略参数的小括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con2 = s -&gt; &#123;</span><br><span class="line">    System.out.println(s)</span><br><span class="line">&#125;;</span><br><span class="line">con2.accept(<span class="string">&quot;没活了&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>多参数且多条执行语句，且拥有返回值</strong></p><p>不使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;&gt;()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">      System.out.println(o1);</span><br><span class="line">      System.out.println(o2);</span><br><span class="line">      <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class="line">   System.out.println(o1);</span><br><span class="line">   System.out.println(o2);</span><br><span class="line">   <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>当Lambda体只有一条语句时，return与大括号可以省略</strong></p><p>不使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;&gt;()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2);</span><br></pre></td></tr></table></figure></li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型是 JDK 5 中引入的一个新特性，泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p><p>注：例子来源 <a href="https://pdai.tech/md/java/basic/java-basic-x-generic.html#%E6%B3%9B%E5%9E%8B%E7%B1%BB">Java 基础 - 泛型机制详解 | Java 全栈知识体系 (pdai.tech)</a></p><h3 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h3><ul><li><p>代码复用</p><p>在没有泛型的情况下，如果我们想实现不同类型的加法，我们需要每种类型都重载一个add方法（如下）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过泛型，我们可以复用为一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这就是一种模板开发的方式，在实例化前不指定T的类型，在实例化时再去指定，可以达到代码复用的作用。</p></li><li><p>类型安全</p><p>泛型中的类型在使用时指定，不需要强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;String&quot;</span>);</span><br><span class="line">list.add(<span class="number">100d</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br></pre></td></tr></table></figure><p>在使用list时，list里的元素是Object类型的，我们无法约束其中的类型，所以当我们取出元素的时候，很容易会出现类型转换错误的问题。</p><p>使用泛型可以达到类型约束的效果，提供了一个编译前的检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h3><p>泛型的使用大概分为三种类型：泛型类、泛型接口、泛型方法</p><h4 id="泛型类、泛型接口"><a href="#泛型类、泛型接口" class="headerlink" title="泛型类、泛型接口"></a>泛型类、泛型接口</h4><p>泛型类和泛型接口是一种模板化开发的思想，也就是我们提及的第一个作用。</p><p>如果定义了泛型类，在实例化时没有指定类的泛型，则认为此泛型为Object，不建议这样使用。</p><p>一个简单的泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T&gt;&#123;         <span class="comment">// 此处可以随便写标识符号，T是type的简称  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;     <span class="comment">// var的类型由T指定，即：由外部指定  </span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;  <span class="comment">// 返回值的类型由外部决定  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;  <span class="comment">// 设置的类型也由外部决定  </span></span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo06</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Point&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;String&gt;() ;     <span class="comment">// 里面的var类型为String类型  </span></span><br><span class="line">        p.setVar(<span class="string">&quot;it&quot;</span>) ;                            <span class="comment">// 设置字符串  </span></span><br><span class="line">        System.out.println(p.getVar().length()) ;   <span class="comment">// 取得字符串的长度  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多元泛型:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Notepad</span>&lt;K,V&gt;&#123;       <span class="comment">// 此处指定了两个泛型类型  </span></span><br><span class="line">    <span class="keyword">private</span> K key ;     <span class="comment">// 此变量的类型由外部决定  </span></span><br><span class="line">    <span class="keyword">private</span> V value ;   <span class="comment">// 此变量的类型由外部决定  </span></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(K key)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.key = key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(V value)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo09</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Notepad&lt;String,Integer&gt; t = <span class="literal">null</span> ;        <span class="comment">// 定义两个泛型类型的对象  </span></span><br><span class="line">        t = <span class="keyword">new</span> <span class="title class_">Notepad</span>&lt;String,Integer&gt;() ;       <span class="comment">// 里面的key为String，value为Integer  </span></span><br><span class="line">        t.setKey(<span class="string">&quot;汤姆&quot;</span>) ;        <span class="comment">// 设置第一个内容  </span></span><br><span class="line">        t.setValue(<span class="number">20</span>) ;            <span class="comment">// 设置第二个内容  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;姓名；&quot;</span> + t.getKey()) ;      <span class="comment">// 取得信息  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;，年龄；&quot;</span> + t.getValue()) ;       <span class="comment">// 取得信息  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>泛型方法的使用并不是简单将类型替换为泛型，以下例子均<strong>不是</strong>泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(K key)</span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.key = key ;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(V value)</span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.value = value ;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（10）：枚举类与注解</title>
      <link href="/2022/05/27/Java%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89%EF%BC%9A%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
      <url>/2022/05/27/Java%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89%EF%BC%9A%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等等。</p><h3 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h3><h4 id="方式一：通过一般类"><a href="#方式一：通过一般类" class="headerlink" title="方式一：通过一般类"></a>方式一：通过一般类</h4><ol><li>声明对象的属性：private final修饰</li><li>私有化类的构造器，并给对象属性初始化</li><li>提供当前枚举类的多个对象：public static final修饰</li><li>可选：获取枚举类的属性 getXXX() 或 toString()</li></ol><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//3.提供当前枚举类的多个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;Spring&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;Summer&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;Autumn&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;Winter&quot;</span>);</span><br><span class="line">    <span class="comment">//1.声明对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">//2.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.可选</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式二：enum关键字"><a href="#方式二：enum关键字" class="headerlink" title="方式二：enum关键字"></a>方式二：enum关键字</h4><p>在jdk5.0以后，枚举类可以使用 enum 关键字来定义，各个常量使用逗号 <strong>,</strong> 来分割。</p><p>枚举跟普通类一样可以用自己的变量、方法和构造函数，构造器只能使用 private 访问修饰符，所以外部无法调用。</p><p>枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> Season.SPRING;</span><br><span class="line">        System.out.println(spring);</span><br><span class="line">        spring.printSeason();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING, SUMMER, FALL, WINTER;</span><br><span class="line">    Season()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Season is created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printSeason</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Season is &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Season is created</span><br><span class="line">Season is created</span><br><span class="line">Season is created</span><br><span class="line">Season is created</span><br><span class="line">SPRING</span><br><span class="line">Season is SPRING</span><br></pre></td></tr></table></figure><h3 id="Enum类常用方法"><a href="#Enum类常用方法" class="headerlink" title="Enum类常用方法"></a>Enum类常用方法</h3><p>我们自定义的枚举类默认继承于java.lang.Enum类，例如默认重写了toString()方法，以及提供了很多常用方法。</p><ul><li><p>value()：返回枚举类中所有的值(返回一个数组)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Season[] values = Season.values();</span><br><span class="line"><span class="keyword">for</span> (Season s : values) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SPRING</span><br><span class="line">SUMMER</span><br><span class="line">FALL</span><br><span class="line">WINTER</span><br></pre></td></tr></table></figure></li><li><p>valueOf(String str)：返回枚举类中对象名为<code>str</code>的对象，如果没有<code>str</code>为名的枚举类。则抛出错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season</span> <span class="variable">summer</span> <span class="operator">=</span> Season.valueOf(<span class="string">&quot;SUMMER&quot;</span>);</span><br><span class="line">System.out.println(summer);<span class="comment">//out:SUMMER</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="enum关键词枚举类实现接口"><a href="#enum关键词枚举类实现接口" class="headerlink" title="enum关键词枚举类实现接口"></a>enum关键词枚举类实现接口</h3><h4 id="一：枚举类实现接口"><a href="#一：枚举类实现接口" class="headerlink" title="一：枚举类实现接口"></a>一：枚举类实现接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">   SPRING, SUoMMER, FALL, WINTER;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二：枚举类对象实现接口"><a href="#二：枚举类对象实现接口" class="headerlink" title="二：枚举类对象实现接口"></a>二：枚举类对象实现接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">   SPRING&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   SUMMER&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   &#125;, </span><br><span class="line">   FALL&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   &#125;, </span><br><span class="line">   WINTER&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（9）：多线程</title>
      <link href="/2022/05/16/Java%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/05/16/Java%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h3><h4 id="方式一：继承于Thread类"><a href="#方式一：继承于Thread类" class="headerlink" title="方式一：继承于Thread类"></a>方式一：继承于Thread类</h4><ol><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run()方法（将线程执行的操作写在里面）</li><li>创建Thread类子类的对象</li><li>通过此对象调用start()方法（不能通过直接调用run()方法启动线程）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">TestThread</span> <span class="variable">testThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThread</span>();</span><br><span class="line">testThread.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要两个线程同时进行的时候，我们不可以再启动一个已经start的线程的对象，需要新建一个对象。</p><p>我们还可以通过创建Thread类的匿名子类实现多线程创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><h4 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h4><ol><li>创建一个实现了Runnable接口的类</li><li>实现run()方法</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TestThread</span>()).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于实现类的对象与启动线程的对象不相同，因此一个实现类对象可以有多个线程。</p><p>开发中我们一般优先选择方式二实现Runnable接口的方式：</p><ol><li>实现没有类的单继承性的局限性</li><li>实现的方法更适合来处理多个线程有共享数据的情况</li></ol><p>二者之间有所联系：Thread类本身也是实现Runnable接口的</p><h4 id="Thread类常用方法"><a href="#Thread类常用方法" class="headerlink" title="Thread类常用方法"></a>Thread类常用方法</h4><p>void start()：启动线程，并执行run()方法</p><p>run()：线程被调度时执行的操作</p><p>String getName()：返回线程的名字</p><p>void setName()：设置线程名字</p><p>static Thread currentThread()：返回当前线程，相当于this</p><p>yiele()：释放当前线程的cpu执行权</p><p>join()：优先执行该线程，原线程进入阻塞状态，执行完该线程后再继续执行原线程</p><p>stop()：强制结束当前线程生命期（<strong>不推荐使用</strong>）</p><p>sleep(long millisec)：让当前执行的线程休眠指定millisec毫秒（进入阻塞状态）。使用该方法时，会抛出一个异常，由于父类run()方法是没有抛出异常的，因此只能使用try-catch处理异常</p><p>isAlive()：判断线程是否存活</p><h4 id="方式三：实现Callable接口"><a href="#方式三：实现Callable接口" class="headerlink" title="方式三：实现Callable接口"></a>方式三：实现Callable接口</h4><p>这种创建多线程的方式是JDK5.0新增的一种方式。与实现Runnable相比，Callable功能更强大：</p><ul><li>相比run()方法，call()方法可以有返回值</li><li>call()方法可以抛出异常</li><li>支持泛型的返回值</li><li>需要借助FutureTask类</li></ul><p>FutureTask是Future接口的唯一的实现类，它同时实现了Runnable和Future接口。它既可以作为Runnable被线程执行，也可以作为Future得到Callable的返回值。</p><p>使用过程：</p><ol><li>创建一个实现Callable的实现类</li><li>实现Call()方法，类似于run()</li><li>创建Callable实现类的对象</li><li>将Callable实现类的对象传递到FutureTask构造器中</li><li>创建Thread对象，并执行start()方法启动线程</li><li>若需要返回值，则可以使用Callable实现类的对象的get()方法返回值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//3.创建Callable实现类的对象</span></span><br><span class="line">      <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">      <span class="comment">//4.将Callable实现类的对象传递到FutureTask构造器中</span></span><br><span class="line">      <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//get()返回值即为FutureTask构造器参数的Callable实现类重写的call()方法的返回值</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">         System.out.println(<span class="string">&quot;sum = &quot;</span> + sum);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//2.实现Call()方法</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            sum += i;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式四：线程池"><a href="#方式四：线程池" class="headerlink" title="方式四：线程池"></a>方式四：线程池</h4><p>当经常需要创建和销毁、使用量比较大的资源，比如并发情况下的线程，对性能影响较大。这时候我们可以提前创建好多个线程，放入线程池中，使用时直接获取，使用完后放入池中。使用线程池有几点好处：</p><ul><li>提高响应速度</li><li>降低资源消耗</li><li>便于线程管理</li></ul><p>Java标准库提供了ExecutorService接口表示线程池，但ExecutorService只是一个接口，Java标准库提供的几个常用实现类：</p><ul><li>FixedThreadPool：线程数固定的线程池</li><li>CachedThreadPool：线程数根据任务动态调整的线程池</li><li>SingleThreadExecutor：仅单线程执行的线程池</li></ul><p>创建这些线程池的方法都被封装在Executors类中，均为<code>newXXXX</code>。</p><p>线程池多线程使用流程：</p><ol><li>创建线程池</li><li>执行指定的线程的操作，提供一个Runnable接口（execute()方法）或Callable接口（submit()方法）实现类的对象作为参数</li><li>关闭线程池</li></ol><p>例子以FixedThreadPool线程池为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">      service.execute(<span class="keyword">new</span> <span class="title class_">TestThread</span>());</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      service.shutdown();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设置线程池属性</strong></p><p>由于ExecutorService作为一个接口，里面不包含具体的方法，我们通过getClass()方法可以获取到service的类是ThreadPoolExecutor，我们前面是使用多态的方式创建的对象，导致ThreadPoolExecutor的方法不能使用，因此我们可以使用强转的方式转换为ThreadPoolExecutor类，再调用设置线程池属性的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">service2</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">service2.setCorePoolSize(<span class="number">10</span>);<span class="comment">//设置核心池大小为15</span></span><br></pre></td></tr></table></figure><h3 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h3><p>Java对于同优先级线程组成先进先出队列（先到先服务），采用“时间片”策略（切换处理），对于高优先级，使用有限调度的抢占式策略（高优先级线程抢占CPU）。</p><p>线程的优先级有三个常量：</p><ul><li>MAX_PRIORITY : 10</li><li>MIN_PRIORITY : 1</li><li>NORM_PRIORITY : 5</li></ul><p>涉及的方法：</p><ul><li>getPriority() : 返回线程优先值</li><li>setPriority(int newPriority) : 改变线程的优先级</li></ul><p>注意点：</p><p>高优先级线程抢占低线程的执行权，但是不意味需要当高优先级执行完以后，低优先级的线程才能执行，只是从概率上讲，高优先级的线程更优先被执行。</p><p>线程创建时会自动继承父线程的优先级。</p><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>线程的启动到线程的结束的整个过程被称之为线程的生命周期。</p><p>线程的生命周期中存在多种状态：</p><ol><li>新建：当一个Thread类及其子类被声明并创建时，新生的线程处于就绪状态</li><li>就绪：当新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已经具备了运行的条件，但暂时没有分配到CPU资源</li><li>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态</li><li>阻塞：在某些情况下，被人为挂起或者执行输入输出操作时，临时中止自己的执行，进入阻塞状态</li><li>死亡：线程完成了全部工作，或者线程被强制提前终止，或出现异常导致结束</li></ol><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202205201717258.png" alt="image-20220520171701160"></p><h3 id="线程的安全性问题"><a href="#线程的安全性问题" class="headerlink" title="线程的安全性问题"></a>线程的安全性问题</h3><p>当我们多个线程同时去对同一个参数进行操作时，我们往往会发现，这个参数出现多个线程同时操作时出现只操作一次的情况，举个售票的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ticketWindows</span> <span class="variable">ticketWindows</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ticketWindows</span>();</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketWindows);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketWindows);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketWindows);</span><br><span class="line">      t1.setName(<span class="string">&quot;Window1&quot;</span>);</span><br><span class="line">      t2.setName(<span class="string">&quot;Window2&quot;</span>);</span><br><span class="line">      t3.setName(<span class="string">&quot;Window3&quot;</span>);</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">      t3.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ticketWindows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行如上代码，在控制台，我们发现一个严重的问题，窗口1、2、3出现了售出同一张票的情况：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202205211739097.png" alt="image-20220521173909064"></p><p>这种就是线程的安全问题。解决方式就是当线程A在操作的时候，其他线程无法参与，直到线程A操作完成后，其他线程才可以开始操作，即使线程A出现阻塞也无法参与。</p><h4 id="同步机制解决线程安全问题"><a href="#同步机制解决线程安全问题" class="headerlink" title="同步机制解决线程安全问题"></a>同步机制解决线程安全问题</h4><p><strong>方式一：同步代码块</strong></p><p>结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line"><span class="comment">//需要被同步的代码：操作共享数据的代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享数据：多个线程共同操作的变量，比如：ticket；</p><p>同步监视器：俗称锁。任何一个类的对象都可以充当锁，但要求多个线程必须共用同一个锁。</p><p>例1：</p><p>我们将上面卖票窗口的代码修改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ticketWindows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">         <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">               ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再去检查控制台，发现没有再次出现重票错票的情况了。</p><p>但是当我们通过继承Thread的方式去创建多线程的时候，我们就发现了一个问题——他仍然出现了错票重票的情况。我们前面提到锁必须多个线程共用一个，而当我们通过继承Thread的方式创建多线程的时候，我们使用的锁<code>this</code>指代的对象并不是指代的同一个，而分别是<code>t1, t2, t3</code>，因此锁就失效了，因此我们作出对应的修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (ticketWindows.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">ticket--;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射的知识，我们可以直接将<code>ticketWindows</code>作为一个对象，充当了锁，因为<code>t1, t2, t3</code>内的<code>ticketWindows</code>都是共用的一个对象，因此，我们就没有出现线程的安全性问题了。</p><p>注意，我们用synchronized代码块包含代码时，我们仅需将操作共享数据的代码包起来即可，不能包多，包多可能会与实际情况相违背了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (ticketWindows.class) &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">         ticket--;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如这种情况，我们就会出现一个线程在操作，其他线程全部没有使用的情况。</p><p><strong>方式二：同步方法</strong></p><p>在方法定义出加上synchronized关键词可以将方法变成同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>同步方法同样是存在锁的，它的锁是<code>this</code>，因此对于继承<code>Thread</code>方法创建的多线程，直接如上使用的话一样是存在线程的安全性问题的。我们可以通过将方法写为静态的方式，解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>由于静态方法里面不能使用<code>this</code>，所以它的锁自然而然的就变成类<code>ticketWindows.class</code>。</p><p><strong>总结</strong></p><p>使用同步机制，我们解决线程的安全问题，但操作同步代码时，只能由一个线程参与，其他线程只能等待，相当于是一个单线程的过程，效率不太高。</p><p><strong>懒汉式单例改写为线程安全式</strong></p><p>在多线程调用懒汉式的<code>getInstance</code>方法时，如果我们不做保证线程安全性问题的措施，我们有可能会出现多个线程同时进入了if语句内，导致创建了多个实例，不能实现我们单例设计模式的目的。因此我们需要通过上面所学的知识，解决线程安全性问题，首先是同步方法和同步代码块的方式解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(bank == <span class="literal">null</span>)&#123;</span><br><span class="line">      bank = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bank;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Bank.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(bank == <span class="literal">null</span>)&#123;</span><br><span class="line">bank = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bank;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但者两种方式效率并不是很高，表面上是多线程执行，但实际上只能同时进行一个操作，与之前所提到的例子不同，单例设计模式线程安全性问题仅会出现在不存在实例的时候，因此我们可以在外面再包多一次if语句判断是否已经存在实例，这样就只会在实例不存在的时候，进入一次同步代码块，这样效率就高很多了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(bank == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Bank.class) &#123;</span><br><span class="line">         <span class="keyword">if</span>(bank == <span class="literal">null</span>)&#123;</span><br><span class="line">            bank = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程的死锁问题</strong></p><p>死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放出自己需要的同步资源，就形成了线程的死锁。出现死锁后，不会出现异常，不会出现提示，但所有的线程都会处于阻塞状态，无法继续执行。</p><p>我们构造两个线程，第一个线程先握住s1锁，再握住s2锁，第二个线程先握住s2锁，再握住s1锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">      <span class="type">StringBuffer</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">               s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">               s2.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">100</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">                  s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                  s2.append(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">                  System.out.println(s1);</span><br><span class="line">                  System.out.println(s2);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">               s1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">               s2.append(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">100</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">                  s1.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">                  s2.append(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">                  System.out.println(s1);</span><br><span class="line">                  System.out.println(s2);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，控制台它什么都没有显示，什么都没有提示：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202205231919190.png" alt="image-20220523191927155"></p><p>这是因为线程1抢到了s1锁，然后线程2抢到了s2锁，但是线程1又需要s2锁才能继续执行，而线程2有需要s1锁才能继续执行，然后二者就僵持住了，导致了这个结果。</p><p>解决方式：</p><ul><li>专门的算法、原则</li><li>尽量减少同步资料的定义</li><li>尽量减少嵌套同步</li></ul><h4 id="Lock锁解决线程安全问题"><a href="#Lock锁解决线程安全问题" class="headerlink" title="Lock锁解决线程安全问题"></a>Lock锁解决线程安全问题</h4><p>Lock锁是JDK5.0新增的更强大的线程同步机制，通过显式定义同步锁对象来实现同步，同步锁使用Lock对象充当。</p><p>使用的步骤：</p><ol><li>定义一个ReentrantLock类的对象，构造器内可以选择是否启用公平机制，如果填入true的话，Lock锁就会按先来后到的顺序安排线程，而不是抢占式，默认不填构造器即false</li><li>使用try-finally环绕包含执行操作过程，并在操作过程前调用锁定方法lock()</li><li>在finally内调用解锁方法unlock()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ticketWindows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="comment">// 定义一个ReentrantLock类的对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用锁定方法lock()</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">               ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 调用解锁方法unlock()</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="synchronized与Lock锁差别"><a href="#synchronized与Lock锁差别" class="headerlink" title="synchronized与Lock锁差别"></a>synchronized与Lock锁差别</h4><ul><li>Lock锁是手动锁定与解锁，是显式锁，而synchronized机制是相应代码执行完后自动解锁线程</li><li>Lock只有代码块锁，synchronized有代码锁和方法锁</li><li>Lock锁由于比较后出现，优化较好，JVM将使用较少时间来调度线程，性能更好，而且提供了更多子类</li><li>优先使用顺序：Lock ——&gt; 同步代码块 ——&gt; 同步方法</li></ul><h3 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h3><p>涉及到的方法：</p><ul><li>wait()：执行该方法会使当前线程进入阻塞状态，并释放锁</li><li>notify()：执行此方法会唤醒的被wait的线程，如果多个线程都被wait，则优先唤醒优先度高的线程</li><li>notifyAll()：执行此方法会唤醒全部被wait的线程</li></ul><p>例：使用两个线程交替售票</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ticketWindows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            notify();</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">               ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体思路就是通过wait()阻塞线程1，然后让线程2拿到锁再去唤醒线程1，执行完线程2操作后线程2进入阻塞，以此循环。</p><p><strong>注意点</strong></p><ol><li>wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中</li><li>wait()，notify()，notifyAll()三个方法调用者必须是同步代码块或同步方法的同步监视器，否则会出现异常</li><li>wait()，notify()，notifyAll()三个方法式定义在java.lang.Object类中</li></ol><p><strong>sleep()与wait()异同</strong></p><ul><li>同：都会进入阻塞状态</li><li>sleep()定义在Thread类中，wait()定义在Object类中</li><li>调用的范围：sleep()可以在任何情景下调用，wait()必须在同步代码块和同步方法中</li><li>sleep()不会释放锁，wait()会释放锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（8）：异常处理</title>
      <link href="/2022/05/10/Java%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2022/05/10/Java%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>异常是程序在执行过程中发生不正常的情况。</p><p>Java程序的异常情况分为两类：</p><ul><li><strong>Error：</strong>Java虚拟机无法解决的严重问题。如JVM内部错误、资源耗尽等。一般不编写针对性代码处理。</li><li><strong>Exception：</strong>其他由于编程出错或者偶发性的外在因素导致的一般性错误，则可以通过针对性的代码进行处理。如：空指针访问，试图读取不存在的文件，网络中断，数组越界等等情况。</li></ul><p>对于异常，我们拥有两种办法：第一种是不处理，直接终止程序运行。另外一种就是在编写程序的过程中，将异常的处理方法写入代码中。</p><h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><ul><li><p>NullPointerException 空指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure></li><li><p>ArrayIndexOutOfBoundsException 数组越界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(arr[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure></li><li><p>ClassCastException 类型转换错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br></pre></td></tr></table></figure></li><li><p>NumberFormatException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(str);</span><br></pre></td></tr></table></figure></li><li><p>InputMismatchException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(score);</span><br></pre></td></tr></table></figure><p>当你输入内容为非int类型时，就会报出错误。</p></li><li><p>ArithmeticException 算术异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(a / b);</span><br></pre></td></tr></table></figure></li></ul><h4 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h4><ul><li><p>IOException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line"><span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">   System.out.print((<span class="type">char</span>) data);</span><br><span class="line">   data = fis.read();</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><p>这种编译是无法通过的。</p></li></ul><h3 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h3><p>在编写程序时候，我们往往需要<code>if-else</code>分支对可能出现错误的地方进行检测，但是过多的<code>if-else</code>分支会导致代码过于臃肿。异常处理机制可以将异常处理的代码集中在一起，与正常代码分开，减少过多<code>if-else</code>分支。</p><p>Java有两种异常处理的方式，分别是<code>try-catch-finally</code>方式与<code>throws</code>方式。<code>try-catch-finally</code>方式是自行解决，<code>throws</code>方式是上报的方式，让上面去解决。</p><p>Java的异常处理是一个“抓抛模型”：“抛”是指程序执行的过程中，如果出现异常，就会生成一个对应异常类的对象，并将此对象抛出，一旦抛出异常对象以后，其后代码将不再执行。“抓”是抓取到异常对象后，对异常的处理——try-catch-finally和throws。</p><h4 id="try-catch-finally方式"><a href="#try-catch-finally方式" class="headerlink" title="try-catch-finally方式"></a>try-catch-finally方式</h4><p><strong>结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//处理异常类型1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量<span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//处理异常类型2</span></span><br><span class="line">&#125;.....</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>使用try将可能出现异常代码包装起来，在执行的过程中一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，在catch中进行匹配。进入catch后，进行异常的处理，处理完成后，就会跳出结构（在没有写finally情况下），继续执行后面代码。</p><p>在try-catch结构中申明的变量，在出了结构以后，就不可以再使用了。</p><p>使用<code>try-catch</code>处理异常时，可以使得编译时的错误延迟到运行时再出现。</p><p><code>catch</code>可以写多个。<code>finally</code>是可选的，不一定要写。</p><p><strong>try-catch基础例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">   System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;NumberFormatException&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * output:</span></span><br><span class="line"><span class="comment"> * NumberFormatException</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>由于<code>System.out.println(&quot;1&quot;);</code>是位于异常后面，因此在抛出异常后，发生异常之后的代码将不会执行。</p><h4 id="throws方式"><a href="#throws方式" class="headerlink" title="throws方式"></a>throws方式</h4><p><code>throws</code>给我个人的感觉与抽象类有点相似，<code>throws</code>就是在这个方法里我先不处理，谁调用了这个方法就由谁进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      test();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">   <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">   <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line">   <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.print((<span class="type">char</span>) data);</span><br><span class="line">      data = fis.read();</span><br><span class="line">   &#125;</span><br><span class="line">   fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何选择处理方式"><a href="#如何选择处理方式" class="headerlink" title="如何选择处理方式"></a>如何选择处理方式</h4><ol><li>如果父类中被重写的方法没有throws处理异常，则子类重写的方法如果出现异常，就只能使用try-catch-finally进行处理；</li><li>在执行的方法A中，如果需要先后调用几个具有递进关系的方法，则这几个方法使用throw的方式处理，而A方法使用try-catch-finally的方式处理；</li><li>注意：子类重写的方法抛出的异常类型不大于父类被重写方法抛出的异常类型。</li></ol><h3 id="手动抛出异常"><a href="#手动抛出异常" class="headerlink" title="手动抛出异常"></a>手动抛出异常</h3><p>异常对象可以通过跟一般对象一样，通过<code>new</code>生成异常对象。</p><p>通过<code>throw</code>关键词，我们可以将异常对象抛出。注意此处为<code>throw</code>，并非<code>throws</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.id = id;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;id must be greater than 0&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>下面是自定义的步骤</p><ol><li>自定义异常类一般我们先会让我们自定义的类继承现有的异常体系（Exception、RuntimeException）；</li><li>定义全局常量<code>serialVersionUID</code>（对类的唯一标识）；</li><li>提供重载的构造器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">NewException</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">NewException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(msg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记零碎补充（2）：包装类、单例、代码块</title>
      <link href="/2022/04/29/Java%E7%AC%94%E8%AE%B0%E9%9B%B6%E7%A2%8E%E8%A1%A5%E5%85%85%EF%BC%882%EF%BC%89%EF%BC%9A%E5%8C%85%E8%A3%85%E7%B1%BB%E3%80%81%E5%8D%95%E4%BE%8B%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
      <url>/2022/04/29/Java%E7%AC%94%E8%AE%B0%E9%9B%B6%E7%A2%8E%E8%A1%A5%E5%85%85%EF%BC%882%EF%BC%89%EF%BC%9A%E5%8C%85%E8%A3%85%E7%B1%BB%E3%80%81%E5%8D%95%E4%BE%8B%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>包装类是针对八种基本数据类型定义相应的引用类型。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Lnteger</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr></tbody></table><p>其中<code>Byte  Short  Lnteger  Long  Float  Double</code>拥有一个父类<code>Number</code>。</p><p>包装类的出现，使得基本数据类型可以封装起来，作为一个类使用，完善了Java面向对象的特性。</p><h3 id="包装类、基本数据类型、String相互转换"><a href="#包装类、基本数据类型、String相互转换" class="headerlink" title="包装类、基本数据类型、String相互转换"></a>包装类、基本数据类型、String相互转换</h3><p><strong>使用构造器将基本数据类型装箱</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(i1.toString());<span class="comment">//out:1</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">System.out.println(i2.toString());<span class="comment">//out:1</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">&quot;true123&quot;</span>);</span><br><span class="line">System.out.println(b2.toString());<span class="comment">//out:false</span></span><br><span class="line"><span class="comment">//Java在将布尔类型装箱时，如果不是null或者true，一律均未false</span></span><br><span class="line"><span class="comment">//布尔作为基本数据类型的时候，初值为false，作为包装类的时候，初值为null</span></span><br></pre></td></tr></table></figure><p><strong>使用包装类内置方法转换为基本数据类型</strong></p><p>包装类拥有一个<code>xxxValue</code>的方法，<code>xxx</code>是指要转换的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> i.intValue();</span><br><span class="line">System.out.println(i1);</span><br></pre></td></tr></table></figure><p><strong>自动装箱与自动拆箱</strong></p><p>这是包装类与基本数据类型之间最常用的转换方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line">   Test(i1);<span class="comment">//自动装箱</span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> i1;<span class="comment">//自动装箱</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> i2;<span class="comment">//自动拆箱</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">(Object obj)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="包装类、基本数据类型与String之间的转换"><a href="#包装类、基本数据类型与String之间的转换" class="headerlink" title="包装类、基本数据类型与String之间的转换"></a>包装类、基本数据类型与String之间的转换</h3><p><strong>包装类、基本数据类型–&gt;String</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> i1 + <span class="string">&quot;&quot;</span>;<span class="comment">//方式一</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> String.valueOf(i1);<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure><p><strong>String–&gt;包装类、基本数据类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;114514&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(str1);<span class="comment">//包装类的parseXxx方法</span></span><br></pre></td></tr></table></figure><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>单例的设计模式就是让某一个类只能存在一个对象实例，并且这个类只提供一个取得其对象实例的方法。</p><p>具体就是将类的<strong>构造器访问权限设置为<code>private</code><strong>，这样类的外部就无法访问到类的构造器，但我们可以在</strong>类的内部产生类的对象</strong>。由于在类的外部，我们无法得到类的对象，只能通过<strong>该类的某个静态方法</strong>返回类内部构建的对象，由于静态方法只能访问静态成员变量，所以，指向类内部产生的<strong>对象的变量也必须是静态的</strong>。</p><p>单例有两种实现的方式——饿汉式与懒汉式。</p><h3 id="饿汉式实现"><a href="#饿汉式实现" class="headerlink" title="饿汉式实现"></a>饿汉式实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="comment">//1.私有化类的构造器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//2.内部创建类的对象，并将其设置为静态</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">   <span class="comment">//3.提供公共的静态的方法，返回类的对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式实现"><a href="#懒汉式实现" class="headerlink" title="懒汉式实现"></a>懒汉式实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="comment">//1.初始化类的构造器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//2.声明一个静态类对象，但不进行初始化</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">//3.声明一个公共、静态的方法，返回当前类的对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;<span class="comment">//防止创建多个对象</span></span><br><span class="line">         instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例的使用"><a href="#单例的使用" class="headerlink" title="单例的使用"></a>单例的使用</h3><p>当一个实例生成需要使用大量资源的时候，使用单例可以节约系统性能的开销。单例模式应用场景其实挺常见的：</p><ul><li>应用程序的日志</li><li>网站计数器</li><li>数据库连接池</li><li>读取配置文件的类</li><li>Windows的回收站</li><li>…</li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块在Java中指的是使用<code>&#123;&#125;</code>包围起来的代码集合。代码块分为四种，普通代码块，静态代码块，同步代码块，构造代码块。后面三种代码块均为类的成员之一。由于同步的内容还未学习，所以同步代码块的内容暂时不写。</p><h3 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h3><p>普通代码块就是在方法体内定义的代码块，普通代码块和一般代码的执行顺序与书写顺序一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;普通代码块&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代码块在类被加载的时候会被执行，而且只执行一次，并且优先于各种代码块以及构造函数。如果类中含有多个代码块，则会按照代码顺序执行。</p><p>由于静态代码块的加载是优先于类的其他成员的，所以他既不能存在任何方法体中，也不能访问任何普通变量。</p><p>静态代码块用于某些代码需要启动时就执行，例如启动时加载配置文件等。</p><h3 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造代码块与静态代码块在外观上差距了一个<code>static</code>关键词。</p><p>构造代码块在创建对象时会被调用，每次创建对象时都会调用依次，且执行顺序是优先于构造函数的。实际上，构造代码块是依托于构造函数的，在编译后，构造代码块就是将里面的代码置入构造函数的最前端。</p><p>由于构造代码块每次创建对象都会执行，而构造函数不一定每个对象构造的时候都执行（多个构造函数情况下，建立对象时传入的参数不同则初始化使用对应的构造函数），利用这个特性，我们可以做统计对象创建次数等功能。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门笔记（3）：分支管理</title>
      <link href="/2022/04/24/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
      <url>/2022/04/24/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Git入门笔记（三）"><a href="#Git入门笔记（三）" class="headerlink" title="Git入门笔记（三）"></a>Git入门笔记（三）</h2><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>分支管理是Git中非常重要的管理，使用分支可以使你在开发主线中分离出来，在不影响开发主线的情况下继续工作，例如开发测试版、测试功能之类的。接下来介绍几个基础操作。</p><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>现在我们需要创建一个叫<code>test</code>的分支，并切换至分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b test</span><br></pre></td></tr></table></figure><p>实际上这是两条命令的简写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch test</span><br><span class="line">git checkout test</span><br></pre></td></tr></table></figure><p>第一条命令，代表创建一个<code>test</code>分支；</p><p>第二个命令，代表切换到<code>test</code>分支。</p><h4 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h4><p>我们使用不带任何参数的<code>git branch</code>命令即可查看所有分支，并且该命令会将当前分支用<code>*</code>号标注出来。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204262039070.png" alt="image-20220426203906050"></p><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d test</span><br></pre></td></tr></table></figure><p>这样我们就删除了<code>test</code>分支了。如果<code>test</code>分支包含我们未合并到分支的更改，它会报出错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: The branch &#x27;test&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D test&#x27;.</span><br></pre></td></tr></table></figure><p>此时，我们如果的的确确不想要这些更改了，我们就按照错误信息中的操作，使用<code>-D</code>强制将它删除即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D test</span><br></pre></td></tr></table></figure><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>分支出来的往往是测试的分支，我们需要将他合并会主分区。</p><p>首先，我们切换会主分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br></pre></td></tr></table></figure><p>接着我们使用合并指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge test</span><br></pre></td></tr></table></figure><p>合并完成后我们就可以删除分支了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d test</span><br></pre></td></tr></table></figure><h4 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h4><p>合并分支肯定会出现两边在同一处地方不同修改的问题，这时，我们就需要去解决冲突。</p><p>我们现在在分支下修改一个文件，然后我再在主分支下修改同一文件，使得分支与主分支的文件不同。</p><p>当我们运行合并分支指令<code>git merge test</code>，它会报出错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Auto-merging git.md</span><br><span class="line">CONFLICT (content): Merge conflict in git.md</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p><code>git.md</code>自动合并失败了，我们需要去手动解决合并错误。这时，我们通过任何一种文本的方式打开我们冲突的文件<code>git.md</code>，Git会将冲突的地方帮我我们标注出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">First.Third.</span><br><span class="line">=======</span><br><span class="line">First.Second.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; test</span><br></pre></td></tr></table></figure><p><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>表示当前分支；</p><p><code>=======</code>是分割线；</p><p><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; test</code>表示Test分支。</p><p>接下来，我们根据实际情况，保留我们需要的部分，将文件进行修改，这里我们演示将两个部分合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">First.Third.</span><br><span class="line">First.Second.</span><br></pre></td></tr></table></figure><p>解决冲突内容后，我们使用提交到本地库的操作，将修改后的文件提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .\git.md</span><br><span class="line">git commit -m &#x27;主干分支冲突解决&#x27;</span><br></pre></td></tr></table></figure><p>这时，我们就解决了合并冲突了。最后我们可以将不需要的分支删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d test</span><br></pre></td></tr></table></figure><p>我们的本地分支合并工作就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门笔记（2）：远程仓库</title>
      <link href="/2022/04/22/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>/2022/04/22/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Git入门笔记（二）"><a href="#Git入门笔记（二）" class="headerlink" title="Git入门笔记（二）"></a>Git入门笔记（二）</h2><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="克隆项目到本地"><a href="#克隆项目到本地" class="headerlink" title="克隆项目到本地"></a>克隆项目到本地</h4><p>很简单，<code>git clone &lt;url&gt;</code>在url填入远程仓库的地址就可以clone到本地了，url处有两种地址，一种是通过SSH进行克隆，另外一种是通过HTTPS的方式进行克隆。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221855787.png" alt="image-20220422185525713" style="zoom:67%;" /><p>上面为SSH的方式，下面为HTTPS的方式。</p><h4 id="初始化远程仓库"><a href="#初始化远程仓库" class="headerlink" title="初始化远程仓库"></a>初始化远程仓库</h4><h5 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h5><p>以GitHub为例子，具体账号与仓库创建不再赘述。</p><p>仓库创建好了之后，我们看到我们的仓库是没有初始化的，GitHub页面上会出现一个初始化的教程。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204222053081.png" alt="image-20220422205301003" style="zoom: 33%;" /><p>我们照着教程上初始化即可，简单来说，它的初始化过程就是，先生成一个<code>README.md</code>，接着创建一个本地仓库，提交<code>README.md</code>到本地仓库，然后将本地仓库推送到远程仓库，即可完成初始化。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204222103895.png" alt="image-20220422210303739" style="zoom: 40%;" /><h5 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h5><p>Git支持多种协议，其中包括SSH，SSH速度相当不错，比HTTPS效果更佳。我们来配置一下SSH。</p><p>第一步，我们检查一下电脑上是否已经存在<code>SSH Key</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>如果显示出存在<code>id_rsa.pub</code>或<code> id_dsa.pub</code>文件时，则证明已经存在<code>SSH Key</code>，可以跳过第二步。</p><p>第二步，创建<code>SSH Key</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>如果你的电脑不支持<code>ed25519</code>的加密格式，我们也可以使用传统的<code>rsa</code>加密：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>我们可以来看看参数的含义：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-b</td><td>指定密钥长度</td></tr><tr><td>-e</td><td>读取openssh的私钥或者公钥文件</td></tr><tr><td>-f</td><td>指定用于保存密钥的文件名</td></tr><tr><td>-t</td><td>指定密钥类型</td></tr><tr><td>-C</td><td>添加注释，往往以邮箱作为注释</td></tr></tbody></table><p>通常的，我们可以省略<code>-b</code>参数。<code>-f</code>参数会在后面提示中让你填写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/yourusersname/.ssh/id_rsa): [Press enter]</span></span><br></pre></td></tr></table></figure><p>这里推荐使用默认即可，接着会提醒是输入两次密码，此密码为push时使用的密码，不是GitHub的密码，我们可以不输入，这样在push时就不需要密码了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span> </span><br><span class="line"><span class="meta"># </span><span class="language-bash">Enter same passphrase again:</span></span><br></pre></td></tr></table></figure><p>接下来，就会出现代码提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Your identification has been saved <span class="keyword">in</span> /c/Users/yourusersname/.ssh/id_rsa.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Your public key has been saved <span class="keyword">in</span> /c/Users/yourusersname/.ssh/id_rsa.pub.</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>意味着你的<code>SSH Key</code>就创建好了，公钥就是<code>/c/Users/yourusersname/.ssh/id_rsa.pub</code>、私钥是<code>/c/Users/yourusersname/.ssh/id_rsa</code>。</p><p>第三步，添加<code>SSH Key</code>至Github。</p><p>用任何文本编辑器打开你的公钥<code>id_rsa.pub</code>，复制文件内所有信息。</p><p>打开你的Github，点击你的头像，选择<code>settings</code>，然后再<code>Access</code>中找到<code>SSH and GPG keys</code>选项，选择<code>New SSH key</code>。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204242038466.png" alt="image-20220424203852243"></p><p>在<code>title</code>填入你想给这个<code>SSH Key</code>的备注，在<code>Key</code>中粘贴进刚刚复制的信息，点击<code>Add SSH key</code>即可。</p><p>这样就添加成功<code>SSH Key</code>了。</p><p>第四步，测试SSH Key。</p><p>打开Git Bash，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>出现提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">The authenticity of host <span class="string">&#x27;github.com (207.97.227.239)&#x27;</span> can<span class="string">&#x27;t be established.</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">RSA key fingerprint is （你的密钥）</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span></span><br></pre></td></tr></table></figure><p>输入<code>yes</code>即可，若创建时使用了密码，这时就需要输入你的密码。</p><p>完成后就会出现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Hi username! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">provide shell access.</span></span></span><br></pre></td></tr></table></figure><p>这样，你的Github的SSH设置就算完成了。</p><p>接下来初始化的步骤，与HTTPS几乎没有什么区别，按照Github上提示完成即可。</p><p>[^参考资料2]: <a href="https://docs.github.com/cn/authentication/connecting-to-github-with-ssh">使用 SSH 连接到 GitHub - GitHub Docs</a></p><h4 id="从远程仓库更新"><a href="#从远程仓库更新" class="headerlink" title="从远程仓库更新"></a>从远程仓库更新</h4><p>有两种方法，第一种比较安全，第二种比较方便。</p><h5 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h5><p>我们需要两个步骤：</p><ol><li>从远程仓库中抓取与拉取</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure><p>这个命令可以从远程仓库中下载数据到本地仓库，但没有进行合并。</p><p>我们clone了一个远程仓库，命令会自动将远程仓库命名为<code>origin</code>，一般来说，我们在本地仓库的文件夹内，使用<code>origin</code>作为<code>&lt;remote&gt;</code>即可，即</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure><ol start="2"><li>合并到本地仓库分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;remote&gt;/&lt;branch&gt;</span><br></pre></td></tr></table></figure><p>这个命令的意思是，将<code>&lt;remote&gt;/&lt;branch&gt;</code>分支与主合并。</p><p><code>&lt;remote&gt;/&lt;branch&gt;</code>是我们从远程仓库下载下来的分支，在Github中，主分支被命名为<code>main</code>，因此，我们从Github远程仓库下载下来的主分支名字一般都为<code>main</code>，所以我们要将远程下载下来的主分支与本地仓库当前分支合并，运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/main</span><br></pre></td></tr></table></figure><h5 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h5><p>这个命令相当于是将上面两个命令合二为一，即抓取数据并自动尝试合并到当前所在的分支。使用很简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote&gt; &lt;remote branch&gt;:&lt;local branch&gt;</span><br></pre></td></tr></table></figure><p>意思是从<code>remote</code>远程仓库中拉取<code>remote branch</code>分支，并与本地的<code>local branch</code>分支合并：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main:main</span><br></pre></td></tr></table></figure><p>如果远程分支是与当前分支合并，则冒号后面可以省略：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p>推送到远程仓库的命令，与上面<code>git pull</code>的命令格式非常相似：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</span><br></pre></td></tr></table></figure><p>意思是将本地仓库<code>local branch</code>分支与<code>remote</code>远程仓库中的<code>remote branch</code>分支合并。</p><p>如果远程分支名与本地分支名相同，则可以省略冒号后面的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote&gt; &lt;local branch&gt;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure><p>意思为将本地的<code>mian</code>分支推送到远程仓库，并于其中的<code>main</code>分支合并。</p><p>使用这个命令，我们还可以删除远程仓库中的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete testbranch</span><br></pre></td></tr></table></figure><p>意思是删除远程仓库中<code>testbranch</code>分支。</p>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门笔记（1）：基本知识与基本操作</title>
      <link href="/2022/04/19/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/04/19/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Git入门笔记（一）"><a href="#Git入门笔记（一）" class="headerlink" title="Git入门笔记（一）"></a>Git入门笔记（一）</h2><p>Git是一个非常常用的版本控制软件，很多被广泛使用的软件项目都是使用Git进行版本控制的。</p><p>本教程将不包括基础的安装流程。</p><h3 id="Git文件的三种状态"><a href="#Git文件的三种状态" class="headerlink" title="Git文件的三种状态"></a>Git文件的三种状态</h3><p>使用Git进行操作软件时，文件状态有三种：</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>已提交(committed)</td><td>表示文件已经保存在本地Git库中。</td></tr><tr><td>已修改(modifiled)</td><td>表示文件已修改，但暂未保存到Git库中。</td></tr><tr><td>已暂存(staged)</td><td>表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</td></tr></tbody></table><p>由于Git提交文件到Git库时，并不是直接从工作区直接到Git库的，中间存在一个暂存区(staging area)，这个过程的文件就被称之为<code>已暂存</code>。</p><h4 id="Git项目的三个工作区域"><a href="#Git项目的三个工作区域" class="headerlink" title="Git项目的三个工作区域"></a>Git项目的三个工作区域</h4><p>针对Git文件的三种状态，Git项目分为三个区域：</p><table><thead><tr><th>区域</th><th>描述</th></tr></thead><tbody><tr><td>工作区</td><td>简单来说就是本地看到的目录。</td></tr><tr><td>暂存区(stage &#x2F; index)</td><td>一般存放在<code>.git</code>目录下，里面包含了Git自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针<code>HEAD</code>。</td></tr><tr><td>Git仓库(版本库)</td><td>工作区下隐藏的目录<code>.git</code>，是Git的版本库（仓库）。</td></tr></tbody></table><h4 id="Git基本工作流程"><a href="#Git基本工作流程" class="headerlink" title="Git基本工作流程"></a>Git基本工作流程</h4><ul><li>工作区修改文件</li><li>对修改后的文件暂存</li><li>提交更新，将暂存的文件转储到Git仓库内</li></ul><h3 id="创建仓库与提交文件"><a href="#创建仓库与提交文件" class="headerlink" title="创建仓库与提交文件"></a>创建仓库与提交文件</h3><h4 id="初始化Git本地仓库"><a href="#初始化Git本地仓库" class="headerlink" title="初始化Git本地仓库"></a>初始化Git本地仓库</h4><p>在Git的命令行窗口，使用<code>git init</code>命令可以在本地初始化一个空仓库。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201215657.png" alt="image-20220420121506627" style="zoom:125%;" /><h4 id="提交文件至暂存区"><a href="#提交文件至暂存区" class="headerlink" title="提交文件至暂存区"></a>提交文件至暂存区</h4><p>我们可以使用<code>git add &lt;path&gt;</code>的命令，使一个位于<code>path</code>的文件或者目录添加至暂存区。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201221833.png" alt="image-20220420122135812" style="zoom:130%;" /><p>之后我们可以通过<code>git status</code>的命令，查看工作区与暂存区的文件状态。该命令可以查看到哪些修改被暂存，哪些修改没有，或是哪些文件没有被git追踪到（Untracked files）。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201222564.png" alt="image-20220420122243543"></p><h4 id="提交至本地仓库"><a href="#提交至本地仓库" class="headerlink" title="提交至本地仓库"></a>提交至本地仓库</h4><p>执行<code>git commit</code>命令可以提交暂存区的文件至本地仓库中。通常在使用该命令时，会选择加入<code>-m &lt;text&gt;</code>参数，我们可以在<code>&lt;text&gt;</code>处填入本次提交的说明。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201237212.png" alt="image-20220420123716186" style="zoom: 67%;" /><p>如果加入<code>-a &lt;file&gt;</code>参数，我们将不需要执行<code>git add</code>命令，直接将<code>file</code>提交至本地仓库。</p><p>我们也可以在<code>git commit</code>后加入<code>&lt;file1&gt; &lt;file2&gt; ....</code>文件参数，指定暂存区的某文件到本地仓库。</p><h4 id="查看提交日志信息"><a href="#查看提交日志信息" class="headerlink" title="查看提交日志信息"></a>查看提交日志信息</h4><p>使用<code>git log</code>命令，我们可以查看到提交日志信息。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201238061.png" alt="image-20220420123842023" style="zoom: 80%;" /><h4 id="修改文件并提交"><a href="#修改文件并提交" class="headerlink" title="修改文件并提交"></a>修改文件并提交</h4><p>实际上修改文件并提交的过程与上面新增一个文件并提交的过程并无太大差异。</p><p>首先我们可以用<code>git status</code>命令来查看我们已修改（modified）的文件。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201351883.png" alt="image-20220420135140855"></p><p>我们可以得知的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">On branch master 在主分支</span><br><span class="line">Changes not staged for commit: 更改没有被保存至暂存区</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) 使用git add命令保存更改至暂存区</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) 使用git restore放弃工作区的更改</span><br><span class="line">        modified:   git2.md 已更改文件： git2.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 没有要提交的更改（可以使用git add或git commit -a提交更改）</span><br></pre></td></tr></table></figure><p>通常的，我们会使用<code>git status -s</code>来获取简短的输出结果：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201405965.png" alt="image-20220420140501938"></p><p>一个红色的M表示更改未保存至暂存区，一个绿色M表示更改已保存至暂存区，当同时出现一个红和一个绿M时候，则表示添加至暂存区后又发生了更改。</p><p>我们使用<code>git add</code>提交后，就可以执行<code>git commit -m</code>来使我们暂存区的更改保存到本地仓库中了。</p><h4 id="比较文件不同"><a href="#比较文件不同" class="headerlink" title="比较文件不同"></a>比较文件不同</h4><p>我们使用<code>git diff &lt;file&gt;</code>命令，可以比较文件的不同，当不加入额外参数时，它的作用是查看尚未保存至暂存区的更改。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201426753.png" alt="image-20220420142630702"></p><p>当我们加入<code>--cached</code>或是<code>--staged</code>参数时，作用是查看已保存至暂存区的更改。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201427778.png" alt="image-20220420142702736"></p><p>当我们加入<code>HEAD</code>参数时，我们将可以看到已保存至暂存区和未保存的全部更改。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201430943.png" alt="image-20220420143033890"></p><p>而<code>--stat</code>参数的加入，可以使其仅展示摘要，而不是完整的修改内容。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201432715.png" alt="image-20220420143210685"></p><h4 id="撤销暂存区更改"><a href="#撤销暂存区更改" class="headerlink" title="撤销暂存区更改"></a>撤销暂存区更改</h4><p>执行<code>git reset HEAD &lt;file&gt;</code>我们可以撤销已保存至暂存区的更改。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201439223.png" alt="image-20220420143909172"></p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><p>在学习版本回退之前，先补充一下<code>git log</code>指令的相关参数详解。</p><p><code>--oneline </code>参数可以查看历史记录的简洁版本。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204211604452.png" alt="image-20220421160458412" style="zoom: 70%;" /><p><code>--graph</code>参数可以以拓扑图的形式，展示历史中出现的分支、合并。</p><p><code>--reverse</code>参数用于逆向显示日志。</p><p><code>--author=name</code>参数用于查询名为<code>name</code>这个人的提交日志。</p><p><code>-&lt;number&gt;</code>参数可以显示近<number>次数的提交日志。</p><h4 id="版本回退-1"><a href="#版本回退-1" class="headerlink" title="版本回退"></a>版本回退</h4><p>前面我们提及了一个撤销暂存区更改的命令<code>git reset HEAD &lt;file&gt;</code>，实际上这个命令是版本回退命令的一个使用，现在我们来详解这个命令。</p><p><code>--hard</code>参数撤销工作区所有未提交的修改内容，将工作区与暂存区都回退到上一个版本。</p><p><code>HEAD</code>参数：</p><ul><li><code>HEAD</code>表示当前版本</li><li><code>HEAD^</code>表示上版本，以此类推，<code>HEAD^^</code>表示上上个版本等等</li><li><code>HEAD~0</code>表示当前版本</li><li><code>HEAD~1</code>表示上个版本，以此类推，<code>HEAD~50</code>表示上50个版本</li></ul><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221627089.png" alt="image-20220422162741046" style="zoom:50%;" /><p><code>aabbcc</code>这个aabbcc代表的是版本唯一的标识码，我们可以用这个参数来指定回退到某以aabbcc作为版本唯一标识码的版本。</p><p>当我们后悔了，需要“回到未来”怎么办呢，我们可以用到<code>git reflog</code>的命令，来查看你每一次的操作，并且获得操作的标识码，这样就可以获得某个版本的<code>commit id</code>，也就是标识码了。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221632822.png" alt="image-20220422163214788" style="zoom: 67%;" /><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221627655.png" alt="image-20220422162701602" style="zoom: 50%;" /><h3 id="文件从本地仓库恢复"><a href="#文件从本地仓库恢复" class="headerlink" title="文件从本地仓库恢复"></a>文件从本地仓库恢复</h3><p>如果我们在工作区误删了文件，我们需要用到一个命令<code>git checkout -- &lt;file&gt;</code>，这个命令可以帮助我们从本地仓库中恢复<code>file</code>文件。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221648927.png" alt="image-20220422164852884" style="zoom: 50%;" /><h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><p>首先，我们可以在资源管理器中将工作区的文件删除，使用<code>git status</code>就可以看到我们确实删除了一个文件。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221656455.png" alt="image-20220422165616423" style="zoom: 67%;" /><p>然后我们可以使用<code>git rm &lt;file&gt; </code>的指令，确定删除该文件，接着我们用<code>git commit</code>将我们这个更改上传至本地仓库，这样文件就在本地仓库被删除了。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221701131.png" alt="image-20220422170159105" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（7）：反射</title>
      <link href="/2022/03/31/Java%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/03/31/Java%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>据我们所知，Java是一种静态语言。但是Java却可以通过<code>Reflection（反射）</code>实现动态语言的特性，反射机制允许在执行期间借助<code>Reflection API</code>取得任何类的内部信息，并且能直接操作任意对象的内部属性及方法。</p><p>反射对象相当于是一面镜子，通过镜子，”反射”得到对象的信息：某个类的属性、方法、构造器、实现的接口。</p><h3 id="获得反射对象"><a href="#获得反射对象" class="headerlink" title="获得反射对象"></a>获得反射对象</h3><h4 id="通过对象获得"><a href="#通过对象获得" class="headerlink" title="通过对象获得"></a>通过对象获得</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> person.getClass();</span><br></pre></td></tr></table></figure><h4 id="通过forname获得"><a href="#通过forname获得" class="headerlink" title="通过forname获得"></a>通过<code>forname</code>获得</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.icewindy.test.Person&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="通过类名-class获得"><a href="#通过类名-class获得" class="headerlink" title="通过类名.class获得"></a>通过类名.class获得</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Person.class;</span><br></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;c1:%s,c2:%s,c3:%s\n&quot;</span>, c1.hashCode(), c2.hashCode(), c3.hashCode());<span class="comment">//output:c1:295530567,c2:295530567,c3:295530567</span></span><br></pre></td></tr></table></figure><h4 id="基本内置类型的包装类都有一个TYPE属性"><a href="#基本内置类型的包装类都有一个TYPE属性" class="headerlink" title="基本内置类型的包装类都有一个TYPE属性"></a>基本内置类型的包装类都有一个<code>TYPE</code>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> Integer.TYPE;</span><br></pre></td></tr></table></figure><h4 id="获得父类类型"><a href="#获得父类类型" class="headerlink" title="获得父类类型"></a>获得父类类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> student.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> c4.getSuperclass();</span><br><span class="line">System.out.printf(<span class="string">&quot;c5:%s\n&quot;</span>, c5.hashCode());<span class="comment">//output:c5:295530567</span></span><br></pre></td></tr></table></figure><h3 id="拥有Class对象的类型"><a href="#拥有Class对象的类型" class="headerlink" title="拥有Class对象的类型"></a>拥有Class对象的类型</h3><p>class 各种类、interface 接口、[] 数组、enum 枚举、annotation 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Object.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Comparable.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> String[].class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="type">int</span>[][].class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> Override.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c6</span> <span class="operator">=</span> ElementType.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c7</span> <span class="operator">=</span> Integer.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c8</span> <span class="operator">=</span> <span class="keyword">void</span>.class;<span class="comment">//小写v表示void基本数据类型，大写V表示void的自动装箱类型</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c9</span> <span class="operator">=</span> Class.class;</span><br><span class="line"></span><br><span class="line">System.out.println(c1);<span class="comment">//output:class java.lang.Object</span></span><br><span class="line">System.out.println(c2);<span class="comment">//output:class java.lang.Comparable</span></span><br><span class="line">System.out.println(c3);<span class="comment">//output:class [Ljava.lang.String; ,一维数组用一个[</span></span><br><span class="line">System.out.println(c4);<span class="comment">//output:class [[I ,二维数组用两个[</span></span><br><span class="line">System.out.println(c5);<span class="comment">//output:interface java.lang.Override</span></span><br><span class="line">System.out.println(c6);<span class="comment">//output:enum java.lang.annotation.ElementType</span></span><br><span class="line">System.out.println(c7);<span class="comment">//output:class java.lang.Integer</span></span><br><span class="line">System.out.println(c8);<span class="comment">//output:void</span></span><br><span class="line">System.out.println(c9);<span class="comment">//output:class java.lang.Class</span></span><br></pre></td></tr></table></figure><h3 id="类加载过程分析"><a href="#类加载过程分析" class="headerlink" title="类加载过程分析"></a>类加载过程分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">System.out.println(a.m);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.加载到内存，产生一个类对应的java.lang.Class对象</span></span><br><span class="line"><span class="comment"> * 2.链接JVM，为类变量（静态变量）分配内存并设置为默认初始化值</span></span><br><span class="line"><span class="comment"> * 3.初始化类，调用类构造器&lt;clinit&gt;()将代码块合并</span></span><br><span class="line"><span class="comment"> * &lt;clinit&gt;()&#123;</span></span><br><span class="line"><span class="comment"> * System.out.println(&quot;A静态代码块初始化&quot;);</span></span><br><span class="line"><span class="comment"> *    m = 300;</span></span><br><span class="line"><span class="comment"> * m = 100;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A静态代码块初始化&quot;</span>);</span><br><span class="line">m = <span class="number">300</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A构造函数初始化&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>out:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A静态代码块初始化</span><br><span class="line">A构造函数初始化</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h4 id="类的初始化发生"><a href="#类的初始化发生" class="headerlink" title="类的初始化发生"></a>类的初始化发生</h4><h5 id="类的主动引用（会发生初始化）"><a href="#类的主动引用（会发生初始化）" class="headerlink" title="类的主动引用（会发生初始化）"></a>类的主动引用（会发生初始化）</h5><ol><li>JVM启动，初始化main方法所在的类</li><li>new一个类的对象</li><li>调用类的静态成员（除了常量final）和静态方法</li><li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用</li><li>当初始化一个类，如果父类没有被初始化，则先初始化父类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Main类被加载&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="comment">/*out:</span></span><br><span class="line"><span class="comment"> * Main类被加载 --1</span></span><br><span class="line"><span class="comment"> * 父类被加载   --5</span></span><br><span class="line"><span class="comment"> * 子类被加载   --2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class.forName(<span class="string">&quot;cn.icewindy.test.Son&quot;</span>);</span><br><span class="line"><span class="comment">/*out: --4</span></span><br><span class="line"><span class="comment"> * Main类被加载</span></span><br><span class="line"><span class="comment"> * 父类被加载</span></span><br><span class="line"><span class="comment"> * 子类被加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;父类被加载&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;子类被加载&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类的被动引用（不会发生初始化）"><a href="#类的被动引用（不会发生初始化）" class="headerlink" title="类的被动引用（不会发生初始化）"></a>类的被动引用（不会发生初始化）</h5><ol><li>当访问一个静态域，只有真正申明这个域的类才会被初始化。如：通过子类引用父类的静态变量，不会导致子类初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Father.a);</span><br><span class="line">System.out.println(Son.a);</span><br><span class="line"><span class="comment">/* out:    --1</span></span><br><span class="line"><span class="comment"> * Main类被加载</span></span><br><span class="line"><span class="comment"> * 父类被加载</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过数组定义类的引用，不会发生此类初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Son[] arraySon = <span class="keyword">new</span> <span class="title class_">Son</span>[<span class="number">5</span>];<span class="comment">//out: Main类被加载</span></span><br></pre></td></tr></table></figure><ol start="3"><li>引用常量不会触发类的初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Son.b);</span><br><span class="line"><span class="comment">/* out:</span></span><br><span class="line"><span class="comment"> * Main类被加载</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="获取类的结构"><a href="#获取类的结构" class="headerlink" title="获取类的结构"></a>获取类的结构</h3><h4 id="获取类的名称"><a href="#获取类的名称" class="headerlink" title="获取类的名称"></a>获取类的名称</h4><ul><li><p><code>getName()</code>可以获取包名+类名；</p></li><li><p><code>getSimpleName()</code>可以获取类名。</p></li></ul><h4 id="获取类的属性"><a href="#获取类的属性" class="headerlink" title="获取类的属性"></a>获取类的属性</h4><ul><li><code>Field getField(name)</code>根据<code>name</code>获取某个<code>public</code>的属性（包括父类）；</li><li><code>Field getDeclaredField(name)</code>根据<code>name</code>获取某个属性（不包括父类）；</li><li><code>Field[] getFields()</code>获取所有<code>public</code>的属性（包括父类）；</li><li><code>Field[] getDeclaredFields()</code>获取所有属性（不包括父类）。</li></ul><h4 id="获得属性的值"><a href="#获得属性的值" class="headerlink" title="获得属性的值"></a>获得属性的值</h4><ul><li><code>Field.get(Object)</code>根据<code>Object</code>实例获取其对应属性的值。</li></ul><h4 id="获取类的方法"><a href="#获取类的方法" class="headerlink" title="获取类的方法"></a>获取类的方法</h4><ul><li><code>Method getMethod(name, Class...)</code>获取某个<code>public</code>的方法（包括父类）<code>Classs</code>代表参数类型；</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取某个方法（不包括父类）<code>Classs</code>代表参数类型；</li><li><code>Method[] getMethods()</code>获取所有<code>public</code>的方法（包括父类）；</li><li><code>Method[] getDeclaredMethods()</code>获取所有方法（不包括父类）。</li></ul><h4 id="获取类的构造器"><a href="#获取类的构造器" class="headerlink" title="获取类的构造器"></a>获取类的构造器</h4><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的构造器；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个构造器；</li><li><code>getConstructors()</code>：获取<code>public</code>的构造器；</li><li><code>getDeclaredConstructors()</code>：获取所有构造器。</li></ul><h4 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line">      <span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.icewindy.test.Student&quot;</span>);</span><br><span class="line">      <span class="comment">//获得类的名字</span></span><br><span class="line">      System.out.println(s.getName());      <span class="comment">//out:cn.icewindy.test.Student</span></span><br><span class="line">      System.out.println(s.getSimpleName());<span class="comment">//out:Student</span></span><br><span class="line">      <span class="comment">//获得类的属性</span></span><br><span class="line">      Field[] fields = s.getDeclaredFields();<span class="comment">//获取所有field（不包括父类）</span></span><br><span class="line">      <span class="keyword">for</span> (Field field : fields) &#123;           <span class="comment">//out:</span></span><br><span class="line">         System.out.println(field);         <span class="comment">//private int cn.icewindy.test.Student.ID</span></span><br><span class="line">      &#125;</span><br><span class="line">      Field[] fields2 = s.getFields();<span class="comment">//获取所有public的field（包括父类）</span></span><br><span class="line">      <span class="keyword">for</span> (Field field : fields2) &#123;  <span class="comment">//output:</span></span><br><span class="line">         System.out.println(field);  <span class="comment">//public java.lang.String cn.icewindy.test.Person.name</span></span><br><span class="line">      &#125;                       <span class="comment">//public int cn.icewindy.test.Person.age</span></span><br><span class="line">      <span class="comment">//获得属性的值</span></span><br><span class="line">      <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> s.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">      <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(<span class="keyword">new</span> <span class="title class_">Student</span>());<span class="comment">//多态</span></span><br><span class="line">      System.out.println(value);        <span class="comment">//out:icewindy</span></span><br><span class="line">      <span class="comment">//获得类的方法</span></span><br><span class="line">      Method[] methods = s.getMethods();<span class="comment">//获取所有public的method（包括父类）</span></span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;      <span class="comment">//output:太长了，省略，包括了Object的方法</span></span><br><span class="line">         System.out.println(method);</span><br><span class="line">      &#125;</span><br><span class="line">      Method[] methods2 = s.getDeclaredMethods();<span class="comment">//获取所有method（不包括父类）</span></span><br><span class="line">      <span class="keyword">for</span>(Method method : methods2)&#123;             <span class="comment">//output:</span></span><br><span class="line">         System.out.println(method);             <span class="comment">//public void cn.icewindy.test.Student.study()</span></span><br><span class="line">      &#125;                                <span class="comment">//private void cn.icewindy.test.Student.talk()</span></span><br><span class="line">      <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> s.getMethod(<span class="string">&quot;say&quot;</span>, String.class);<span class="comment">//获取指定method</span></span><br><span class="line">      System.out.println(method);                 <span class="comment">//output:public void cn.icewindy.test.Student.say(java.lang.String)</span></span><br><span class="line">      <span class="comment">//获取类的构造器</span></span><br><span class="line">      Constructor[] constructors = s.getConstructors();<span class="comment">//获取所有public的constructor（包括父类）</span></span><br><span class="line">      <span class="keyword">for</span>(Constructor constructor : constructors)&#123;<span class="comment">//output:public cn.icewindy.test.Student()</span></span><br><span class="line">         System.out.println(constructor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;icewindy&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;I am a Student&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ID</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Student is studying&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">talk</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String str)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Student is saying: &quot;</span>+str);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><h4 id="调用构造器"><a href="#调用构造器" class="headerlink" title="调用构造器"></a>调用构造器</h4><h4 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h4>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记零碎补充（1）：大数、用var声明局部变量、字符串</title>
      <link href="/2022/03/29/Java%E7%AC%94%E8%AE%B0%E9%9B%B6%E7%A2%8E%E8%A1%A5%E5%85%85%EF%BC%881%EF%BC%89%EF%BC%9A%E5%A4%A7%E6%95%B0%E3%80%81%E7%94%A8var%E5%A3%B0%E6%98%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/03/29/Java%E7%AC%94%E8%AE%B0%E9%9B%B6%E7%A2%8E%E8%A1%A5%E5%85%85%EF%BC%881%EF%BC%89%EF%BC%9A%E5%A4%A7%E6%95%B0%E3%80%81%E7%94%A8var%E5%A3%B0%E6%98%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h2><p>当基本的整数和浮点数精度不能够满足你的需求的时候，我们就可以引入在<code>java.math</code>包中的两个类——<code>BigInteger</code>和<code>BigDecimal</code>。这两个类可以处理任意长度的数值。</p><p><code>BigInteger</code>类可以处理任何精度的<code>整数运算</code>，而<code>BigDecimal</code>类可以处理任何精度的<code>浮点数运算</code>。</p><p>它们的使用方法非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;...&quot;</span>);<span class="comment">//大整数</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;...&quot;</span>);<span class="comment">//大浮点数</span></span><br></pre></td></tr></table></figure><p><code>bi / bd</code>处可以填入任意你想叫的名字，当然，最好还是尊重一下命名规则，除非你想让你的代码无人能够流畅阅读，甚至是刚睡了一觉的你。而<code>...</code>处是填入你想要的给<code>bi / bd</code>赋的数值。</p><p>我们也可以使用静态的<code>valueOf</code>方法将普通的数转换为大数，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">100</span>);<span class="comment">//100这里可以改成别的数或者是变量</span></span><br></pre></td></tr></table></figure><p>由于大数不是基础数据类型，我们就无法使用熟悉的算数运算符来处理大数，而是应该使用大数类型中的方法，下表列出最常见的运算：</p><p>BigInteger：</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>add(BigInteger other)</td><td>做加法运算</td></tr><tr><td>subtract(BigInteger other)</td><td>做减法运算</td></tr><tr><td>multiply(BigInteger other)</td><td>做乘法运算</td></tr><tr><td>divide(BigInteger other)</td><td>做除法运算</td></tr><tr><td>remainder(BigInteger other)</td><td>做取余数运算</td></tr><tr><td>pow(int n)</td><td>做n次方运算</td></tr><tr><td>mod(BigInteger other)</td><td>返回两个大数的和、差、积、商、余数</td></tr></tbody></table><p>BigDecimal：</p><p><code>BigDecimal</code>基本运算大致与<code>BigInteger</code>相同，但除法有所不同，因为需要考虑到除不尽末尾小数的处理方法。</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>add(BigDecimal other)</td><td>做加法运算</td></tr><tr><td>subtract(BigDecimal other)</td><td>做减法运算</td></tr><tr><td>multiply(BigDecimal other)</td><td>做乘法运算</td></tr><tr><td>divide(BigDecimal other)</td><td>做除法运算</td></tr><tr><td>divide(BigDecimal other，int scale,  roundingMode)</td><td>做除法运算，三个参数分别代表除数，商后的位数，近似值的处理模式</td></tr></tbody></table><p>近似值的处理模式有太多种了，这里只介绍一个，即最常见的四舍五入——<code>ROUND_HALF_UP</code>。</p><p>来个例子吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">BigDecimal</span> <span class="variable">bd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1234567890123456789012345678901234567890&quot;</span>);</span><br><span class="line">      <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;9876543210987654321098765432109876543210&quot;</span>);</span><br><span class="line">      <span class="type">BigDecimal</span> <span class="variable">bd3</span> <span class="operator">=</span> bd1.divide(bd2, <span class="number">10</span>, BigDecimal.ROUND_HALF_UP);</span><br><span class="line">      System.out.println(bd3);<span class="comment">//out:0.1249999989</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用var声明局部变量"><a href="#用var声明局部变量" class="headerlink" title="用var声明局部变量"></a>用var声明局部变量</h2><p>在Java10以上的版本，对于可以从变量初始值推导出他们的类型的，可以用<code>var</code>关键词声明局部变量。</p><p>注意，一定是在Java10以上的版本，<code>var</code>关键词是在该版本才引入的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;a&quot;</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure><p><code>var</code>关键词避免了重复写类型名，优化了写代码体验与观感，非常便利。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><p><code>String</code>类中的<code>substring</code>方法可以从字符串中提取出一个子串。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.substring(<span class="number">1</span>, <span class="number">3</span>);<span class="comment">//s2 = &quot;el&quot;</span></span><br></pre></td></tr></table></figure><p><code>1</code>处填入的是截取开始的位置，<code>3</code>截取结束的位置。（tips：字符串位置跟数组一样是从0开始的）</p><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p>有截取的方法，那自然有拼接的方法，使用<code>+</code>号就可以拼接起两个字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1+s1;<span class="comment">//s2 = &quot;HelloHello&quot;</span></span><br></pre></td></tr></table></figure><p>当一个字符串与非字符串拼接时，非字符串就会转换成字符串进行拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">233</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1 + i;<span class="comment">//s2 = &quot;Hello233&quot;</span></span><br></pre></td></tr></table></figure><p>这种用法我们就常常用在输出结果。</p><p>当我们希望多个字符串放在一起的时候，我们也可以使用<code>join</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> String.join(s1, <span class="string">&quot; &quot;</span>, s2);<span class="comment">//s3 = &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><p>在Java11以上的版本，还提供了一个重复某个字符串多次的方法<code>repeat</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.repeat(<span class="number">3</span>);<span class="comment">//s2 = &quot;HelloHelloHello&quot;</span></span><br></pre></td></tr></table></figure><h3 id="不可变字符串"><a href="#不可变字符串" class="headerlink" title="不可变字符串"></a>不可变字符串</h3><p>Java的字符串与C语言的字符串不太相同，Java字符串不是一个数组，它的字符串不可以修改里面的某一个字符，想修改字符串，只能通过截取字符串，再重新拼接方式来修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Helle&quot;</span>;</span><br><span class="line">s1 = s1.substring(<span class="number">0</span>, <span class="number">4</span>)+<span class="string">&quot;o!&quot;</span>;<span class="comment">//s1 = &quot;Hello!&quot; </span></span><br></pre></td></tr></table></figure><h3 id="判断字符串是否相等"><a href="#判断字符串是否相等" class="headerlink" title="判断字符串是否相等"></a>判断字符串是否相等</h3><p>虽然字符串不是一个数组，但是我们也不能通过<code>==</code>来判断是否相等，而是应该用<code>equals</code>方法来判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s1.equals(s2);<span class="comment">// false</span></span><br><span class="line">s1.equals(s3);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果我们想让判断不区分大小写，我们还可以用<code>equalsIgnoreCase</code>来判断。</p><p><code>==</code>判断符只能判断两个字符串是否在同一位置（地址）上，而不能真正判断是否相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(str.substring(<span class="number">0</span>, <span class="number">3</span>) == <span class="string">&quot;Hel&quot;</span>)&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;true&quot;</span>);<span class="comment">//</span></span><br><span class="line">&#125;<span class="comment">//none</span></span><br></pre></td></tr></table></figure><h3 id="构建字符串"><a href="#构建字符串" class="headerlink" title="构建字符串"></a>构建字符串</h3><p>如果我们遇到需要经常拼接的情况，例如读取按键的时候，我们采用上面那种字符串拼接方式，就会导致每次都要构建一个新的<code>String</code>对象，既耗时又浪费空间，效率低下，这时候，我们使用<code>StringBuilder</code>类就可以避免这个问题的发生。</p><p>首先我们需要构建一个空的字符串构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><p>然后就可以使用<code>StringBuilder</code>类的方法来构建字符串了，下面给出部分常用的方法：</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>append(String str &#x2F; char c)</td><td>添加一个字符串 &#x2F; 代码单元</td></tr><tr><td>setCharAt(int i, char c)</td><td>讲第 i 个代码单元替换为 c</td></tr><tr><td>insert(int i, String str &#x2F; char c)</td><td>在 i 的位置插入字符串str &#x2F; 代码单元 c</td></tr><tr><td>delete(int i, int j)</td><td>删除 i 到 j 的代码单元</td></tr></tbody></table><p>在构建完字符串之后就可以使用<code>toString</code>返回一个字符串了。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">builder.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">System.out.println(builder.toString());<span class="comment">//out:helloworld</span></span><br></pre></td></tr></table></figure><h2 id="文件的输入输出"><a href="#文件的输入输出" class="headerlink" title="文件的输入输出"></a>文件的输入输出</h2><p>当我们需要读取一个文件，需要构建一个<code>Scanner</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Path.of(<span class="string">&quot;test.txt&quot;</span>), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure><p><code>Path.of(&quot;...&quot;)</code>这里面填入的是文件的位置，当你填入像上面那种相对地址时，该相对地址是相对于Java虚拟机启动目录的位置，实际上我认为还是填入绝对地址比较方便，例如<code>c:\\testPath\\test.txt</code>、<code>/home/icewindy/testPath/test.txt</code>。</p><p><code>StandardCharsets.UTF_8</code>很容易看出，这里填入的是文件的编码格式，如果不指定文件的编码格式，则会使用运行该程序的机器的“默认编码”，或许会导致不同平台上运行效果的差异，不建议这样使用。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（6）：注解</title>
      <link href="/2022/03/24/Java%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/03/24/Java%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解就是带有一定功能的注释。</p><h3 id="内置的注解"><a href="#内置的注解" class="headerlink" title="内置的注解"></a>内置的注解</h3><h4 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h4><p>该注解我们在前面的学习中也见到过多次了，这个注解是声明下面的方法重写了超类中的方法，如果注解下面的方法没有重写超类中的方法，则编译器报错。</p><h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h4><p>这个注解表示该程序元素是不鼓励使用的，因为通常的，它是危险的，或者是已经存在更好的替代方法。该注解会使编译器在出现该程序元素的代码处发出警告。</p><h4 id="SuppressWarnings-“…”"><a href="#SuppressWarnings-“…”" class="headerlink" title="@SuppressWarnings(“…”)"></a>@SuppressWarnings(“…”)</h4><p>镇压警告。</p><p>它与前面两种注解不太相同，这个注解需要一个参数。</p><p><code>SuppressWarnings</code>常用的参数的表格：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>deprecation</td><td>使用了不赞成使用的类或方法时的警告</td></tr><tr><td>unchecked</td><td>执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。</td></tr><tr><td>fallthrough</td><td>当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。</td></tr><tr><td>path</td><td>在类路径、源文件路径等中有不存在的路径时的警告。</td></tr><tr><td>serial</td><td>当在可序列化的类上缺少 serialVersionUID 定义时的警告。</td></tr><tr><td>finally</td><td>任何 finally 子句不能正常完成时的警告。</td></tr><tr><td>all</td><td>关于以上所有情况的警告。</td></tr></tbody></table><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解的作用是负责注解（定义）其他的注解。</p><h4 id="Target-value-x3D-…"><a href="#Target-value-x3D-…" class="headerlink" title="@Target(value &#x3D; …)"></a>@Target(value &#x3D; …)</h4><p>描述注解适用的范围（注解可以用在什么地方）。</p><p><code>...</code>处填入java.lang.annotation.ElementType 枚举类型，ElementType 常用的枚举常量在下表：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>CONSTRUCTOR</td><td>用于构造方法</td></tr><tr><td>FIELD</td><td>用于成员变量（包括枚举常量）</td></tr><tr><td>LOCAL_VARIABLE</td><td>用于局部变量</td></tr><tr><td>METHOD</td><td>用于方法</td></tr><tr><td>PACKAGE</td><td>用于包</td></tr><tr><td>PARAMETER</td><td>用于类型参数（JDK 1.8新增）</td></tr><tr><td>TYPE</td><td>用于类、接口（包括注解类型）或 enum 声明</td></tr></tbody></table><p>例：</p><p>TestAnnotation：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(value = &#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="meta">@TestAnnotation</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Retention-value-x3D-…"><a href="#Retention-value-x3D-…" class="headerlink" title="@Retention(value &#x3D; …)"></a>@Retention(value &#x3D; …)</h4><p>表示需要在什么级别保存该注释信息，用于描述注解的生命周期。</p><p><code>...</code>处填入java.lang.annotation.RetentionPolicy 枚举类型，RetentionPolicy 有 3 个枚举常量，如下所示：</p><p>SOURCE：在源代码时，该注解生效；</p><p>CLASS：在class文件时，该注解仍然生效；</p><p>RUNTIME：在运行的时候，该注解仍然生效；</p><p>生命周期：SOURCE &lt; CLASS &lt; <strong>RUNTIME（常用）</strong>。</p><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>说明该注解将会包含在javadoc中。</p><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>说明子类可以继承父类中的该注解。</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>使用<code>@interface</code>自定义注解时，自动继承了<code>java.lang.annotation</code>接口。</p><p>自定义注解一般以<code>public @interface ...</code>的格式，在类里生命一个注解时候，需去除<code>public</code>。</p><p>一般来说，当注解内参数只有一个值时，值的名字可以命名为<code>vlaue</code>。因为在注解内参数只有一个值且值的名字为<code>value</code>的时候，往往可以将<code>value</code>省略。</p><p>如果自定义注解里没有成员，则表明是一个标识作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="meta">@MyAnnotation(name = &quot;test&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@MyAnnotation2(&quot;test&quot;)</span><span class="comment">//只有一个参数可以省略value，而且省略只能省略以value命名的参数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><span class="comment">//指定注解的作用目标</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//指定注解的生命周期</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">   <span class="comment">//注解的参数：参数类型+参数名();</span></span><br><span class="line">   String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;<span class="comment">//default表示默认值参数</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;<span class="comment">//如果默认值是-1，则表示不存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><span class="comment">//指定注解的作用目标</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//指定注解的生命周期</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation2 &#123;</span><br><span class="line">   String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可重复注解"><a href="#可重复注解" class="headerlink" title="可重复注解"></a>可重复注解</h3><p>jdk8之前，当我们需要写两个相同的注解A但不同值得时，我们需要造多一个注解B，内部值设置为注解A数组，然后使用注解B包含两个注解A完成这个操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="meta">@BigTest(&#123;@Test(&quot;1&quot;), @Test(&quot;2&quot;)&#125;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface</span> Test&#123;</span><br><span class="line">   String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface</span> BigTest&#123;</span><br><span class="line">   Test[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在jdk8之后引入了一个新的元注解，使得我们可以重复注解——@Repeatable()：</p><ol><li>在注解A中声明@Repeatable()，成员值为注解B</li><li>注解A与注解B的Target、Retention需要相同</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="meta">@Test(&quot;1&quot;)</span></span><br><span class="line">   <span class="meta">@Test(&quot;2&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repeatable(BigTest.class)</span></span><br><span class="line"><span class="meta">@interface</span> Test&#123;</span><br><span class="line">   String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface</span> BigTest&#123;</span><br><span class="line">   Test[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（5）：抽象类、接口、内部类</title>
      <link href="/2022/03/23/Java%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2022/03/23/Java%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象（三）"><a href="#面向对象（三）" class="headerlink" title="面向对象（三）"></a>面向对象（三）</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类用<code>abstract</code>进行修饰。</p><p>在前面的学习我们知道，所有的对象都是通过类来描绘的，但是不是所有的类都是用来描述对象的，如果一个类中没有足够的成员来描绘一个具体的对象，那这个类就是抽象类。</p><p>简而言之，抽象类里面可以什么东西都不用去实现，只留有一个大概的框架，作为对后面继承的子类的约束。</p><p>抽象类里面可以有正常的方法，也可以有用<code>abstract</code>修饰的抽象方法，抽象方法也同样是可以不去实现的。</p><p>实际上受限于Java只能单继承，抽象类使用并不如接口常见。</p><p>总结一下，抽象类的特点：</p><ol><li>抽象类无法实例化，也就是无法new出来，它需要靠子类去实现它；</li><li>子类继承抽象类需要实现抽象类内的内容，除非子类也是个抽象类；</li><li>抽象类里可以写普通方法，但是抽象方法必须在抽象类中；静态方法，也就是被<code>static</code>修饰的方法，不能被声明为抽象方法；</li><li>抽象类含有构造器，是为了被子类继承，子类必须调用父类构造器。</li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">      student.run();<span class="comment">//out：I am running.</span></span><br><span class="line">      student.say();<span class="comment">//out：I am studying.</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person（抽象类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;I am running.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student（子类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;I am studying.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口与抽象类比较相似，但它并不是一个类，因此他并不是用<code>class</code>来声明，而是使用<code>interface</code>。抽象类和接口的区别在于，抽象类可以有具体实现和抽象方法，而接口只存在抽象方法。</p><p>接口是对类的实现进行一种约束，也就是一种<code>你是什么就应该做什么</code>的规范，也就是例如，人你就得会吃饭，汽车你就得会跑，但是你怎么吃饭，汽车怎么跑，这是类应该去描绘的内容。接口实现了约束和实现的分离。</p><h4 id="接口的特性"><a href="#接口的特性" class="headerlink" title="接口的特性"></a>接口的特性</h4><ol><li>接口中的方法都是<code>public abstract</code>的，而且只能是<code>public abstract</code>的；</li><li>接口中可以含有变量，但是变量都是<code>public static final</code>的，而且只能是<code>public</code>的；</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的来实现接口的方法。</li></ol><p>类用<code>implements</code>关键词来实现接口。跟抽象类一样，实现了接口的类，就需要重写接口中的方法。与只能继承一个抽象类不同，类可以实现多个接口。</p><p>接口和接口直接也是可以互相继承的，同样也是使用<code>extend</code>来继承。虽然他有继承关系，但是接口里是不存在构造器的。</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>PersonImple：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonImpl</span> <span class="keyword">implements</span> <span class="title class_">Person</span>,Clothes&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">color</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Animal：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Clothes：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Clothes</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">color</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类是在一个类的内部再定义一个类。</p><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>由于该内部类嵌套在外部类内，我们需要先实例化外部类，然后再通过外部类实例化的对象来实例化内部类。</p><p>内部类是可以访问到外部类的私有成员的。</p><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">inner.get();<span class="comment">//out:外部类</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Outer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;外部类&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类可以使用<code>private</code>或<code>protected</code>来修饰，如果你不希望内部类被外部类访问可以使用<code>private </code>修饰符。</p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类可以使用 static 关键字定义，静态内部类就不需要先实例化外部类再实例化内部类了，可以直接实例化内部类。</p><p>如果外部类是非静态的，而内部类是静态的，那么内部类就无法在外部类实例化之前调用外部类的成员了。</p><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br><span class="line">      System.out.println(inner.str2);<span class="comment">//out:内部类</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Outer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;外部类&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;内部类&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类与局部变量一样，不能使用访问控制修饰符和<code>static</code>修饰符，局部内部类仅在当前方法中有效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;&#125;<span class="comment">//内部类</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>这种类我们之前有所使用，我们来举一个例子，应该会很清楚。总所周知接口是不能实例化的，而这个例子却可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">test</span>()&#123;<span class="comment">//实际上这里的效果跟test test = new test()相同</span></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">test</span>&#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（4）：继承、多态</title>
      <link href="/2022/03/17/Java%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/"/>
      <url>/2022/03/17/Java%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象（二）"><a href="#面向对象（二）" class="headerlink" title="面向对象（二）"></a>面向对象（二）</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在前面的学习我们可以知道，类是对某一批对象的抽象，而继承的本质是对某一批类的抽象，类比于现实世界中对动植物进行界门纲目科属种的逐级分类。</p><p>子类（派生类）是父类（基类）的拓展，子类继承父类，我们用<code>extends</code>这个关键词表示继承的关系。（<code>extends v.拓展</code>）子类与父类之间具有一个<code>is</code>的关系，比如学生（子类）是人（父类）。</p><p>子类可以继承父类所有<code>public</code>的属性与方法，而父类<code>private</code>的属性与方法，子类是无法继承的。当我们需要让子类继承父类的属性与方法，且又不被继承关系以外的访问到的时候，我们就需要用到<code>protected</code>关键词，让子类能够继承父类使用<code>protected</code>的属性与方法。</p><p>在Java里，所有的类，都默认直接或者间接继承了<code>Object</code>类。</p><p>注意，在Java里，只有单继承，无多继承，一个子类只能有一个父类。</p><p>tips:在IDEA里，<code>ctrl+h</code>快捷键可以打开继承树，可以很直观看到继承关系。</p><p>例：</p><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">       </span><br><span class="line">      student1.setName(<span class="string">&quot;XiaoMing&quot;</span>);</span><br><span class="line">      student1.setAge(<span class="number">17</span>);</span><br><span class="line">      student1.setID(<span class="number">810</span>);</span><br><span class="line">      student1.setGrade(<span class="number">99</span>);<span class="comment">//无参构造</span></span><br><span class="line">       </span><br><span class="line">      <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;XiaoHong&quot;</span>, <span class="number">16</span>, <span class="number">114</span>, <span class="number">100</span>);<span class="comment">//有参构造</span></span><br><span class="line">      </span><br><span class="line">      System.out.println(student1.getName()+<span class="string">&quot; &quot;</span>+student1.getAge()+<span class="string">&quot; &quot;</span>+student1.getID()+<span class="string">&quot; &quot;</span>+student1.getGrade());<span class="comment">//out:XiaoMing 17 810 99</span></span><br><span class="line">      System.out.println(student2.getName()+<span class="string">&quot; &quot;</span>+student2.getAge()+<span class="string">&quot; &quot;</span>+student2.getID()+<span class="string">&quot; &quot;</span>+student2.getGrade());<span class="comment">//out:XiaoHong 16 114 100</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person:（父类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> String name;</span><br><span class="line">   <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student:（子类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> grade;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> ID;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String aName, <span class="type">int</span> aAge, <span class="type">int</span> aID, <span class="type">int</span> aGrade)</span>&#123;</span><br><span class="line">      name = aName;</span><br><span class="line">      age = aAge;<span class="comment">//子类继承了父类的属性</span></span><br><span class="line">      ID = aID;</span><br><span class="line">      grade = aGrade;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getGrade</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> grade;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGrade</span><span class="params">(<span class="type">int</span> grade)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.grade = grade;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getID</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ID;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setID</span><span class="params">(<span class="type">int</span> ID)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.ID = ID;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p><code>super</code>关键词可以调用父类的属性与方法，用来引用当前对象的父类。</p><p>直接进入例子：</p><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">      <span class="comment">/*out：</span></span><br><span class="line"><span class="comment">      父类无参构造被执行</span></span><br><span class="line"><span class="comment">      子类无参构造被执行</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      student.output();</span><br><span class="line">      <span class="comment">/*out：</span></span><br><span class="line"><span class="comment">      Student</span></span><br><span class="line"><span class="comment">      Student</span></span><br><span class="line"><span class="comment">      Person</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person（父类）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;父类无参构造被执行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student（子类）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//由于子类是不继承父类的构造器，所以这里隐藏着调用父类构造器:super();</span></span><br><span class="line">      <span class="comment">//注意：调用父类构造器时，必须写在子类构造器的第一行</span></span><br><span class="line">      System.out.println(<span class="string">&quot;子类无参构造被执行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span>&#123;</span><br><span class="line">      print();</span><br><span class="line">      <span class="built_in">this</span>.print();</span><br><span class="line">      <span class="built_in">super</span>.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点</strong>：</p><ol><li><code>super</code>只能出现在子类的方法或者构造器中</li><li>当父类没有无参构造时，子类就无法调用父类无参构造，也就是说必须要在子类构造器内写上父类的有参构造。</li></ol><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">super</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>子类可以重写父类的方法。</p><p>方法重写的特点：</p><ol><li>方法名必须相同</li><li>参数列表必须相同（与方法重载不同）</li><li>修饰符：范围可以扩大，不可以缩小。</li></ol><p>tips：在IDEA里，<code>ctrl+inside</code>快捷键可以快速调用方法重写功能。</p><p>不能重写的方法：</p><ol><li>static 方法；</li><li>private 方法；</li><li>final 常量；</li></ol><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">      b.output(); <span class="comment">//out:B-out</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A（父类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;A-out&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B（子类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;<span class="comment">//修饰符范围可以扩大</span></span><br><span class="line">      System.out.println(<span class="string">&quot;B-out&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h4><p>同一个行为具有多个不同表现形式或形态的能力。</p><p>比如在现实世界中，猫和狗（子类）都是动物（父类），他们都会吃（父类继承的方法），但是猫吃鱼，狗吃骨头（方法重写）。</p><h4 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h4><ol><li>继承</li><li>重写</li><li>父类引用指向子类对象<code>Person s2 = new Student();</code></li></ol><p>Demo1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">pet1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">pet2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      pet1.eat();<span class="comment">//Eat:bone</span></span><br><span class="line">      pet2.eat();<span class="comment">//out:Eat fish</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pet（父类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Eat All&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dog（子类1）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Eat bone&quot;</span>);;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cat（子类2）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Eat fish&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态的作用"><a href="#多态的作用" class="headerlink" title="多态的作用"></a>多态的作用</h4><p>提高了代码的拓展性，使用父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用。</p><p>听起来很难理解，我们来看例子就很容易理解这个意思的。</p><p>依然使用上面例子的三个类<code>Pet</code>、<code>Dog</code>、<code>Cat</code>。</p><p>Demo2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">      <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      petEat(dog);<span class="comment">//out:Eat bone</span></span><br><span class="line">      petEat(cat);<span class="comment">//out:Eat fish</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">petEat</span><span class="params">(Pet pet)</span>&#123;</span><br><span class="line">      pet.eat();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态的”局限”"><a href="#多态的”局限”" class="headerlink" title="多态的”局限”"></a>多态的”局限”</h4><p>当某个子类拥有独有的方法的时候，我们多态的写法就无法访问子类独有的方法了。</p><p>我们重写一下<code>Cat</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Eat fish&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playBall</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Cat is playing Ball&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      cat.eat();<span class="comment">//out:Eat fish</span></span><br><span class="line">      cat.playBall();<span class="comment">//error!这个编译是没法通过的</span></span><br><span class="line">      <span class="comment">//Pet类本身是没有playBall()这个方法的，因此是没法通过编译的。</span></span><br><span class="line">      <span class="comment">//在使用多态时，编译看左边，运行看右边。</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><code>instanceof</code>关键词可以用来测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p><p>这种比较需要两边存在关系，否则连编译都没法通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      System.out.println(object <span class="keyword">instanceof</span> Cat);<span class="comment">//out:true</span></span><br><span class="line">      System.out.println(object <span class="keyword">instanceof</span> Pet);<span class="comment">//out:true</span></span><br><span class="line">      System.out.println(object <span class="keyword">instanceof</span> Object);<span class="comment">//out:true</span></span><br><span class="line">      System.out.println(object <span class="keyword">instanceof</span> Dog);<span class="comment">//out:false</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在之前的学习中，我们知道，基本数据类型之间的转换，低转高可以自动转化，高转低需要强制转化，在多态的类型转化也是如此。</p><p>多态本身是子类向父类向上转换（自动转换）的过程，这个过程是默认的，因此上文提到的“局限”就出现了，所以我们需要一种强制转化的方法来是对象可以调用子类独有的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      <span class="comment">//将cat对象转化为Cat类型，就可以使用playBall()这个属于Cat类的方法了。</span></span><br><span class="line">      ((Cat) cat).playBall();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种强制转化的方法，也可以使得子转父，但是在子转父的时候，我们就会损失子类的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（3）：静态方法与非静态方法、参数传递、构造器、封装</title>
      <link href="/2022/03/11/Java%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E3%80%81%E5%B0%81%E8%A3%85/"/>
      <url>/2022/03/11/Java%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E3%80%81%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象（一）"><a href="#面向对象（一）" class="headerlink" title="面向对象（一）"></a>面向对象（一）</h2><p><strong>本质：</strong>以类的方式组织代码，以对象的方式封装数据。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><code>static</code>修饰词所修饰实际上是类的方法或属性，而无<code>static</code>关键词修饰的是在实例化类后，即对象出现后才出现的。</p><h4 id="静态方法-非静态方法"><a href="#静态方法-非静态方法" class="headerlink" title="静态方法   \ 非静态方法"></a>静态方法   \ 非静态方法</h4><p>非静态方法的调用需要先实例化这个类，再进行调用。</p><p>Demo1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Demo2</span> <span class="variable">demo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo2</span>();</span><br><span class="line">demo2.out1();<span class="comment">//非静态方法的调用1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Demo2</span>().out1();<span class="comment">//非静态方法的调用2</span></span><br><span class="line">Demo2.out2();<span class="comment">//这是静态方法的调用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out1</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是非静态方法调用&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">out2</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是静态方法的调用&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>在同一个类中，静态方法不可以直接调用非静态方法，需要先实例化类，非静态方法可以直接互相调用。这是因为静态方法是与类一起加载的，而非静态方法是在类实例化之后才存在的。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>我们先来看一下值传递和引用传递的定义；</p><p><strong>值传递(pass by value)：</strong>在调用函数时，将实际参数复制一份传递到函数中，这样在函数中对参数进行修改，就不会影响到原来的实际参数。</p><p><strong>引用传递(pass by reference)：</strong>在调用函数时，将实际参数的地址直接传递到函数中。这样在函数中对参数进行的修改，就会影响到实际参数。</p><p>在Java中，所有的传递都是值传递。如果参数是基本类型，传递的是基本类型的字面量值的拷贝。如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      System.out.println(a);<span class="comment">//out:1</span></span><br><span class="line">      test.change(a);</span><br><span class="line">      System.out.println(a);<span class="comment">//out:1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">      a = <span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看第二个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      System.out.println(person.name);<span class="comment">//out:null</span></span><br><span class="line">      test.change(person);</span><br><span class="line">      System.out.println(person.name);<span class="comment">//out:IceWindy</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(Person person)</span>&#123;</span><br><span class="line">      person.name = <span class="string">&quot;IceWindy&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>类中的构造器也称为构造方法，是在进行创建对象的时候必须调用的。</p><p>构造器有两个特点：</p><ol><li>必须与类的名字相同。</li><li>必须没有返回值，也不可以写<code>void</code>。</li></ol><p>构造器的作用：</p><ol><li>使用<code>new</code>关键词，实际上是在调用构造器。</li><li>一般用于初始化值。</li></ol><p>tip:在IDEA里使用alt+insert，可以快速生成构造器。</p><p>例子：</p><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">classDemo</span> <span class="variable">demo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">classDemo</span>();<span class="comment">//调用的是无参构造</span></span><br><span class="line">      System.out.println(demo1.str);<span class="comment">//out:null</span></span><br><span class="line">      <span class="type">classDemo</span> <span class="variable">demo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">classDemo</span>(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//调用的是有参构造</span></span><br><span class="line">      System.out.println(demo2.str);<span class="comment">//out:hello world</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">classDemo</span> &#123;</span><br><span class="line">   String str;</span><br><span class="line">   <span class="comment">//无参构造：若无有参构造，无参构造可以隐式</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">classDemo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//有参构造：一旦定义了有参构造，无参构造就必须显示定义</span></span><br><span class="line">   <span class="keyword">public</span>  <span class="title function_">classDemo</span><span class="params">(String aStr)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.str = aStr;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>通常的，我们会让类的内部数据操作细节自己完成，不允许外部干涉，仅留有少量的方法给外部使用。</p><p>这时，我们会使用<code>private</code>关键词对对象的属性进行隐藏，仅留下<code>public</code>关键词的方法可以对属性进行操作和查看。</p><p>封装之后有什么好处呢：</p><ol><li>提高了程序的安全性，保护数据</li><li>隐藏了代码的实现细节</li><li>统一了接口</li><li>增强了可维护性</li></ol><p>例子：</p><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">student</span> <span class="variable">Student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>();</span><br><span class="line">      Student1.setName(<span class="string">&quot;XiaoMing&quot;</span>);</span><br><span class="line">      Student1.setGrade(<span class="number">100</span>);</span><br><span class="line">       </span><br><span class="line">      System.out.println(Student1.getName()+<span class="string">&quot; &quot;</span>+Student1.getGrade());<span class="comment">//out:XiaoMing 100</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>student:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> grade;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getGrade</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> grade;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGrade</span><span class="params">(<span class="type">double</span> grade)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.grade = grade;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（2）：数组、三元运算符</title>
      <link href="/2022/03/09/Java%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2022/03/09/Java%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataType[] array;   <span class="comment">// 首选的方法</span></span><br><span class="line">dataType array[];  <span class="comment">// 效果相同，但不是首选方法</span></span><br></pre></td></tr></table></figure><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array = <span class="keyword">new</span> <span class="title class_">dataType</span>[arraySize];</span><br></pre></td></tr></table></figure><p>创建数组时做了两件事：</p><ol><li>使用<code>dataType[arraySize]</code>创建了一个数组。</li><li>把新创建的数组的引用赋值给变量 <code>array</code>。</li></ol><p>我们也可以讲声明与创建数组合二为一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] array = <span class="keyword">new</span> <span class="title class_">dataType</span>[arraySize];</span><br></pre></td></tr></table></figure><p>还可以使用下面方法来创建数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] array = &#123;value0, value1, ..., valuek&#125;; </span><br></pre></td></tr></table></figure><h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] firstArray = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] secondArray = firstArray;</span><br><span class="line">secondArray[<span class="number">1</span>] = <span class="number">10</span>;<span class="comment">//此时，firstArray[1]的值也变成了10</span></span><br></pre></td></tr></table></figure><p>这种拷贝方式会将两个变量引用到同一个数组。</p><p>如果我们希望的是将一个数组的所有值拷贝到一个新的数组中去，就要使用<code>Arrays</code>类的<code>copyOf</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] secondArray = Arrays.copy0f(firstArray, firstArray.length);</span><br></pre></td></tr></table></figure><p>第二个参数为新数组的长度，我们通常用此方法来增加数组大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] secondArray = Arrays.copy0f(firstArray, <span class="number">2</span> * firstArray.length);</span><br></pre></td></tr></table></figure><p>当新数组长度小于原数组时，则只拷贝前面的值，后面的值会被裁切丢弃。</p><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p><code>Arrays</code>类中给我们提供了一种排序的方法–快速排序<code>QuickSort</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">in</span>[<span class="number">10000</span>];</span><br><span class="line">...</span><br><span class="line">Arrays.sort(a);</span><br></pre></td></tr></table></figure><p>这种排序方法可以满足大部分排序的需求，当然你也可以选择自己写，那就不在本文的范畴之内了。</p><p>另外<code>Arrays</code>类中还提供了别的方法，有兴趣的可以自行查阅。</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>允许调用方法时传入不定长度的参数，实质上是基于数组的实现。</p><p>例：构造输出最大的数字的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoVarargs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoVarargs</span> <span class="variable">demoVarargs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoVarargs</span>();</span><br><span class="line">        demoVarargs.printMax(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMax</span><span class="params">(<span class="type">double</span>... nums)</span>&#123;<span class="comment">//可变参数</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No argument passed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">double</span> x: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; max)&#123;</span><br><span class="line">                max = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;max:&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x?y:z</span><br></pre></td></tr></table></figure><p>当<code>x==true</code>，则结果为<code>y</code>，否则结果为<code>z</code>。</p><p>注意点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o);<span class="comment">//out:1.0</span></span><br></pre></td></tr></table></figure><p>三元运算符运行的左右两边需要是同一类型，于是int的包装类就自动转换为double的包装类。这与<code>if else</code>有所区别，因此我们在使用三元运算符时需要注意。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（1）：进制表示、Equals、For each循环、方法基础</title>
      <link href="/2022/03/07/Java%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E3%80%81Equals%E3%80%81For%20each%E5%BE%AA%E7%8E%AF%E3%80%81%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/07/Java%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E3%80%81Equals%E3%80%81For%20each%E5%BE%AA%E7%8E%AF%E3%80%81%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示"></a>进制表示</h2><p>二进制0b 十进制 八进制0 十六进制0x</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">010</span>;  <span class="comment">//八进制0 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0x10</span>; <span class="comment">//十六进制0x</span></span><br></pre></td></tr></table></figure><p>out:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 3 16</span><br></pre></td></tr></table></figure><h2 id="Equals"><a href="#Equals" class="headerlink" title="Equals"></a>Equals</h2><p><code>.equals</code>方法可以用来判断字符串是否相等。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(str.equals(<span class="string">&quot;Hello&quot;</span>))&#123; <span class="comment">//判断str是否与Hello相等</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="For-each循环"><a href="#For-each循环" class="headerlink" title="For each循环"></a>For each循环</h2><p>for each element in a：循环A中的每一个元素。</p><p>主要用于数组或集合的增强型for循环。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//For each</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x: nums)&#123;<span class="comment">//遍历数组元素</span></span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是用普通的for表示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    System.out.println(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法基础"><a href="#方法基础" class="headerlink" title="方法基础"></a>方法基础</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>Java的方法跟其他语言的函数类似。</p><p>方法的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">...</span><br><span class="line">方法体</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><p><strong>default</strong> (即默认，什么也不写）：在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br><strong>private</strong>：在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong><br><strong>public</strong>：对所有类可见。使用对象：类、接口、变量、方法<br><strong>protected</strong>：对同一包内的类和其所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。实际上<code>protected</code>的成员，有两种可见：</p><ol><li>父类的<code>protected</code>成员是包内可见的，并且对子类可见；</li><li>若子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的<code>protected</code>方法，而不能访问父类实例的<code>protected</code>方法。</li></ol><p>Father:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.base;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Son:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.test;</span><br><span class="line"><span class="keyword">import</span> cn.icewindy.base.Father;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">      father.test();<span class="comment">//Compile Error</span></span><br><span class="line">      test2();<span class="comment">//Compile OK </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">super</span>.test();<span class="comment">//Compile OK ，在override可以调用父类的protected方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h4><p><strong>static</strong>：用来修饰类方法和类变量。详细请看笔记（三）<br><strong>final</strong>：用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。<br><strong>abstract</strong>：用来创建抽象类和抽象方法。<br><strong>synchronized、volatile</strong> ：主要用于线程的编程。</p><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>在同一个类中，有相同的函数名字，但形参不同的函数。</p><p>例：构建一个比较大小的方法<code>max</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(max(<span class="number">10</span>,<span class="number">20</span>));    <span class="comment">//调用的是第一个方法</span></span><br><span class="line">System.out.println(max(<span class="number">10.0</span>,<span class="number">20.0</span>));<span class="comment">//调用的是第二个方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> num1, <span class="type">double</span> num2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法重载的规则：</p><ol><li>方法名称必须相同。</li><li>参数列表必须不同。</li><li>返回值类型可以相同，也可以不同。</li><li>仅仅返回值不同不构成方法的重载。</li></ol><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>Java支持传递同类型的可变参数给一个方法。</p><p>使用方法：</p><p>在方法声明中，在指定参数类型后加一个省略号(…) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数类型... 参数名</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoVarargs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoVarargs</span> <span class="variable">demoVarargs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoVarargs</span>();</span><br><span class="line">        demoVarargs.printMax(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        demoVarargs.printMax(<span class="keyword">new</span> <span class="title class_">double</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMax</span><span class="params">(<span class="type">double</span>... nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No argument passed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">double</span> x: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; max)&#123;</span><br><span class="line">                max = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;max:&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux主要目录</title>
      <link href="/2022/03/06/Linux%E4%B8%BB%E8%A6%81%E7%9B%AE%E5%BD%95/"/>
      <url>/2022/03/06/Linux%E4%B8%BB%E8%A6%81%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>大部分Linux系统的主要目录和内容都遵循着FHS（文件系统层次结构标准）标准，但并不是所有的Linux系统都完全执行FHS标准。</p><p>在FHS中，所有的文件和目录都在跟目录“&#x2F;”下，无论他们是否在同一物理设备中（例如不在同一硬盘中）。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>图表来自维基百科：</p><table><thead><tr><th align="left">目录</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>/</code></td><td align="left"><em>第一层次结构</em> 的根、 整个文件系统层次结构的<a href="https://zh.m.wikipedia.org/wiki/%E6%A0%B9%E7%9B%AE%E5%BD%95">根目录</a>。</td></tr><tr><td align="left"><code>/bin/</code></td><td align="left">需要在<a href="https://zh.m.wikipedia.org/wiki/%E5%96%AE%E7%94%A8%E6%88%B6%E6%A8%A1%E5%BC%8F">单用户模式</a>可用的必要命令（<a href="https://zh.m.wikipedia.org/wiki/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">可执行文件</a>）；面向所有用户，<em>例如</em>： <a href="https://zh.m.wikipedia.org/wiki/Cat_(Unix)">cat</a>、 <a href="https://zh.m.wikipedia.org/wiki/Ls">ls</a>、 <a href="https://zh.m.wikipedia.org/wiki/Cp_(Unix)">cp</a>。</td></tr><tr><td align="left"><code>/boot/</code></td><td align="left"><a href="https://zh.m.wikipedia.org/wiki/%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F">引导程序</a>文件，<em>例如：</em> <a href="https://zh.m.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">kernel</a>、<a href="https://zh.m.wikipedia.org/wiki/Initrd">initrd</a>；时常是一个单独的分区[<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-8">8]</a></td></tr><tr><td align="left"><code>/dev/</code></td><td align="left">必要<a href="https://zh.m.wikipedia.org/wiki/%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">设备</a>, <em>例如：</em><code>/dev/null</code>.</td></tr><tr><td align="left"><code>/etc/</code></td><td align="left">特定主机，系统范围内的<a href="https://zh.m.wikipedia.org/wiki/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a>。关于这个名称目前有争议。在贝尔实验室关于UNIX实现文档的早期版本中，&#x2F;etc 被称为*<a href="https://zh.m.wikipedia.org/wiki/%E7%AD%89%E7%AD%89">etcetera</a>*， [<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-9">9]</a> 这是由于过去此目录中存放所有不属于别处的所有东西（然而，FHS限制&#x2F;etc只能存放静态配置文件，不能包含二进制文件）。 [<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-10">10]</a> 自从早期文档出版以来，目录名称已被以各种方式重新称呼。最近的解释包括<a href="https://zh.m.wikipedia.org/wiki/%E9%80%86%E5%90%91%E9%A6%96%E5%AD%97%E6%AF%8D%E7%BC%A9%E7%95%A5%E8%AF%8D">逆向首字母缩略词</a>如：”可编辑的文本配置”（英文 “Editable Text Configuration”）或”扩展工具箱”（英文 “Extended Tool Chest”）。 [<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-11">11]</a></td></tr><tr><td align="left"><code>/etc/opt/</code></td><td align="left"><code>/opt/</code>的配置文件</td></tr><tr><td align="left"><code>/etc/X11/</code></td><td align="left"><a href="https://zh.m.wikipedia.org/wiki/X_Window%E7%B3%BB%E7%BB%9F">X Window系统</a>(版本11)的配置文件</td></tr><tr><td align="left"><code>/etc/sgml/</code></td><td align="left"><a href="https://zh.m.wikipedia.org/wiki/SGML">SGML</a>的配置文件</td></tr><tr><td align="left"><code>/etc/xml/</code></td><td align="left"><a href="https://zh.m.wikipedia.org/wiki/XML">XML</a>的配置文件</td></tr><tr><td align="left"><code>/home/</code></td><td align="left">用户的<a href="https://zh.m.wikipedia.org/wiki/%E5%AE%B6%E7%9B%AE%E5%BD%95">家目录</a>，包含保存的文件、个人设置等，一般为单独的分区。</td></tr><tr><td align="left"><code>/lib/</code></td><td align="left"><code>/bin/</code> 和 <code>/sbin/</code>中二进制文件必要的<a href="https://zh.m.wikipedia.org/wiki/%E5%87%BD%E5%BC%8F%E5%BA%AB">库</a>文件。</td></tr><tr><td align="left"><code>/media/</code></td><td align="left">可移除媒体(如<a href="https://zh.m.wikipedia.org/wiki/CD-ROM">CD-ROM</a>)的挂载点 (在FHS-2.3中出现)。</td></tr><tr><td align="left"><code>/mnt/</code></td><td align="left">临时<a href="https://zh.m.wikipedia.org/wiki/%E6%8C%82%E8%BD%BD">挂载</a>的文件系统。</td></tr><tr><td align="left"><code>/opt/</code></td><td align="left">可选<a href="https://zh.m.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6">应用软件</a> <a href="https://zh.m.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8C%85">包</a>。[<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-12">12]</a></td></tr><tr><td align="left"><code>/proc/</code></td><td align="left">虚拟<a href="https://zh.m.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件系统</a>，将<a href="https://zh.m.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">内核</a>与<a href="https://zh.m.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B">进程</a>状态归档为文本文件。<em>例如：</em>uptime、 network。在Linux中，对应<a href="https://zh.m.wikipedia.org/wiki/Procfs">Procfs</a>格式挂载。</td></tr><tr><td align="left"><code>/root/</code></td><td align="left"><a href="https://zh.m.wikipedia.org/wiki/%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7">超级用户</a>的<a href="https://zh.m.wikipedia.org/wiki/%E5%AE%B6%E7%9B%AE%E5%BD%95">家目录</a></td></tr><tr><td align="left"><code>/sbin/</code></td><td align="left">必要的系统二进制文件，<em>例如：</em> init、 ip、 mount。</td></tr><tr><td align="left"><code>/srv/</code></td><td align="left">站点的具体<a href="https://zh.m.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE">数据</a>，由系统提供。</td></tr><tr><td align="left"><code>/tmp/</code></td><td align="left">临时文件(参见 <code>/var/tmp</code>)，在系统重启时目录中文件不会被保留。</td></tr><tr><td align="left"><code>/usr/</code></td><td align="left">用于存储只读用户数据的<em>第二层次</em>； 包含绝大多数的(<a href="https://zh.m.wikipedia.org/wiki/%E5%A4%9A%E7%94%A8%E6%88%B7">多</a>)用户工具和应用程序[<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-13">13]</a>，注意不是user的缩写，而是”Unix Software Resource”的缩写。</td></tr><tr><td align="left"><code>/usr/bin/</code></td><td align="left">非必要<a href="https://zh.m.wikipedia.org/wiki/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">可执行文件</a> (在<a href="https://zh.m.wikipedia.org/wiki/%E5%96%AE%E7%94%A8%E6%88%B6%E6%A8%A1%E5%BC%8F">单用户模式</a>中不需要)；面向所有用户。</td></tr><tr><td align="left"><code>/usr/include/</code></td><td align="left">标准<a href="https://zh.m.wikipedia.org/wiki/%E5%A4%B4%E6%96%87%E4%BB%B6">包含文件</a>。</td></tr><tr><td align="left"><code>/usr/lib/</code></td><td align="left"><code>/usr/bin/</code>和<code>/usr/sbin/</code>中二进制文件的<a href="https://zh.m.wikipedia.org/wiki/%E5%BA%93">库</a>。</td></tr><tr><td align="left"><code>/usr/sbin/</code></td><td align="left">非必要的系统二进制文件，<em>例如：</em>大量<a href="https://zh.m.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1">网络服务</a>的<a href="https://zh.m.wikipedia.org/wiki/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">守护进程</a>。</td></tr><tr><td align="left"><code>/usr/share/</code></td><td align="left"><a href="https://zh.m.wikipedia.org/wiki/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">体系结构</a>无关（共享）数据。</td></tr><tr><td align="left"><code>/usr/src/</code></td><td align="left"><a href="https://zh.m.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81">源代码</a>,*例如:*内核源代码及其头文件。</td></tr><tr><td align="left"><code>/usr/X11R6/</code></td><td align="left"><a href="https://zh.m.wikipedia.org/wiki/X_Window%E7%B3%BB%E7%BB%9F">X Window系统</a> 版本 11, Release 6.</td></tr><tr><td align="left"><code>/usr/local/</code></td><td align="left">本地数据的<em>第三层次</em>， 具体到本台主机。通常而言有进一步的子目录， <em>例如：</em><code>bin/</code>、<code>lib/</code>、<code>share/</code>.[<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-14">14]</a></td></tr><tr><td align="left"><code>/var/</code></td><td align="left">变量文件——在正常运行的系统中其内容不断变化的文件，如日志，脱机文件和临时电子邮件文件。有时是一个单独的分区。</td></tr><tr><td align="left"><code>/var/cache/</code></td><td align="left">应用程序缓存数据。这些数据是在本地生成的一个耗时的I&#x2F;O或计算结果。应用程序必须能够再生或恢复数据。缓存的文件可以被删除而不导致数据丢失。</td></tr><tr><td align="left"><code>/var/lib/</code></td><td align="left">状态信息。 由程序在运行时维护的持久性数据。 <em>例如：</em>数据库、包装的系统元数据等。</td></tr><tr><td align="left"><code>/var/lock/</code></td><td align="left">锁文件，一类跟踪当前使用中资源的文件。</td></tr><tr><td align="left"><code>/var/log/</code></td><td align="left">日志文件，包含大量日志文件，为了防止日志占满根分区，生产环境中一般是单独分区。</td></tr><tr><td align="left"><code>/var/mail/</code></td><td align="left">用户的<a href="https://zh.m.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1">电子邮箱</a>。</td></tr><tr><td align="left"><code>/var/run/</code></td><td align="left">自最后一次启动以来运行中的系统的信息，<em>例如：</em>当前登录的用户和运行中的<a href="https://zh.m.wikipedia.org/wiki/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">守护进程</a>、一些守护进程的pid文件、socket文件。现已经被&#x2F;run代替[<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-15">15]</a>。</td></tr><tr><td align="left"><code>/var/spool/</code></td><td align="left">等待处理的任务的<a href="https://zh.m.wikipedia.org/w/index.php?title=%E8%84%B1%E6%9C%BA%E6%96%87%E4%BB%B6&action=edit&redlink=1">脱机文件</a>，<em>例如：</em>打印队列和未读的邮件。</td></tr><tr><td align="left"><code>/var/spool/mail/</code></td><td align="left">用户的邮箱(不鼓励的存储位置)</td></tr><tr><td align="left"><code>/var/tmp/</code></td><td align="left">在系统重启过程中可以保留的临时文件。</td></tr><tr><td align="left"><code>/run/</code></td><td align="left">代替&#x2F;var&#x2F;run目录。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC、GDB食用方法</title>
      <link href="/2022/03/06/GCC%E3%80%81GDB%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2022/03/06/GCC%E3%80%81GDB%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -o test test.c</span><br></pre></td></tr></table></figure><p><code>-o</code>自定义目标文件</p><p><code>-Wall</code>自动提示一些出错警告的信息</p><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><p>在GCC编译时需要添加一个参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -ggdb3 -Wall -o test test.c</span><br></pre></td></tr></table></figure><p>如无报错，即可启动GDB：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb test</span><br></pre></td></tr></table></figure><h3 id="GDB指令"><a href="#GDB指令" class="headerlink" title="GDB指令"></a>GDB指令</h3><p><code>break 10</code>在第十行设置断点。</p><p><code>break test</code>在<code>test</code>函数处设置断点</p><p><code>s / step</code>下一步</p><p><code>c / continue</code>当程序在某一断点处停止后，用该指令可以继续执行，直至遇到断点或者程序结束</p><p><code>u / until</code> 运行程序直到退出循环体</p><p><code>r / run</code>运行</p><p><code>q / quit</code>结束调试</p><p><code>p / print</code>显示某个变量的值</p><p><code>p *array@len</code> 输出数组</p><p><code>enable</code> 恢复失效的断点</p><p><code>disable </code>使断点失效</p><p><code>clear</code> 清除断点</p><p><code>bt / backtrace </code>查看堆栈信息</p><p><code>watch</code>监测某变量或表达式，当发生变化时停止</p>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora借助Gitee+PicGo-Core实现云图床</title>
      <link href="/2022/03/06/Typora-Gitee-PicgoCore%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/06/Typora-Gitee-PicgoCore%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="云图床搭建"><a href="#云图床搭建" class="headerlink" title="云图床搭建"></a>云图床搭建</h2><p>2022.3.25更新：gitee搭的图床疑似寄了。已经改用阿里云oss。</p><p>这次我们选择的云图床的搭建是基于gitee。gitee服务器位于国内，避免了github被墙的等一系列问题。</p><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>（省略gitee账号创建的过程，如果这都不会，建议不要折腾了）我们看到gitee页面右上角那个加号，然后点击新建仓库。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112213354.png" alt="image-20220112213353460"></p><p>然后输入你自己想要的仓库名称，路径会自动生成跟你仓库名称一样的名称，当然你也可以自己自定义路径名称。</p><p>勾选上开源和设置模板、Readme文件，省去后面初始化的步骤，即可创建好你的仓库。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112213557.png" alt="image-20220112213556929"></p><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>点击你的头像，进入设置。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112214030.png" alt="image-20220112214029486"></p><p>看到安全设置&#x2F;私人密钥。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112214120.png" alt="image-20220112214119534"></p><p>点击“生成新令牌”</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112214157.png" alt="image-20220112214157037"></p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112214214.png" alt="image-20220112214213174"></p><p>填上上描述，勾选上“projects”，生成一串密钥。</p><p><strong>注意：该密钥只会显示一次，注意好保存！！！</strong></p><h2 id="PicGO-Core配置"><a href="#PicGO-Core配置" class="headerlink" title="PicGO-Core配置"></a>PicGO-Core配置</h2><p>接下来我们就来配置PicGo-Core，至于为什么使用Core这种命令行版本，而不使用app这种带ui，是因为我不想在后台开多一个软件。</p><h3 id="配置Typora"><a href="#配置Typora" class="headerlink" title="配置Typora"></a>配置Typora</h3><p>点击“文件” “偏好设置” “图像”。</p><p>将“插入图片时候…”修改为“上传图片”，接着将上传服务修改为”PicGO-Core (command line)”，然后点击下载或更新，等他进度条走完。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112214915.png" alt="image-20220112214914458"></p><p>接着点击验证图片上传选项，出现下面窗口。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112215312.png" alt="image-20220112215311393"></p><p>复制前面一长串类似于“ C:\Users\IceWindy\AppData\Roaming\Typora\picgo\win64\picgo.exe”。</p><h3 id="PicGo-Core插件安装与配置"><a href="#PicGo-Core插件安装与配置" class="headerlink" title="PicGo-Core插件安装与配置"></a>PicGo-Core插件安装与配置</h3><p>打开你的命令行（cmd)，运行如下命令：<strong>（注意：需要安装Node.js！）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Users\IceWindy\AppData\Roaming\Typora\picgo\win64\picgo.exe</span><br><span class="line">.\picgo.exe install gitee-uploader</span><br><span class="line">.\picgo.exe install super-prefix </span><br></pre></td></tr></table></figure><p>在Typora图像设置中，点击打开配置文件，我们就打开了一个json格式的文件，按照我下面的样式填写</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gitee&quot;</span><span class="punctuation">,</span><span class="comment">//当前上传的图床</span></span><br><span class="line">    <span class="attr">&quot;gitee&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icewindy/note-img&quot;</span><span class="punctuation">,</span><span class="comment">//仓库位置</span></span><br><span class="line">      <span class="attr">&quot;branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;master&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">//我们上文提到的生成的gitee密钥</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;note&quot;</span><span class="punctuation">,</span><span class="comment">//上传到你的仓库的文件夹</span></span><br><span class="line">      <span class="attr">&quot;customPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span><span class="comment">//默认即可</span></span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="comment">//插件的启用</span></span><br><span class="line">  <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fileFormat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YYYYMMDDHHmmss&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="comment">//这段是配置时间戳插件的</span></span><br><span class="line">  <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;lastSync&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2022-01-12 10:05:31&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>仓库的位置可以打开你仓库的链接，“icewindy&#x2F;note-img”这地方就是你的仓库位置。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112220530.png" alt="20220112220530"></p><h2 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h2><p>还是打开Typora的图像设置，点击验证图片上传选项，如图即成功。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112222001.png" alt="image-20220112222000592"></p>]]></content>
      
      
      <categories>
          
          <category> 小服务搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习笔记（1）：隐性转换、值与引用、for-in与for-of、数组</title>
      <link href="/2022/01/12/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E9%9A%90%E6%80%A7%E8%BD%AC%E6%8D%A2%E3%80%81%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E3%80%81for-in%E4%B8%8Efor-of%E3%80%81%E6%95%B0%E7%BB%84/"/>
      <url>/2022/01/12/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E9%9A%90%E6%80%A7%E8%BD%AC%E6%8D%A2%E3%80%81%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E3%80%81for-in%E4%B8%8Efor-of%E3%80%81%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="隐性转换"><a href="#隐性转换" class="headerlink" title="隐性转换"></a>隐性转换</h2><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li><p><code>NaN != NaN</code></p></li><li><p><code>boolean</code>值在比较时会变为<code>number</code></p></li><li><p><code>string</code>和<code>number</code>比较时会变为<code>number</code></p></li><li><p><code>null == undefined</code>，其余任何值与<code>null</code>&#x2F;<code>undefined</code>比较都为<code>false</code></p></li><li><p>原始类型与引用类型比较，会调用<code>toPrimitive</code>方法，具体做法就是先<code>valueOf</code>后<code>toString</code></p></li><li><p>我们在对各种非<code>Number</code>类型运用数学运算符(<code>- * /</code>)时，会先将非<code>Number</code>类型转换为<code>Number</code>类型</p></li><li><p>加法特殊：</p><p>当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</p><p>当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</p><p>当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</p><p><strong>该三点由上到下，优先级从高到低</strong></p></li><li></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123;&#125; + &#123;&#125;</span><br><span class="line"><span class="title class_">NaN</span></span><br></pre></td></tr></table></figure><p>这个问题的原因是，JavaScript 把第一个 <code>&#123;&#125; </code>解释成了一个空的代码块（code block）并忽略了它。<code>NaN</code>其实是表达式<code>+&#123;&#125;</code>计算的结果 (+ 加号以及第二个 {})。 你在这里看到的 <code>+ </code>加号并不是二元运算符「加法」，而是一个一元运算符，作用是将它后面的操作数转换成数字，和 <code>Number() </code>函数完全一样。</p><ol start="9"><li>转换表：</li></ol><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112212233.png" alt="20220112212233"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>1. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1, 2, 3&#x27;</span> == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>   <strong>true</strong></p><p>2. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>   <strong>false</strong></p><p>3. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> == [<span class="string">&#x27;1&#x27;</span>]</span><br></pre></td></tr></table></figure><p>   <strong>true</strong></p><p>4. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>   <strong>false</strong></p><p>5. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>   <strong>true</strong></p><h2 id="值与引用"><a href="#值与引用" class="headerlink" title="值与引用"></a>值与引用</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ol><li>值类型</li></ol><p>​        数字，字符串，布尔，符号，未定义，空</p><ol start="2"><li>引用类型</li></ol><p>​        对象，函数，数组</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">value</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line">x.<span class="property">value</span> = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>控制台中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x</span><br><span class="line">&gt;&#123;<span class="attr">value</span>:<span class="number">20</span>&#125;</span><br><span class="line">y</span><br><span class="line">&gt;&#123;<span class="attr">value</span>:<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><p>对象不是存储在变量中，而是存储在内存中，变量保存的是对象的内存地址，因此y在复制x的时候，是复制x的内存地址，即x，y都指向同一内存地址，无论通过x还是y去修改这个对象的时候，修改的变化另外一个对象也能看到。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>值类型数据复制值</p><p>引用类型数据或对象复制引用（内存地址）</p><h2 id="for-in与for-of"><a href="#for-in与for-of" class="headerlink" title="for-in与for-of"></a>for-in与for-of</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> object)</span><br></pre></td></tr></table></figure><p>可以循环对象中的每一个成员，可以遍历一个数组，但最好使用<code>for-of</code>。</p><p><code>in</code>可以检查对象中是否包含给定的值</p><h3 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h3><p>从ES6开始，更好遍历数组的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> array)</span><br></pre></td></tr></table></figure><p>在<code>for-of</code>中<code>key</code>直接表示为数组内的一个元素。</p><p>该方法仅可用于可枚举的类型（数组和映射）。</p><h3 id="可用于for-of-的Object方法"><a href="#可用于for-of-的Object方法" class="headerlink" title="可用于for-of 的Object方法"></a>可用于for-of 的Object方法</h3><p><code>Object.key()</code>方法可获得输入对象的所有成员的键，并返回一个数组。</p><p><code>Object.entries()</code>方法可获得输入对象的所有成员的键值对，并返回一个数组。</p><h2 id="克隆一个Object的方法"><a href="#克隆一个Object的方法" class="headerlink" title="克隆一个Object的方法"></a>克隆一个Object的方法</h2><ol><li><pre><code class="javascript">const newObject = Object.assign(&#123;&#125;, oldObject);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   `&#123;&#125;`内不一定要为空，也可以为一个键值对，相当于是在`newObject`里新增一个键值对，然后再将`oldObject`中的成员克隆过来。</span><br><span class="line"></span><br><span class="line">2. 拆分操作符法</span><br><span class="line"></span><br><span class="line">   ```javascript</span><br><span class="line">   const newObject = &#123; ...oldObject &#125;;</span><br></pre></td></tr></table></figure>最简单的方法，该方法相当于是将使用`...`拆分操作符将`oldObject`内的成员读取并拆解出填入`&#123; &#125;`中。</code></pre></li><li><p>for-in法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObject = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> oldObject)</span><br><span class="line">    newObject[key] = oldObject[key];</span><br></pre></td></tr></table></figure><p>最朴素的方法。</p></li></ol><h2 id="JavaScript部分内置对象"><a href="#JavaScript部分内置对象" class="headerlink" title="JavaScript部分内置对象"></a>JavaScript部分内置对象</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p><code>Math</code>参考文档</p><p>[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math]">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math]</a>: </p><p><code>Math</code> 是一个内置对象，它拥有一些数学常数属性和数学函数方法。</p><p>注意:<code>Math</code>并不是一个函数对象</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>JavaScript中<code>string</code>分为两种，一种是值类型字符串，另外一种是<code>String</code>对象 。但在对值类型的字符串使用点操作符时,JavaScript会自动将值转换为对象，可以像操作对象一样操作它。</p><p><code>String</code>参考文档</p><p>[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String]">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String]</a>: </p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><h4 id="In-End"><a href="#In-End" class="headerlink" title="In End"></a>In End</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="title function_">push</span>(anyThings);</span><br></pre></td></tr></table></figure><p><code>anyThings</code>可填入任意元素（不止一个元素）。</p><h4 id="In-Beginning"><a href="#In-Beginning" class="headerlink" title="In Beginning"></a>In Beginning</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="title function_">unshift</span>(anyThings);</span><br></pre></td></tr></table></figure><p><code>anyThings</code>可填入任意元素（不止一个元素）。</p><h4 id="In-Middle"><a href="#In-Middle" class="headerlink" title="In Middle"></a>In Middle</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="title function_">splice</span>(startNumber, deleteCount, anyThings);</span><br></pre></td></tr></table></figure><p><code>startNumber</code>元素的位置。注意：数组从0开始计数。</p><p><code>deleteCount</code>想要删除的元素的个数。</p><p><code>anyThings</code>可填入任意元素（不止一个元素）。</p><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><h4 id="indexOF（查找值）"><a href="#indexOF（查找值）" class="headerlink" title="indexOF（查找值）"></a>indexOF（查找值）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="title function_">indexOF</span>(anyThings, startNumber);</span><br></pre></td></tr></table></figure><p>查找<code>numbers</code>内从<code>startNumber</code>开始（可选）是否存在<code>anyThings</code>元素，如果存在则返回所在位置，如果不存在则返回<code>-1</code>。</p><p>注意：该方法是严格对应类型的，字符类型的<code>&#39;1&#39;</code>与数字类型的<code>1</code>是不同的。</p><p>类似的方法<code>lastIndexOF</code>，返回最后一个匹配的元素。</p><p><code>includes</code>方法可以判断是否存在匹配元素，返回<code>true</code> or  <code>false</code></p><p>以上方法均可以加入第二参数<code>startNumber</code>设定开始查找的位置。</p><h2 id="一些实用技巧补充"><a href="#一些实用技巧补充" class="headerlink" title="一些实用技巧补充"></a>一些实用技巧补充</h2><ol><li><code>$&#123;&#125;</code>占位符用于一对反引号的模板语句中显示表达式或者变量。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Web三板斧 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
