<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java笔记（九）：多线程</title>
      <link href="/2022/05/16/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/05/16/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h3><h4 id="方式一：继承于Thread类"><a href="#方式一：继承于Thread类" class="headerlink" title="方式一：继承于Thread类"></a>方式一：继承于Thread类</h4><ol><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run()方法（将线程执行的操作写在里面）</li><li>创建Thread类子类的对象</li><li>通过此对象调用start()方法（不能通过直接调用run()方法启动线程）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">TestThread</span> <span class="variable">testThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThread</span>();</span><br><span class="line">testThread.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要两个线程同时进行的时候，我们不可以再启动一个已经start的线程的对象，需要新建一个对象。</p><p>我们还可以通过创建Thread类的匿名子类实现多线程创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><h4 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h4><ol><li>创建一个实现了Runnable接口的类</li><li>实现run()方法</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TestThread</span>()).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于实现类的对象与启动线程的对象不相同，因此一个实现类对象可以有多个线程。</p><p>开发中我们一般优先选择方式二实现Runnable接口的方式：</p><ol><li>实现没有类的单继承性的局限性</li><li>实现的方法更适合来处理多个线程有共享数据的情况</li></ol><p>二者之间有所联系：Thread类本身也是实现Runnable接口的</p><h4 id="Thread类常用方法"><a href="#Thread类常用方法" class="headerlink" title="Thread类常用方法"></a>Thread类常用方法</h4><p>void start()：启动线程，并执行run()方法</p><p>run()：线程被调度时执行的操作</p><p>String getName()：返回线程的名字</p><p>void setName()：设置线程名字</p><p>static Thread currentThread()：返回当前线程，相当于this</p><p>yiele()：释放当前线程的cpu执行权</p><p>join()：优先执行该线程，原线程进入阻塞状态，执行完该线程后再继续执行原线程</p><p>stop()：强制结束当前线程生命期（<strong>不推荐使用</strong>）</p><p>sleep(long millisec)：让当前执行的线程休眠指定millisec毫秒（进入阻塞状态）。使用该方法时，会抛出一个异常，由于父类run()方法是没有抛出异常的，因此只能使用try-catch处理异常</p><p>isAlive()：判断线程是否存活</p><h4 id="方式三：实现Callable接口"><a href="#方式三：实现Callable接口" class="headerlink" title="方式三：实现Callable接口"></a>方式三：实现Callable接口</h4><p>这种创建多线程的方式是JDK5.0新增的一种方式。与实现Runnable相比，Callable功能更强大：</p><ul><li>相比run()方法，call()方法可以有返回值</li><li>call()方法可以抛出异常</li><li>支持泛型的返回值</li><li>需要借助FutureTask类</li></ul><p>FutureTask是Future接口的唯一的实现类，它同时实现了Runnable和Future接口。它既可以作为Runnable被线程执行，也可以作为Future得到Callable的返回值。</p><p>使用过程：</p><ol><li>创建一个实现Callable的实现类</li><li>实现Call()方法，类似于run()</li><li>创建Callable实现类的对象</li><li>将Callable实现类的对象传递到FutureTask构造器中</li><li>创建Thread对象，并执行start()方法启动线程</li><li>若需要返回值，则可以使用Callable实现类的对象的get()方法返回值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//3.创建Callable实现类的对象</span></span><br><span class="line">      <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">      <span class="comment">//4.将Callable实现类的对象传递到FutureTask构造器中</span></span><br><span class="line">      <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//get()返回值即为FutureTask构造器参数的Callable实现类重写的call()方法的返回值</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">         System.out.println(<span class="string">&quot;sum = &quot;</span> + sum);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//2.实现Call()方法</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            sum += i;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式四：线程池"><a href="#方式四：线程池" class="headerlink" title="方式四：线程池"></a>方式四：线程池</h4><p>当经常需要创建和销毁、使用量比较大的资源，比如并发情况下的线程，对性能影响较大。这时候我们可以提前创建好多个线程，放入线程池中，使用时直接获取，使用完后放入池中。使用线程池有几点好处：</p><ul><li>提高响应速度</li><li>降低资源消耗</li><li>便于线程管理</li></ul><p>Java标准库提供了ExecutorService接口表示线程池，但ExecutorService只是一个接口，Java标准库提供的几个常用实现类：</p><ul><li>FixedThreadPool：线程数固定的线程池</li><li>CachedThreadPool：线程数根据任务动态调整的线程池</li><li>SingleThreadExecutor：仅单线程执行的线程池</li></ul><p>创建这些线程池的方法都被封装在Executors类中，均为<code>newXXXX</code>。</p><p>线程池多线程使用流程：</p><ol><li>创建线程池</li><li>执行指定的线程的操作，提供一个Runnable接口（execute()方法）或Callable接口（submit()方法）实现类的对象作为参数</li><li>关闭线程池</li></ol><p>例子以FixedThreadPool线程池为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">      service.execute(<span class="keyword">new</span> <span class="title class_">TestThread</span>());</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      service.shutdown();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设置线程池属性</strong></p><p>由于ExecutorService作为一个接口，里面不包含具体的方法，我们通过getClass()方法可以获取到service的类是ThreadPoolExecutor，我们前面是使用多态的方式创建的对象，导致ThreadPoolExecutor的方法不能使用，因此我们可以使用强转的方式转换为ThreadPoolExecutor类，再调用设置线程池属性的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">service2</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">service2.setCorePoolSize(<span class="number">10</span>);<span class="comment">//设置核心池大小为15</span></span><br></pre></td></tr></table></figure><h3 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h3><p>Java对于同优先级线程组成先进先出队列（先到先服务），采用“时间片”策略（切换处理），对于高优先级，使用有限调度的抢占式策略（高优先级线程抢占CPU）。</p><p>线程的优先级有三个常量：</p><ul><li>MAX_PRIORITY : 10</li><li>MIN_PRIORITY : 1</li><li>NORM_PRIORITY : 5</li></ul><p>涉及的方法：</p><ul><li>getPriority() : 返回线程优先值</li><li>setPriority(int newPriority) : 改变线程的优先级</li></ul><p>注意点：</p><p>高优先级线程抢占低线程的执行权，但是不意味需要当高优先级执行完以后，低优先级的线程才能执行，只是从概率上讲，高优先级的线程更优先被执行。</p><p>线程创建时会自动继承父线程的优先级。</p><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>线程的启动到线程的结束的整个过程被称之为线程的生命周期。</p><p>线程的生命周期中存在多种状态：</p><ol><li>新建：当一个Thread类及其子类被声明并创建时，新生的线程处于就绪状态</li><li>就绪：当新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已经具备了运行的条件，但暂时没有分配到CPU资源</li><li>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态</li><li>阻塞：在某些情况下，被人为挂起或者执行输入输出操作时，临时中止自己的执行，进入阻塞状态</li><li>死亡：线程完成了全部工作，或者线程被强制提前终止，或出现异常导致结束</li></ol><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202205201717258.png" alt="image-20220520171701160"></p><h3 id="线程的安全性问题"><a href="#线程的安全性问题" class="headerlink" title="线程的安全性问题"></a>线程的安全性问题</h3><p>当我们多个线程同时去对同一个参数进行操作时，我们往往会发现，这个参数出现多个线程同时操作时出现只操作一次的情况，举个售票的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ticketWindows</span> <span class="variable">ticketWindows</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ticketWindows</span>();</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketWindows);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketWindows);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketWindows);</span><br><span class="line">      t1.setName(<span class="string">&quot;Window1&quot;</span>);</span><br><span class="line">      t2.setName(<span class="string">&quot;Window2&quot;</span>);</span><br><span class="line">      t3.setName(<span class="string">&quot;Window3&quot;</span>);</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">      t3.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ticketWindows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行如上代码，在控制台，我们发现一个严重的问题，窗口1、2、3出现了售出同一张票的情况：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202205211739097.png" alt="image-20220521173909064"></p><p>这种就是线程的安全问题。解决方式就是当线程A在操作的时候，其他线程无法参与，直到线程A操作完成后，其他线程才可以开始操作，即使线程A出现阻塞也无法参与。</p><h4 id="同步机制解决线程安全问题"><a href="#同步机制解决线程安全问题" class="headerlink" title="同步机制解决线程安全问题"></a>同步机制解决线程安全问题</h4><p><strong>方式一：同步代码块</strong></p><p>结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line"><span class="comment">//需要被同步的代码：操作共享数据的代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享数据：多个线程共同操作的变量，比如：ticket；</p><p>同步监视器：俗称锁。任何一个类的对象都可以充当锁，但要求多个线程必须共用同一个锁。</p><p>例1：</p><p>我们将上面卖票窗口的代码修改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ticketWindows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">         <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">               ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再去检查控制台，发现没有再次出现重票错票的情况了。</p><p>但是当我们通过继承Thread的方式去创建多线程的时候，我们就发现了一个问题——他仍然出现了错票重票的情况。我们前面提到锁必须多个线程共用一个，而当我们通过继承Thread的方式创建多线程的时候，我们使用的锁<code>this</code>指代的对象并不是指代的同一个，而分别是<code>t1, t2, t3</code>，因此锁就失效了，因此我们作出对应的修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (ticketWindows.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">ticket--;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射的知识，我们可以直接将<code>ticketWindows</code>作为一个对象，充当了锁，因为<code>t1, t2, t3</code>内的<code>ticketWindows</code>都是共用的一个对象，因此，我们就没有出现线程的安全性问题了。</p><p>注意，我们用synchronized代码块包含代码时，我们仅需将操作共享数据的代码包起来即可，不能包多，包多可能会与实际情况相违背了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (ticketWindows.class) &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">         ticket--;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如这种情况，我们就会出现一个线程在操作，其他线程全部没有使用的情况。</p><p><strong>方式二：同步方法</strong></p><p>在方法定义出加上synchronized关键词可以将方法变成同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>同步方法同样是存在锁的，它的锁是<code>this</code>，因此对于继承<code>Thread</code>方法创建的多线程，直接如上使用的话一样是存在线程的安全性问题的。我们可以通过将方法写为静态的方式，解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>由于静态方法里面不能使用<code>this</code>，所以它的锁自然而然的就变成类<code>ticketWindows.class</code>。</p><p><strong>总结</strong></p><p>使用同步机制，我们解决线程的安全问题，但操作同步代码时，只能由一个线程参与，其他线程只能等待，相当于是一个单线程的过程，效率不太高。</p><p><strong>懒汉式单例改写为线程安全式</strong></p><p>在多线程调用懒汉式的<code>getInstance</code>方法时，如果我们不做保证线程安全性问题的措施，我们有可能会出现多个线程同时进入了if语句内，导致创建了多个实例，不能实现我们单例设计模式的目的。因此我们需要通过上面所学的知识，解决线程安全性问题，首先是同步方法和同步代码块的方式解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(bank == <span class="literal">null</span>)&#123;</span><br><span class="line">      bank = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bank;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Bank.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(bank == <span class="literal">null</span>)&#123;</span><br><span class="line">bank = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bank;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但者两种方式效率并不是很高，表面上是多线程执行，但实际上只能同时进行一个操作，与之前所提到的例子不同，单例设计模式线程安全性问题仅会出现在不存在实例的时候，因此我们可以在外面再包多一次if语句判断是否已经存在实例，这样就只会在实例不存在的时候，进入一次同步代码块，这样效率就高很多了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(bank == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Bank.class) &#123;</span><br><span class="line">         <span class="keyword">if</span>(bank == <span class="literal">null</span>)&#123;</span><br><span class="line">            bank = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程的死锁问题</strong></p><p>死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放出自己需要的同步资源，就形成了线程的死锁。出现死锁后，不会出现异常，不会出现提示，但所有的线程都会处于阻塞状态，无法继续执行。</p><p>我们构造两个线程，第一个线程先握住s1锁，再握住s2锁，第二个线程先握住s2锁，再握住s1锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">      <span class="type">StringBuffer</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">               s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">               s2.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">100</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">                  s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                  s2.append(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">                  System.out.println(s1);</span><br><span class="line">                  System.out.println(s2);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">               s1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">               s2.append(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">100</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">                  s1.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">                  s2.append(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">                  System.out.println(s1);</span><br><span class="line">                  System.out.println(s2);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，控制台它什么都没有显示，什么都没有提示：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202205231919190.png" alt="image-20220523191927155"></p><p>这是因为线程1抢到了s1锁，然后线程2抢到了s2锁，但是线程1又需要s2锁才能继续执行，而线程2有需要s1锁才能继续执行，然后二者就僵持住了，导致了这个结果。</p><p>解决方式：</p><ul><li>专门的算法、原则</li><li>尽量减少同步资料的定义</li><li>尽量减少嵌套同步</li></ul><h4 id="Lock锁解决线程安全问题"><a href="#Lock锁解决线程安全问题" class="headerlink" title="Lock锁解决线程安全问题"></a>Lock锁解决线程安全问题</h4><p>Lock锁是JDK5.0新增的更强大的线程同步机制，通过显式定义同步锁对象来实现同步，同步锁使用Lock对象充当。</p><p>使用的步骤：</p><ol><li>定义一个ReentrantLock类的对象，构造器内可以选择是否启用公平机制，如果填入true的话，Lock锁就会按先来后到的顺序安排线程，而不是抢占式，默认不填构造器即false</li><li>使用try-finally环绕包含执行操作过程，并在操作过程前调用锁定方法lock()</li><li>在finally内调用解锁方法unlock()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ticketWindows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="comment">// 定义一个ReentrantLock类的对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用锁定方法lock()</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">               ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 调用解锁方法unlock()</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="synchronized与Lock锁差别"><a href="#synchronized与Lock锁差别" class="headerlink" title="synchronized与Lock锁差别"></a>synchronized与Lock锁差别</h4><ul><li>Lock锁是手动锁定与解锁，是显式锁，而synchronized机制是相应代码执行完后自动解锁线程</li><li>Lock只有代码块锁，synchronized有代码锁和方法锁</li><li>Lock锁由于比较后出现，优化较好，JVM将使用较少时间来调度线程，性能更好，而且提供了更多子类</li><li>优先使用顺序：Lock ——&gt; 同步代码块 ——&gt; 同步方法</li></ul><h3 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h3><p>涉及到的方法：</p><ul><li>wait()：执行该方法会使当前线程进入阻塞状态，并释放锁</li><li>notify()：执行此方法会唤醒的被wait的线程，如果多个线程都被wait，则优先唤醒优先度高的线程</li><li>notifyAll()：执行此方法会唤醒全部被wait的线程</li></ul><p>例：使用两个线程交替售票</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ticketWindows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            notify();</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">               ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体思路就是通过wait()阻塞线程1，然后让线程2拿到锁再去唤醒线程1，执行完线程2操作后线程2进入阻塞，以此循环。</p><p><strong>注意点</strong></p><ol><li>wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中</li><li>wait()，notify()，notifyAll()三个方法调用者必须是同步代码块或同步方法的同步监视器，否则会出现异常</li><li>wait()，notify()，notifyAll()三个方法式定义在java.lang.Object类中</li></ol><p><strong>sleep()与wait()异同</strong></p><ul><li>同：都会进入阻塞状态</li><li>sleep()定义在Thread类中，wait()定义在Object类中</li><li>调用的范围：sleep()可以在任何情景下调用，wait()必须在同步代码块和同步方法中</li><li>sleep()不会释放锁，wait()会释放锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（八）：异常处理</title>
      <link href="/2022/05/10/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2022/05/10/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>异常是程序在执行过程中发生不正常的情况。</p><p>Java程序的异常情况分为两类：</p><ul><li><strong>Error：</strong>Java虚拟机无法解决的严重问题。如JVM内部错误、资源耗尽等。一般不编写针对性代码处理。</li><li><strong>Exception：</strong>其他由于编程出错或者偶发性的外在因素导致的一般性错误，则可以通过针对性的代码进行处理。如：空指针访问，试图读取不存在的文件，网络中断，数组越界等等情况。</li></ul><p>对于异常，我们拥有两种办法：第一种是不处理，直接终止程序运行。另外一种就是在编写程序的过程中，将异常的处理方法写入代码中。</p><h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><ul><li><p>NullPointerException 空指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure></li><li><p>ArrayIndexOutOfBoundsException 数组越界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(arr[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure></li><li><p>ClassCastException 类型转换错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br></pre></td></tr></table></figure></li><li><p>NumberFormatException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(str);</span><br></pre></td></tr></table></figure></li><li><p>InputMismatchException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(score);</span><br></pre></td></tr></table></figure><p>当你输入内容为非int类型时，就会报出错误。</p></li><li><p>ArithmeticException 算术异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(a / b);</span><br></pre></td></tr></table></figure></li></ul><h4 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h4><ul><li><p>IOException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line"><span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">   System.out.print((<span class="type">char</span>) data);</span><br><span class="line">   data = fis.read();</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><p>这种编译是无法通过的。</p></li></ul><h3 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h3><p>在编写程序时候，我们往往需要<code>if-else</code>分支对可能出现错误的地方进行检测，但是过多的<code>if-else</code>分支会导致代码过于臃肿。异常处理机制可以将异常处理的代码集中在一起，与正常代码分开，减少过多<code>if-else</code>分支。</p><p>Java有两种异常处理的方式，分别是<code>try-catch-finally</code>方式与<code>throws</code>方式。<code>try-catch-finally</code>方式是自行解决，<code>throws</code>方式是上报的方式，让上面去解决。</p><p>Java的异常处理是一个“抓抛模型”：“抛”是指程序执行的过程中，如果出现异常，就会生成一个对应异常类的对象，并将此对象抛出，一旦抛出异常对象以后，其后代码将不再执行。“抓”是抓取到异常对象后，对异常的处理——try-catch-finally和throws。</p><h4 id="try-catch-finally方式"><a href="#try-catch-finally方式" class="headerlink" title="try-catch-finally方式"></a>try-catch-finally方式</h4><p><strong>结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//处理异常类型1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量<span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//处理异常类型2</span></span><br><span class="line">&#125;.....</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>使用try将可能出现异常代码包装起来，在执行的过程中一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，在catch中进行匹配。进入catch后，进行异常的处理，处理完成后，就会跳出结构（在没有写finally情况下），继续执行后面代码。</p><p>在try-catch结构中申明的变量，在出了结构以后，就不可以再使用了。</p><p>使用<code>try-catch</code>处理异常时，可以使得编译时的错误延迟到运行时再出现。</p><p><code>catch</code>可以写多个。<code>finally</code>是可选的，不一定要写。</p><p><strong>try-catch基础例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">   System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;NumberFormatException&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * output:</span></span><br><span class="line"><span class="comment"> * NumberFormatException</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>由于<code>System.out.println(&quot;1&quot;);</code>是位于异常后面，因此在抛出异常后，发生异常之后的代码将不会执行。</p><h4 id="throws方式"><a href="#throws方式" class="headerlink" title="throws方式"></a>throws方式</h4><p><code>throws</code>给我个人的感觉与抽象类有点相似，<code>throws</code>就是在这个方法里我先不处理，谁调用了这个方法就由谁进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      test();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">   <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">   <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line">   <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.print((<span class="type">char</span>) data);</span><br><span class="line">      data = fis.read();</span><br><span class="line">   &#125;</span><br><span class="line">   fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何选择处理方式"><a href="#如何选择处理方式" class="headerlink" title="如何选择处理方式"></a>如何选择处理方式</h4><ol><li>如果父类中被重写的方法没有throws处理异常，则子类重写的方法如果出现异常，就只能使用try-catch-finally进行处理；</li><li>在执行的方法A中，如果需要先后调用几个具有递进关系的方法，则这几个方法使用throw的方式处理，而A方法使用try-catch-finally的方式处理；</li><li>注意：子类重写的方法抛出的异常类型不大于父类被重写方法抛出的异常类型。</li></ol><h3 id="手动抛出异常"><a href="#手动抛出异常" class="headerlink" title="手动抛出异常"></a>手动抛出异常</h3><p>异常对象可以通过跟一般对象一样，通过<code>new</code>生成异常对象。</p><p>通过<code>throw</code>关键词，我们可以将异常对象抛出。注意此处为<code>throw</code>，并非<code>throws</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.id = id;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;id must be greater than 0&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>下面是自定义的步骤</p><ol><li>自定义异常类一般我们先会让我们自定义的类继承现有的异常体系（Exception、RuntimeException）；</li><li>定义全局常量<code>serialVersionUID</code>（对类的唯一标识）；</li><li>提供重载的构造器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">NewException</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">NewException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(msg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记零碎补充（二）：包装类、单例、代码块</title>
      <link href="/2022/04/29/Java%E7%AC%94%E8%AE%B0%E9%9B%B6%E7%A2%8E%E8%A1%A5%E5%85%85%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8C%85%E8%A3%85%E7%B1%BB%E3%80%81%E5%8D%95%E4%BE%8B%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
      <url>/2022/04/29/Java%E7%AC%94%E8%AE%B0%E9%9B%B6%E7%A2%8E%E8%A1%A5%E5%85%85%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8C%85%E8%A3%85%E7%B1%BB%E3%80%81%E5%8D%95%E4%BE%8B%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>包装类是针对八种基本数据类型定义相应的引用类型。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Lnteger</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr></tbody></table><p>其中<code>Byte  Short  Lnteger  Long  Float  Double</code>拥有一个父类<code>Number</code>。</p><p>包装类的出现，使得基本数据类型可以封装起来，作为一个类使用，完善了Java面向对象的特性。</p><h3 id="包装类、基本数据类型、String相互转换"><a href="#包装类、基本数据类型、String相互转换" class="headerlink" title="包装类、基本数据类型、String相互转换"></a>包装类、基本数据类型、String相互转换</h3><p><strong>使用构造器将基本数据类型装箱</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(i1.toString());<span class="comment">//out:1</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">System.out.println(i2.toString());<span class="comment">//out:1</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">&quot;true123&quot;</span>);</span><br><span class="line">System.out.println(b2.toString());<span class="comment">//out:false</span></span><br><span class="line"><span class="comment">//Java在将布尔类型装箱时，如果不是null或者true，一律均未false</span></span><br><span class="line"><span class="comment">//布尔作为基本数据类型的时候，初值为false，作为包装类的时候，初值为null</span></span><br></pre></td></tr></table></figure><p><strong>使用包装类内置方法转换为基本数据类型</strong></p><p>包装类拥有一个<code>xxxValue</code>的方法，<code>xxx</code>是指要转换的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> i.intValue();</span><br><span class="line">System.out.println(i1);</span><br></pre></td></tr></table></figure><p><strong>自动装箱与自动拆箱</strong></p><p>这是包装类与基本数据类型之间最常用的转换方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line">   Test(i1);<span class="comment">//自动装箱</span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> i1;<span class="comment">//自动装箱</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> i2;<span class="comment">//自动拆箱</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">(Object obj)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="包装类、基本数据类型与String之间的转换"><a href="#包装类、基本数据类型与String之间的转换" class="headerlink" title="包装类、基本数据类型与String之间的转换"></a>包装类、基本数据类型与String之间的转换</h3><p><strong>包装类、基本数据类型–&gt;String</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> i1 + <span class="string">&quot;&quot;</span>;<span class="comment">//方式一</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> String.valueOf(i1);<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure><p><strong>String–&gt;包装类、基本数据类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;114514&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(str1);<span class="comment">//包装类的parseXxx方法</span></span><br></pre></td></tr></table></figure><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>单例的设计模式就是让某一个类只能存在一个对象实例，并且这个类只提供一个取得其对象实例的方法。</p><p>具体就是将类的<strong>构造器访问权限设置为<code>private</code><strong>，这样类的外部就无法访问到类的构造器，但我们可以在</strong>类的内部产生类的对象</strong>。由于在类的外部，我们无法得到类的对象，只能通过<strong>该类的某个静态方法</strong>返回类内部构建的对象，由于静态方法只能访问静态成员变量，所以，指向类内部产生的<strong>对象的变量也必须是静态的</strong>。</p><p>单例有两种实现的方式——饿汉式与懒汉式。</p><h3 id="饿汉式实现"><a href="#饿汉式实现" class="headerlink" title="饿汉式实现"></a>饿汉式实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="comment">//1.私有化类的构造器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//2.内部创建类的对象，并将其设置为静态</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">   <span class="comment">//3.提供公共的静态的方法，返回类的对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式实现"><a href="#懒汉式实现" class="headerlink" title="懒汉式实现"></a>懒汉式实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="comment">//1.初始化类的构造器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//2.声明一个静态类对象，但不进行初始化</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">//3.声明一个公共、静态的方法，返回当前类的对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;<span class="comment">//防止创建多个对象</span></span><br><span class="line">         instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例的使用"><a href="#单例的使用" class="headerlink" title="单例的使用"></a>单例的使用</h3><p>当一个实例生成需要使用大量资源的时候，使用单例可以节约系统性能的开销。单例模式应用场景其实挺常见的：</p><ul><li>应用程序的日志</li><li>网站计数器</li><li>数据库连接池</li><li>读取配置文件的类</li><li>Windows的回收站</li><li>…</li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块在Java中指的是使用<code>&#123;&#125;</code>包围起来的代码集合。代码块分为四种，普通代码块，静态代码块，同步代码块，构造代码块。后面三种代码块均为类的成员之一。由于同步的内容还未学习，所以同步代码块的内容暂时不写。</p><h3 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h3><p>普通代码块就是在方法体内定义的代码块，普通代码块和一般代码的执行顺序与书写顺序一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;普通代码块&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代码块在类被加载的时候会被执行，而且只执行一次，并且优先于各种代码块以及构造函数。如果类中含有多个代码块，则会按照代码顺序执行。</p><p>由于静态代码块的加载是优先于类的其他成员的，所以他既不能存在任何方法体中，也不能访问任何普通变量。</p><p>静态代码块用于某些代码需要启动时就执行，例如启动时加载配置文件等。</p><h3 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造代码块与静态代码块在外观上差距了一个<code>static</code>关键词。</p><p>构造代码块在创建对象时会被调用，每次创建对象时都会调用依次，且执行顺序是优先于构造函数的。实际上，构造代码块是依托于构造函数的，在编译后，构造代码块就是将里面的代码置入构造函数的最前端。</p><p>由于构造代码块每次创建对象都会执行，而构造函数不一定每个对象构造的时候都执行（多个构造函数情况下，建立对象时传入的参数不同则初始化使用对应的构造函数），利用这个特性，我们可以做统计对象创建次数等功能。</p>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门笔记（三）：分支管理</title>
      <link href="/2022/04/24/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
      <url>/2022/04/24/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Git入门笔记（三）"><a href="#Git入门笔记（三）" class="headerlink" title="Git入门笔记（三）"></a>Git入门笔记（三）</h2><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>分支管理是Git中非常重要的管理，使用分支可以使你在开发主线中分离出来，在不影响开发主线的情况下继续工作，例如开发测试版、测试功能之类的。接下来介绍几个基础操作。</p><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>现在我们需要创建一个叫<code>test</code>的分支，并切换至分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b test</span><br></pre></td></tr></table></figure><p>实际上这是两条命令的简写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch test</span><br><span class="line">git checkout test</span><br></pre></td></tr></table></figure><p>第一条命令，代表创建一个<code>test</code>分支；</p><p>第二个命令，代表切换到<code>test</code>分支。</p><h4 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h4><p>我们使用不带任何参数的<code>git branch</code>命令即可查看所有分支，并且该命令会将当前分支用<code>*</code>号标注出来。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204262039070.png" alt="image-20220426203906050"></p><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d test</span><br></pre></td></tr></table></figure><p>这样我们就删除了<code>test</code>分支了。如果<code>test</code>分支包含我们未合并到分支的更改，它会报出错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: The branch &#x27;test&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D test&#x27;.</span><br></pre></td></tr></table></figure><p>此时，我们如果的的确确不想要这些更改了，我们就按照错误信息中的操作，使用<code>-D</code>强制将它删除即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D test</span><br></pre></td></tr></table></figure><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>分支出来的往往是测试的分支，我们需要将他合并会主分区。</p><p>首先，我们切换会主分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br></pre></td></tr></table></figure><p>接着我们使用合并指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge test</span><br></pre></td></tr></table></figure><p>合并完成后我们就可以删除分支了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d test</span><br></pre></td></tr></table></figure><h4 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h4><p>合并分支肯定会出现两边在同一处地方不同修改的问题，这时，我们就需要去解决冲突。</p><p>我们现在在分支下修改一个文件，然后我再在主分支下修改同一文件，使得分支与主分支的文件不同。</p><p>当我们运行合并分支指令<code>git merge test</code>，它会报出错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Auto-merging git.md</span><br><span class="line">CONFLICT (content): Merge conflict in git.md</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p><code>git.md</code>自动合并失败了，我们需要去手动解决合并错误。这时，我们通过任何一种文本的方式打开我们冲突的文件<code>git.md</code>，Git会将冲突的地方帮我我们标注出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">First.Third.</span><br><span class="line">=======</span><br><span class="line">First.Second.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; test</span><br></pre></td></tr></table></figure><p><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>表示当前分支；</p><p><code>=======</code>是分割线；</p><p><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; test</code>表示Test分支。</p><p>接下来，我们根据实际情况，保留我们需要的部分，将文件进行修改，这里我们演示将两个部分合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">First.Third.</span><br><span class="line">First.Second.</span><br></pre></td></tr></table></figure><p>解决冲突内容后，我们使用提交到本地库的操作，将修改后的文件提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .\git.md</span><br><span class="line">git commit -m &#x27;主干分支冲突解决&#x27;</span><br></pre></td></tr></table></figure><p>这时，我们就解决了合并冲突了。最后我们可以将不需要的分支删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d test</span><br></pre></td></tr></table></figure><p>我们的本地分支合并工作就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> 新技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门笔记（二）：远程仓库</title>
      <link href="/2022/04/22/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>/2022/04/22/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Git入门笔记（二）"><a href="#Git入门笔记（二）" class="headerlink" title="Git入门笔记（二）"></a>Git入门笔记（二）</h2><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="克隆项目到本地"><a href="#克隆项目到本地" class="headerlink" title="克隆项目到本地"></a>克隆项目到本地</h4><p>很简单，<code>git clone &lt;url&gt;</code>在url填入远程仓库的地址就可以clone到本地了，url处有两种地址，一种是通过SSH进行克隆，另外一种是通过HTTPS的方式进行克隆。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221855787.png" alt="image-20220422185525713" style="zoom:67%;" /><p>上面为SSH的方式，下面为HTTPS的方式。</p><h4 id="初始化远程仓库"><a href="#初始化远程仓库" class="headerlink" title="初始化远程仓库"></a>初始化远程仓库</h4><h5 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h5><p>以GitHub为例子，具体账号与仓库创建不再赘述。</p><p>仓库创建好了之后，我们看到我们的仓库是没有初始化的，GitHub页面上会出现一个初始化的教程。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204222053081.png" alt="image-20220422205301003" style="zoom: 33%;" /><p>我们照着教程上初始化即可，简单来说，它的初始化过程就是，先生成一个<code>README.md</code>，接着创建一个本地仓库，提交<code>README.md</code>到本地仓库，然后将本地仓库推送到远程仓库，即可完成初始化。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204222103895.png" alt="image-20220422210303739" style="zoom: 40%;" /><h5 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h5><p>Git支持多种协议，其中包括SSH，SSH速度相当不错，比HTTPS效果更佳。我们来配置一下SSH。</p><p>第一步，我们检查一下电脑上是否已经存在<code>SSH Key</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>如果显示出存在<code>id_rsa.pub</code>或<code> id_dsa.pub</code>文件时，则证明已经存在<code>SSH Key</code>，可以跳过第二步。</p><p>第二步，创建<code>SSH Key</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>如果你的电脑不支持<code>ed25519</code>的加密格式，我们也可以使用传统的<code>rsa</code>加密：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>我们可以来看看参数的含义：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-b</td><td>指定密钥长度</td></tr><tr><td>-e</td><td>读取openssh的私钥或者公钥文件</td></tr><tr><td>-f</td><td>指定用于保存密钥的文件名</td></tr><tr><td>-t</td><td>指定密钥类型</td></tr><tr><td>-C</td><td>添加注释，往往以邮箱作为注释</td></tr></tbody></table><p>通常的，我们可以省略<code>-b</code>参数。<code>-f</code>参数会在后面提示中让你填写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/yourusersname/.ssh/id_rsa): [Press enter]</span></span><br></pre></td></tr></table></figure><p>这里推荐使用默认即可，接着会提醒是输入两次密码，此密码为push时使用的密码，不是GitHub的密码，我们可以不输入，这样在push时就不需要密码了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span> </span><br><span class="line"><span class="meta"># </span><span class="language-bash">Enter same passphrase again:</span></span><br></pre></td></tr></table></figure><p>接下来，就会出现代码提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Your identification has been saved <span class="keyword">in</span> /c/Users/yourusersname/.ssh/id_rsa.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Your public key has been saved <span class="keyword">in</span> /c/Users/yourusersname/.ssh/id_rsa.pub.</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>意味着你的<code>SSH Key</code>就创建好了，公钥就是<code>/c/Users/yourusersname/.ssh/id_rsa.pub</code>、私钥是<code>/c/Users/yourusersname/.ssh/id_rsa</code>。</p><p>第三步，添加<code>SSH Key</code>至Github。</p><p>用任何文本编辑器打开你的公钥<code>id_rsa.pub</code>，复制文件内所有信息。</p><p>打开你的Github，点击你的头像，选择<code>settings</code>，然后再<code>Access</code>中找到<code>SSH and GPG keys</code>选项，选择<code>New SSH key</code>。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204242038466.png" alt="image-20220424203852243"></p><p>在<code>title</code>填入你想给这个<code>SSH Key</code>的备注，在<code>Key</code>中粘贴进刚刚复制的信息，点击<code>Add SSH key</code>即可。</p><p>这样就添加成功<code>SSH Key</code>了。</p><p>第四步，测试SSH Key。</p><p>打开Git Bash，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>出现提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">The authenticity of host <span class="string">&#x27;github.com (207.97.227.239)&#x27;</span> can<span class="string">&#x27;t be established.</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">RSA key fingerprint is （你的密钥）</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span></span><br></pre></td></tr></table></figure><p>输入<code>yes</code>即可，若创建时使用了密码，这时就需要输入你的密码。</p><p>完成后就会出现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Hi username! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">provide shell access.</span></span></span><br></pre></td></tr></table></figure><p>这样，你的Github的SSH设置就算完成了。</p><p>接下来初始化的步骤，与HTTPS几乎没有什么区别，按照Github上提示完成即可。</p><p>[^参考资料2]: <a href="https://docs.github.com/cn/authentication/connecting-to-github-with-ssh">使用 SSH 连接到 GitHub - GitHub Docs</a></p><h4 id="从远程仓库更新"><a href="#从远程仓库更新" class="headerlink" title="从远程仓库更新"></a>从远程仓库更新</h4><p>有两种方法，第一种比较安全，第二种比较方便。</p><h5 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h5><p>我们需要两个步骤：</p><ol><li>从远程仓库中抓取与拉取</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure><p>这个命令可以从远程仓库中下载数据到本地仓库，但没有进行合并。</p><p>我们clone了一个远程仓库，命令会自动将远程仓库命名为<code>origin</code>，一般来说，我们在本地仓库的文件夹内，使用<code>origin</code>作为<code>&lt;remote&gt;</code>即可，即</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure><ol start="2"><li>合并到本地仓库分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;remote&gt;/&lt;branch&gt;</span><br></pre></td></tr></table></figure><p>这个命令的意思是，将<code>&lt;remote&gt;/&lt;branch&gt;</code>分支与主合并。</p><p><code>&lt;remote&gt;/&lt;branch&gt;</code>是我们从远程仓库下载下来的分支，在Github中，主分支被命名为<code>main</code>，因此，我们从Github远程仓库下载下来的主分支名字一般都为<code>main</code>，所以我们要将远程下载下来的主分支与本地仓库当前分支合并，运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/main</span><br></pre></td></tr></table></figure><h5 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h5><p>这个命令相当于是将上面两个命令合二为一，即抓取数据并自动尝试合并到当前所在的分支。使用很简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote&gt; &lt;remote branch&gt;:&lt;local branch&gt;</span><br></pre></td></tr></table></figure><p>意思是从<code>remote</code>远程仓库中拉取<code>remote branch</code>分支，并与本地的<code>local branch</code>分支合并：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main:main</span><br></pre></td></tr></table></figure><p>如果远程分支是与当前分支合并，则冒号后面可以省略：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p>推送到远程仓库的命令，与上面<code>git pull</code>的命令格式非常相似：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</span><br></pre></td></tr></table></figure><p>意思是将本地仓库<code>local branch</code>分支与<code>remote</code>远程仓库中的<code>remote branch</code>分支合并。</p><p>如果远程分支名与本地分支名相同，则可以省略冒号后面的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote&gt; &lt;local branch&gt;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure><p>意思为将本地的<code>mian</code>分支推送到远程仓库，并于其中的<code>main</code>分支合并。</p><p>使用这个命令，我们还可以删除远程仓库中的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete testbranch</span><br></pre></td></tr></table></figure><p>意思是删除远程仓库中<code>testbranch</code>分支。</p>]]></content>
      
      
      <categories>
          
          <category> 新技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门笔记（一）：基本知识与基本操作</title>
      <link href="/2022/04/19/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/04/19/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Git入门笔记（一）"><a href="#Git入门笔记（一）" class="headerlink" title="Git入门笔记（一）"></a>Git入门笔记（一）</h2><p>Git是一个非常常用的版本控制软件，很多被广泛使用的软件项目都是使用Git进行版本控制的。</p><p>本教程将不包括基础的安装流程。</p><h3 id="Git文件的三种状态"><a href="#Git文件的三种状态" class="headerlink" title="Git文件的三种状态"></a>Git文件的三种状态</h3><p>使用Git进行操作软件时，文件状态有三种：</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>已提交(committed)</td><td>表示文件已经保存在本地Git库中。</td></tr><tr><td>已修改(modifiled)</td><td>表示文件已修改，但暂未保存到Git库中。</td></tr><tr><td>已暂存(staged)</td><td>表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</td></tr></tbody></table><p>由于Git提交文件到Git库时，并不是直接从工作区直接到Git库的，中间存在一个暂存区(staging area)，这个过程的文件就被称之为<code>已暂存</code>。</p><h4 id="Git项目的三个工作区域"><a href="#Git项目的三个工作区域" class="headerlink" title="Git项目的三个工作区域"></a>Git项目的三个工作区域</h4><p>针对Git文件的三种状态，Git项目分为三个区域：</p><table><thead><tr><th>区域</th><th>描述</th></tr></thead><tbody><tr><td>工作区</td><td>简单来说就是本地看到的目录。</td></tr><tr><td>暂存区(stage &#x2F; index)</td><td>一般存放在<code>.git</code>目录下，里面包含了Git自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针<code>HEAD</code>。</td></tr><tr><td>Git仓库(版本库)</td><td>工作区下隐藏的目录<code>.git</code>，是Git的版本库（仓库）。</td></tr></tbody></table><h4 id="Git基本工作流程"><a href="#Git基本工作流程" class="headerlink" title="Git基本工作流程"></a>Git基本工作流程</h4><ul><li>工作区修改文件</li><li>对修改后的文件暂存</li><li>提交更新，将暂存的文件转储到Git仓库内</li></ul><h3 id="创建仓库与提交文件"><a href="#创建仓库与提交文件" class="headerlink" title="创建仓库与提交文件"></a>创建仓库与提交文件</h3><h4 id="初始化Git本地仓库"><a href="#初始化Git本地仓库" class="headerlink" title="初始化Git本地仓库"></a>初始化Git本地仓库</h4><p>在Git的命令行窗口，使用<code>git init</code>命令可以在本地初始化一个空仓库。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201215657.png" alt="image-20220420121506627" style="zoom:125%;" /><h4 id="提交文件至暂存区"><a href="#提交文件至暂存区" class="headerlink" title="提交文件至暂存区"></a>提交文件至暂存区</h4><p>我们可以使用<code>git add &lt;path&gt;</code>的命令，使一个位于<code>path</code>的文件或者目录添加至暂存区。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201221833.png" alt="image-20220420122135812" style="zoom:130%;" /><p>之后我们可以通过<code>git status</code>的命令，查看工作区与暂存区的文件状态。该命令可以查看到哪些修改被暂存，哪些修改没有，或是哪些文件没有被git追踪到（Untracked files）。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201222564.png" alt="image-20220420122243543"></p><h4 id="提交至本地仓库"><a href="#提交至本地仓库" class="headerlink" title="提交至本地仓库"></a>提交至本地仓库</h4><p>执行<code>git commit</code>命令可以提交暂存区的文件至本地仓库中。通常在使用该命令时，会选择加入<code>-m &lt;text&gt;</code>参数，我们可以在<code>&lt;text&gt;</code>处填入本次提交的说明。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201237212.png" alt="image-20220420123716186" style="zoom: 67%;" /><p>如果加入<code>-a &lt;file&gt;</code>参数，我们将不需要执行<code>git add</code>命令，直接将<code>file</code>提交至本地仓库。</p><p>我们也可以在<code>git commit</code>后加入<code>&lt;file1&gt; &lt;file2&gt; ....</code>文件参数，指定暂存区的某文件到本地仓库。</p><h4 id="查看提交日志信息"><a href="#查看提交日志信息" class="headerlink" title="查看提交日志信息"></a>查看提交日志信息</h4><p>使用<code>git log</code>命令，我们可以查看到提交日志信息。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201238061.png" alt="image-20220420123842023" style="zoom: 80%;" /><h4 id="修改文件并提交"><a href="#修改文件并提交" class="headerlink" title="修改文件并提交"></a>修改文件并提交</h4><p>实际上修改文件并提交的过程与上面新增一个文件并提交的过程并无太大差异。</p><p>首先我们可以用<code>git status</code>命令来查看我们已修改（modified）的文件。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201351883.png" alt="image-20220420135140855"></p><p>我们可以得知的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">On branch master 在主分支</span><br><span class="line">Changes not staged for commit: 更改没有被保存至暂存区</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) 使用git add命令保存更改至暂存区</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) 使用git restore放弃工作区的更改</span><br><span class="line">        modified:   git2.md 已更改文件： git2.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 没有要提交的更改（可以使用git add或git commit -a提交更改）</span><br></pre></td></tr></table></figure><p>通常的，我们会使用<code>git status -s</code>来获取简短的输出结果：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201405965.png" alt="image-20220420140501938"></p><p>一个红色的M表示更改未保存至暂存区，一个绿色M表示更改已保存至暂存区，当同时出现一个红和一个绿M时候，则表示添加至暂存区后又发生了更改。</p><p>我们使用<code>git add</code>提交后，就可以执行<code>git commit -m</code>来使我们暂存区的更改保存到本地仓库中了。</p><h4 id="比较文件不同"><a href="#比较文件不同" class="headerlink" title="比较文件不同"></a>比较文件不同</h4><p>我们使用<code>git diff &lt;file&gt;</code>命令，可以比较文件的不同，当不加入额外参数时，它的作用是查看尚未保存至暂存区的更改。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201426753.png" alt="image-20220420142630702"></p><p>当我们加入<code>--cached</code>或是<code>--staged</code>参数时，作用是查看已保存至暂存区的更改。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201427778.png" alt="image-20220420142702736"></p><p>当我们加入<code>HEAD</code>参数时，我们将可以看到已保存至暂存区和未保存的全部更改。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201430943.png" alt="image-20220420143033890"></p><p>而<code>--stat</code>参数的加入，可以使其仅展示摘要，而不是完整的修改内容。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201432715.png" alt="image-20220420143210685"></p><h4 id="撤销暂存区更改"><a href="#撤销暂存区更改" class="headerlink" title="撤销暂存区更改"></a>撤销暂存区更改</h4><p>执行<code>git reset HEAD &lt;file&gt;</code>我们可以撤销已保存至暂存区的更改。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201439223.png" alt="image-20220420143909172"></p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><p>在学习版本回退之前，先补充一下<code>git log</code>指令的相关参数详解。</p><p><code>--oneline </code>参数可以查看历史记录的简洁版本。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204211604452.png" alt="image-20220421160458412" style="zoom: 70%;" /><p><code>--graph</code>参数可以以拓扑图的形式，展示历史中出现的分支、合并。</p><p><code>--reverse</code>参数用于逆向显示日志。</p><p><code>--author=name</code>参数用于查询名为<code>name</code>这个人的提交日志。</p><p><code>-&lt;number&gt;</code>参数可以显示近<number>次数的提交日志。</p><h4 id="版本回退-1"><a href="#版本回退-1" class="headerlink" title="版本回退"></a>版本回退</h4><p>前面我们提及了一个撤销暂存区更改的命令<code>git reset HEAD &lt;file&gt;</code>，实际上这个命令是版本回退命令的一个使用，现在我们来详解这个命令。</p><p><code>--hard</code>参数撤销工作区所有未提交的修改内容，将工作区与暂存区都回退到上一个版本。</p><p><code>HEAD</code>参数：</p><ul><li><code>HEAD</code>表示当前版本</li><li><code>HEAD^</code>表示上版本，以此类推，<code>HEAD^^</code>表示上上个版本等等</li><li><code>HEAD~0</code>表示当前版本</li><li><code>HEAD~1</code>表示上个版本，以此类推，<code>HEAD~50</code>表示上50个版本</li></ul><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221627089.png" alt="image-20220422162741046" style="zoom:50%;" /><p><code>aabbcc</code>这个aabbcc代表的是版本唯一的标识码，我们可以用这个参数来指定回退到某以aabbcc作为版本唯一标识码的版本。</p><p>当我们后悔了，需要“回到未来”怎么办呢，我们可以用到<code>git reflog</code>的命令，来查看你每一次的操作，并且获得操作的标识码，这样就可以获得某个版本的<code>commit id</code>，也就是标识码了。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221632822.png" alt="image-20220422163214788" style="zoom: 67%;" /><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221627655.png" alt="image-20220422162701602" style="zoom: 50%;" /><h3 id="文件从本地仓库恢复"><a href="#文件从本地仓库恢复" class="headerlink" title="文件从本地仓库恢复"></a>文件从本地仓库恢复</h3><p>如果我们在工作区误删了文件，我们需要用到一个命令<code>git checkout -- &lt;file&gt;</code>，这个命令可以帮助我们从本地仓库中恢复<code>file</code>文件。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221648927.png" alt="image-20220422164852884" style="zoom: 50%;" /><h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><p>首先，我们可以在资源管理器中将工作区的文件删除，使用<code>git status</code>就可以看到我们确实删除了一个文件。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221656455.png" alt="image-20220422165616423" style="zoom: 67%;" /><p>然后我们可以使用<code>git rm &lt;file&gt; </code>的指令，确定删除该文件，接着我们用<code>git commit</code>将我们这个更改上传至本地仓库，这样文件就在本地仓库被删除了。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221701131.png" alt="image-20220422170159105" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 新技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（七）：反射</title>
      <link href="/2022/03/31/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/03/31/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>据我们所知，Java是一种静态语言。但是Java却可以通过<code>Reflection（反射）</code>实现动态语言的特性，反射机制允许在执行期间借助<code>Reflection API</code>取得任何类的内部信息，并且能直接操作任意对象的内部属性及方法。</p><p>反射对象相当于是一面镜子，通过镜子，”反射”得到对象的信息：某个类的属性、方法、构造器、实现的接口。</p><h3 id="获得反射对象"><a href="#获得反射对象" class="headerlink" title="获得反射对象"></a>获得反射对象</h3><h4 id="通过对象获得"><a href="#通过对象获得" class="headerlink" title="通过对象获得"></a>通过对象获得</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> person.getClass();</span><br></pre></td></tr></table></figure><h4 id="通过forname获得"><a href="#通过forname获得" class="headerlink" title="通过forname获得"></a>通过<code>forname</code>获得</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.icewindy.test.Person&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="通过类名-class获得"><a href="#通过类名-class获得" class="headerlink" title="通过类名.class获得"></a>通过类名.class获得</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Person.class;</span><br></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;c1:%s,c2:%s,c3:%s\n&quot;</span>, c1.hashCode(), c2.hashCode(), c3.hashCode());<span class="comment">//output:c1:295530567,c2:295530567,c3:295530567</span></span><br></pre></td></tr></table></figure><h4 id="基本内置类型的包装类都有一个TYPE属性"><a href="#基本内置类型的包装类都有一个TYPE属性" class="headerlink" title="基本内置类型的包装类都有一个TYPE属性"></a>基本内置类型的包装类都有一个<code>TYPE</code>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> Integer.TYPE;</span><br></pre></td></tr></table></figure><h4 id="获得父类类型"><a href="#获得父类类型" class="headerlink" title="获得父类类型"></a>获得父类类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> student.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> c4.getSuperclass();</span><br><span class="line">System.out.printf(<span class="string">&quot;c5:%s\n&quot;</span>, c5.hashCode());<span class="comment">//output:c5:295530567</span></span><br></pre></td></tr></table></figure><h3 id="拥有Class对象的类型"><a href="#拥有Class对象的类型" class="headerlink" title="拥有Class对象的类型"></a>拥有Class对象的类型</h3><p>class 各种类、interface 接口、[] 数组、enum 枚举、annotation 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Object.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Comparable.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> String[].class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="type">int</span>[][].class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> Override.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c6</span> <span class="operator">=</span> ElementType.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c7</span> <span class="operator">=</span> Integer.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c8</span> <span class="operator">=</span> <span class="keyword">void</span>.class;<span class="comment">//小写v表示void基本数据类型，大写V表示void的自动装箱类型</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c9</span> <span class="operator">=</span> Class.class;</span><br><span class="line"></span><br><span class="line">System.out.println(c1);<span class="comment">//output:class java.lang.Object</span></span><br><span class="line">System.out.println(c2);<span class="comment">//output:class java.lang.Comparable</span></span><br><span class="line">System.out.println(c3);<span class="comment">//output:class [Ljava.lang.String; ,一维数组用一个[</span></span><br><span class="line">System.out.println(c4);<span class="comment">//output:class [[I ,二维数组用两个[</span></span><br><span class="line">System.out.println(c5);<span class="comment">//output:interface java.lang.Override</span></span><br><span class="line">System.out.println(c6);<span class="comment">//output:enum java.lang.annotation.ElementType</span></span><br><span class="line">System.out.println(c7);<span class="comment">//output:class java.lang.Integer</span></span><br><span class="line">System.out.println(c8);<span class="comment">//output:void</span></span><br><span class="line">System.out.println(c9);<span class="comment">//output:class java.lang.Class</span></span><br></pre></td></tr></table></figure><h3 id="类加载过程分析"><a href="#类加载过程分析" class="headerlink" title="类加载过程分析"></a>类加载过程分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">System.out.println(a.m);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.加载到内存，产生一个类对应的java.lang.Class对象</span></span><br><span class="line"><span class="comment"> * 2.链接JVM，为类变量（静态变量）分配内存并设置为默认初始化值</span></span><br><span class="line"><span class="comment"> * 3.初始化类，调用类构造器&lt;clinit&gt;()将代码块合并</span></span><br><span class="line"><span class="comment"> * &lt;clinit&gt;()&#123;</span></span><br><span class="line"><span class="comment"> * System.out.println(&quot;A静态代码块初始化&quot;);</span></span><br><span class="line"><span class="comment"> *    m = 300;</span></span><br><span class="line"><span class="comment"> * m = 100;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A静态代码块初始化&quot;</span>);</span><br><span class="line">m = <span class="number">300</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A构造函数初始化&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>out:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A静态代码块初始化</span><br><span class="line">A构造函数初始化</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h4 id="类的初始化发生"><a href="#类的初始化发生" class="headerlink" title="类的初始化发生"></a>类的初始化发生</h4><h5 id="类的主动引用（会发生初始化）"><a href="#类的主动引用（会发生初始化）" class="headerlink" title="类的主动引用（会发生初始化）"></a>类的主动引用（会发生初始化）</h5><ol><li>JVM启动，初始化main方法所在的类</li><li>new一个类的对象</li><li>调用类的静态成员（除了常量final）和静态方法</li><li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用</li><li>当初始化一个类，如果父类没有被初始化，则先初始化父类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Main类被加载&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="comment">/*out:</span></span><br><span class="line"><span class="comment"> * Main类被加载 --1</span></span><br><span class="line"><span class="comment"> * 父类被加载   --5</span></span><br><span class="line"><span class="comment"> * 子类被加载   --2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class.forName(<span class="string">&quot;cn.icewindy.test.Son&quot;</span>);</span><br><span class="line"><span class="comment">/*out: --4</span></span><br><span class="line"><span class="comment"> * Main类被加载</span></span><br><span class="line"><span class="comment"> * 父类被加载</span></span><br><span class="line"><span class="comment"> * 子类被加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;父类被加载&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;子类被加载&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类的被动引用（不会发生初始化）"><a href="#类的被动引用（不会发生初始化）" class="headerlink" title="类的被动引用（不会发生初始化）"></a>类的被动引用（不会发生初始化）</h5><ol><li>当访问一个静态域，只有真正申明这个域的类才会被初始化。如：通过子类引用父类的静态变量，不会导致子类初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Father.a);</span><br><span class="line">System.out.println(Son.a);</span><br><span class="line"><span class="comment">/* out:    --1</span></span><br><span class="line"><span class="comment"> * Main类被加载</span></span><br><span class="line"><span class="comment"> * 父类被加载</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过数组定义类的引用，不会发生此类初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Son[] arraySon = <span class="keyword">new</span> <span class="title class_">Son</span>[<span class="number">5</span>];<span class="comment">//out: Main类被加载</span></span><br></pre></td></tr></table></figure><ol start="3"><li>引用常量不会触发类的初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Son.b);</span><br><span class="line"><span class="comment">/* out:</span></span><br><span class="line"><span class="comment"> * Main类被加载</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="获取类的结构"><a href="#获取类的结构" class="headerlink" title="获取类的结构"></a>获取类的结构</h3><h4 id="获取类的名称"><a href="#获取类的名称" class="headerlink" title="获取类的名称"></a>获取类的名称</h4><ul><li><p><code>getName()</code>可以获取包名+类名；</p></li><li><p><code>getSimpleName()</code>可以获取类名。</p></li></ul><h4 id="获取类的属性"><a href="#获取类的属性" class="headerlink" title="获取类的属性"></a>获取类的属性</h4><ul><li><code>Field getField(name)</code>根据<code>name</code>获取某个<code>public</code>的属性（包括父类）；</li><li><code>Field getDeclaredField(name)</code>根据<code>name</code>获取某个属性（不包括父类）；</li><li><code>Field[] getFields()</code>获取所有<code>public</code>的属性（包括父类）；</li><li><code>Field[] getDeclaredFields()</code>获取所有属性（不包括父类）。</li></ul><h4 id="获得属性的值"><a href="#获得属性的值" class="headerlink" title="获得属性的值"></a>获得属性的值</h4><ul><li><code>Field.get(Object)</code>根据<code>Object</code>实例获取其对应属性的值。</li></ul><h4 id="获取类的方法"><a href="#获取类的方法" class="headerlink" title="获取类的方法"></a>获取类的方法</h4><ul><li><code>Method getMethod(name, Class...)</code>获取某个<code>public</code>的方法（包括父类）<code>Classs</code>代表参数类型；</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取某个方法（不包括父类）<code>Classs</code>代表参数类型；</li><li><code>Method[] getMethods()</code>获取所有<code>public</code>的方法（包括父类）；</li><li><code>Method[] getDeclaredMethods()</code>获取所有方法（不包括父类）。</li></ul><h4 id="获取类的构造器"><a href="#获取类的构造器" class="headerlink" title="获取类的构造器"></a>获取类的构造器</h4><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的构造器；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个构造器；</li><li><code>getConstructors()</code>：获取<code>public</code>的构造器；</li><li><code>getDeclaredConstructors()</code>：获取所有构造器。</li></ul><h4 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line">      <span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.icewindy.test.Student&quot;</span>);</span><br><span class="line">      <span class="comment">//获得类的名字</span></span><br><span class="line">      System.out.println(s.getName());      <span class="comment">//out:cn.icewindy.test.Student</span></span><br><span class="line">      System.out.println(s.getSimpleName());<span class="comment">//out:Student</span></span><br><span class="line">      <span class="comment">//获得类的属性</span></span><br><span class="line">      Field[] fields = s.getDeclaredFields();<span class="comment">//获取所有field（不包括父类）</span></span><br><span class="line">      <span class="keyword">for</span> (Field field : fields) &#123;           <span class="comment">//out:</span></span><br><span class="line">         System.out.println(field);         <span class="comment">//private int cn.icewindy.test.Student.ID</span></span><br><span class="line">      &#125;</span><br><span class="line">      Field[] fields2 = s.getFields();<span class="comment">//获取所有public的field（包括父类）</span></span><br><span class="line">      <span class="keyword">for</span> (Field field : fields2) &#123;  <span class="comment">//output:</span></span><br><span class="line">         System.out.println(field);  <span class="comment">//public java.lang.String cn.icewindy.test.Person.name</span></span><br><span class="line">      &#125;                       <span class="comment">//public int cn.icewindy.test.Person.age</span></span><br><span class="line">      <span class="comment">//获得属性的值</span></span><br><span class="line">      <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> s.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">      <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(<span class="keyword">new</span> <span class="title class_">Student</span>());<span class="comment">//多态</span></span><br><span class="line">      System.out.println(value);        <span class="comment">//out:icewindy</span></span><br><span class="line">      <span class="comment">//获得类的方法</span></span><br><span class="line">      Method[] methods = s.getMethods();<span class="comment">//获取所有public的method（包括父类）</span></span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;      <span class="comment">//output:太长了，省略，包括了Object的方法</span></span><br><span class="line">         System.out.println(method);</span><br><span class="line">      &#125;</span><br><span class="line">      Method[] methods2 = s.getDeclaredMethods();<span class="comment">//获取所有method（不包括父类）</span></span><br><span class="line">      <span class="keyword">for</span>(Method method : methods2)&#123;             <span class="comment">//output:</span></span><br><span class="line">         System.out.println(method);             <span class="comment">//public void cn.icewindy.test.Student.study()</span></span><br><span class="line">      &#125;                                <span class="comment">//private void cn.icewindy.test.Student.talk()</span></span><br><span class="line">      <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> s.getMethod(<span class="string">&quot;say&quot;</span>, String.class);<span class="comment">//获取指定method</span></span><br><span class="line">      System.out.println(method);                 <span class="comment">//output:public void cn.icewindy.test.Student.say(java.lang.String)</span></span><br><span class="line">      <span class="comment">//获取类的构造器</span></span><br><span class="line">      Constructor[] constructors = s.getConstructors();<span class="comment">//获取所有public的constructor（包括父类）</span></span><br><span class="line">      <span class="keyword">for</span>(Constructor constructor : constructors)&#123;<span class="comment">//output:public cn.icewindy.test.Student()</span></span><br><span class="line">         System.out.println(constructor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;icewindy&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;I am a Student&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ID</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Student is studying&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">talk</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String str)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Student is saying: &quot;</span>+str);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><h4 id="调用构造器"><a href="#调用构造器" class="headerlink" title="调用构造器"></a>调用构造器</h4><h4 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h4>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记零碎补充（一）：大数、用var声明局部变量、字符串</title>
      <link href="/2022/03/29/Java%E7%AC%94%E8%AE%B0%E9%9B%B6%E7%A2%8E%E8%A1%A5%E5%85%85%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%A4%A7%E6%95%B0%E3%80%81%E7%94%A8var%E5%A3%B0%E6%98%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/03/29/Java%E7%AC%94%E8%AE%B0%E9%9B%B6%E7%A2%8E%E8%A1%A5%E5%85%85%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%A4%A7%E6%95%B0%E3%80%81%E7%94%A8var%E5%A3%B0%E6%98%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h2><p>当基本的整数和浮点数精度不能够满足你的需求的时候，我们就可以引入在<code>java.math</code>包中的两个类——<code>BigInteger</code>和<code>BigDecimal</code>。这两个类可以处理任意长度的数值。</p><p><code>BigInteger</code>类可以处理任何精度的<code>整数运算</code>，而<code>BigDecimal</code>类可以处理任何精度的<code>浮点数运算</code>。</p><p>它们的使用方法非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;...&quot;</span>);<span class="comment">//大整数</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;...&quot;</span>);<span class="comment">//大浮点数</span></span><br></pre></td></tr></table></figure><p><code>bi / bd</code>处可以填入任意你想叫的名字，当然，最好还是尊重一下命名规则，除非你想让你的代码无人能够流畅阅读，甚至是刚睡了一觉的你。而<code>...</code>处是填入你想要的给<code>bi / bd</code>赋的数值。</p><p>我们也可以使用静态的<code>valueOf</code>方法将普通的数转换为大数，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">100</span>);<span class="comment">//100这里可以改成别的数或者是变量</span></span><br></pre></td></tr></table></figure><p>由于大数不是基础数据类型，我们就无法使用熟悉的算数运算符来处理大数，而是应该使用大数类型中的方法，下表列出最常见的运算：</p><p>BigInteger：</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>add(BigInteger other)</td><td>做加法运算</td></tr><tr><td>subtract(BigInteger other)</td><td>做减法运算</td></tr><tr><td>multiply(BigInteger other)</td><td>做乘法运算</td></tr><tr><td>divide(BigInteger other)</td><td>做除法运算</td></tr><tr><td>remainder(BigInteger other)</td><td>做取余数运算</td></tr><tr><td>pow(int n)</td><td>做n次方运算</td></tr><tr><td>mod(BigInteger other)</td><td>返回两个大数的和、差、积、商、余数</td></tr></tbody></table><p>BigDecimal：</p><p><code>BigDecimal</code>基本运算大致与<code>BigInteger</code>相同，但除法有所不同，因为需要考虑到除不尽末尾小数的处理方法。</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>add(BigDecimal other)</td><td>做加法运算</td></tr><tr><td>subtract(BigDecimal other)</td><td>做减法运算</td></tr><tr><td>multiply(BigDecimal other)</td><td>做乘法运算</td></tr><tr><td>divide(BigDecimal other)</td><td>做除法运算</td></tr><tr><td>divide(BigDecimal other，int scale,  roundingMode)</td><td>做除法运算，三个参数分别代表除数，商后的位数，近似值的处理模式</td></tr></tbody></table><p>近似值的处理模式有太多种了，这里只介绍一个，即最常见的四舍五入——<code>ROUND_HALF_UP</code>。</p><p>来个例子吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">BigDecimal</span> <span class="variable">bd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1234567890123456789012345678901234567890&quot;</span>);</span><br><span class="line">      <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;9876543210987654321098765432109876543210&quot;</span>);</span><br><span class="line">      <span class="type">BigDecimal</span> <span class="variable">bd3</span> <span class="operator">=</span> bd1.divide(bd2, <span class="number">10</span>, BigDecimal.ROUND_HALF_UP);</span><br><span class="line">      System.out.println(bd3);<span class="comment">//out:0.1249999989</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用var声明局部变量"><a href="#用var声明局部变量" class="headerlink" title="用var声明局部变量"></a>用var声明局部变量</h2><p>在Java10以上的版本，对于可以从变量初始值推导出他们的类型的，可以用<code>var</code>关键词声明局部变量。</p><p>注意，一定是在Java10以上的版本，<code>var</code>关键词是在该版本才引入的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;a&quot;</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure><p><code>var</code>关键词避免了重复写类型名，优化了写代码体验与观感，非常便利。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><p><code>String</code>类中的<code>substring</code>方法可以从字符串中提取出一个子串。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.substring(<span class="number">1</span>, <span class="number">3</span>);<span class="comment">//s2 = &quot;el&quot;</span></span><br></pre></td></tr></table></figure><p><code>1</code>处填入的是截取开始的位置，<code>3</code>截取结束的位置。（tips：字符串位置跟数组一样是从0开始的）</p><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p>有截取的方法，那自然有拼接的方法，使用<code>+</code>号就可以拼接起两个字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1+s1;<span class="comment">//s2 = &quot;HelloHello&quot;</span></span><br></pre></td></tr></table></figure><p>当一个字符串与非字符串拼接时，非字符串就会转换成字符串进行拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">233</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1 + i;<span class="comment">//s2 = &quot;Hello233&quot;</span></span><br></pre></td></tr></table></figure><p>这种用法我们就常常用在输出结果。</p><p>当我们希望多个字符串放在一起的时候，我们也可以使用<code>join</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> String.join(s1, <span class="string">&quot; &quot;</span>, s2);<span class="comment">//s3 = &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><p>在Java11以上的版本，还提供了一个重复某个字符串多次的方法<code>repeat</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.repeat(<span class="number">3</span>);<span class="comment">//s2 = &quot;HelloHelloHello&quot;</span></span><br></pre></td></tr></table></figure><h3 id="不可变字符串"><a href="#不可变字符串" class="headerlink" title="不可变字符串"></a>不可变字符串</h3><p>Java的字符串与C语言的字符串不太相同，Java字符串不是一个数组，它的字符串不可以修改里面的某一个字符，想修改字符串，只能通过截取字符串，再重新拼接方式来修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Helle&quot;</span>;</span><br><span class="line">s1 = s1.substring(<span class="number">0</span>, <span class="number">4</span>)+<span class="string">&quot;o!&quot;</span>;<span class="comment">//s1 = &quot;Hello!&quot; </span></span><br></pre></td></tr></table></figure><h3 id="判断字符串是否相等"><a href="#判断字符串是否相等" class="headerlink" title="判断字符串是否相等"></a>判断字符串是否相等</h3><p>虽然字符串不是一个数组，但是我们也不能通过<code>==</code>来判断是否相等，而是应该用<code>equals</code>方法来判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s1.equals(s2);<span class="comment">// false</span></span><br><span class="line">s1.equals(s3);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果我们想让判断不区分大小写，我们还可以用<code>equalsIgnoreCase</code>来判断。</p><p><code>==</code>判断符只能判断两个字符串是否在同一位置（地址）上，而不能真正判断是否相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(str.substring(<span class="number">0</span>, <span class="number">3</span>) == <span class="string">&quot;Hel&quot;</span>)&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;true&quot;</span>);<span class="comment">//</span></span><br><span class="line">&#125;<span class="comment">//none</span></span><br></pre></td></tr></table></figure><h3 id="构建字符串"><a href="#构建字符串" class="headerlink" title="构建字符串"></a>构建字符串</h3><p>如果我们遇到需要经常拼接的情况，例如读取按键的时候，我们采用上面那种字符串拼接方式，就会导致每次都要构建一个新的<code>String</code>对象，既耗时又浪费空间，效率低下，这时候，我们使用<code>StringBuilder</code>类就可以避免这个问题的发生。</p><p>首先我们需要构建一个空的字符串构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><p>然后就可以使用<code>StringBuilder</code>类的方法来构建字符串了，下面给出部分常用的方法：</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>append(String str &#x2F; char c)</td><td>添加一个字符串 &#x2F; 代码单元</td></tr><tr><td>setCharAt(int i, char c)</td><td>讲第 i 个代码单元替换为 c</td></tr><tr><td>insert(int i, String str &#x2F; char c)</td><td>在 i 的位置插入字符串str &#x2F; 代码单元 c</td></tr><tr><td>delete(int i, int j)</td><td>删除 i 到 j 的代码单元</td></tr></tbody></table><p>在构建完字符串之后就可以使用<code>toString</code>返回一个字符串了。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">builder.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">System.out.println(builder.toString());<span class="comment">//out:helloworld</span></span><br></pre></td></tr></table></figure><h2 id="文件的输入输出"><a href="#文件的输入输出" class="headerlink" title="文件的输入输出"></a>文件的输入输出</h2><p>当我们需要读取一个文件，需要构建一个<code>Scanner</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Path.of(<span class="string">&quot;test.txt&quot;</span>), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure><p><code>Path.of(&quot;...&quot;)</code>这里面填入的是文件的位置，当你填入像上面那种相对地址时，该相对地址是相对于Java虚拟机启动目录的位置，实际上我认为还是填入绝对地址比较方便，例如<code>c:\\testPath\\test.txt</code>、<code>/home/icewindy/testPath/test.txt</code>。</p><p><code>StandardCharsets.UTF_8</code>很容易看出，这里填入的是文件的编码格式，如果不指定文件的编码格式，则会使用运行该程序的机器的“默认编码”，或许会导致不同平台上运行效果的差异，不建议这样使用。</p>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（六）：注解</title>
      <link href="/2022/03/24/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/03/24/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解就是带有一定功能的注释。</p><h3 id="内置的注解"><a href="#内置的注解" class="headerlink" title="内置的注解"></a>内置的注解</h3><h4 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h4><p>该注解我们在前面的学习中也见到过多次了，这个注解是声明下面的方法重写了超类中的方法，如果注解下面的方法没有重写超类中的方法，则编译器报错。</p><h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h4><p>这个注解表示该程序元素是不鼓励使用的，因为通常的，它是危险的，或者是已经存在更好的替代方法。该注解会使编译器在出现该程序元素的代码处发出警告。</p><h4 id="SuppressWarnings-“…”"><a href="#SuppressWarnings-“…”" class="headerlink" title="@SuppressWarnings(“…”)"></a>@SuppressWarnings(“…”)</h4><p>镇压警告。</p><p>它与前面两种注解不太相同，这个注解需要一个参数。</p><p><code>SuppressWarnings</code>常用的参数的表格：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>deprecation</td><td>使用了不赞成使用的类或方法时的警告</td></tr><tr><td>unchecked</td><td>执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。</td></tr><tr><td>fallthrough</td><td>当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。</td></tr><tr><td>path</td><td>在类路径、源文件路径等中有不存在的路径时的警告。</td></tr><tr><td>serial</td><td>当在可序列化的类上缺少 serialVersionUID 定义时的警告。</td></tr><tr><td>finally</td><td>任何 finally 子句不能正常完成时的警告。</td></tr><tr><td>all</td><td>关于以上所有情况的警告。</td></tr></tbody></table><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解的作用是负责注解（定义）其他的注解。</p><h4 id="Target-value-x3D-…"><a href="#Target-value-x3D-…" class="headerlink" title="@Target(value &#x3D; …)"></a>@Target(value &#x3D; …)</h4><p>描述注解适用的范围（注解可以用在什么地方）。</p><p><code>...</code>处填入java.lang.annotation.ElementType 枚举类型，ElementType 常用的枚举常量在下表：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>CONSTRUCTOR</td><td>用于构造方法</td></tr><tr><td>FIELD</td><td>用于成员变量（包括枚举常量）</td></tr><tr><td>LOCAL_VARIABLE</td><td>用于局部变量</td></tr><tr><td>METHOD</td><td>用于方法</td></tr><tr><td>PACKAGE</td><td>用于包</td></tr><tr><td>PARAMETER</td><td>用于类型参数（JDK 1.8新增）</td></tr><tr><td>TYPE</td><td>用于类、接口（包括注解类型）或 enum 声明</td></tr></tbody></table><p>例：</p><p>TestAnnotation：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(value = &#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="meta">@TestAnnotation</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Retention-value-x3D-…"><a href="#Retention-value-x3D-…" class="headerlink" title="@Retention(value &#x3D; …)"></a>@Retention(value &#x3D; …)</h4><p>表示需要在什么级别保存该注释信息，用于描述注解的生命周期。</p><p><code>...</code>处填入java.lang.annotation.RetentionPolicy 枚举类型，RetentionPolicy 有 3 个枚举常量，如下所示：</p><p>SOURCE：在源代码时，该注解生效；</p><p>CLASS：在class文件时，该注解仍然生效；</p><p>RUNTIME：在运行的时候，该注解仍然生效；</p><p>生命周期：SOURCE &lt; CLASS &lt; <strong>RUNTIME（常用）</strong>。</p><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>说明该注解将会包含在javadoc中。</p><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>说明子类可以继承父类中的该注解。</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>使用<code>@interface</code>自定义注解时，自动继承了<code>java.lang.annotation</code>接口。</p><p>自定义注解一般以<code>public @interface ...</code>的格式，在类里生命一个注解时候，需去除<code>public</code>。</p><p>在注解内参数只有一个值且值的名字位<code>value</code>的时候，往往可以将<code>value</code>省略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="meta">@MyAnnotation(name = &quot;test&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@MyAnnotation2(&quot;test&quot;)</span><span class="comment">//只有一个参数可以省略value，而且省略只能省略以value命名的参数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><span class="comment">//指定注解的作用目标</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//指定注解的生命周期</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">   <span class="comment">//注解的参数：参数类型+参数名();</span></span><br><span class="line">   String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;<span class="comment">//default表示默认值参数</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;<span class="comment">//如果默认值是-1，则表示不存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><span class="comment">//指定注解的作用目标</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//指定注解的生命周期</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation2 &#123;</span><br><span class="line">   String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（五）：抽象类、接口、内部类</title>
      <link href="/2022/03/23/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2022/03/23/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象（三）"><a href="#面向对象（三）" class="headerlink" title="面向对象（三）"></a>面向对象（三）</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类用<code>abstract</code>进行修饰。</p><p>在前面的学习我们知道，所有的对象都是通过类来描绘的，但是不是所有的类都是用来描述对象的，如果一个类中没有足够的成员来描绘一个具体的对象，那这个类就是抽象类。</p><p>简而言之，抽象类里面可以什么东西都不用去实现，只留有一个大概的框架，作为对后面继承的子类的约束。</p><p>抽象类里面可以有正常的方法，也可以有用<code>abstract</code>修饰的抽象方法，抽象方法也同样是可以不去实现的。</p><p>实际上受限于Java只能单继承，抽象类使用并不如接口常见。</p><p>总结一下，抽象类的特点：</p><ol><li>抽象类无法实例化，也就是无法new出来，它需要靠子类去实现它；</li><li>子类继承抽象类需要实现抽象类内的内容，除非子类也是个抽象类；</li><li>抽象类里可以写普通方法，但是抽象方法必须在抽象类中；静态方法，也就是被<code>static</code>修饰的方法，不能被声明为抽象方法；</li><li>抽象类含有构造器，是为了被子类继承，子类必须调用父类构造器。</li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">      student.run();<span class="comment">//out：I am running.</span></span><br><span class="line">      student.say();<span class="comment">//out：I am studying.</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person（抽象类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;I am running.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student（子类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;I am studying.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口与抽象类比较相似，但它并不是一个类，因此他并不是用<code>class</code>来声明，而是使用<code>interface</code>。抽象类和接口的区别在于，抽象类可以有具体实现和抽象方法，而接口只存在抽象方法。</p><p>接口是对类的实现进行一种约束，也就是一种<code>你是什么就应该做什么</code>的规范，也就是例如，人你就得会吃饭，汽车你就得会跑，但是你怎么吃饭，汽车怎么跑，这是类应该去描绘的内容。接口实现了约束和实现的分离。</p><h4 id="接口的特性"><a href="#接口的特性" class="headerlink" title="接口的特性"></a>接口的特性</h4><ol><li>接口中的方法都是<code>public abstract</code>的，而且只能是<code>public abstract</code>的；</li><li>接口中可以含有变量，但是变量都是<code>public static final</code>的，而且只能是<code>public</code>的；</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的来实现接口的方法。</li></ol><p>类用<code>implements</code>关键词来实现接口。跟抽象类一样，实现了接口的类，就需要重写接口中的方法。与只能继承一个抽象类不同，类可以实现多个接口。</p><p>接口和接口直接也是可以互相继承的，同样也是使用<code>extend</code>来继承。虽然他有继承关系，但是接口里是不存在构造器的。</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>PersonImple：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonImpl</span> <span class="keyword">implements</span> <span class="title class_">Person</span>,Clothes&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">color</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Animal：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Clothes：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Clothes</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">color</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类是在一个类的内部再定义一个类。</p><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>由于该内部类嵌套在外部类内，我们需要先实例化外部类，然后再通过外部类实例化的对象来实例化内部类。</p><p>内部类是可以访问到外部类的私有成员的。</p><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">inner.get();<span class="comment">//out:外部类</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Outer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;外部类&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类可以使用<code>private</code>或<code>protected</code>来修饰，如果你不希望内部类被外部类访问可以使用<code>private </code>修饰符。</p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类可以使用 static 关键字定义，静态内部类就不需要先实例化外部类再实例化内部类了，可以直接实例化内部类。</p><p>如果外部类是非静态的，而内部类是静态的，那么内部类就无法在外部类实例化之前调用外部类的成员了。</p><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br><span class="line">      System.out.println(inner.str2);<span class="comment">//out:内部类</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Outer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;外部类&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;内部类&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类与局部变量一样，不能使用访问控制修饰符和<code>static</code>修饰符，局部内部类仅在当前方法中有效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;&#125;<span class="comment">//内部类</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>这种类我们之前有所使用，我们来举一个例子，应该会很清楚。总所周知接口是不能实例化的，而这个例子却可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">test</span>()&#123;<span class="comment">//实际上这里的效果跟test test = new test()相同</span></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">test</span>&#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（四）：继承、多态</title>
      <link href="/2022/03/17/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/"/>
      <url>/2022/03/17/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象（二）"><a href="#面向对象（二）" class="headerlink" title="面向对象（二）"></a>面向对象（二）</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在前面的学习我们可以知道，类是对某一批对象的抽象，而继承的本质是对某一批类的抽象，类比于现实世界中对动植物进行界门纲目科属种的逐级分类。</p><p>子类（派生类）是父类（基类）的拓展，子类继承父类，我们用<code>extends</code>这个关键词表示继承的关系。（<code>extends v.拓展</code>）子类与父类之间具有一个<code>is</code>的关系，比如学生（子类）是人（父类）。</p><p>子类可以继承父类所有<code>public</code>的属性与方法，而父类<code>private</code>的属性与方法，子类是无法继承的。当我们需要让子类继承父类的属性与方法，且又不被继承关系以外的访问到的时候，我们就需要用到<code>protected</code>关键词，让子类能够继承父类使用<code>protected</code>的属性与方法。</p><p>在Java里，所有的类，都默认直接或者间接继承了<code>Object</code>类。</p><p>注意，在Java里，只有单继承，无多继承，一个子类只能有一个父类。</p><p>tips:在IDEA里，<code>ctrl+h</code>快捷键可以打开继承树，可以很直观看到继承关系。</p><p>例：</p><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">       </span><br><span class="line">      student1.setName(<span class="string">&quot;XiaoMing&quot;</span>);</span><br><span class="line">      student1.setAge(<span class="number">17</span>);</span><br><span class="line">      student1.setID(<span class="number">810</span>);</span><br><span class="line">      student1.setGrade(<span class="number">99</span>);<span class="comment">//无参构造</span></span><br><span class="line">       </span><br><span class="line">      <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;XiaoHong&quot;</span>, <span class="number">16</span>, <span class="number">114</span>, <span class="number">100</span>);<span class="comment">//有参构造</span></span><br><span class="line">      </span><br><span class="line">      System.out.println(student1.getName()+<span class="string">&quot; &quot;</span>+student1.getAge()+<span class="string">&quot; &quot;</span>+student1.getID()+<span class="string">&quot; &quot;</span>+student1.getGrade());<span class="comment">//out:XiaoMing 17 810 99</span></span><br><span class="line">      System.out.println(student2.getName()+<span class="string">&quot; &quot;</span>+student2.getAge()+<span class="string">&quot; &quot;</span>+student2.getID()+<span class="string">&quot; &quot;</span>+student2.getGrade());<span class="comment">//out:XiaoHong 16 114 100</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person:（父类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> String name;</span><br><span class="line">   <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student:（子类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> grade;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> ID;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String aName, <span class="type">int</span> aAge, <span class="type">int</span> aID, <span class="type">int</span> aGrade)</span>&#123;</span><br><span class="line">      name = aName;</span><br><span class="line">      age = aAge;<span class="comment">//子类继承了父类的属性</span></span><br><span class="line">      ID = aID;</span><br><span class="line">      grade = aGrade;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getGrade</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> grade;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGrade</span><span class="params">(<span class="type">int</span> grade)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.grade = grade;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getID</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ID;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setID</span><span class="params">(<span class="type">int</span> ID)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.ID = ID;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p><code>super</code>关键词可以调用父类的属性与方法，用来引用当前对象的父类。</p><p>直接进入例子：</p><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">      <span class="comment">/*out：</span></span><br><span class="line"><span class="comment">      父类无参构造被执行</span></span><br><span class="line"><span class="comment">      子类无参构造被执行</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      student.output();</span><br><span class="line">      <span class="comment">/*out：</span></span><br><span class="line"><span class="comment">      Student</span></span><br><span class="line"><span class="comment">      Student</span></span><br><span class="line"><span class="comment">      Person</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person（父类）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;父类无参构造被执行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student（子类）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//由于子类是不继承父类的构造器，所以这里隐藏着调用父类构造器:super();</span></span><br><span class="line">      <span class="comment">//注意：调用父类构造器时，必须写在子类构造器的第一行</span></span><br><span class="line">      System.out.println(<span class="string">&quot;子类无参构造被执行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span>&#123;</span><br><span class="line">      print();</span><br><span class="line">      <span class="built_in">this</span>.print();</span><br><span class="line">      <span class="built_in">super</span>.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点</strong>：</p><ol><li><code>super</code>只能出现在子类的方法或者构造器中</li><li>当父类没有无参构造时，子类就无法调用父类无参构造，也就是说必须要在子类构造器内写上父类的有参构造。</li></ol><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">super</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>子类可以重写父类的方法。</p><p>方法重写的特点：</p><ol><li>方法名必须相同</li><li>参数列表必须相同（与方法重载不同）</li><li>修饰符：范围可以扩大，不可以缩小。</li></ol><p>tips：在IDEA里，<code>ctrl+inside</code>快捷键可以快速调用方法重写功能。</p><p>不能重写的方法：</p><ol><li>static 方法；</li><li>private 方法；</li><li>final 常量；</li></ol><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">      b.output(); <span class="comment">//out:B-out</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A（父类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;A-out&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B（子类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;<span class="comment">//修饰符范围可以扩大</span></span><br><span class="line">      System.out.println(<span class="string">&quot;B-out&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h4><p>同一个行为具有多个不同表现形式或形态的能力。</p><p>比如在现实世界中，猫和狗（子类）都是动物（父类），他们都会吃（父类继承的方法），但是猫吃鱼，狗吃骨头（方法重写）。</p><h4 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h4><ol><li>继承</li><li>重写</li><li>父类引用指向子类对象<code>Person s2 = new Student();</code></li></ol><p>Demo1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">pet1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">pet2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      pet1.eat();<span class="comment">//Eat:bone</span></span><br><span class="line">      pet2.eat();<span class="comment">//out:Eat fish</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pet（父类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Eat All&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dog（子类1）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Eat bone&quot;</span>);;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cat（子类2）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Eat fish&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态的作用"><a href="#多态的作用" class="headerlink" title="多态的作用"></a>多态的作用</h4><p>提高了代码的拓展性，使用父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用。</p><p>听起来很难理解，我们来看例子就很容易理解这个意思的。</p><p>依然使用上面例子的三个类<code>Pet</code>、<code>Dog</code>、<code>Cat</code>。</p><p>Demo2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">      <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      petEat(dog);<span class="comment">//out:Eat bone</span></span><br><span class="line">      petEat(cat);<span class="comment">//out:Eat fish</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">petEat</span><span class="params">(Pet pet)</span>&#123;</span><br><span class="line">      pet.eat();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态的”局限”"><a href="#多态的”局限”" class="headerlink" title="多态的”局限”"></a>多态的”局限”</h4><p>当某个子类拥有独有的方法的时候，我们多态的写法就无法访问子类独有的方法了。</p><p>我们重写一下<code>Cat</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Eat fish&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playBall</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Cat is playing Ball&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      cat.eat();<span class="comment">//out:Eat fish</span></span><br><span class="line">      cat.playBall();<span class="comment">//error!这个编译是没法通过的</span></span><br><span class="line">      <span class="comment">//Pet类本身是没有playBall()这个方法的，因此是没法通过编译的。</span></span><br><span class="line">      <span class="comment">//在使用多态时，编译看左边，运行看右边。</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><code>instanceof</code>关键词可以用来测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p><p>这种比较需要两边存在关系，否则连编译都没法通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      System.out.println(object <span class="keyword">instanceof</span> Cat);<span class="comment">//out:true</span></span><br><span class="line">      System.out.println(object <span class="keyword">instanceof</span> Pet);<span class="comment">//out:true</span></span><br><span class="line">      System.out.println(object <span class="keyword">instanceof</span> Object);<span class="comment">//out:true</span></span><br><span class="line">      System.out.println(object <span class="keyword">instanceof</span> Dog);<span class="comment">//out:false</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在之前的学习中，我们知道，基本数据类型之间的转换，低转高可以自动转化，高转低需要强制转化，在多态的类型转化也是如此。</p><p>多态本身是子类向父类向上转换（自动转换）的过程，这个过程是默认的，因此上文提到的“局限”就出现了，所以我们需要一种强制转化的方法来是对象可以调用子类独有的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      <span class="comment">//将cat对象转化为Cat类型，就可以使用playBall()这个属于Cat类的方法了。</span></span><br><span class="line">      ((Cat) cat).playBall();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种强制转化的方法，也可以使得子转父，但是在子转父的时候，我们就会损失子类的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（三）：静态方法与非静态方法、参数传递、构造器、封装</title>
      <link href="/2022/03/11/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E3%80%81%E5%B0%81%E8%A3%85/"/>
      <url>/2022/03/11/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E3%80%81%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象（一）"><a href="#面向对象（一）" class="headerlink" title="面向对象（一）"></a>面向对象（一）</h2><p><strong>本质：</strong>以类的方式组织代码，以对象的方式封装数据。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><code>static</code>修饰词所修饰实际上是类的方法或属性，而无<code>static</code>关键词修饰的是在实例化类后，即对象出现后才出现的。</p><h4 id="静态方法-非静态方法"><a href="#静态方法-非静态方法" class="headerlink" title="静态方法   \ 非静态方法"></a>静态方法   \ 非静态方法</h4><p>非静态方法的调用需要先实例化这个类，再进行调用。</p><p>Demo1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Demo2</span> <span class="variable">demo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo2</span>();</span><br><span class="line">demo2.out1();<span class="comment">//非静态方法的调用1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Demo2</span>().out1();<span class="comment">//非静态方法的调用2</span></span><br><span class="line">Demo2.out2();<span class="comment">//这是静态方法的调用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out1</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是非静态方法调用&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">out2</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是静态方法的调用&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>在同一个类中，静态方法不可以直接调用非静态方法，需要先实例化类，非静态方法可以直接互相调用。这是因为静态方法是与类一起加载的，而非静态方法是在类实例化之后才存在的。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>我们先来看一下值传递和引用传递的定义；</p><p><strong>值传递(pass by value)：</strong>在调用函数时，将实际参数复制一份传递到函数中，这样在函数中对参数进行修改，就不会影响到原来的实际参数。</p><p><strong>引用传递(pass by reference)：</strong>在调用函数时，将实际参数的地址直接传递到函数中。这样在函数中对参数进行的修改，就会影响到实际参数。</p><p>在Java中，所有的传递都是值传递。如果参数是基本类型，传递的是基本类型的字面量值的拷贝。如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      System.out.println(a);<span class="comment">//out:1</span></span><br><span class="line">      test.change(a);</span><br><span class="line">      System.out.println(a);<span class="comment">//out:1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">      a = <span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看第二个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      System.out.println(person.name);<span class="comment">//out:null</span></span><br><span class="line">      test.change(person);</span><br><span class="line">      System.out.println(person.name);<span class="comment">//out:IceWindy</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(Person person)</span>&#123;</span><br><span class="line">      person.name = <span class="string">&quot;IceWindy&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>类中的构造器也称为构造方法，是在进行创建对象的时候必须调用的。</p><p>构造器有两个特点：</p><ol><li>必须与类的名字相同。</li><li>必须没有返回值，也不可以写<code>void</code>。</li></ol><p>构造器的作用：</p><ol><li>使用<code>new</code>关键词，实际上是在调用构造器。</li><li>一般用于初始化值。</li></ol><p>tip:在IDEA里使用alt+insert，可以快速生成构造器。</p><p>例子：</p><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">classDemo</span> <span class="variable">demo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">classDemo</span>();<span class="comment">//调用的是无参构造</span></span><br><span class="line">      System.out.println(demo1.str);<span class="comment">//out:null</span></span><br><span class="line">      <span class="type">classDemo</span> <span class="variable">demo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">classDemo</span>(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//调用的是有参构造</span></span><br><span class="line">      System.out.println(demo2.str);<span class="comment">//out:hello world</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">classDemo</span> &#123;</span><br><span class="line">   String str;</span><br><span class="line">   <span class="comment">//无参构造：若无有参构造，无参构造可以隐式</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">classDemo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//有参构造：一旦定义了有参构造，无参构造就必须显示定义</span></span><br><span class="line">   <span class="keyword">public</span>  <span class="title function_">classDemo</span><span class="params">(String aStr)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.str = aStr;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>通常的，我们会让类的内部数据操作细节自己完成，不允许外部干涉，仅留有少量的方法给外部使用。</p><p>这时，我们会使用<code>private</code>关键词对对象的属性进行隐藏，仅留下<code>public</code>关键词的方法可以对属性进行操作和查看。</p><p>封装之后有什么好处呢：</p><ol><li>提高了程序的安全性，保护数据</li><li>隐藏了代码的实现细节</li><li>统一了接口</li><li>增强了可维护性</li></ol><p>例子：</p><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">student</span> <span class="variable">Student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>();</span><br><span class="line">      Student1.setName(<span class="string">&quot;XiaoMing&quot;</span>);</span><br><span class="line">      Student1.setGrade(<span class="number">100</span>);</span><br><span class="line">       </span><br><span class="line">      System.out.println(Student1.getName()+<span class="string">&quot; &quot;</span>+Student1.getGrade());<span class="comment">//out:XiaoMing 100</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>student:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> grade;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getGrade</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> grade;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGrade</span><span class="params">(<span class="type">double</span> grade)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.grade = grade;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（二）：数组、三元运算符</title>
      <link href="/2022/03/09/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2022/03/09/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataType[] array;   <span class="comment">// 首选的方法</span></span><br><span class="line">dataType array[];  <span class="comment">// 效果相同，但不是首选方法</span></span><br></pre></td></tr></table></figure><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array = <span class="keyword">new</span> <span class="title class_">dataType</span>[arraySize];</span><br></pre></td></tr></table></figure><p>创建数组时做了两件事：</p><ol><li>使用<code>dataType[arraySize]</code>创建了一个数组。</li><li>把新创建的数组的引用赋值给变量 <code>array</code>。</li></ol><p>我们也可以讲声明与创建数组合二为一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] array = <span class="keyword">new</span> <span class="title class_">dataType</span>[arraySize];</span><br></pre></td></tr></table></figure><p>还可以使用下面方法来创建数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] array = &#123;value0, value1, ..., valuek&#125;; </span><br></pre></td></tr></table></figure><h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] firstArray = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] secondArray = firstArray;</span><br><span class="line">secondArray[<span class="number">1</span>] = <span class="number">10</span>;<span class="comment">//此时，firstArray[1]的值也变成了10</span></span><br></pre></td></tr></table></figure><p>这种拷贝方式会将两个变量引用到同一个数组。</p><p>如果我们希望的是将一个数组的所有值拷贝到一个新的数组中去，就要使用<code>Arrays</code>类的<code>copy0f</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] secondArray = Arrays.copy0f(firstArray, firstArray.length);</span><br></pre></td></tr></table></figure><p>第二个参数为新数组的长度，我们通常用此方法来增加数组大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] secondArray = Arrays.copy0f(firstArray, <span class="number">2</span> * firstArray.length);</span><br></pre></td></tr></table></figure><p>当新数组长度小于原数组时，则只拷贝前面的值，后面的值会被裁切丢弃。</p><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p><code>Arrays</code>类中给我们提供了一种排序的方法–快速排序<code>QuickSort</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">in</span>[<span class="number">10000</span>];</span><br><span class="line">...</span><br><span class="line">Arrays.sort(a);</span><br></pre></td></tr></table></figure><p>这种排序方法可以满足大部分排序的需求，当然你也可以选择自己写，那就不在本文的范畴之内了。</p><p>另外<code>Arrays</code>类中还提供了别的方法，有兴趣的可以自行查阅。</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>允许调用方法时传入不定长度的参数，实质上是基于数组的实现。</p><p>例：构造输出最大的数字的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoVarargs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoVarargs</span> <span class="variable">demoVarargs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoVarargs</span>();</span><br><span class="line">        demoVarargs.printMax(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMax</span><span class="params">(<span class="type">double</span>... nums)</span>&#123;<span class="comment">//可变参数</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No argument passed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">double</span> x: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; max)&#123;</span><br><span class="line">                max = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;max:&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x?y:z</span><br></pre></td></tr></table></figure><p>当<code>x==true</code>，则结果为<code>y</code>，否则结果为<code>z</code>。</p><p>注意点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o);<span class="comment">//out:1.0</span></span><br></pre></td></tr></table></figure><p>三元运算符运行的左右两边需要是同一类型，于是int的包装类就自动转换为double的包装类。这与<code>if else</code>有所区别，因此我们在使用三元运算符时需要注意。</p>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（一）：进制表示、Equals、For each循环、方法基础</title>
      <link href="/2022/03/07/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E3%80%81Equals%E3%80%81For%20each%E5%BE%AA%E7%8E%AF%E3%80%81%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/07/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E3%80%81Equals%E3%80%81For%20each%E5%BE%AA%E7%8E%AF%E3%80%81%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示"></a>进制表示</h2><p>二进制0b 十进制 八进制0 十六进制0x</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">010</span>;  <span class="comment">//八进制0 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0x10</span>; <span class="comment">//十六进制0x</span></span><br></pre></td></tr></table></figure><p>out:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 3 16</span><br></pre></td></tr></table></figure><h2 id="Equals"><a href="#Equals" class="headerlink" title="Equals"></a>Equals</h2><p><code>.equals</code>方法可以用来判断字符串是否相等。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(str.equals(<span class="string">&quot;Hello&quot;</span>))&#123; <span class="comment">//判断str是否与Hello相等</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="For-each循环"><a href="#For-each循环" class="headerlink" title="For each循环"></a>For each循环</h2><p>for each element in a：循环A中的每一个元素。</p><p>主要用于数组或集合的增强型for循环。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//For each</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x: nums)&#123;<span class="comment">//遍历数组元素</span></span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是用普通的for表示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    System.out.println(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法基础"><a href="#方法基础" class="headerlink" title="方法基础"></a>方法基础</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>Java的方法跟其他语言的函数类似。</p><p>方法的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">...</span><br><span class="line">方法体</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><p><strong>default</strong> (即默认，什么也不写）：在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br><strong>private</strong>：在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong><br><strong>public</strong>：对所有类可见。使用对象：类、接口、变量、方法<br><strong>protected</strong>：对同一包内的类和其所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。实际上<code>protected</code>的成员，有两种可见：</p><ol><li>父类的<code>protected</code>成员是包内可见的，并且对子类可见；</li><li>若子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的<code>protected</code>方法，而不能访问父类实例的<code>protected</code>方法。</li></ol><p>Father:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.base;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Son:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.test;</span><br><span class="line"><span class="keyword">import</span> cn.icewindy.base.Father;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">      father.test();<span class="comment">//Compile Error</span></span><br><span class="line">      test2();<span class="comment">//Compile OK </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">super</span>.test();<span class="comment">//Compile OK ，在override可以调用父类的protected方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h4><p><strong>static</strong>：用来修饰类方法和类变量。详细请看笔记（三）<br><strong>final</strong>：用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。<br><strong>abstract</strong>：用来创建抽象类和抽象方法。<br><strong>synchronized、volatile</strong> ：主要用于线程的编程。</p><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>在同一个类中，有相同的函数名字，但形参不同的函数。</p><p>例：构建一个比较大小的方法<code>max</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(max(<span class="number">10</span>,<span class="number">20</span>));    <span class="comment">//调用的是第一个方法</span></span><br><span class="line">System.out.println(max(<span class="number">10.0</span>,<span class="number">20.0</span>));<span class="comment">//调用的是第二个方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> num1, <span class="type">double</span> num2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法重载的规则：</p><ol><li>方法名称必须相同。</li><li>参数列表必须不同。</li><li>返回值类型可以相同，也可以不同。</li><li>仅仅返回值不同不构成方法的重载。</li></ol><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>Java支持传递同类型的可变参数给一个方法。</p><p>使用方法：</p><p>在方法声明中，在指定参数类型后加一个省略号(…) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数类型... 参数名</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoVarargs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoVarargs</span> <span class="variable">demoVarargs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoVarargs</span>();</span><br><span class="line">        demoVarargs.printMax(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        demoVarargs.printMax(<span class="keyword">new</span> <span class="title class_">double</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMax</span><span class="params">(<span class="type">double</span>... nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No argument passed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">double</span> x: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; max)&#123;</span><br><span class="line">                max = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;max:&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统目录</title>
      <link href="/2022/03/06/Linux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/"/>
      <url>/2022/03/06/Linux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>存放着整个系统必须的二进制文件或可执行文件</p><p>可以随时通过命令行运行这些二进制文件</p><h2 id="sbin"><a href="#sbin" class="headerlink" title="sbin"></a>sbin</h2><p>存放着仅可由root用户运行的系统二进制文件</p><h2 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h2><p>二进制文件的公共库</p><h2 id="usr"><a href="#usr" class="headerlink" title="usr"></a>usr</h2><h3 id="bin-1"><a href="#bin-1" class="headerlink" title="bin"></a>bin</h3><p>usr文件夹下存放的各自的bin和sbin目录，但它并不是操作系统必须的</p><h3 id="local"><a href="#local" class="headerlink" title="local"></a>local</h3><p>存放着手动编译的二进制文件，为一个安全区，与包管理器安装的软件发生冲突</p><h2 id="PATH"><a href="#PATH" class="headerlink" title="$PATH"></a>$PATH</h2><p>$PATH环境变量包含了由包管理器安装的二进制文件的位置</p><h2 id="etc"><a href="#etc" class="headerlink" title="etc"></a>etc</h2><p>配置系统中文件的具体行为，内包含了可编辑文本配置文件</p><h2 id="home"><a href="#home" class="headerlink" title="home"></a>home</h2><p>home目录下可以找到系统内注册的每一个用户的文件，配置和软件</p><h2 id="boot"><a href="#boot" class="headerlink" title="boot"></a>boot</h2><p>包含系统启动所需的文件，如内核等</p><h2 id="dev"><a href="#dev" class="headerlink" title="dev"></a>dev</h2><p>设备文件，管理硬件和驱动程序，可以在此创建硬盘分区</p><h2 id="opt"><a href="#opt" class="headerlink" title="opt"></a>opt</h2><p>包含可选软件和软件包</p><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p>存放着操作系统使用过程中会发生变化的文件</p><h2 id="tmp"><a href="#tmp" class="headerlink" title="tmp"></a>tmp</h2><p>临时文件</p>]]></content>
      
      
      <categories>
          
          <category> Linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC、GDB食用方法</title>
      <link href="/2022/03/06/GCC%E3%80%81GDB%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2022/03/06/GCC%E3%80%81GDB%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -o test test.c</span><br></pre></td></tr></table></figure><p><code>-o</code>自定义目标文件</p><p><code>-Wall</code>自动提示一些出错警告的信息</p><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><p>在GCC编译时需要添加一个参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -ggdb3 -Wall -o test test.c</span><br></pre></td></tr></table></figure><p>如无报错，即可启动GDB：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb test</span><br></pre></td></tr></table></figure><h3 id="GDB指令"><a href="#GDB指令" class="headerlink" title="GDB指令"></a>GDB指令</h3><p><code>break 10</code>在第十行设置断点。</p><p><code>break test</code>在<code>test</code>函数处设置断点</p><p><code>s / step</code>下一步</p><p><code>c / continue</code>当程序在某一断点处停止后，用该指令可以继续执行，直至遇到断点或者程序结束</p><p><code>u / until</code> 运行程序直到退出循环体</p><p><code>r / run</code>运行</p><p><code>q / quit</code>结束调试</p><p><code>p / print</code>显示某个变量的值</p><p><code>p *array@len</code> 输出数组</p><p><code>enable</code> 恢复失效的断点</p><p><code>disable </code>使断点失效</p><p><code>clear</code> 清除断点</p><p><code>bt / backtrace </code>查看堆栈信息</p><p><code>watch</code>监测某变量或表达式，当发生变化时停止</p>]]></content>
      
      
      <categories>
          
          <category> 新技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora借助Gitee+PicGo-Core实现云图床</title>
      <link href="/2022/03/06/Typora-Gitee-PicgoCore%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/06/Typora-Gitee-PicgoCore%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="云图床搭建"><a href="#云图床搭建" class="headerlink" title="云图床搭建"></a>云图床搭建</h2><p>2022.3.25更新：gitee搭的图床疑似寄了。已经改用阿里云oss。</p><p>这次我们选择的云图床的搭建是基于gitee。gitee服务器位于国内，避免了github被墙的等一系列问题。</p><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>（省略gitee账号创建的过程，如果这都不会，建议不要折腾了）我们看到gitee页面右上角那个加号，然后点击新建仓库。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112213354.png" alt="image-20220112213353460"></p><p>然后输入你自己想要的仓库名称，路径会自动生成跟你仓库名称一样的名称，当然你也可以自己自定义路径名称。</p><p>勾选上开源和设置模板、Readme文件，省去后面初始化的步骤，即可创建好你的仓库。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112213557.png" alt="image-20220112213556929"></p><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>点击你的头像，进入设置。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112214030.png" alt="image-20220112214029486"></p><p>看到安全设置&#x2F;私人密钥。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112214120.png" alt="image-20220112214119534"></p><p>点击“生成新令牌”</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112214157.png" alt="image-20220112214157037"></p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112214214.png" alt="image-20220112214213174"></p><p>填上上描述，勾选上“projects”，生成一串密钥。</p><p><strong>注意：该密钥只会显示一次，注意好保存！！！</strong></p><h2 id="PicGO-Core配置"><a href="#PicGO-Core配置" class="headerlink" title="PicGO-Core配置"></a>PicGO-Core配置</h2><p>接下来我们就来配置PicGo-Core，至于为什么使用Core这种命令行版本，而不使用app这种带ui，是因为我不想在后台开多一个软件。</p><h3 id="配置Typora"><a href="#配置Typora" class="headerlink" title="配置Typora"></a>配置Typora</h3><p>点击“文件” “偏好设置” “图像”。</p><p>将“插入图片时候…”修改为“上传图片”，接着将上传服务修改为”PicGO-Core (command line)”，然后点击下载或更新，等他进度条走完。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112214915.png" alt="image-20220112214914458"></p><p>接着点击验证图片上传选项，出现下面窗口。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112215312.png" alt="image-20220112215311393"></p><p>复制前面一长串类似于“ C:\Users\IceWindy\AppData\Roaming\Typora\picgo\win64\picgo.exe”。</p><h3 id="PicGo-Core插件安装与配置"><a href="#PicGo-Core插件安装与配置" class="headerlink" title="PicGo-Core插件安装与配置"></a>PicGo-Core插件安装与配置</h3><p>打开你的命令行（cmd)，运行如下命令：<strong>（注意：需要安装Node.js！）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Users\IceWindy\AppData\Roaming\Typora\picgo\win64\picgo.exe</span><br><span class="line">.\picgo.exe install gitee-uploader</span><br><span class="line">.\picgo.exe install super-prefix </span><br></pre></td></tr></table></figure><p>在Typora图像设置中，点击打开配置文件，我们就打开了一个json格式的文件，按照我下面的样式填写</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gitee&quot;</span><span class="punctuation">,</span><span class="comment">//当前上传的图床</span></span><br><span class="line">    <span class="attr">&quot;gitee&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icewindy/note-img&quot;</span><span class="punctuation">,</span><span class="comment">//仓库位置</span></span><br><span class="line">      <span class="attr">&quot;branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;master&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">//我们上文提到的生成的gitee密钥</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;note&quot;</span><span class="punctuation">,</span><span class="comment">//上传到你的仓库的文件夹</span></span><br><span class="line">      <span class="attr">&quot;customPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span><span class="comment">//默认即可</span></span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="comment">//插件的启用</span></span><br><span class="line">  <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fileFormat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YYYYMMDDHHmmss&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="comment">//这段是配置时间戳插件的</span></span><br><span class="line">  <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;lastSync&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2022-01-12 10:05:31&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>仓库的位置可以打开你仓库的链接，“icewindy&#x2F;note-img”这地方就是你的仓库位置。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112220530.png" alt="20220112220530"></p><h2 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h2><p>还是打开Typora的图像设置，点击验证图片上传选项，如图即成功。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112222001.png" alt="image-20220112222000592"></p>]]></content>
      
      
      <categories>
          
          <category> 新技能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习笔记（一）：隐性转换、值与引用、for-in与for-of、数组</title>
      <link href="/2022/01/12/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%9A%90%E6%80%A7%E8%BD%AC%E6%8D%A2%E3%80%81%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E3%80%81for-in%E4%B8%8Efor-of%E3%80%81%E6%95%B0%E7%BB%84/"/>
      <url>/2022/01/12/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%9A%90%E6%80%A7%E8%BD%AC%E6%8D%A2%E3%80%81%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E3%80%81for-in%E4%B8%8Efor-of%E3%80%81%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="隐性转换"><a href="#隐性转换" class="headerlink" title="隐性转换"></a>隐性转换</h2><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li><p><code>NaN != NaN</code></p></li><li><p><code>boolean</code>值在比较时会变为<code>number</code></p></li><li><p><code>string</code>和<code>number</code>比较时会变为<code>number</code></p></li><li><p><code>null == undefined</code>，其余任何值与<code>null</code>&#x2F;<code>undefined</code>比较都为<code>false</code></p></li><li><p>原始类型与引用类型比较，会调用<code>toPrimitive</code>方法，具体做法就是先<code>valueOf</code>后<code>toString</code></p></li><li><p>我们在对各种非<code>Number</code>类型运用数学运算符(<code>- * /</code>)时，会先将非<code>Number</code>类型转换为<code>Number</code>类型</p></li><li><p>加法特殊：</p><p>当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</p><p>当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</p><p>当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</p><p><strong>该三点由上到下，优先级从高到低</strong></p></li><li></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123;&#125; + &#123;&#125;</span><br><span class="line"><span class="title class_">NaN</span></span><br></pre></td></tr></table></figure><p>这个问题的原因是，JavaScript 把第一个 <code>&#123;&#125; </code>解释成了一个空的代码块（code block）并忽略了它。<code>NaN</code>其实是表达式<code>+&#123;&#125;</code>计算的结果 (+ 加号以及第二个 {})。 你在这里看到的 <code>+ </code>加号并不是二元运算符「加法」，而是一个一元运算符，作用是将它后面的操作数转换成数字，和 <code>Number() </code>函数完全一样。</p><ol start="9"><li>转换表：</li></ol><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112212233.png" alt="20220112212233"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>1. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1, 2, 3&#x27;</span> == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>   <strong>true</strong></p><p>2. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>   <strong>false</strong></p><p>3. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> == [<span class="string">&#x27;1&#x27;</span>]</span><br></pre></td></tr></table></figure><p>   <strong>true</strong></p><p>4. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>   <strong>false</strong></p><p>5. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>   <strong>true</strong></p><h2 id="值与引用"><a href="#值与引用" class="headerlink" title="值与引用"></a>值与引用</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ol><li>值类型</li></ol><p>​        数字，字符串，布尔，符号，未定义，空</p><ol start="2"><li>引用类型</li></ol><p>​        对象，函数，数组</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">value</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line">x.<span class="property">value</span> = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>控制台中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x</span><br><span class="line">&gt;&#123;<span class="attr">value</span>:<span class="number">20</span>&#125;</span><br><span class="line">y</span><br><span class="line">&gt;&#123;<span class="attr">value</span>:<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><p>对象不是存储在变量中，而是存储在内存中，变量保存的是对象的内存地址，因此y在复制x的时候，是复制x的内存地址，即x，y都指向同一内存地址，无论通过x还是y去修改这个对象的时候，修改的变化另外一个对象也能看到。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>值类型数据复制值</p><p>引用类型数据或对象复制引用（内存地址）</p><h2 id="for-in与for-of"><a href="#for-in与for-of" class="headerlink" title="for-in与for-of"></a>for-in与for-of</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> object)</span><br></pre></td></tr></table></figure><p>可以循环对象中的每一个成员，可以遍历一个数组，但最好使用<code>for-of</code>。</p><p><code>in</code>可以检查对象中是否包含给定的值</p><h3 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h3><p>从ES6开始，更好遍历数组的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> array)</span><br></pre></td></tr></table></figure><p>在<code>for-of</code>中<code>key</code>直接表示为数组内的一个元素。</p><p>该方法仅可用于可枚举的类型（数组和映射）。</p><h3 id="可用于for-of-的Object方法"><a href="#可用于for-of-的Object方法" class="headerlink" title="可用于for-of 的Object方法"></a>可用于for-of 的Object方法</h3><p><code>Object.key()</code>方法可获得输入对象的所有成员的键，并返回一个数组。</p><p><code>Object.entries()</code>方法可获得输入对象的所有成员的键值对，并返回一个数组。</p><h2 id="克隆一个Object的方法"><a href="#克隆一个Object的方法" class="headerlink" title="克隆一个Object的方法"></a>克隆一个Object的方法</h2><ol><li><pre><code class="javascript">const newObject = Object.assign(&#123;&#125;, oldObject);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   `&#123;&#125;`内不一定要为空，也可以为一个键值对，相当于是在`newObject`里新增一个键值对，然后再将`oldObject`中的成员克隆过来。</span><br><span class="line"></span><br><span class="line">2. 拆分操作符法</span><br><span class="line"></span><br><span class="line">   ```javascript</span><br><span class="line">   const newObject = &#123; ...oldObject &#125;;</span><br></pre></td></tr></table></figure>最简单的方法，该方法相当于是将使用`...`拆分操作符将`oldObject`内的成员读取并拆解出填入`&#123; &#125;`中。</code></pre></li><li><p>for-in法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObject = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> oldObject)</span><br><span class="line">    newObject[key] = oldObject[key];</span><br></pre></td></tr></table></figure><p>最朴素的方法。</p></li></ol><h2 id="JavaScript部分内置对象"><a href="#JavaScript部分内置对象" class="headerlink" title="JavaScript部分内置对象"></a>JavaScript部分内置对象</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p><code>Math</code>参考文档</p><p>[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math]">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math]</a>: </p><p><code>Math</code> 是一个内置对象，它拥有一些数学常数属性和数学函数方法。</p><p>注意:<code>Math</code>并不是一个函数对象</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>JavaScript中<code>string</code>分为两种，一种是值类型字符串，另外一种是<code>String</code>对象 。但在对值类型的字符串使用点操作符时,JavaScript会自动将值转换为对象，可以像操作对象一样操作它。</p><p><code>String</code>参考文档</p><p>[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String]">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String]</a>: </p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><h4 id="In-End"><a href="#In-End" class="headerlink" title="In End"></a>In End</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="title function_">push</span>(anyThings);</span><br></pre></td></tr></table></figure><p><code>anyThings</code>可填入任意元素（不止一个元素）。</p><h4 id="In-Beginning"><a href="#In-Beginning" class="headerlink" title="In Beginning"></a>In Beginning</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="title function_">unshift</span>(anyThings);</span><br></pre></td></tr></table></figure><p><code>anyThings</code>可填入任意元素（不止一个元素）。</p><h4 id="In-Middle"><a href="#In-Middle" class="headerlink" title="In Middle"></a>In Middle</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="title function_">splice</span>(startNumber, deleteCount, anyThings);</span><br></pre></td></tr></table></figure><p><code>startNumber</code>元素的位置。注意：数组从0开始计数。</p><p><code>deleteCount</code>想要删除的元素的个数。</p><p><code>anyThings</code>可填入任意元素（不止一个元素）。</p><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><h4 id="indexOF（查找值）"><a href="#indexOF（查找值）" class="headerlink" title="indexOF（查找值）"></a>indexOF（查找值）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="title function_">indexOF</span>(anyThings, startNumber);</span><br></pre></td></tr></table></figure><p>查找<code>numbers</code>内从<code>startNumber</code>开始（可选）是否存在<code>anyThings</code>元素，如果存在则返回所在位置，如果不存在则返回<code>-1</code>。</p><p>注意：该方法是严格对应类型的，字符类型的<code>&#39;1&#39;</code>与数字类型的<code>1</code>是不同的。</p><p>类似的方法<code>lastIndexOF</code>，返回最后一个匹配的元素。</p><p><code>includes</code>方法可以判断是否存在匹配元素，返回<code>true</code> or  <code>false</code></p><p>以上方法均可以加入第二参数<code>startNumber</code>设定开始查找的位置。</p><h2 id="一些实用技巧补充"><a href="#一些实用技巧补充" class="headerlink" title="一些实用技巧补充"></a>一些实用技巧补充</h2><ol><li><code>$&#123;&#125;</code>占位符用于一对反引号的模板语句中显示表达式或者变量。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Web三板斧 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
