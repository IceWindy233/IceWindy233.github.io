<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web开发基础（3）：CSS文本、链接、表格、伪类选择器</title>
      <link href="/2022/11/09/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%EF%BC%9ACSS%E6%96%87%E6%9C%AC%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E8%A1%A8%E6%A0%BC%E3%80%81%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2022/11/09/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%EF%BC%9ACSS%E6%96%87%E6%9C%AC%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E8%A1%A8%E6%A0%BC%E3%80%81%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="文本-text"><a href="#文本-text" class="headerlink" title="文本 text"></a>文本 text</h2><h3 id="颜色-color"><a href="#颜色-color" class="headerlink" title="颜色 color"></a>颜色 color</h3><p>color是一个非常常用的css指定，在body选择器中指定的color，将会成为页面默认的文本颜色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">color</span>:<span class="number">#00ff00</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.ex</span> &#123;<span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>);&#125;</span><br></pre></td></tr></table></figure><h3 id="对齐方式-text-align"><a href="#对齐方式-text-align" class="headerlink" title="对齐方式 text-align"></a>对齐方式 text-align</h3><p>该属性可以设定文本的水平对齐方式。</p><p>文本可以<strong>居中center</strong>、<strong>对齐到左left</strong>或<strong>右right</strong>、<strong>两端对齐justify</strong></p><p>两端对齐就是每一行都展开为宽度相等，左右边距都是对齐（如杂志和报纸）</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211092226128.png" alt="image-20221109222638064"></p><h3 id="文本修饰-text-decoration"><a href="#文本修饰-text-decoration" class="headerlink" title="文本修饰 text-decoration"></a>文本修饰 text-decoration</h3><p>该属性用于设置文本的<strong>上划线（overline）</strong>、<strong>下划线（underline）</strong>、<strong>划去（line-through）</strong>以及<strong>删除链接的下划线（none）</strong>等修饰</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211092252640.png" alt="image-20221109225246612"></p><h3 id="文本转换-text-transform"><a href="#文本转换-text-transform" class="headerlink" title="文本转换 text-transform"></a>文本转换 text-transform</h3><p>该属性用于设置一个文本的大写或者小写字母</p><p>可用于所有字句变成<strong>大写（uppercase）</strong>或<strong>小写（lowercase）</strong>字母，或<strong>每个单词的首字母大写（capitalize）</strong>。</p><h3 id="文本缩进-text-indent"><a href="#文本缩进-text-indent" class="headerlink" title="文本缩进 text-indent"></a>文本缩进 text-indent</h3><p>该属性可以指定文本第一行缩进的大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">text-indent</span>:<span class="number">50px</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接有四个状态</p><ul><li>a:link - 一般情况，未访问过的链接</li><li>a:visited - 用户已经访问过的链接</li><li>a:hover - 用户的光标悬停在链接上时</li><li>a:active - 被点击的那一刻</li></ul><p>这四个状态都可以单独设定样式，状态的样式设置有一定的顺序规矩：</p><ul><li>a:hover 必须跟在 a:link 和 a:visited后面</li><li>a:active 必须跟在 a:hover后面</li></ul><p>常见的样式设置有<strong>文本修饰（text-decoration）</strong>、<strong>背景颜色（background-color）</strong>、<strong>字体大小（font-size）</strong>等等，基本上文本修饰可以使用的，在链接上都可以使用。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h3 id="边框-border"><a href="#边框-border" class="headerlink" title="边框 border"></a>边框 border</h3><p>该属性可以设置边框的相关属性，<strong>厚度</strong>、<strong>边框样式（连续、分段等）</strong>、<strong>颜色</strong>等</p><p>他们可以写在同一个定义中，以空格分开，也可以分开几个定义</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span>;</span><br><span class="line"><span class="attribute">border</span>: solid;</span><br><span class="line"><span class="attribute">border</span>: black;</span><br></pre></td></tr></table></figure><p>值的顺序无关紧要</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211100116142.png" alt="image-20221110011604103"></p><h3 id="单个边框-border-collapse"><a href="#单个边框-border-collapse" class="headerlink" title="单个边框 border-collapse"></a>单个边框 border-collapse</h3><p>该属性可以将默认两个边框的折叠成一个边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">border-collapse</span>:collapse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span>,<span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211100115969.png" alt="image-20221110011549930"></p><h3 id="宽度和高度-width、height"><a href="#宽度和高度-width、height" class="headerlink" title="宽度和高度 width、height"></a>宽度和高度 width、height</h3><p>该属性值与文字值类似，可以用百分数或者是像素等等来表示宽度或者高度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">th</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文字对齐-text-align、vertical-alig"><a href="#文字对齐-text-align、vertical-alig" class="headerlink" title="文字对齐 text-align、vertical-alig"></a>文字对齐 text-align、vertical-alig</h3><p>该属性用于设置表格中的文本对齐与垂直属性</p><p>水平对齐属性 <code>text-align</code>可以设置<strong>居中center</strong>、<strong>对齐到左left</strong>或<strong>右right</strong></p><p>垂直对齐属性<code>vertical-alig</code>设置垂直对齐，比如<strong>顶部top</strong>，<strong>底部bottom</strong>或<strong>中间middle</strong></p><h3 id="表格单元格大小-padding"><a href="#表格单元格大小-padding" class="headerlink" title="表格单元格大小 padding"></a>表格单元格大小 padding</h3><p>该属性用于控制单元格大小</p><p>padding可以接受1-4个值：</p><ul><li>当只指定<strong>一个</strong>值时，该值会统一应用到<strong>全部四个边</strong>的内边距上。</li><li>指定<strong>两个</strong>值时，第一个值会应用于<strong>上边和下边</strong>的内边距，第二个值应用于<strong>左边和右边</strong>。</li><li>指定<strong>三个</strong>值时，第一个值应用于<strong>上边</strong>，第二个值应用于<strong>右边和左边</strong>，第三个则应用于<strong>下边</strong>的内边距。</li><li>指定<strong>四个</strong>值时，依次（顺时针方向）作为<strong>上边</strong>，<strong>右边</strong>，<strong>下边</strong>，和<strong>左边</strong>的内边距。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 应用于所有边 */</span></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上边下边 | 左边右边 */</span></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">5%</span> <span class="number">10%</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上边 | 左边右边 | 下边 */</span></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">1em</span> <span class="number">2em</span> <span class="number">2em</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上边 | 右边 | 下边 | 左边 */</span></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">1em</span> <span class="number">0</span> <span class="number">2em</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局值 */</span></span><br><span class="line"><span class="attribute">padding</span>: inherit;</span><br><span class="line"><span class="attribute">padding</span>: initial;</span><br><span class="line"><span class="attribute">padding</span>: unset;</span><br></pre></td></tr></table></figure><h3 id="颜色-background-color、color"><a href="#颜色-background-color、color" class="headerlink" title="颜色 background-color、color"></a>颜色 background-color、color</h3><p><code>background-color</code>用于设定表格的背景颜色</p><p><code>color</code>用于设定表格内的文本颜色</p><p>下面例子分别设定了</p><ul><li>表格的间距、样式、颜色</li><li>表头的背景颜色和文本颜色</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span>, <span class="selector-tag">td</span>, <span class="selector-tag">th</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">th</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:green;</span><br><span class="line">    <span class="attribute">color</span>:white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202211112127271.png" alt="image-20221111212727215"></p><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>伪类：专门用来表现元素的一种特殊状态</p><p>实际上，我们在上面就有一种伪类选择器，即链接的四种状态</p><p>常用的伪类选择器</p><ul><li><p>超链接伪类 <code>&lt;a&gt;</code></p><p><code>a:visited</code>已被访问</p><p><code>a:link</code>未访问</p><p><code>a:hover</code>悬停</p><p><code>a:active</code>点击瞬间</p></li><li><p>表单 </p><p><code>:focus</code>获得焦点</p></li><li><p>:first-child</p><p>选择元素的第一个子元素，如列表第一个元素</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php笔记（1）</title>
      <link href="/2022/10/27/php%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
      <url>/2022/10/27/php%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>此笔记为本人随手记，无任意顺序。</p><h2 id="包含文件include-x2F-require"><a href="#包含文件include-x2F-require" class="headerlink" title="包含文件include&#x2F;require"></a>包含文件include&#x2F;require</h2><p>该关键词作用是可以在执行PHP文件之前导入一个文件的内容，与C语言中include类似。include与require都是用于执行流中插入位于其他文件中的代码。</p><p><strong>include 和 require 除了包含不到文件时处理错误的方式不同之外，在其他方面都是相同的：</strong></p><ul><li>require 会生成一个致命错误，在错误发生后脚本会停止执行；</li><li>include 会生成一个警告，在错误发生后脚本会继续执行。</li></ul><p>一般来说，include和require使用的位置有所区别：</p><ul><li>require 一般放在 PHP 文件的最前面，程序在执行前就会先导入要引用的文件；</li><li>include 一般放在程序的流程控制中，当程序执行时碰到才会引用，简化程序的执行流程。</li></ul><p>使用方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">&#x27;filename&#x27;</span>;</span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;filename&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="include与include-once"><a href="#include与include-once" class="headerlink" title="include与include_once"></a>include与include_once</h3><p>include在遇见多次时会重复加载，include_once即使遇见多次也仅会加载一次。</p><p>有时候如果导入的代码中包含了定义常量等操作时，重复加载会导致报错或导致执行结果与预期不符，这时候就会需要用到include_once保证仅加载一次。</p><h2 id="流程控制替代语法"><a href="#流程控制替代语法" class="headerlink" title="流程控制替代语法"></a>流程控制替代语法</h2><p>php本身是嵌入HTML的脚本语言，在需要在HTML中书写一些关于判断或者循环的结构语法，如果使用原始的PHP代码会使得代码变得难以辨别。</p><p>例子：打印一个九九乘法表格，使用HTML表格进行展示</p><p>传统方法下，我们需要非常臃肿的写法：</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210272153230.png" alt="image-20221027215325182" style="zoom: 50%;" /><p>在PHP书写到HTML中的这些大括号非常不美观，所以提供了一共替代机制，可以不写大括号：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for(;;)&#123; --&gt; for(;;):</span></span><br><span class="line"><span class="comment">// &#125;        --&gt; endfor;</span></span><br></pre></td></tr></table></figure><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210291204629.png" alt="image-20221029120414575"></p><p>PHP也提供了分支结构的替代语法，都使用了同样的模式：</p><p><strong>左大括号<code>&#123;</code>使用冒号替代</strong></p><p><strong>右大括号<code>&#125;</code>使用<code>end+对应标记</code>替代</strong></p><p>对应标记包括：switch, if, for, while, foreach</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>我们可以通过变量名去保存一个匿名函数，并且通过<code>$变量名()</code>的方式去调用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$变量名 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;;</span><br><span class="line">$变量名(); <span class="comment">//调用</span></span><br></pre></td></tr></table></figure><p>变量名保存匿名函数，本质上得到的是一个<code>Closure</code>对象，即闭包。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包：closure，一词来源于两者的结合：</p><ul><li>要执行的代码块</li><li>为自由变量提供绑定的计算环境（作用域）</li></ul><p>简单理解：函数内部有一些局部变量（要执行的代码块）在函数执行之后没有释放，是因为在函数内部还有对应的函数在引用（函数的内部函数：匿名函数）</p><p>举个例子</p><p>这是无闭包的情况：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//定义变量：局部变量</span></span><br><span class="line">    <span class="variable">$name</span> = <span class="keyword">__FUNCTION__</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">display</span>();</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210300013109.png" alt="image-20221030001342086"></p><p>由于局部变量在函数运行完后就销毁了，因此页面没有显示。</p><p>这是闭包的情况：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//定义变量：局部变量</span></span><br><span class="line">    <span class="variable">$name</span> = <span class="keyword">__FUNCTION__</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义匿名函数</span></span><br><span class="line">    <span class="comment">//use就是将外部变量（局部）保留给内部使用</span></span><br><span class="line">    <span class="comment">//在这里就形成了闭包</span></span><br><span class="line">    <span class="variable">$innerFunction</span> = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) <span class="keyword">use</span> (<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//函数内部的函数</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$name</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用函数</span></span><br><span class="line">    <span class="variable">$innerFunction</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">display</span>();</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210300012458.png" alt="image-20221030001253423"></p><p>由于形成了闭包，局部变量在函数内部得以保留，因此页面会显示出变量名字</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>错误处理：指的是系统（或用户）在对某些代码进行执行的时候，出现了错误，就会通过错误处理的</p><h3 id="错误代号"><a href="#错误代号" class="headerlink" title="错误代号"></a>错误代号</h3><p>所有的错误代码在php中都被定义成系统常量（可以直接访问与使用）</p><ol><li>系统错误<ul><li>E_PARSE：编译代码，代码不会执行</li><li>E_ERROR：致命错误，会中止代码执行</li><li>E_WARNING：警告错误，不会影响代码执行，但是执行结果有误</li><li>E_NOTICE：通知错误，不会影响代码错误</li><li>…</li></ul></li><li>用户错误：用户在使用自定义错误触发的时候，使用到的错误代号<ul><li>E_USER_ERROR</li><li>E_USER_WARING</li><li>E_USER_NOTICE</li><li>…</li></ul></li><li>其他<ul><li>E_ALL：代表所有的错误，通常在进行错误控制的时候使用，建议在开发过程中使用</li><li>…</li></ul></li></ol><p>所有以E开头的错误常量（代号）都是由一个字节存取的，然后一种错误占据一个对应的位，如果像进行一些错误的控制，可以使用位运算进行操作，例如：排除通知级别 E_ALL &amp; ~E_NOTICE、只要警告和通知 E_WARNING | E_NOTICE</p><h3 id="错误触发"><a href="#错误触发" class="headerlink" title="错误触发"></a>错误触发</h3><p>运行时触发：系统自动根据错误发生后，对比对应的错误信息，输出给用户。主要是针对代码的语法错误和运行时错误</p><p>人为触发：知道某些逻辑可能会出错，从而使用对应判断代码进行应对触发响应</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发基础（2）：CSS选择器、字体、背景</title>
      <link href="/2022/10/20/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%EF%BC%9ACSS%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%81%E5%AD%97%E4%BD%93%E3%80%81%E8%83%8C%E6%99%AF/"/>
      <url>/2022/10/20/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%EF%BC%9ACSS%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%81%E5%AD%97%E4%BD%93%E3%80%81%E8%83%8C%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS简介"><a href="#CSS简介" class="headerlink" title="CSS简介"></a>CSS简介</h2><p>CSS (Cascading Style Sheets，层叠样式表），是一种用来为<strong>结构化文档</strong>（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言</p><h2 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h2><p>CSS主要由两个主要部分组成：选择器与一条或多条声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123;属性:值;...&#125;</span><br></pre></td></tr></table></figure><p>选择器是需要更改样式的HTML元素</p><p>每条声明由一个属性和一个值组成</p><p>属性是需要设置的样式属性，属性与值间用冒号隔开</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>如果需要在HTML元素中设置CSS样式，我们需要在元素中设置<code>id</code>和<code>class</code>选择器</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;text1&quot;</span>&gt;</span>text1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text2&quot;</span>&gt;</span>text2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>id选择器可以为标有特定id的HTML代码指定特定的样式</p><p>在CSS中id选择器以<code>#</code>就开头来定义</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#text1</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器"></a>class选择器</h3><p>class选择器可以用于描述一组元素的样式，class与id选择器不同处在于class选择器可以在多个元素中使用</p><p>在CSS中id选择器以<code>.</code>开头为定义，以下例子为应用在所有<code>text2</code>类的HTML元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text2</span> &#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以指定某个元素使用class选择器，以下实例中即让p元素使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.text2</span> &#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><p>通配符选择器可以选取页面中所有的元素（标签）</p><p>在CSS中，它使用<code>*</code>来定义</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通配符选择器不需要调用，会自动给所有元素使用样式</p><p>一般而言只有在特殊情况下才会使用，例如清楚所有的元素标签的内外边距</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS使用"><a href="#CSS使用" class="headerlink" title="CSS使用"></a>CSS使用</h2><p>插入CSS的方法有三种</p><ul><li>外部样式表</li><li>内部样式表</li><li>内联样式</li></ul><h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><p>如果样式表需要应用在多个页面的时候，外部样式表就是最理想的选择</p><p>通过在HTML文档头部使用<code>&lt;link&gt;</code>标签可以连接到样式表文件<code>xxx.css</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器在渲染输出的时候会将<code>style.css</code>文件读取并格式化文档</p><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>当某个文档需要特殊样式时，就可以用到内部样式表</p><p>通过在HTML文档头部使用<code>&lt;style&gt;</code>标签在文档头部可以定义内部样式表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>:<span class="number">20px</span>;&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><p>内联样式这种方法，一般会用仅需要在一个元素上应用一次的情况。由于内联样式要将央视哦与内容混在一起，会丢失样式表本有的优势，所以这种方式需要慎用</p><p>通过在标签内使用<code>style</code>属性，可以在标签中使用CSS样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:red;margin-left:20px&quot;</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多重样式"><a href="#多重样式" class="headerlink" title="多重样式"></a>多重样式</h3><p>如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。 </p><p>一般情况下，多重样式的优先级为</p><p>内联样式 &gt; 内部样式表 &gt; 外部样式表 &gt; 浏览器默认样式</p><p>外部样式表</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">8pt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部样式表</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:right</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">20pt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>h3最终得到的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"><span class="attribute">text-align</span><span class="selector-pseudo">:right</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">20pt</span>;</span><br></pre></td></tr></table></figure><h2 id="字体-Font"><a href="#字体-Font" class="headerlink" title="字体 Font"></a>字体 Font</h2><h3 id="字体系列-font-family"><a href="#字体系列-font-family" class="headerlink" title="字体系列 font-family"></a>字体系列 font-family</h3><p>font-family 属性设置文本的字体，例如设置为宋体、黑体等</p><p>如果字体系列的名称超过一个字或者一个单词，它必须用引号，如Font Family：”宋体”。</p><p>font-family 属性应该设置几个字体名称作为一种”后备”机制，如果浏览器不支持第一种字体，他将尝试下一种字体。<a href="https://www.runoob.com/cssref/css-websafe-fonts.html">CSS Web安全字体 | 菜鸟教程 (runoob.com)</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-family</span>:<span class="string">&quot;Times New Roman&quot;</span>, Times, serif&#125;</span><br></pre></td></tr></table></figure><h3 id="字体样式-font-style"><a href="#字体样式-font-style" class="headerlink" title="字体样式 font-style"></a>字体样式 font-style</h3><p>该属性用于指定斜体文字的样式属性</p><p>这个属性有三个值：</p><ul><li>normal - 正常</li><li>italic - 以斜体字显示的文字</li><li>oblique - 文字向一边倾斜（与斜体非常类似）</li></ul><p>因为不是所有的字体都有斜体，italic 是使用文字的斜体，oblique 是让没有斜体属性的文字倾斜</p><p>oblique是可以设定字体倾斜的角度<code>font-style: oblique 40deg;</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.normal</span> &#123;<span class="attribute">font-style</span>:normal;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.italic</span> &#123;<span class="attribute">font-style</span>:italic;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.oblique</span> &#123;<span class="attribute">font-style</span>:oblique;&#125;</span><br></pre></td></tr></table></figure><h3 id="字体大小-font-size"><a href="#字体大小-font-size" class="headerlink" title="字体大小 font-size"></a>字体大小 font-size</h3><p>该属性用于设置文本的大小，合理管理文字的大小，在网页设计中是非常重要的</p><p>字体大小的值可以是相对大小或绝对大小，也可以是个固定的值，还可以是个基于父元素的百分比值</p><p>相对大小</p><ul><li>相对于周围的元素来设置大小</li><li>允许用户在浏览器种改变文字大小</li></ul><p>绝对大小</p><ul><li>设定一个指定大小的文本</li><li>不允许用户在浏览器中改变文本大小</li><li>确定了输出的物理尺寸时绝对大小很有用</li></ul><h4 id="绝对大小"><a href="#绝对大小" class="headerlink" title="绝对大小"></a>绝对大小</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font-size</span>: xx-small;</span><br><span class="line"><span class="attribute">font-size</span>: x-small;</span><br><span class="line"><span class="attribute">font-size</span>: small;</span><br><span class="line"><span class="attribute">font-size</span>: medium;</span><br><span class="line"><span class="attribute">font-size</span>: large;</span><br><span class="line"><span class="attribute">font-size</span>: x-large;</span><br><span class="line"><span class="attribute">font-size</span>: xx-large;</span><br></pre></td></tr></table></figure><h4 id="相对大小"><a href="#相对大小" class="headerlink" title="相对大小"></a>相对大小</h4><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>smaller</td><td>把 font-size 设置为比父元素更小的尺寸。</td></tr><tr><td>larger</td><td>把 font-size 设置为比父元素更大的尺寸。</td></tr></tbody></table><h4 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h4><p>像素(px)是网页中最常用的单位，同样的，我们也可以通过px作为固定值来设定我们字体的大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;&#125;</span><br></pre></td></tr></table></figure><p>如果你不指定一个字体大小，默认大小和普通文本段落一样，为16px(1em)</p><h3 id="字体粗细-font-weight"><a href="#字体粗细-font-weight" class="headerlink" title="字体粗细 font-weight"></a>字体粗细 font-weight</h3><p>该属性用于设定字体的粗细</p><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">normal</td><td align="left">默认值。定义标准的字符。</td></tr><tr><td align="left">bold</td><td align="left">定义粗体字符。</td></tr><tr><td align="left">bolder</td><td align="left">定义更粗的字符。</td></tr><tr><td align="left">lighter</td><td align="left">定义更细的字符。</td></tr><tr><td align="left">100、200、300…900</td><td align="left">定义由细到粗的字符。400 等同于 normal，而 700 等同于 bold。</td></tr><tr><td align="left">inherit</td><td align="left">规定应该从父元素继承字体的粗细。</td></tr></tbody></table><h2 id="背景-Background"><a href="#背景-Background" class="headerlink" title="背景 Background"></a>背景 Background</h2><h3 id="背景颜色-background-color"><a href="#背景颜色-background-color" class="headerlink" title="背景颜色 background-color"></a>背景颜色 background-color</h3><p>该属性定义了元素的背景颜色</p><p>颜色的值可以用以下方法定义：</p><ul><li>十六进制 例：“#ff0000”</li><li>RGB 例：“rgb(255,0,0)”</li><li>颜色名称 例：“red”</li></ul><p>页面的背景颜色使用在body的选择器上</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>:red;&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;h1-h6&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code>等等标签都可以通过自己的选择器调整各自的背景颜色</p><h3 id="背景图片-backgroud-image"><a href="#背景图片-backgroud-image" class="headerlink" title="背景图片 backgroud-image"></a>背景图片 backgroud-image</h3><p>该属性定义了元素的背景图像，默认情况背景图像会平铺重复显示，覆盖整个元素实体</p><p>同样的，页面的背景图片设置也在body的选择器上</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;backgroud-image:<span class="built_in">url</span>(<span class="string">&#x27;xxx.jpg&#x27;</span>);&#125;</span><br></pre></td></tr></table></figure><h4 id="平铺方式-background-repeat"><a href="#平铺方式-background-repeat" class="headerlink" title="平铺方式 background-repeat"></a>平铺方式 background-repeat</h4><p>我们可以通过<code>background-repeat</code>属性设置平铺方式</p><p>水平平铺</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    backgroud-image:<span class="built_in">url</span>(<span class="string">&#x27;xxx.jpg&#x27;</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>:repeat-x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不平铺</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    backgroud-image:<span class="built_in">url</span>(<span class="string">&#x27;xxx.jpg&#x27;</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图像定位-background-position"><a href="#图像定位-background-position" class="headerlink" title="图像定位 background-position"></a>图像定位 background-position</h4><p>我们还可以通过<code>background-position</code>改变图像在背景的位置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">&#x27;img_tree.png&#x27;</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span><span class="selector-pseudo">:right</span> <span class="attribute">top</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简写属性"><a href="#简写属性" class="headerlink" title="简写属性"></a>简写属性</h4><p>由于背景需要通过多个属性来控制，为了简化这些属性的代码，我们可以将其合并为同一个属性中</p><p>当使用简写属性时，属性值的顺序为：</p><ul><li>background-color</li><li>background-image</li><li>background-repeat</li><li>background-attachment</li><li>background-position</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">background</span>:<span class="number">#ffffff</span> <span class="built_in">url</span>(<span class="string">&#x27;img_tree.png&#x27;</span>) no-repeat right top;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Server笔记（1）</title>
      <link href="/2022/10/12/SQLServer%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
      <url>/2022/10/12/SQLServer%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>该笔记的所观看的视频为<a href="https://www.youtube.com/user/waspec">Timothy Liu</a>的”SQL速通”</p><p>所使用的数据库为微软官方提供的学习用数据库：<a href="https://learn.microsoft.com/en-us/sql/samples/adventureworks-install-configure?view=sql-server-ver16&tabs=ssms">AdventureWorks sample databases - SQL Server | Microsoft Learn</a></p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li><p>数据库管理系统 Database Management System <strong>DBMS</strong></p></li><li><p>DBMS客户端 Client&#x2F;Server C&#x2F;S架构</p><p>客户端：与数据库管理系统交互的程序，分为两种图形和命令行，而SQL Server的客户端就是SQL Server Management Studio <strong>SSMS</strong></p><p>服务器：正在运行的数据库管理系统，一个服务器可以为多个客户端提供服务</p></li><li><p>数据库：真正存放数据的地方；数据的存储结构针对速度与安全性进行了优化</p><p>数据库的类型有多种，如关系型数据库、文档型数据库等，而SQL Server就是一种关系型数据库，<strong>关系型数据库</strong>是建立在关系模型基础上的数据库，常用在对数据的完整性要求比较高的场景，比如银行系统、销售系统等。<strong>文档型数据库</strong>是一种非关系型数据库，数据作为单条记录保存在数据库，主要应用在大数据处理、应用与分析方面，比如购物应用与页面的广告展示记录系统等。关系型数据库与文档型数据库并不是相对立的，而是互补而成的，关系型数据库存放经过处理后的文档型数据库，而文档型数据库可以存大量未经处理的数据。</p></li><li><p>查询（query）</p><table><thead><tr><th>英文</th><th>中文</th></tr></thead><tbody><tr><td>C:Create</td><td>增</td></tr><tr><td>R:Read</td><td>查</td></tr><tr><td>U:Update</td><td>改</td></tr><tr><td>D:Delete</td><td>删</td></tr></tbody></table></li></ul><h2 id="查询基础"><a href="#查询基础" class="headerlink" title="查询基础"></a>查询基础</h2><h3 id="查询的过程"><a href="#查询的过程" class="headerlink" title="查询的过程"></a>查询的过程</h3><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210141908072.png" alt="image-20221014190839018" style="zoom: 67%;" /><p><strong>树立思想</strong></p><ol><li>除了关注结果，还需要<strong>关注性能</strong></li><li>随时准备应对错误、排查原因</li></ol><h3 id="SELECT语法定义"><a href="#SELECT语法定义" class="headerlink" title="SELECT语法定义"></a>SELECT语法定义</h3><p>SELECT语句是SQL查询中最核心的语句。其呈现一种嵌套的形态，各级语法元素层层展开：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210151713461.png" alt="image-20221015171333331"></p><p>问题一：表示三种可能 整个表达式不出现、AC、BC</p><p>问题二：最简形式即<code>SELECT &lt;select_list&gt;</code></p><p><code>&lt;select_list&gt;</code>可以让服务器运行的一个运算，例如<code>SELECT 100+100</code>则会让服务器运行<code>100 + 100</code>这个运算，然后返回运算后的结果到客户端：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210160138557.png" alt="image-20221016013805527"></p><p>我们在这个运算中，也可以加入设定自变量，通过<code>DECLARE @变量名 数据类型 = 初始值</code>可以声明一个变量。</p><p>问题三：在语法定义中，会出现一个套一个的操作，例如：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210160253123.png" alt="image-20221016025343088"></p><p>这种属于是直接的套娃，还有一种是间接的套娃：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210160256954.png" alt="image-20221016025618921"></p><p><code>&lt;table_source&gt;</code>表示的是一张“源表格”，“源表格”除了数据库原生的表格，还可以将<code>SELECT语句</code>查询的结果作为一个“源表格”，提供在<code>&lt;table_source&gt;</code>中使用。我们使用<code>AS</code>关键词可以声明一个新的“源表格”：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210160302803.png" alt="image-20221016030218768"></p><p>这种嵌套的方式，可以称之为递归。在<code>SELECT语句</code>的定义中是存在递归的解释的。</p><h2 id="SELECT具体使用"><a href="#SELECT具体使用" class="headerlink" title="SELECT具体使用"></a>SELECT具体使用</h2><h3 id="From子句基础用法"><a href="#From子句基础用法" class="headerlink" title="From子句基础用法"></a>From子句基础用法</h3><p>From涉及到“数据从何而来”的问题。</p><p>From子句最重要的部分是<code>&lt;table_source&gt;</code>，即数据源，一个From子句可以带有多个<code>&lt;table_source&gt;</code>，多个可以产生<strong>正交组合</strong>。正交组合就是将两个表的数据取出来进行两两组合（笛卡尔乘积）。</p><p><code>&lt;table_source&gt;</code>也具有非常丰富的展开，这里暂时仅解释两个基础的用法</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202210172311504.png" alt="image-20221017231151461"></p><p><code>&lt;joined_table&gt;</code>与<code>&lt;pivoted_table&gt;</code>也是非常重要的用法，这四个用法，是From最重要四个用法。</p><h4 id="table-or-view-name"><a href="#table-or-view-name" class="headerlink" title="table_or_view_name"></a><code>table_or_view_name</code></h4><p><strong>表<code>table</code>的概念：</strong></p><p>表并不是我们看见的执行结果所出现的“表格”，“表格”是对表的抽象逻辑的具体化。</p><ol><li><p>表是数据库存储数据的地方，而且<strong>所有的数据</strong>都是存储在表中。</p></li><li><p>在表里面，是以行和列的<strong>逻辑</strong>进行存储的，行是表里”唯一”的一条数据记录，列是表里所有记录某一个字段的所有记录</p><p>行的”唯一性”由<strong>主键</strong>来保证，当我们在设计表的时候，我们需要通过某行某列的组合保证行的唯一性。</p></li></ol><p><strong>视图<code>view</code>的概念：</strong></p><ol><li>视图是一张由<strong>查询query</strong>定义出来的<strong>虚拟表virtual table</strong></li><li>可以将其视作查看一组数据的时候的<strong>过滤器filter</strong></li></ol><h4 id="derived-table"><a href="#derived-table" class="headerlink" title="derived_table"></a><code>derived_table</code></h4><ol><li><code>derived_table</code>是来自于数据库的一个<strong>子查询</strong></li><li>其用于作为其他查询的数据输入</li><li><code>derived_table</code>与<code>view</code>可以相互转换，当<code>derived_table</code>比较常用于作为其他查询的数据输入的时候，我们可以将其固化为一个<code>view</code></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发基础（1）：参考文档或教程、HTML</title>
      <link href="/2022/08/30/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E6%88%96%E6%95%99%E7%A8%8B%E3%80%81HTML/"/>
      <url>/2022/08/30/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E6%88%96%E6%95%99%E7%A8%8B%E3%80%81HTML/</url>
      
        <content type="html"><![CDATA[<h2 id="参考文档or教程"><a href="#参考文档or教程" class="headerlink" title="参考文档or教程"></a>参考文档or教程</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web">Web 开发技术 | MDN (mozilla.org)</a></p><p><a href="https://www.runoob.com/html/html-tutorial.html">HTML 教程 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://www.runoob.com/css/css-tutorial.html">CSS 教程 | 菜鸟教程 (runoob.com)</a></p><h2 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h2><p>HTML是一个标记语言，不是一个编程语言。HTML 使用标记标签来描述网页，HTML 文档包含了HTML标签及文本内容。</p><p>HTML标签是HTML所使用的标记，是由尖括号所包围的关键词，如<code>&lt;head&gt;</code>等。HTML标签是成对出现的，第一个标签是开始标签，第二个标签是结束标签。HTML元素就是HTML标签所涵盖的内容。</p><p>HTML的网页结构：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202208301605882.png" alt="image-20220830160532846"></p><p>一个完整HTML网页：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>first html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>HHHHHELLO WORLD<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在vscode中，我们新建一个html文件时，我们可以通过英文的<code>!</code>＋回车快速生成html文档的基本结构</p><p>在JB系软件中，可以通过<code>html:5</code>+tab快速生成</p><h2 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li>HTML 元素以<strong>开始标签</strong>起始</li><li>HTML 元素以<strong>结束标签</strong>终止</li><li><strong>元素的内容</strong>是开始标签与结束标签之间的内容</li><li>某些 HTML 元素具有<strong>空内容</strong></li><li>空元素<strong>在开始标签中进行关闭</strong>（以开始标签的结束而结束）</li><li>大多数 HTML 元素可拥有<strong>属性</strong></li></ul><p>大部分HTML元素都可以嵌套。</p><h3 id="基本结构标签"><a href="#基本结构标签" class="headerlink" title="基本结构标签"></a>基本结构标签</h3><ul><li><p><code>&lt;html&gt;&lt;/html&gt;</code> HTML标签</p><p>根标签，是页面中最大的标签</p></li><li><p><code>&lt;head&gt;&lt;/head&gt;</code> 文档的头部</p><p>注意在head标签中必须设定title标签</p><p><code>&lt;title&gt;&lt;title&gt;</code>设定网页的标题</p></li><li><p><code>&lt;body&gt;&lt;/body&gt;</code> 文档的主体</p><p>包含着HTML文档的所有内容，页面显示的内容都会放在body内</p></li></ul><h3 id="文档类型声明标签"><a href="#文档类型声明标签" class="headerlink" title="文档类型声明标签"></a>文档类型声明标签</h3><ul><li><p><code>&lt;!DOCTYPE&gt;</code>文档类型声明</p><p>声明HTML的版本，这句代码需要放在HTML文档的最前面</p></li><li><p><code>lang = </code>定义当前文档显示的语言</p><p>作用是给搜索引擎和浏览器作提示作用，并不是限制文档所使用的语言</p></li><li><p><code>&lt;mate charset= &quot;XXXX&quot;&gt;</code> 规定HTML文档使用的字符编码</p><p>一般情况下都是用UTF-8，避免出现乱码现象</p></li></ul><h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><ul><li><p>标题标签 <code>&lt;h1&gt;-&lt;h6&gt;</code> 有大到小递减</p></li><li><p>段落标签<code>&lt;p&gt;&lt;/p&gt;</code> 定义段落，可以将网页分割成多个段落</p><p>特性：会根据浏览器窗口自动换行</p></li><li><p>换行标签<code>&lt;br/&gt;</code> 手动换行 单标签</p></li><li><p>文本格式化标签</p><table><thead><tr><th>语义</th><th>标签</th></tr></thead><tbody><tr><td>加粗</td><td><strong></strong>或<b></b></td></tr><tr><td>倾斜</td><td><em></em>或<i></i></td></tr><tr><td>删除线</td><td><del></del>或<s></s></td></tr><tr><td>下划线</td><td><ins></ins>或<u></u></td></tr></tbody></table></li><li><p><code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>标签</p><p>这两个标签本身是没有含义，是作为一个盒子的存在，用于存储内容</p><p>特点：</p><ol><li><code>&lt;div&gt;</code>一行只能放一个，该标签独占一行，相当于是一种大盒子</li><li><code>&lt;span&gt;</code>一行可以放置多个，相当于是一种小盒子</li></ol></li><li><p>图像标签<code>&lt;img src = &quot;图像URL&quot; /&gt;</code> 单标签</p><p>图像标签有以下属性可以设置：</p><table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>src</td><td>图片路径</td><td>必须属性，用于指定图像文件的路径和文件名</td></tr><tr><td>alt</td><td>文本</td><td>替换文本。图片不能显示时的文字</td></tr><tr><td>title</td><td>文本</td><td>提示文本。鼠标放在图像上显示的文字</td></tr><tr><td>width</td><td>像素</td><td>宽度</td></tr><tr><td>height</td><td>像素</td><td>高度</td></tr><tr><td>border</td><td>像素</td><td>边框的粗细</td></tr></tbody></table><p>图像标签注意点：</p><ol><li>图像标签可以拥有多个属性，必须写在标签名的后面</li><li>属性之间不分先后顺序，标签名与属性、属性与属性之间以空格隔开</li><li>属性采用键值对的格式，即<code>key = &quot;value&quot;</code></li></ol><p>相对路径的含义：</p><table><thead><tr><th>相对路径含义</th><th>符号</th></tr></thead><tbody><tr><td>同一级路径</td><td></td></tr><tr><td>下一级路径</td><td>&#x2F;</td></tr><tr><td>上一级路径</td><td>..&#x2F;</td></tr></tbody></table></li><li><p>超链接标签 <code>&lt;a href = &quot;跳转目标&quot; target = &quot;目标窗口弹出方式&quot;&gt;文本或者图像&lt;/a&gt;</code></p><p>作用是从一个页面链接到另外一个页面</p><p><code>target</code>默认为<code>_self</code>，<code>_blank</code>为在新窗口中打开的方式</p><p>在<code>文本或者图像</code>的位置，我们可以填入文本，或者是图像标签之类的各种网页元素</p><p><code>href</code>跳转目标：</p><ol><li><p>外部链接</p></li><li><p>网站内部的其他网页</p></li><li><p>空链接</p></li><li><p>下载链接：文件所在的路径</p></li><li><p>锚点链接：点击链接可以快速定位到页面的某个位置</p><p>找到目标位置的标签，在内部添加一个<code>id = &quot;名字&quot;</code>，在<code>href</code>属性中设置为<code>#名字</code>即可</p></li></ol></li><li><p>注释 <code>&lt;!-- 注释语句 --&gt;</code></p></li></ul><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>在HTML中，空格等特殊字符我们需要借助特殊的标记进行表示</p><p>常用的特殊字符：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209160127388.png" alt="image-20220916012707314"></p><p>详细请参考<a href="https://www.runoob.com/tags/ref-entities.html">HTML ISO-8859-1 参考手册 | 菜鸟教程 (runoob.com)</a></p><h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h2><p>表格的主要作用是显示、展示数据</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>表格主要由三组标签组成，<code>&lt;table&gt;</code>、<code>&lt;tr&gt;</code>、<code>&lt;td&gt;</code></p><ul><li><code>&lt;table&gt;</code>用于定义表格的标签 </li><li><code>&lt;tr&gt;</code>用于定义表格的行</li><li><code>&lt;td&gt;</code> <code>table date</code> 即单元格</li><li>三组标签呈现<code>&lt;td&gt; -&gt; &lt;tr&gt; -&gt; &lt;table&gt;</code>的嵌套关系</li></ul><p>表格的基本例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>17<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209161037616.png" alt="image-20220916103701582"></p><h3 id="表头单元格标签"><a href="#表头单元格标签" class="headerlink" title="表头单元格标签"></a>表头单元格标签</h3><p><code>&lt;th&gt;</code> 即table head</p><p>表格的第一行一般都是作为表头使用，因此<code>&lt;th&gt;</code>标签可以使得里面的文本内容加粗居中显示，以此表示表头</p><p>注意：这是个单元格大小的标签，与<code>&lt;td&gt;</code>类似</p><h3 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h3><p>实际开发中并不常用，实际开发中表格属性往往通过CSS来设置</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209161303070.png" alt="image-20220916130347019"></p><h3 id="表格结构标签"><a href="#表格结构标签" class="headerlink" title="表格结构标签"></a>表格结构标签</h3><p>为了更好的表示表格，可以将被表格分割成表格头部和表格主体两大部分</p><p>在表格标签中，分别用：<code>&lt;thead&gt;</code>表示表格的头部区域、<code>&lt;tbody&gt;</code>表示表格的主体区域</p><p>这两个结构标签位于<code>&lt;table&gt;</code>下面，在<code>&lt;tr&gt;</code>之上</p><p>注意：<code>&lt;thead&gt;</code>的属性与表格总的属性是分隔的，需要额外设置</p><h3 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h3><p>特殊情况下，我们需要用到多个单元格合并成一个单元格，例：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209161313160.png" alt="image-20220916131341116"></p><p>这种情况下，<code>个人简历</code>和<code>图片</code>就用到了合并单元格</p><p><strong>合并单元格的方式：</strong></p><ul><li>跨行合并：rowspan&#x3D;”合并单元格的个数”</li><li>跨列合并：colspan&#x3D;”合并单元格的个数”</li></ul><p>合并的代码需要写到目标单元格上：</p><ul><li>跨行：最上侧单元格为目标单元格</li><li>跨列：最左侧单元格为目标单元格</li></ul><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209161325942.png" alt="image-20220916132536909"></p><p>举个实现上图的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><p>跟表格标签不同，列表最主要是用来<strong>布局</strong></p><p>列表的特点是整齐、整洁、有序，且作为布局会更加自由和方便</p><p>列表主要分为三大类：无序列表、有序列表、自定义列表</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209161550863.png" alt="image-20220916155000749"></p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p> <code>&lt;ul&gt;</code>标签表示无序列表，列表项使用<code>&lt;li&gt;</code>定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>one<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>three<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>four<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>five<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>&lt;li&gt;</code>里相当于是一个容器，可以容纳任何内容</p><p>无序列表有自己的样式属性，但是在实际使用中，我们往往使用CSS进行设置</p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p><code>&lt;ol&gt;</code>标签表示有序列表，列表项用<code>&lt;li&gt;</code>定义</p><p>与无序列表类似<code>&lt;li&gt;</code>里相当于是一个容器，可以容纳任何内容，且有序列表有自己的样式属性，但开发中更常用CSS进行设置样式</p><h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h3><p>开发中自定义列表常用于对术语或名词进行解释和描述，自定义列表的列表项前面没有任何项目符号</p><p><code>&lt;dl&gt;</code>标签用于表示自定义列表，<code>&lt;dt&gt;</code>用于表示项目&#x2F;名字，<code>&lt;dd&gt;</code>用于表示详细描述</p><p><code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>的关系类似于表头和单元格的关系</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>关注我们<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>bilibili<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>联系我们<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>数量都是没有限制的，比较常用的是一个<code>&lt;dt&gt;</code>对应多个<code>&lt;dd&gt;</code></p><h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><p>表单常用在注册等场景下使用，常用于收集用户的信息和相关数据</p><p>在HTML中，一个完整的表单一般由三部分组成，<strong>表单域、表单控件（表单元素）、提示信息</strong></p><h3 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h3><p>表单域即包含整个表单元素的区域，<code>&lt;form&gt;</code>标签用于定义表单域，以实现用户信息的收集及传递</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;提交方式&quot;</span> <span class="attr">name</span>=<span class="string">&quot;表单域名称&quot;</span>&gt;</span></span><br><span class="line">表单控件与其他元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>url地址：用于接收并处理表单数据的服务器程序的url地址</p><p>提交方式：可用的取值为，<code>get</code>与<code>post</code>，在我的另外一篇文章（渗透测试（1））中提及两者区别</p><p>名称：用于指定表单的名称，以区分不同表单</p><h3 id="表单控件"><a href="#表单控件" class="headerlink" title="表单控件"></a>表单控件</h3><p>表单控件可用按照使用的方式分为以下几种类型</p><ul><li><p>input输入表单元素</p><p><code>&lt;input&gt;</code>标签可以让用户输入数据，注意，他是一个单标签</p><p>在<code>&lt;input&gt;</code>标签中，包含一个必填的属性<code>type</code>属性，根据不同的属性，输入的字段拥有很多种形式（文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）</p><p><code>type</code>具体可以取得值可以见下表：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209170203818.png" alt="image-20220917020311733"></p><p>除了<code>type</code>属性以外，<code>&lt;input&gt;</code>还提供其他属性以供设置，其常用的其他属性如下：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209170219563.png" alt="image-20220917021924503"></p><p>其中<code>name</code>值，在用<code>radio</code>实现多选一的时候，必须让多个按钮有同一个<code>name</code>值，才能实现多选一的效果，否则会出现可以多选的问题。复选按钮<code>&lt;checkbox&gt;</code>也同样需要有相同的<code>name</code>值</p><p><code>value</code>属性对于不同<code>type</code>类型，用法也不同：</p><ul><li>对于 <code>button</code>、<code>reset</code>、<code>submit</code> 类型 - 定义按钮上的文本</li><li>对于 <code>text</code>、<code>password</code>、<code>hidden</code> 类型 - 定义输入字段的初始（默认）值</li><li>对于 <code>checkbox</code>、<code>radio</code>、<code>image</code> 类型 - 定义与 input 元素相关的值，当提交表单时该值会发送到表单的 action URL。</li></ul></li><li><p>select下拉表单元素</p><p>下拉表单常用于选择分类之类的地方</p><p>我们可以使用<code>&lt;select&gt;</code>标签控件定义下拉列表，具体的列表选项我们可以使用<code>&lt;option&gt;</code>来进行列出</p><p>在<code>&lt;select&gt;</code>标签应当至少含有一对<code>&lt;option&gt;</code>标签，在<code>&lt;option&gt;</code>标签中设置属性<code>selected = &quot;selected&quot;</code>时会使得当前选项成为默认选项</p></li><li><p>textarea文本域元素</p><p>与<code>&lt;input&gt;</code>标签的 <code>text</code>相类似，都是作为让用户输入文字表单的地方，但是这个文本域元素能提供更大的输入空间，一般用于让用户输入自我介绍等内容的地方，可以理解为大号的 <code>text</code></p><p>这个标签带有两个属性，<code>rows</code>和<code>cols</code>，<code>rows</code>是用于调整每行中的字符数，<code>cols</code>是用于调整显示的行数，但是我们在开发中很少会使用，因为一般都是使用CSS进行大小的调控</p><p>在标签中间填入的内容是用于定义输入字段的初始（默认）值</p></li></ul><h3 id="lt-label-gt-标签"><a href="#lt-label-gt-标签" class="headerlink" title="&lt;label&gt;标签"></a><code>&lt;label&gt;</code>标签</h3><p><code>&lt;label&gt;</code>标签并不属于表单标签，但是常常用于表单中，可以使得用户不比精准点中表单也可以选中选项</p><p><code>&lt;label&gt;</code>标签用于绑定一个表单元素，当点击<code>&lt;label&gt;</code>标签内的元素时，浏览器会自动将焦点（即光标）转向对应的表单元素上，增加用户体验</p><p>绑定的方式是设置<code>for</code>属性，并在表单元素上设定<code>id</code>属性，通过<code>for</code>绑定<code>id</code>属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试学习（1）：概述、信息收集</title>
      <link href="/2022/08/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%EF%BC%9A%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/08/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%EF%BC%9A%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="渗透测试基本流程"><a href="#渗透测试基本流程" class="headerlink" title="渗透测试基本流程"></a>渗透测试基本流程</h2><ol><li>确定目标</li><li>信息收集</li><li>漏洞探寻</li><li>漏洞分析</li><li>漏洞利用</li><li>信息整理</li><li>形成报告</li></ol><h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>HTTP请求方式有七种，常用get、post</p><p>get请求 请求参数在url地址中，url有长度限制</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209052334587.png" alt="image-20220905233435518"></p><p>post请求 请求参数在请求体中，无大小限制</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209052334088.png" alt="image-20220905233446026"></p><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>Host：请求主机域名&#x2F;ip地址</p><p>User-Agent：提供浏览器的版本信息，供服务器解决浏览器兼容问题</p><p>Accept：传输文件类型（text&#x2F;html，application&#x2F;xhtml+xml，application&#x2F;xml）</p><p>Referer：跳转前的地址，可以用于统计用户来源和防止盗链</p><p>Accept-Encoding：浏览器申明自己可接收的编码方法</p><p>Accept-Language：浏览器申明自己可接收的语言</p><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><ol><li><p><strong>响应行</strong></p><p>协议及版本 响应状态码 状态码描述</p><p>例子：HTTP&#x2F;1.1 200 OK</p><p><strong>响应状态码详解：</strong></p><ul><li>1xx：服务器接受浏览器信息未完成，发送1xx状态码</li><li>2xx：成功，200</li><li>3xx：重定向，302，304（访问缓存）</li><li>4xx：客户端错误，404（没有找到对应资源），405（请求方法不被允许）</li><li>5xx：服务器错误，500（服务器内部出现异常）</li></ul><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209060033315.png" alt="image-20220906003345245"></p></li><li><p><strong>响应头</strong></p></li><li><p><strong>响应空行</strong></p><p>即一个空行</p></li><li><p><strong>响应体</strong></p><p>即网页的内容</p></li></ol><h2 id="前期信息收集"><a href="#前期信息收集" class="headerlink" title="前期信息收集"></a>前期信息收集</h2><p>信息收集是指通过各种方式获取所需要的信息</p><p>信息包括目标站点ip、中间件、脚本语言、端口、邮箱等，包括资产收集但不限于资产收集</p><p>信息收集的意义</p><ul><li>渗透测试成功的保障</li><li>更多的暴露面</li><li>更大的可能性</li></ul><p>信息收集的分类</p><ul><li><p>主动信息收集</p><p>通过直接对网站进行操作、扫描等，这种是有网络流量经过目标服务器的信息收集方式</p></li><li><p>被动信息收集</p><p>基于公开的渠道，如搜索引擎，在不与目标交互的情况下获取信息，并尽量避免留下痕迹</p></li></ul><p>需要收集的信息</p><ul><li>服务器信息（端口、服务、真实ip）</li><li>网站信息(网站架构[操作系统、中间件、数据库、编程语言]、指纹信息、WAF、敏感目录、敏感文件、源码泄露、旁站、C段)</li><li>域名信息(whois、 备案信息、子域名)</li><li>管理员信息(姓名、职务、生日、联系电话、邮件地址)</li><li>以上均是包括但不限于</li></ul><h3 id="域名信息收集"><a href="#域名信息收集" class="headerlink" title="域名信息收集"></a>域名信息收集</h3><p><strong>whois查询</strong></p><p>通过whois查询，我们可以收集到域名的ip及其所有者的信息</p><p>可以通过域名注册商、站长工具、命令行查询等等方式查询到whois</p><p><strong>域名备案信息</strong></p><p>在中国大陆解析网站都需要备案，备案具有网站的很多信息，同样的我们也可以通过站长工具进行查询</p><p><strong>注册人、邮箱反查</strong></p><p>通过whois获取注册人和邮箱，再通过注册人和邮箱反查域名</p><p>缺点是很多公司都是dns解析的运营商注册的，并不能很好的获取到信息</p><p><strong>子域名收集</strong></p><p>通过搜索子域名，找到主域名的其他子网站，由于主网站往往是防御做最好的，因此可以作为寻找突破口的作用</p><ol><li><p>google hacking</p><p>这是Google提供的一个信息搜集作用的语法，具体语法可以参考：</p><p><a href="https://zhuanlan.zhihu.com/p/25715992">详解GOOGLE HACK语法 - 知乎 (zhihu.com)</a></p><p>最简单的用法就是：<code>site:域名</code>，可以找到该域名的子域名</p></li><li><p>第三方web接口查询</p><p><a href="https://dnsdumpster.com/">DNSdumpster.com - dns recon and research, find and lookup dns records</a></p><p><a href="https://tool.chinaz.com/subdomain/">子域名查询 - 站长工具 (chinaz.com)</a></p></li><li><p>网络空间安全搜索引擎</p><p><a href="https://fofa.info/">网络空间测绘，网络空间安全搜索引擎，网络空间搜索引擎，安全态势感知 - FOFA网络空间测绘系统</a></p><p><a href="https://www.zoomeye.org/">首页 - 网络空间测绘,网络安全,漏洞分析,动态测绘,钟馗之眼,时空测绘,赛博测绘 - ZoomEye(“钟馗之眼”)网络空间搜索引擎</a></p><p><a href="https://www.shodan.io/">Shodan Search Engine</a></p><p>这种搜索引擎跟普通搜索引擎的区别在于，这种搜索引擎会一直对公网进行扫描，可以通过这种引擎，用被动收集信息，达到一定的主动收集方式的效果，缺点是这种引擎一般都是收费的</p></li><li><p>ssl证书查询</p><p><a href="https://crt.sh/">crt.sh | Certificate Search</a></p><p><a href="https://developers.facebook.com/tools/ct/search/">https://developers.facebook.com/tools/ct/search/</a></p><p>可以查询到https协议的网站的信息</p></li><li><p>js文件发现子域名</p><p><a href="https://github.com/Threezh1/JSFinder">Threezh1&#x2F;JSFinder: JSFinder is a tool for quickly extracting URLs and subdomains from JS files on a website. (github.com)</a></p><p>可以通过一些自动化工具来发现子域名</p></li><li><p>借助各种工具</p></li></ol><h3 id="IP信息收集"><a href="#IP信息收集" class="headerlink" title="IP信息收集"></a>IP信息收集</h3><ol><li><p><strong>ip反查域名</strong></p><p>如果渗透目标为虚拟主机，那么通过IP反查到的域名信息很有价值，因为一台物理服如果渗透目标为虚拟主机，那么通过IP反查到的域名信息很有价值，因为一台物理服务器上面可能运行多个虚拟主机。这些虚拟主机有不同的域名，但通常共用一个IP地务器上面可能运行多个虚拟主机.这些虚拟主机有不同的域名，但通常共用一个IP地址。如果你知道有哪些网站共用这台服务器，就有可能通过此台服务器上其他网站的漏洞获取服务器控制权，进而迂回获取渗透目标的权限，这种技术也称为“旁注”漏洞获取服务器控制权，进而迂回获取渗透目标的权限，这种技术也称为<strong>“旁注”</strong></p></li><li><p><strong>域名查询ip</strong></p></li><li><p><strong>判断与绕过CDN</strong></p><p>由于CDN会导致我们在查询域名对应IP时，查询到的是CDN，因此我们需要一些方法去判断和绕过CDN以获得真实IP</p><ul><li><p>多地ping</p><p>多地ping可以查看对应ip是否唯一</p></li><li><p>国外访问</p><p>通过国外访问的方式，有些网站设置CDN可能没有把国外的访问包含进去</p></li><li><p>查询子域名的IP</p><p>由于CDN收费高，很多站长仅只对主站或者流量大的子站做了CDN，而很多小旁站子站点和主站常常是在同一台服务器或者同一个C段内，因此可以通过这种方式辅助查找网站真实IP</p></li><li><p>查看phpinfo文件</p><p>如果是使用Apache HTTP Server的网站，其会内置一个phpinfo.php文件，通过访问这个文件，可以在内部找到一个参数<code>SERVER_ADDR</code>，其保存了服务器的真实地址或者内部地址</p><p>不常用，因为大部分网站管理员都会自行删除该文件使其不暴露</p></li><li><p>Mx记录邮件服务</p><p>缺陷：需要web服务器和邮件服务器在同一ip或同一c段</p></li><li><p>网络空间搜索引擎</p><p><a href="https://search.censys.io/">Censys Search</a></p></li><li><p>查询历史DNS记录</p><p><a href="https://www.dnsdb.io/zh-cn/">DNSDB</a></p><p><a href="https://viewdns.info/">ViewDNS.info - Your one source for DNS related tools!</a></p><p><a href="https://securitytrails.com/">SecurityTrails: Data Security, Threat Hunting, and Attack Surface Management Solutions for Security Teams</a></p><p><a href="https://www.ip138.com/">iP地址查询–手机号码查询归属地 | 邮政编码查询 | iP地址归属地查询 | 身份证号码验证在线查询网 (ip138.com)</a></p><p>这是一个非常实用的方式！</p></li></ul></li><li><p><strong>C段存活主机探测</strong></p><ul><li><p>Nmap</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -sP www.XXX.com/24</span><br><span class="line">nmap -sP 192.168.1.*</span><br></pre></td></tr></table></figure></li><li><p>各种扫描器</p></li></ul></li></ol><h3 id="端口信息收集"><a href="#端口信息收集" class="headerlink" title="端口信息收集"></a>端口信息收集</h3><p><strong>端口类型：</strong></p><ul><li>周知端口：众所周知的端口号，一般都用于固定分配给常用的服务，范围：0-1023</li><li>动态端口：一般不固定分配某种服务，范围：49152-65535</li><li>注册端口：用于分配给用户进程或程序，范围：1024-49151</li></ul><h4 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h4><p>一款开源的网络探测和安全审查的工具</p><p><strong>功能介绍</strong></p><ul><li>主机发现</li><li>端口发现</li><li>服务发现</li><li>检测操作系统，硬件地址，以及软件版本</li><li>检测脆弱性漏洞</li></ul><p><strong>端口状态</strong></p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209182016432.png" alt="image-20220918201629375"></p><p><strong>基础用法</strong></p><p>下面是一个经典的nmap扫描</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -A -T4 192.168.1.1</span><br></pre></td></tr></table></figure><p>-A：启用一个全面的扫描</p><p>-T4：时序选择，有T0-T5不同的六种选项，可以指定不同的速度，速度为0-5递增，但网络带宽需求增加，T5是牺牲准确度来提升速度，扫描国内网站常用为T4</p><p>目标指定的方式：</p><ul><li>单一主机扫描：192.168.1.1</li><li>子网扫描：192.168.1.1&#x2F;24</li><li>多主机扫描：192.168.1.1 192.168.100.1</li><li>主机范围扫描：192.168.1.1-100</li><li>IP列表扫描：-iL list.txt</li><li>除了指定IP以外的子网主机：192.168.1.1&#x2F;24 –exclude 192.168.1.1</li><li>除了指定文件中的IP的子网主机：192.168.1.1&#x2F;24 –excludefile list.txt</li><li>特定端口扫描：nmap -p 80,21,23 192.168.1.1</li></ul><p>一些常用的参数：</p><p>-sS：SYN扫描，半开放扫描。打开一个不完整的TCP连接，也就是不需要三次握手。优点是不需要产生任何会话，目标主机也不会记录该扫描，扫描速度快，效率高。缺点是需要最高权限执行</p><p>-sA：ACK扫描</p><p>-sP：ICMP扫描，通过PING扫描</p><p>-sT：TCP扫描，通过完整的TCP连接扫描</p><p>-Pn：扫描前不进行ping</p><p>-iL：导入扫描列表</p><p>-v&#x2F;sV：探测版本，可能会减缓扫描速度</p><p>-oG 文件名：按照nmap的格式输出文件</p><p>-O：探测操作系统版本</p><p>–script：指定脚本进行漏洞扫描</p><h3 id="网站信息收集"><a href="#网站信息收集" class="headerlink" title="网站信息收集"></a>网站信息收集</h3><h4 id="网站指纹识别"><a href="#网站指纹识别" class="headerlink" title="网站指纹识别"></a>网站指纹识别</h4><ol><li><p><strong>操作系统</strong></p><ul><li>ping判断，Windows TTL一般为128，Linux则为64。TTL大于100一般为Windows，几十的一般为Linux</li><li>nmap -O</li><li>Windows大小写不敏感，Linux大小写区分</li></ul></li><li><p><strong>网站服务 \ 容器类型</strong></p><ul><li>F12查看响应头Server字段</li><li>浏览器插件</li></ul></li><li><p><strong>脚本类型</strong></p><p>通过上面插件也可以查到脚本类型</p></li><li><p><strong>数据库类型</strong></p></li><li><p><strong>CMS识别</strong> CMS：网站内容管理</p><p>常见的CMS：dedecms（织梦）、Discuz、phpcms等</p><ul><li><p>在线识别工具</p><p><a href="http://whatweb.bugscaner.com/look/">在线指纹识别,在线cms识别小插件–在线工具 (bugscaner.com)</a></p></li><li><p>Onlinetools</p><p><a href="https://github.com/iceyhexman/onlinetools">https://github.com/iceyhexman/onlinetools</a></p></li></ul></li></ol><h4 id="敏感文件、目录"><a href="#敏感文件、目录" class="headerlink" title="敏感文件、目录"></a>敏感文件、目录</h4><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202209192134826.png" alt="image-20220919213442779" style="zoom:50%;" /><p><strong>Github泄露</strong></p><p>部分开发人员将网站上传至开源网站的时候，忘记删除敏感信息。此类信息可以在Github上搜索公司的特定信息，查看是否有程序员将这些信息上传到github上</p><p><strong>.git泄露</strong></p><p>使用GitHack对其进行检索</p><p><a href="https://github.com/lijiejie/GitHack">lijiejie&#x2F;GitHack: A .git folder disclosure exploit (github.com)</a></p><p>可以通过泄露的.git文件夹下的文件，重建还原工程源代码</p><p><strong>网站备份文件</strong></p><p><a href="https://github.com/7kbstorm/7kbscan-WebPathBrute">7kbstorm&#x2F;7kbscan-WebPathBrute: 7kbscan-WebPathBrute Web路径暴力探测工具 (github.com)</a></p><p><strong>目标探测</strong></p><p><a href="https://github.com/maurosoria/dirsearch">maurosoria&#x2F;dirsearch: Web path scanner (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（11）：比较器、集合、Lambda表达式</title>
      <link href="/2022/06/07/Java%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%AF%94%E8%BE%83%E5%99%A8%E3%80%81%E9%9B%86%E5%90%88%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/06/07/Java%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%AF%94%E8%BE%83%E5%99%A8%E3%80%81%E9%9B%86%E5%90%88%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p>当我们需要实现对象的排序问题的时候，就要使用到Java的比较器。</p><p>Java实现对象排序的接口有两个：</p><ul><li>自然排序：java.lang.Comparable</li><li>定制排序：java.util.Comparator</li></ul><h3 id="自然排序"><a href="#自然排序" class="headerlink" title="自然排序"></a>自然排序</h3><p>String、包装类等都默认实现了Comparable接口，重写了comparaTo(obj)方法，因此都可以直接使用自然排序。</p><p>自定义类若想实现自然排序，我们需要去实现Comparable接口，然后重写comparaTo(obj)方法方法，重写comparaTo(obj)方法具有一定的规则：</p><p>如果当前对象this大于形参对象obj，则返回正整数；如果当前对象this小于形参对象obj，则返回负整数；如果相等，则返回0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods)&#123;<span class="comment">//判断是否为Goods类型</span></span><br><span class="line">      <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods) o;<span class="comment">//将Object类型转换为Goods类型</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(goods.name);<span class="comment">//若全部相等，则按照name进行比较</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入数据有误&quot;</span>);<span class="comment">//不是Goods类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h3><p>当元素的类没有实现Comparable接口而又不便修改代码，或是实现了Comparable接口的排序不适合当前操作，则我们可以使用Comparator的对象进行排序。</p><p>由于Comparator也是一个接口，同样需要重写方法，我们需要重写compare(Object o1, Object o2)方法，重写规则与自然排序相类似：</p><p>如果返回正整数，则代表o1大于o2；如果返回负整数，则代表o1小于o2；如果返回0，则表示o1与o2相等。</p><p>使用的方式是在调用sort()等排序方法的时候，在参数列表添加Comparator的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(goods, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line"><span class="type">Goods</span> <span class="variable">goods1</span> <span class="operator">=</span> (Goods) o1;</span><br><span class="line"><span class="type">Goods</span> <span class="variable">goods2</span> <span class="operator">=</span> (Goods) o2;</span><br><span class="line"><span class="keyword">if</span>(goods1.getName().equals(goods2.getName()))&#123;</span><br><span class="line"><span class="keyword">return</span> Double.compare(goods1.getPrice(), goods2.getPrice());</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> goods1.getName().compareTo(goods2.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入数据有误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Java集合是Java的一种容器，可以动态的把多个对象的引用放入容器中。集合与数组类似，都是Java容器，但是数组作为存储对象的容器方面具有一些弊端。</p><p><strong>数组在内存存储方式的特点：</strong></p><ol><li>数组初始化以后，长度是确定的</li><li>数组声明的类型，决定了元素初始化的类型</li></ol><p><strong>数组在存储数据方面的弊端：</strong></p><ol><li>数组初始化以后，长度不可改变，不可拓展</li><li>数组提供的属性和方法太少，不便于增删改操作，且往往效率低，而且无法直接获取存储元素的个数（只能通过遍历等方法）</li><li>数组存储的数据是有序的，可以重复的，导致存储数组的特点单一</li></ol><p>Java集合可以分为两种体系：</p><ul><li><p>Collection接口：单列数组，定义了一组对象的方法的集合</p><ul><li>List接口：元素有序、可重复的集合</li><li>Set接口：元素无序、不可重复的集合</li><li>……</li></ul><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202206161133427.png" alt="image-20220616113327310"></p></li><li><p>Map接口：双列数据，保存具有映射关系“Key-value对”的集合，类似于“函数”，一个key只能对应一个value，一个value可以有多个key</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202206161133743.png" alt="image-20220616113350677"></p></li></ul><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><h4 id="Collection接口常用的方法"><a href="#Collection接口常用的方法" class="headerlink" title="Collection接口常用的方法"></a>Collection接口常用的方法</h4><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202206211704116.png" alt="Collection常用方法"></p><h4 id="List接口：有序、可重复"><a href="#List接口：有序、可重复" class="headerlink" title="List接口：有序、可重复"></a>List接口：有序、可重复</h4><p>迭代方式：fori配合size() 与 for-each</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size()方法用于计算List的大小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++)&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (Object i : list)&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>LinkedList</strong>：链表，查询慢、增删快，无同步，线程不安全</li><li><strong>ArrayList</strong>：动态数组，查询快、删减慢，无同步，线程不安全</li><li><strong>Vector</strong>：动态数组，查询快、删减慢，同步，线程安全，但效率相较低</li></ul><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202206221706801.png" alt="这里写图片描述"></p><h4 id="Set接口：无序、不可重复"><a href="#Set接口：无序、不可重复" class="headerlink" title="Set接口：无序、不可重复"></a>Set接口：无序、不可重复</h4><p>无序性不等于随机性，无序性指的是存放的元素不是按照索引的顺序添加的，而是根据元素的哈希值决定的。</p><p>迭代方式：for-each，不可以用fori迭代。</p><ul><li><p><strong>HashSet</strong>：基于HashMap实现，Set接口的主要实现类，它不会记录插入的顺序。HashSet不是线程安全的。</p><p>添加元素的过程：</p><ol><li><p>对添加的元素计算哈希值。当添加元素为对象时，一般而言，我们都会在对象的类中重写hashCode()方法，若不重写，则Object继承下来的hashCode()的作用仅为生成一个随机数</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202206222159350.png" alt="image-20220622215950302"></p></li><li><p>取16（定义的底层数组的默认容量）的模，放入对应的位置</p></li><li><p>若遇到取模相同的，哈希值不同时，则会使用链表的方式存储，jdk7时，会使新元素替代原元素，并指向原元素，jdk8则会让原元素指向新元素</p></li><li><p>若遇到哈希值相同时，则需要equals()比较，若equals()相同则不填入，若equals()不相同，则会使用链表</p></li></ol></li><li><p><strong>LinkedHashSet</strong>：是HashSet的子类，使用链表使得迭代结果是添加顺序的。</p></li><li><p><strong>TreeSet</strong>：底层为红黑树结构存储，可以实现排序的实现类，要求放入的元素为<strong>相同类的对象</strong>。向TreeSet中添加元素，在遍历时默认会以自然排序的顺序遍历。</p><p>若我们添加的元素是对象之类的，由于没有比较的方式，则会报错，我们需要重写对象的类的compareTo()方法。自然排序实际上是实现了Comparable接口。在自然排序中，判断对象是否相等的标准为compareTo()返回是否为0，不再是equals。</p><p>而定制排序则是实现了Comparator接口，我们要使用定制排序，则需要在new TreeSet的时候，使用他的有参构造器，在参数内填入Comparator接口实现类的对象。在定制排序中，判断对象是否相等的标准为compare()返回是否为0，不再是equals。</p></li></ul><p>Set接口里没有定义新的方法。</p><p><strong>向Set接口的实现类添加的元素，一定需要重写hashCode()和equals()方法。且两个方法一定要保持规则的一致性，保证具有相等的散列码。</strong></p><h4 id="使用Iterator接口遍历"><a href="#使用Iterator接口遍历" class="headerlink" title="使用Iterator接口遍历"></a>使用Iterator接口遍历</h4><p>Iterator对象成为迭代器（设计模式的一种），主要用于遍历Collection集合中的元素。</p><p>迭代器定义：提供一种方法访问一个容器对象中各个元素，而不需要暴露该对象的内部细节。</p><p>Collection接口继承了java.lang.Iterable接口，因此它的实现类都提供了一个iterator()方法，它可以返回一个Iterable接口的对象，集合对象每次调用iterator()都会得到一个全新的迭代器对象，<strong>默认游标为第一个元素之前</strong>。</p><p>得到一个Iterable接口对象后，我们可以用Iterable的方法来获取集合内的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;<span class="comment">//hasNext()判断有无下一个元素</span></span><br><span class="line">   System.out.println(iterator.next());<span class="comment">//next()获取下一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterable有一个方法remove()，可以移除集合中的当前元素。</p><p>我们也可以使用for-each循环遍历集合，这样可以不使用Iterable接口。</p><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><h4 id="Map接口的常用方法"><a href="#Map接口的常用方法" class="headerlink" title="Map接口的常用方法"></a>Map接口的常用方法</h4><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202206261006879.png" alt="这里写图片描述"></p><h4 id="Map接口的实现类"><a href="#Map接口的实现类" class="headerlink" title="Map接口的实现类"></a>Map接口的实现类</h4><ul><li><p><strong>HashMap</strong>：作为Map的主要实现类。线程不安全，效率高。可以存储null的key和value。</p></li><li><p><strong>LinkedHashMap</strong>：HashMap的子类。添加了一个链表的机构，可以使得在遍历时，按照添加顺序遍历。对于频繁的遍历操作，可以使用这个实现类。</p></li><li><p><strong>TreeMap</strong>：可以按照添加的Key进行排序，按照自然排序或定制排序遍历，类似于TreeSet，底层实现为红黑树。</p><p>Map的特殊方法：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202206261211501.png" alt="这里写图片描述"></p></li><li><p><strong>Hashtable</strong>：最早的实现类，在Map出现之前就有。线程安全，效率低。不可以存储null的key和value。</p></li><li><p><strong>Properties</strong>：Hashtable的子类。常用于处理配置文件，key和value都是String类型。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>ArrayXxx:底层数据结构是数组，查询快，增删慢</li><li>LinkedXxx:底层数据结构是链表，查询慢，增删快</li><li>HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals()</li><li>TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序</li></ul><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda是一个匿名函数，可以理解为一段可以传递的代码。使用Lambda表达式可以使得我们的代码更加简洁。</p><p>Java的Lambda表达式本质是作为接口的实例。</p><p>使用举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未使用Lambda表达式</span></span><br><span class="line">Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Integer.compare(o1, o2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">compare1</span> <span class="operator">=</span> com1.compare(<span class="number">32</span>, <span class="number">31</span>);</span><br><span class="line">System.out.println(compare1);</span><br><span class="line"><span class="comment">//使用Lambda表达式</span></span><br><span class="line">Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; Integer.compare(o1, o2);</span><br><span class="line"><span class="type">int</span> <span class="variable">compare2</span> <span class="operator">=</span> com2.compare(<span class="number">32</span>, <span class="number">31</span>);</span><br><span class="line">System.out.println(compare2);</span><br><span class="line"><span class="comment">//使用方法引用</span></span><br><span class="line">Comparator&lt;Integer&gt; com3 = Integer::compare;</span><br><span class="line"><span class="type">int</span> <span class="variable">compare3</span> <span class="operator">=</span> com3.compare(<span class="number">32</span>, <span class="number">31</span>);</span><br><span class="line">System.out.println(compare3);</span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>首先我们看到举例代码内的主要部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(o1, o2) -&gt; Integer.compare(o1, o2)</span><br></pre></td></tr></table></figure><p><strong>格式：</strong><br>-&gt;    ：Lambda操作符 &#x2F; 箭头操作符<br>左侧：Lambda形参列表 实际上即为接口中抽象方法的形参<br>右侧：Lambda体 实际上即为实现的抽象方法的方法体</p><p>具体格式大致可分为六种情况：</p><ol><li><p><strong>无参无返回值</strong></p><p>不使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">runnable.run();</span><br></pre></td></tr></table></figure><p>使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">runnable2.run();</span><br></pre></td></tr></table></figure></li><li><p><strong>有参无返回值</strong></p><p>不使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con1 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;&gt;()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      System.out.println(s);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">con1.accept(<span class="string">&quot;114514&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con2 = (String s) -&gt; &#123;</span><br><span class="line">    System.out.println(s)</span><br><span class="line">&#125;;</span><br><span class="line">con2.accept(<span class="string">&quot;1919&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>数据类型省略 “类型推断”</strong></p><p>上面一种情况，编译器可以判断出数据类型，因此我们可以省略数据类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con3 = (s) -&gt; &#123;</span><br><span class="line">    System.out.println(s)</span><br><span class="line">&#125;;</span><br><span class="line">con3.accept(<span class="string">&quot;810&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>只需要一个参数时，可省略参数小括号</strong></p><p>上面的情况，因为只有一个参数，因此我们可以省略参数的小括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con2 = s -&gt; &#123;</span><br><span class="line">    System.out.println(s)</span><br><span class="line">&#125;;</span><br><span class="line">con2.accept(<span class="string">&quot;没活了&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>多参数且多条执行语句，且拥有返回值</strong></p><p>不使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;&gt;()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">      System.out.println(o1);</span><br><span class="line">      System.out.println(o2);</span><br><span class="line">      <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class="line">   System.out.println(o1);</span><br><span class="line">   System.out.println(o2);</span><br><span class="line">   <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>当Lambda体只有一条语句时，return与大括号可以省略</strong></p><p>不使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;&gt;()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2);</span><br></pre></td></tr></table></figure></li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型是 JDK 5 中引入的一个新特性，泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p><p>注：例子来源 <a href="https://pdai.tech/md/java/basic/java-basic-x-generic.html#%E6%B3%9B%E5%9E%8B%E7%B1%BB">Java 基础 - 泛型机制详解 | Java 全栈知识体系 (pdai.tech)</a></p><h3 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h3><ul><li><p>代码复用</p><p>在没有泛型的情况下，如果我们想实现不同类型的加法，我们需要每种类型都重载一个add方法（如下）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过泛型，我们可以复用为一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这就是一种模板开发的方式，在实例化前不指定T的类型，在实例化时再去指定，可以达到代码复用的作用。</p></li><li><p>类型安全</p><p>泛型中的类型在使用时指定，不需要强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;String&quot;</span>);</span><br><span class="line">list.add(<span class="number">100d</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br></pre></td></tr></table></figure><p>在使用list时，list里的元素是Object类型的，我们无法约束其中的类型，所以当我们取出元素的时候，很容易会出现类型转换错误的问题。</p><p>使用泛型可以达到类型约束的效果，提供了一个编译前的检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h3><p>泛型的使用大概分为三种类型：泛型类、泛型接口、泛型方法</p><h4 id="泛型类、泛型接口"><a href="#泛型类、泛型接口" class="headerlink" title="泛型类、泛型接口"></a>泛型类、泛型接口</h4><p>泛型类和泛型接口是一种模板化开发的思想，也就是我们提及的第一个作用。</p><p>如果定义了泛型类，在实例化时没有指定类的泛型，则认为此泛型为Object，不建议这样使用。</p><p>一个简单的泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T&gt;&#123;         <span class="comment">// 此处可以随便写标识符号，T是type的简称  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;     <span class="comment">// var的类型由T指定，即：由外部指定  </span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;  <span class="comment">// 返回值的类型由外部决定  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;  <span class="comment">// 设置的类型也由外部决定  </span></span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo06</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Point&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;String&gt;() ;     <span class="comment">// 里面的var类型为String类型  </span></span><br><span class="line">        p.setVar(<span class="string">&quot;it&quot;</span>) ;                            <span class="comment">// 设置字符串  </span></span><br><span class="line">        System.out.println(p.getVar().length()) ;   <span class="comment">// 取得字符串的长度  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多元泛型:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Notepad</span>&lt;K,V&gt;&#123;       <span class="comment">// 此处指定了两个泛型类型  </span></span><br><span class="line">    <span class="keyword">private</span> K key ;     <span class="comment">// 此变量的类型由外部决定  </span></span><br><span class="line">    <span class="keyword">private</span> V value ;   <span class="comment">// 此变量的类型由外部决定  </span></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(K key)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.key = key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(V value)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo09</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Notepad&lt;String,Integer&gt; t = <span class="literal">null</span> ;        <span class="comment">// 定义两个泛型类型的对象  </span></span><br><span class="line">        t = <span class="keyword">new</span> <span class="title class_">Notepad</span>&lt;String,Integer&gt;() ;       <span class="comment">// 里面的key为String，value为Integer  </span></span><br><span class="line">        t.setKey(<span class="string">&quot;汤姆&quot;</span>) ;        <span class="comment">// 设置第一个内容  </span></span><br><span class="line">        t.setValue(<span class="number">20</span>) ;            <span class="comment">// 设置第二个内容  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;姓名；&quot;</span> + t.getKey()) ;      <span class="comment">// 取得信息  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;，年龄；&quot;</span> + t.getValue()) ;       <span class="comment">// 取得信息  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>泛型方法的使用并不是简单将类型替换为泛型，以下例子均<strong>不是</strong>泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(K key)</span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.key = key ;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(V value)</span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.value = value ;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（十）：枚举类与注解</title>
      <link href="/2022/05/27/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
      <url>/2022/05/27/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等等。</p><h3 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h3><h4 id="方式一：通过一般类"><a href="#方式一：通过一般类" class="headerlink" title="方式一：通过一般类"></a>方式一：通过一般类</h4><ol><li>声明对象的属性：private final修饰</li><li>私有化类的构造器，并给对象属性初始化</li><li>提供当前枚举类的多个对象：public static final修饰</li><li>可选：获取枚举类的属性 getXXX() 或 toString()</li></ol><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//3.提供当前枚举类的多个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;Spring&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;Summer&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;Autumn&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;Winter&quot;</span>);</span><br><span class="line">    <span class="comment">//1.声明对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">//2.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.可选</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式二：enum关键字"><a href="#方式二：enum关键字" class="headerlink" title="方式二：enum关键字"></a>方式二：enum关键字</h4><p>在jdk5.0以后，枚举类可以使用 enum 关键字来定义，各个常量使用逗号 <strong>,</strong> 来分割。</p><p>枚举跟普通类一样可以用自己的变量、方法和构造函数，构造器只能使用 private 访问修饰符，所以外部无法调用。</p><p>枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> Season.SPRING;</span><br><span class="line">        System.out.println(spring);</span><br><span class="line">        spring.printSeason();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING, SUMMER, FALL, WINTER;</span><br><span class="line">    Season()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Season is created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printSeason</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Season is &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Season is created</span><br><span class="line">Season is created</span><br><span class="line">Season is created</span><br><span class="line">Season is created</span><br><span class="line">SPRING</span><br><span class="line">Season is SPRING</span><br></pre></td></tr></table></figure><h3 id="Enum类常用方法"><a href="#Enum类常用方法" class="headerlink" title="Enum类常用方法"></a>Enum类常用方法</h3><p>我们自定义的枚举类默认继承于java.lang.Enum类，例如默认重写了toString()方法，以及提供了很多常用方法。</p><ul><li><p>value()：返回枚举类中所有的值(返回一个数组)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Season[] values = Season.values();</span><br><span class="line"><span class="keyword">for</span> (Season s : values) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SPRING</span><br><span class="line">SUMMER</span><br><span class="line">FALL</span><br><span class="line">WINTER</span><br></pre></td></tr></table></figure></li><li><p>valueOf(String str)：返回枚举类中对象名为<code>str</code>的对象，如果没有<code>str</code>为名的枚举类。则抛出错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season</span> <span class="variable">summer</span> <span class="operator">=</span> Season.valueOf(<span class="string">&quot;SUMMER&quot;</span>);</span><br><span class="line">System.out.println(summer);<span class="comment">//out:SUMMER</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="enum关键词枚举类实现接口"><a href="#enum关键词枚举类实现接口" class="headerlink" title="enum关键词枚举类实现接口"></a>enum关键词枚举类实现接口</h3><h4 id="一：枚举类实现接口"><a href="#一：枚举类实现接口" class="headerlink" title="一：枚举类实现接口"></a>一：枚举类实现接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">   SPRING, SUoMMER, FALL, WINTER;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二：枚举类对象实现接口"><a href="#二：枚举类对象实现接口" class="headerlink" title="二：枚举类对象实现接口"></a>二：枚举类对象实现接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">   SPRING&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   SUMMER&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   &#125;, </span><br><span class="line">   FALL&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   &#125;, </span><br><span class="line">   WINTER&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（九）：多线程</title>
      <link href="/2022/05/16/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/05/16/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h3><h4 id="方式一：继承于Thread类"><a href="#方式一：继承于Thread类" class="headerlink" title="方式一：继承于Thread类"></a>方式一：继承于Thread类</h4><ol><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run()方法（将线程执行的操作写在里面）</li><li>创建Thread类子类的对象</li><li>通过此对象调用start()方法（不能通过直接调用run()方法启动线程）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">TestThread</span> <span class="variable">testThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThread</span>();</span><br><span class="line">testThread.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要两个线程同时进行的时候，我们不可以再启动一个已经start的线程的对象，需要新建一个对象。</p><p>我们还可以通过创建Thread类的匿名子类实现多线程创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><h4 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h4><ol><li>创建一个实现了Runnable接口的类</li><li>实现run()方法</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TestThread</span>()).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于实现类的对象与启动线程的对象不相同，因此一个实现类对象可以有多个线程。</p><p>开发中我们一般优先选择方式二实现Runnable接口的方式：</p><ol><li>实现没有类的单继承性的局限性</li><li>实现的方法更适合来处理多个线程有共享数据的情况</li></ol><p>二者之间有所联系：Thread类本身也是实现Runnable接口的</p><h4 id="Thread类常用方法"><a href="#Thread类常用方法" class="headerlink" title="Thread类常用方法"></a>Thread类常用方法</h4><p>void start()：启动线程，并执行run()方法</p><p>run()：线程被调度时执行的操作</p><p>String getName()：返回线程的名字</p><p>void setName()：设置线程名字</p><p>static Thread currentThread()：返回当前线程，相当于this</p><p>yiele()：释放当前线程的cpu执行权</p><p>join()：优先执行该线程，原线程进入阻塞状态，执行完该线程后再继续执行原线程</p><p>stop()：强制结束当前线程生命期（<strong>不推荐使用</strong>）</p><p>sleep(long millisec)：让当前执行的线程休眠指定millisec毫秒（进入阻塞状态）。使用该方法时，会抛出一个异常，由于父类run()方法是没有抛出异常的，因此只能使用try-catch处理异常</p><p>isAlive()：判断线程是否存活</p><h4 id="方式三：实现Callable接口"><a href="#方式三：实现Callable接口" class="headerlink" title="方式三：实现Callable接口"></a>方式三：实现Callable接口</h4><p>这种创建多线程的方式是JDK5.0新增的一种方式。与实现Runnable相比，Callable功能更强大：</p><ul><li>相比run()方法，call()方法可以有返回值</li><li>call()方法可以抛出异常</li><li>支持泛型的返回值</li><li>需要借助FutureTask类</li></ul><p>FutureTask是Future接口的唯一的实现类，它同时实现了Runnable和Future接口。它既可以作为Runnable被线程执行，也可以作为Future得到Callable的返回值。</p><p>使用过程：</p><ol><li>创建一个实现Callable的实现类</li><li>实现Call()方法，类似于run()</li><li>创建Callable实现类的对象</li><li>将Callable实现类的对象传递到FutureTask构造器中</li><li>创建Thread对象，并执行start()方法启动线程</li><li>若需要返回值，则可以使用Callable实现类的对象的get()方法返回值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//3.创建Callable实现类的对象</span></span><br><span class="line">      <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">      <span class="comment">//4.将Callable实现类的对象传递到FutureTask构造器中</span></span><br><span class="line">      <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//get()返回值即为FutureTask构造器参数的Callable实现类重写的call()方法的返回值</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">         System.out.println(<span class="string">&quot;sum = &quot;</span> + sum);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//2.实现Call()方法</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            sum += i;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式四：线程池"><a href="#方式四：线程池" class="headerlink" title="方式四：线程池"></a>方式四：线程池</h4><p>当经常需要创建和销毁、使用量比较大的资源，比如并发情况下的线程，对性能影响较大。这时候我们可以提前创建好多个线程，放入线程池中，使用时直接获取，使用完后放入池中。使用线程池有几点好处：</p><ul><li>提高响应速度</li><li>降低资源消耗</li><li>便于线程管理</li></ul><p>Java标准库提供了ExecutorService接口表示线程池，但ExecutorService只是一个接口，Java标准库提供的几个常用实现类：</p><ul><li>FixedThreadPool：线程数固定的线程池</li><li>CachedThreadPool：线程数根据任务动态调整的线程池</li><li>SingleThreadExecutor：仅单线程执行的线程池</li></ul><p>创建这些线程池的方法都被封装在Executors类中，均为<code>newXXXX</code>。</p><p>线程池多线程使用流程：</p><ol><li>创建线程池</li><li>执行指定的线程的操作，提供一个Runnable接口（execute()方法）或Callable接口（submit()方法）实现类的对象作为参数</li><li>关闭线程池</li></ol><p>例子以FixedThreadPool线程池为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">      service.execute(<span class="keyword">new</span> <span class="title class_">TestThread</span>());</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      service.shutdown();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设置线程池属性</strong></p><p>由于ExecutorService作为一个接口，里面不包含具体的方法，我们通过getClass()方法可以获取到service的类是ThreadPoolExecutor，我们前面是使用多态的方式创建的对象，导致ThreadPoolExecutor的方法不能使用，因此我们可以使用强转的方式转换为ThreadPoolExecutor类，再调用设置线程池属性的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">service2</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">service2.setCorePoolSize(<span class="number">10</span>);<span class="comment">//设置核心池大小为15</span></span><br></pre></td></tr></table></figure><h3 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h3><p>Java对于同优先级线程组成先进先出队列（先到先服务），采用“时间片”策略（切换处理），对于高优先级，使用有限调度的抢占式策略（高优先级线程抢占CPU）。</p><p>线程的优先级有三个常量：</p><ul><li>MAX_PRIORITY : 10</li><li>MIN_PRIORITY : 1</li><li>NORM_PRIORITY : 5</li></ul><p>涉及的方法：</p><ul><li>getPriority() : 返回线程优先值</li><li>setPriority(int newPriority) : 改变线程的优先级</li></ul><p>注意点：</p><p>高优先级线程抢占低线程的执行权，但是不意味需要当高优先级执行完以后，低优先级的线程才能执行，只是从概率上讲，高优先级的线程更优先被执行。</p><p>线程创建时会自动继承父线程的优先级。</p><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>线程的启动到线程的结束的整个过程被称之为线程的生命周期。</p><p>线程的生命周期中存在多种状态：</p><ol><li>新建：当一个Thread类及其子类被声明并创建时，新生的线程处于就绪状态</li><li>就绪：当新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已经具备了运行的条件，但暂时没有分配到CPU资源</li><li>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态</li><li>阻塞：在某些情况下，被人为挂起或者执行输入输出操作时，临时中止自己的执行，进入阻塞状态</li><li>死亡：线程完成了全部工作，或者线程被强制提前终止，或出现异常导致结束</li></ol><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202205201717258.png" alt="image-20220520171701160"></p><h3 id="线程的安全性问题"><a href="#线程的安全性问题" class="headerlink" title="线程的安全性问题"></a>线程的安全性问题</h3><p>当我们多个线程同时去对同一个参数进行操作时，我们往往会发现，这个参数出现多个线程同时操作时出现只操作一次的情况，举个售票的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ticketWindows</span> <span class="variable">ticketWindows</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ticketWindows</span>();</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketWindows);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketWindows);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketWindows);</span><br><span class="line">      t1.setName(<span class="string">&quot;Window1&quot;</span>);</span><br><span class="line">      t2.setName(<span class="string">&quot;Window2&quot;</span>);</span><br><span class="line">      t3.setName(<span class="string">&quot;Window3&quot;</span>);</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">      t3.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ticketWindows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行如上代码，在控制台，我们发现一个严重的问题，窗口1、2、3出现了售出同一张票的情况：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202205211739097.png" alt="image-20220521173909064"></p><p>这种就是线程的安全问题。解决方式就是当线程A在操作的时候，其他线程无法参与，直到线程A操作完成后，其他线程才可以开始操作，即使线程A出现阻塞也无法参与。</p><h4 id="同步机制解决线程安全问题"><a href="#同步机制解决线程安全问题" class="headerlink" title="同步机制解决线程安全问题"></a>同步机制解决线程安全问题</h4><p><strong>方式一：同步代码块</strong></p><p>结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line"><span class="comment">//需要被同步的代码：操作共享数据的代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享数据：多个线程共同操作的变量，比如：ticket；</p><p>同步监视器：俗称锁。任何一个类的对象都可以充当锁，但要求多个线程必须共用同一个锁。</p><p>例1：</p><p>我们将上面卖票窗口的代码修改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ticketWindows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">         <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">               ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再去检查控制台，发现没有再次出现重票错票的情况了。</p><p>但是当我们通过继承Thread的方式去创建多线程的时候，我们就发现了一个问题——他仍然出现了错票重票的情况。我们前面提到锁必须多个线程共用一个，而当我们通过继承Thread的方式创建多线程的时候，我们使用的锁<code>this</code>指代的对象并不是指代的同一个，而分别是<code>t1, t2, t3</code>，因此锁就失效了，因此我们作出对应的修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (ticketWindows.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">ticket--;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射的知识，我们可以直接将<code>ticketWindows</code>作为一个对象，充当了锁，因为<code>t1, t2, t3</code>内的<code>ticketWindows</code>都是共用的一个对象，因此，我们就没有出现线程的安全性问题了。</p><p>注意，我们用synchronized代码块包含代码时，我们仅需将操作共享数据的代码包起来即可，不能包多，包多可能会与实际情况相违背了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (ticketWindows.class) &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">         ticket--;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如这种情况，我们就会出现一个线程在操作，其他线程全部没有使用的情况。</p><p><strong>方式二：同步方法</strong></p><p>在方法定义出加上synchronized关键词可以将方法变成同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>同步方法同样是存在锁的，它的锁是<code>this</code>，因此对于继承<code>Thread</code>方法创建的多线程，直接如上使用的话一样是存在线程的安全性问题的。我们可以通过将方法写为静态的方式，解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>由于静态方法里面不能使用<code>this</code>，所以它的锁自然而然的就变成类<code>ticketWindows.class</code>。</p><p><strong>总结</strong></p><p>使用同步机制，我们解决线程的安全问题，但操作同步代码时，只能由一个线程参与，其他线程只能等待，相当于是一个单线程的过程，效率不太高。</p><p><strong>懒汉式单例改写为线程安全式</strong></p><p>在多线程调用懒汉式的<code>getInstance</code>方法时，如果我们不做保证线程安全性问题的措施，我们有可能会出现多个线程同时进入了if语句内，导致创建了多个实例，不能实现我们单例设计模式的目的。因此我们需要通过上面所学的知识，解决线程安全性问题，首先是同步方法和同步代码块的方式解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(bank == <span class="literal">null</span>)&#123;</span><br><span class="line">      bank = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bank;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Bank.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(bank == <span class="literal">null</span>)&#123;</span><br><span class="line">bank = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bank;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但者两种方式效率并不是很高，表面上是多线程执行，但实际上只能同时进行一个操作，与之前所提到的例子不同，单例设计模式线程安全性问题仅会出现在不存在实例的时候，因此我们可以在外面再包多一次if语句判断是否已经存在实例，这样就只会在实例不存在的时候，进入一次同步代码块，这样效率就高很多了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(bank == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Bank.class) &#123;</span><br><span class="line">         <span class="keyword">if</span>(bank == <span class="literal">null</span>)&#123;</span><br><span class="line">            bank = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程的死锁问题</strong></p><p>死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放出自己需要的同步资源，就形成了线程的死锁。出现死锁后，不会出现异常，不会出现提示，但所有的线程都会处于阻塞状态，无法继续执行。</p><p>我们构造两个线程，第一个线程先握住s1锁，再握住s2锁，第二个线程先握住s2锁，再握住s1锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">      <span class="type">StringBuffer</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">               s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">               s2.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">100</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">                  s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                  s2.append(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">                  System.out.println(s1);</span><br><span class="line">                  System.out.println(s2);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">               s1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">               s2.append(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">100</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">                  s1.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">                  s2.append(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">                  System.out.println(s1);</span><br><span class="line">                  System.out.println(s2);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，控制台它什么都没有显示，什么都没有提示：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202205231919190.png" alt="image-20220523191927155"></p><p>这是因为线程1抢到了s1锁，然后线程2抢到了s2锁，但是线程1又需要s2锁才能继续执行，而线程2有需要s1锁才能继续执行，然后二者就僵持住了，导致了这个结果。</p><p>解决方式：</p><ul><li>专门的算法、原则</li><li>尽量减少同步资料的定义</li><li>尽量减少嵌套同步</li></ul><h4 id="Lock锁解决线程安全问题"><a href="#Lock锁解决线程安全问题" class="headerlink" title="Lock锁解决线程安全问题"></a>Lock锁解决线程安全问题</h4><p>Lock锁是JDK5.0新增的更强大的线程同步机制，通过显式定义同步锁对象来实现同步，同步锁使用Lock对象充当。</p><p>使用的步骤：</p><ol><li>定义一个ReentrantLock类的对象，构造器内可以选择是否启用公平机制，如果填入true的话，Lock锁就会按先来后到的顺序安排线程，而不是抢占式，默认不填构造器即false</li><li>使用try-finally环绕包含执行操作过程，并在操作过程前调用锁定方法lock()</li><li>在finally内调用解锁方法unlock()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ticketWindows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="comment">// 定义一个ReentrantLock类的对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用锁定方法lock()</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">               ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 调用解锁方法unlock()</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="synchronized与Lock锁差别"><a href="#synchronized与Lock锁差别" class="headerlink" title="synchronized与Lock锁差别"></a>synchronized与Lock锁差别</h4><ul><li>Lock锁是手动锁定与解锁，是显式锁，而synchronized机制是相应代码执行完后自动解锁线程</li><li>Lock只有代码块锁，synchronized有代码锁和方法锁</li><li>Lock锁由于比较后出现，优化较好，JVM将使用较少时间来调度线程，性能更好，而且提供了更多子类</li><li>优先使用顺序：Lock ——&gt; 同步代码块 ——&gt; 同步方法</li></ul><h3 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h3><p>涉及到的方法：</p><ul><li>wait()：执行该方法会使当前线程进入阻塞状态，并释放锁</li><li>notify()：执行此方法会唤醒的被wait的线程，如果多个线程都被wait，则优先唤醒优先度高的线程</li><li>notifyAll()：执行此方法会唤醒全部被wait的线程</li></ul><p>例：使用两个线程交替售票</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ticketWindows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            notify();</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sell:&quot;</span> + ticket);</span><br><span class="line">               ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体思路就是通过wait()阻塞线程1，然后让线程2拿到锁再去唤醒线程1，执行完线程2操作后线程2进入阻塞，以此循环。</p><p><strong>注意点</strong></p><ol><li>wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中</li><li>wait()，notify()，notifyAll()三个方法调用者必须是同步代码块或同步方法的同步监视器，否则会出现异常</li><li>wait()，notify()，notifyAll()三个方法式定义在java.lang.Object类中</li></ol><p><strong>sleep()与wait()异同</strong></p><ul><li>同：都会进入阻塞状态</li><li>sleep()定义在Thread类中，wait()定义在Object类中</li><li>调用的范围：sleep()可以在任何情景下调用，wait()必须在同步代码块和同步方法中</li><li>sleep()不会释放锁，wait()会释放锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（八）：异常处理</title>
      <link href="/2022/05/10/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2022/05/10/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>异常是程序在执行过程中发生不正常的情况。</p><p>Java程序的异常情况分为两类：</p><ul><li><strong>Error：</strong>Java虚拟机无法解决的严重问题。如JVM内部错误、资源耗尽等。一般不编写针对性代码处理。</li><li><strong>Exception：</strong>其他由于编程出错或者偶发性的外在因素导致的一般性错误，则可以通过针对性的代码进行处理。如：空指针访问，试图读取不存在的文件，网络中断，数组越界等等情况。</li></ul><p>对于异常，我们拥有两种办法：第一种是不处理，直接终止程序运行。另外一种就是在编写程序的过程中，将异常的处理方法写入代码中。</p><h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><ul><li><p>NullPointerException 空指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure></li><li><p>ArrayIndexOutOfBoundsException 数组越界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(arr[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure></li><li><p>ClassCastException 类型转换错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br></pre></td></tr></table></figure></li><li><p>NumberFormatException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(str);</span><br></pre></td></tr></table></figure></li><li><p>InputMismatchException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(score);</span><br></pre></td></tr></table></figure><p>当你输入内容为非int类型时，就会报出错误。</p></li><li><p>ArithmeticException 算术异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(a / b);</span><br></pre></td></tr></table></figure></li></ul><h4 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h4><ul><li><p>IOException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line"><span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">   System.out.print((<span class="type">char</span>) data);</span><br><span class="line">   data = fis.read();</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><p>这种编译是无法通过的。</p></li></ul><h3 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h3><p>在编写程序时候，我们往往需要<code>if-else</code>分支对可能出现错误的地方进行检测，但是过多的<code>if-else</code>分支会导致代码过于臃肿。异常处理机制可以将异常处理的代码集中在一起，与正常代码分开，减少过多<code>if-else</code>分支。</p><p>Java有两种异常处理的方式，分别是<code>try-catch-finally</code>方式与<code>throws</code>方式。<code>try-catch-finally</code>方式是自行解决，<code>throws</code>方式是上报的方式，让上面去解决。</p><p>Java的异常处理是一个“抓抛模型”：“抛”是指程序执行的过程中，如果出现异常，就会生成一个对应异常类的对象，并将此对象抛出，一旦抛出异常对象以后，其后代码将不再执行。“抓”是抓取到异常对象后，对异常的处理——try-catch-finally和throws。</p><h4 id="try-catch-finally方式"><a href="#try-catch-finally方式" class="headerlink" title="try-catch-finally方式"></a>try-catch-finally方式</h4><p><strong>结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//处理异常类型1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量<span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//处理异常类型2</span></span><br><span class="line">&#125;.....</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>使用try将可能出现异常代码包装起来，在执行的过程中一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，在catch中进行匹配。进入catch后，进行异常的处理，处理完成后，就会跳出结构（在没有写finally情况下），继续执行后面代码。</p><p>在try-catch结构中申明的变量，在出了结构以后，就不可以再使用了。</p><p>使用<code>try-catch</code>处理异常时，可以使得编译时的错误延迟到运行时再出现。</p><p><code>catch</code>可以写多个。<code>finally</code>是可选的，不一定要写。</p><p><strong>try-catch基础例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">   System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;NumberFormatException&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * output:</span></span><br><span class="line"><span class="comment"> * NumberFormatException</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>由于<code>System.out.println(&quot;1&quot;);</code>是位于异常后面，因此在抛出异常后，发生异常之后的代码将不会执行。</p><h4 id="throws方式"><a href="#throws方式" class="headerlink" title="throws方式"></a>throws方式</h4><p><code>throws</code>给我个人的感觉与抽象类有点相似，<code>throws</code>就是在这个方法里我先不处理，谁调用了这个方法就由谁进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      test();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">   <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">   <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line">   <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.print((<span class="type">char</span>) data);</span><br><span class="line">      data = fis.read();</span><br><span class="line">   &#125;</span><br><span class="line">   fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何选择处理方式"><a href="#如何选择处理方式" class="headerlink" title="如何选择处理方式"></a>如何选择处理方式</h4><ol><li>如果父类中被重写的方法没有throws处理异常，则子类重写的方法如果出现异常，就只能使用try-catch-finally进行处理；</li><li>在执行的方法A中，如果需要先后调用几个具有递进关系的方法，则这几个方法使用throw的方式处理，而A方法使用try-catch-finally的方式处理；</li><li>注意：子类重写的方法抛出的异常类型不大于父类被重写方法抛出的异常类型。</li></ol><h3 id="手动抛出异常"><a href="#手动抛出异常" class="headerlink" title="手动抛出异常"></a>手动抛出异常</h3><p>异常对象可以通过跟一般对象一样，通过<code>new</code>生成异常对象。</p><p>通过<code>throw</code>关键词，我们可以将异常对象抛出。注意此处为<code>throw</code>，并非<code>throws</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.id = id;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;id must be greater than 0&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>下面是自定义的步骤</p><ol><li>自定义异常类一般我们先会让我们自定义的类继承现有的异常体系（Exception、RuntimeException）；</li><li>定义全局常量<code>serialVersionUID</code>（对类的唯一标识）；</li><li>提供重载的构造器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">NewException</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">NewException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(msg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记零碎补充（二）：包装类、单例、代码块</title>
      <link href="/2022/04/29/Java%E7%AC%94%E8%AE%B0%E9%9B%B6%E7%A2%8E%E8%A1%A5%E5%85%85%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8C%85%E8%A3%85%E7%B1%BB%E3%80%81%E5%8D%95%E4%BE%8B%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
      <url>/2022/04/29/Java%E7%AC%94%E8%AE%B0%E9%9B%B6%E7%A2%8E%E8%A1%A5%E5%85%85%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8C%85%E8%A3%85%E7%B1%BB%E3%80%81%E5%8D%95%E4%BE%8B%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>包装类是针对八种基本数据类型定义相应的引用类型。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Lnteger</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr></tbody></table><p>其中<code>Byte  Short  Lnteger  Long  Float  Double</code>拥有一个父类<code>Number</code>。</p><p>包装类的出现，使得基本数据类型可以封装起来，作为一个类使用，完善了Java面向对象的特性。</p><h3 id="包装类、基本数据类型、String相互转换"><a href="#包装类、基本数据类型、String相互转换" class="headerlink" title="包装类、基本数据类型、String相互转换"></a>包装类、基本数据类型、String相互转换</h3><p><strong>使用构造器将基本数据类型装箱</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(i1.toString());<span class="comment">//out:1</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">System.out.println(i2.toString());<span class="comment">//out:1</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">&quot;true123&quot;</span>);</span><br><span class="line">System.out.println(b2.toString());<span class="comment">//out:false</span></span><br><span class="line"><span class="comment">//Java在将布尔类型装箱时，如果不是null或者true，一律均未false</span></span><br><span class="line"><span class="comment">//布尔作为基本数据类型的时候，初值为false，作为包装类的时候，初值为null</span></span><br></pre></td></tr></table></figure><p><strong>使用包装类内置方法转换为基本数据类型</strong></p><p>包装类拥有一个<code>xxxValue</code>的方法，<code>xxx</code>是指要转换的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> i.intValue();</span><br><span class="line">System.out.println(i1);</span><br></pre></td></tr></table></figure><p><strong>自动装箱与自动拆箱</strong></p><p>这是包装类与基本数据类型之间最常用的转换方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line">   Test(i1);<span class="comment">//自动装箱</span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> i1;<span class="comment">//自动装箱</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> i2;<span class="comment">//自动拆箱</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">(Object obj)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="包装类、基本数据类型与String之间的转换"><a href="#包装类、基本数据类型与String之间的转换" class="headerlink" title="包装类、基本数据类型与String之间的转换"></a>包装类、基本数据类型与String之间的转换</h3><p><strong>包装类、基本数据类型–&gt;String</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> i1 + <span class="string">&quot;&quot;</span>;<span class="comment">//方式一</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> String.valueOf(i1);<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure><p><strong>String–&gt;包装类、基本数据类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;114514&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(str1);<span class="comment">//包装类的parseXxx方法</span></span><br></pre></td></tr></table></figure><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>单例的设计模式就是让某一个类只能存在一个对象实例，并且这个类只提供一个取得其对象实例的方法。</p><p>具体就是将类的<strong>构造器访问权限设置为<code>private</code><strong>，这样类的外部就无法访问到类的构造器，但我们可以在</strong>类的内部产生类的对象</strong>。由于在类的外部，我们无法得到类的对象，只能通过<strong>该类的某个静态方法</strong>返回类内部构建的对象，由于静态方法只能访问静态成员变量，所以，指向类内部产生的<strong>对象的变量也必须是静态的</strong>。</p><p>单例有两种实现的方式——饿汉式与懒汉式。</p><h3 id="饿汉式实现"><a href="#饿汉式实现" class="headerlink" title="饿汉式实现"></a>饿汉式实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="comment">//1.私有化类的构造器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//2.内部创建类的对象，并将其设置为静态</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">   <span class="comment">//3.提供公共的静态的方法，返回类的对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式实现"><a href="#懒汉式实现" class="headerlink" title="懒汉式实现"></a>懒汉式实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="comment">//1.初始化类的构造器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//2.声明一个静态类对象，但不进行初始化</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">//3.声明一个公共、静态的方法，返回当前类的对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;<span class="comment">//防止创建多个对象</span></span><br><span class="line">         instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例的使用"><a href="#单例的使用" class="headerlink" title="单例的使用"></a>单例的使用</h3><p>当一个实例生成需要使用大量资源的时候，使用单例可以节约系统性能的开销。单例模式应用场景其实挺常见的：</p><ul><li>应用程序的日志</li><li>网站计数器</li><li>数据库连接池</li><li>读取配置文件的类</li><li>Windows的回收站</li><li>…</li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块在Java中指的是使用<code>&#123;&#125;</code>包围起来的代码集合。代码块分为四种，普通代码块，静态代码块，同步代码块，构造代码块。后面三种代码块均为类的成员之一。由于同步的内容还未学习，所以同步代码块的内容暂时不写。</p><h3 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h3><p>普通代码块就是在方法体内定义的代码块，普通代码块和一般代码的执行顺序与书写顺序一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;普通代码块&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代码块在类被加载的时候会被执行，而且只执行一次，并且优先于各种代码块以及构造函数。如果类中含有多个代码块，则会按照代码顺序执行。</p><p>由于静态代码块的加载是优先于类的其他成员的，所以他既不能存在任何方法体中，也不能访问任何普通变量。</p><p>静态代码块用于某些代码需要启动时就执行，例如启动时加载配置文件等。</p><h3 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造代码块与静态代码块在外观上差距了一个<code>static</code>关键词。</p><p>构造代码块在创建对象时会被调用，每次创建对象时都会调用依次，且执行顺序是优先于构造函数的。实际上，构造代码块是依托于构造函数的，在编译后，构造代码块就是将里面的代码置入构造函数的最前端。</p><p>由于构造代码块每次创建对象都会执行，而构造函数不一定每个对象构造的时候都执行（多个构造函数情况下，建立对象时传入的参数不同则初始化使用对应的构造函数），利用这个特性，我们可以做统计对象创建次数等功能。</p>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门笔记（三）：分支管理</title>
      <link href="/2022/04/24/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
      <url>/2022/04/24/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Git入门笔记（三）"><a href="#Git入门笔记（三）" class="headerlink" title="Git入门笔记（三）"></a>Git入门笔记（三）</h2><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>分支管理是Git中非常重要的管理，使用分支可以使你在开发主线中分离出来，在不影响开发主线的情况下继续工作，例如开发测试版、测试功能之类的。接下来介绍几个基础操作。</p><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>现在我们需要创建一个叫<code>test</code>的分支，并切换至分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b test</span><br></pre></td></tr></table></figure><p>实际上这是两条命令的简写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch test</span><br><span class="line">git checkout test</span><br></pre></td></tr></table></figure><p>第一条命令，代表创建一个<code>test</code>分支；</p><p>第二个命令，代表切换到<code>test</code>分支。</p><h4 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h4><p>我们使用不带任何参数的<code>git branch</code>命令即可查看所有分支，并且该命令会将当前分支用<code>*</code>号标注出来。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204262039070.png" alt="image-20220426203906050"></p><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d test</span><br></pre></td></tr></table></figure><p>这样我们就删除了<code>test</code>分支了。如果<code>test</code>分支包含我们未合并到分支的更改，它会报出错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: The branch &#x27;test&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D test&#x27;.</span><br></pre></td></tr></table></figure><p>此时，我们如果的的确确不想要这些更改了，我们就按照错误信息中的操作，使用<code>-D</code>强制将它删除即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D test</span><br></pre></td></tr></table></figure><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>分支出来的往往是测试的分支，我们需要将他合并会主分区。</p><p>首先，我们切换会主分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br></pre></td></tr></table></figure><p>接着我们使用合并指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge test</span><br></pre></td></tr></table></figure><p>合并完成后我们就可以删除分支了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d test</span><br></pre></td></tr></table></figure><h4 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h4><p>合并分支肯定会出现两边在同一处地方不同修改的问题，这时，我们就需要去解决冲突。</p><p>我们现在在分支下修改一个文件，然后我再在主分支下修改同一文件，使得分支与主分支的文件不同。</p><p>当我们运行合并分支指令<code>git merge test</code>，它会报出错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Auto-merging git.md</span><br><span class="line">CONFLICT (content): Merge conflict in git.md</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p><code>git.md</code>自动合并失败了，我们需要去手动解决合并错误。这时，我们通过任何一种文本的方式打开我们冲突的文件<code>git.md</code>，Git会将冲突的地方帮我我们标注出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">First.Third.</span><br><span class="line">=======</span><br><span class="line">First.Second.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; test</span><br></pre></td></tr></table></figure><p><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>表示当前分支；</p><p><code>=======</code>是分割线；</p><p><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; test</code>表示Test分支。</p><p>接下来，我们根据实际情况，保留我们需要的部分，将文件进行修改，这里我们演示将两个部分合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">First.Third.</span><br><span class="line">First.Second.</span><br></pre></td></tr></table></figure><p>解决冲突内容后，我们使用提交到本地库的操作，将修改后的文件提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .\git.md</span><br><span class="line">git commit -m &#x27;主干分支冲突解决&#x27;</span><br></pre></td></tr></table></figure><p>这时，我们就解决了合并冲突了。最后我们可以将不需要的分支删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d test</span><br></pre></td></tr></table></figure><p>我们的本地分支合并工作就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> 新技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门笔记（二）：远程仓库</title>
      <link href="/2022/04/22/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>/2022/04/22/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Git入门笔记（二）"><a href="#Git入门笔记（二）" class="headerlink" title="Git入门笔记（二）"></a>Git入门笔记（二）</h2><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="克隆项目到本地"><a href="#克隆项目到本地" class="headerlink" title="克隆项目到本地"></a>克隆项目到本地</h4><p>很简单，<code>git clone &lt;url&gt;</code>在url填入远程仓库的地址就可以clone到本地了，url处有两种地址，一种是通过SSH进行克隆，另外一种是通过HTTPS的方式进行克隆。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221855787.png" alt="image-20220422185525713" style="zoom:67%;" /><p>上面为SSH的方式，下面为HTTPS的方式。</p><h4 id="初始化远程仓库"><a href="#初始化远程仓库" class="headerlink" title="初始化远程仓库"></a>初始化远程仓库</h4><h5 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h5><p>以GitHub为例子，具体账号与仓库创建不再赘述。</p><p>仓库创建好了之后，我们看到我们的仓库是没有初始化的，GitHub页面上会出现一个初始化的教程。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204222053081.png" alt="image-20220422205301003" style="zoom: 33%;" /><p>我们照着教程上初始化即可，简单来说，它的初始化过程就是，先生成一个<code>README.md</code>，接着创建一个本地仓库，提交<code>README.md</code>到本地仓库，然后将本地仓库推送到远程仓库，即可完成初始化。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204222103895.png" alt="image-20220422210303739" style="zoom: 40%;" /><h5 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h5><p>Git支持多种协议，其中包括SSH，SSH速度相当不错，比HTTPS效果更佳。我们来配置一下SSH。</p><p>第一步，我们检查一下电脑上是否已经存在<code>SSH Key</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>如果显示出存在<code>id_rsa.pub</code>或<code> id_dsa.pub</code>文件时，则证明已经存在<code>SSH Key</code>，可以跳过第二步。</p><p>第二步，创建<code>SSH Key</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>如果你的电脑不支持<code>ed25519</code>的加密格式，我们也可以使用传统的<code>rsa</code>加密：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>我们可以来看看参数的含义：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-b</td><td>指定密钥长度</td></tr><tr><td>-e</td><td>读取openssh的私钥或者公钥文件</td></tr><tr><td>-f</td><td>指定用于保存密钥的文件名</td></tr><tr><td>-t</td><td>指定密钥类型</td></tr><tr><td>-C</td><td>添加注释，往往以邮箱作为注释</td></tr></tbody></table><p>通常的，我们可以省略<code>-b</code>参数。<code>-f</code>参数会在后面提示中让你填写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/yourusersname/.ssh/id_rsa): [Press enter]</span></span><br></pre></td></tr></table></figure><p>这里推荐使用默认即可，接着会提醒是输入两次密码，此密码为push时使用的密码，不是GitHub的密码，我们可以不输入，这样在push时就不需要密码了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span> </span><br><span class="line"><span class="meta"># </span><span class="language-bash">Enter same passphrase again:</span></span><br></pre></td></tr></table></figure><p>接下来，就会出现代码提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Your identification has been saved <span class="keyword">in</span> /c/Users/yourusersname/.ssh/id_rsa.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Your public key has been saved <span class="keyword">in</span> /c/Users/yourusersname/.ssh/id_rsa.pub.</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>意味着你的<code>SSH Key</code>就创建好了，公钥就是<code>/c/Users/yourusersname/.ssh/id_rsa.pub</code>、私钥是<code>/c/Users/yourusersname/.ssh/id_rsa</code>。</p><p>第三步，添加<code>SSH Key</code>至Github。</p><p>用任何文本编辑器打开你的公钥<code>id_rsa.pub</code>，复制文件内所有信息。</p><p>打开你的Github，点击你的头像，选择<code>settings</code>，然后再<code>Access</code>中找到<code>SSH and GPG keys</code>选项，选择<code>New SSH key</code>。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204242038466.png" alt="image-20220424203852243"></p><p>在<code>title</code>填入你想给这个<code>SSH Key</code>的备注，在<code>Key</code>中粘贴进刚刚复制的信息，点击<code>Add SSH key</code>即可。</p><p>这样就添加成功<code>SSH Key</code>了。</p><p>第四步，测试SSH Key。</p><p>打开Git Bash，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>出现提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">The authenticity of host <span class="string">&#x27;github.com (207.97.227.239)&#x27;</span> can<span class="string">&#x27;t be established.</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">RSA key fingerprint is （你的密钥）</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span></span><br></pre></td></tr></table></figure><p>输入<code>yes</code>即可，若创建时使用了密码，这时就需要输入你的密码。</p><p>完成后就会出现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Hi username! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">provide shell access.</span></span></span><br></pre></td></tr></table></figure><p>这样，你的Github的SSH设置就算完成了。</p><p>接下来初始化的步骤，与HTTPS几乎没有什么区别，按照Github上提示完成即可。</p><p>[^参考资料2]: <a href="https://docs.github.com/cn/authentication/connecting-to-github-with-ssh">使用 SSH 连接到 GitHub - GitHub Docs</a></p><h4 id="从远程仓库更新"><a href="#从远程仓库更新" class="headerlink" title="从远程仓库更新"></a>从远程仓库更新</h4><p>有两种方法，第一种比较安全，第二种比较方便。</p><h5 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h5><p>我们需要两个步骤：</p><ol><li>从远程仓库中抓取与拉取</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure><p>这个命令可以从远程仓库中下载数据到本地仓库，但没有进行合并。</p><p>我们clone了一个远程仓库，命令会自动将远程仓库命名为<code>origin</code>，一般来说，我们在本地仓库的文件夹内，使用<code>origin</code>作为<code>&lt;remote&gt;</code>即可，即</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure><ol start="2"><li>合并到本地仓库分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;remote&gt;/&lt;branch&gt;</span><br></pre></td></tr></table></figure><p>这个命令的意思是，将<code>&lt;remote&gt;/&lt;branch&gt;</code>分支与主合并。</p><p><code>&lt;remote&gt;/&lt;branch&gt;</code>是我们从远程仓库下载下来的分支，在Github中，主分支被命名为<code>main</code>，因此，我们从Github远程仓库下载下来的主分支名字一般都为<code>main</code>，所以我们要将远程下载下来的主分支与本地仓库当前分支合并，运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/main</span><br></pre></td></tr></table></figure><h5 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h5><p>这个命令相当于是将上面两个命令合二为一，即抓取数据并自动尝试合并到当前所在的分支。使用很简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote&gt; &lt;remote branch&gt;:&lt;local branch&gt;</span><br></pre></td></tr></table></figure><p>意思是从<code>remote</code>远程仓库中拉取<code>remote branch</code>分支，并与本地的<code>local branch</code>分支合并：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main:main</span><br></pre></td></tr></table></figure><p>如果远程分支是与当前分支合并，则冒号后面可以省略：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p>推送到远程仓库的命令，与上面<code>git pull</code>的命令格式非常相似：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</span><br></pre></td></tr></table></figure><p>意思是将本地仓库<code>local branch</code>分支与<code>remote</code>远程仓库中的<code>remote branch</code>分支合并。</p><p>如果远程分支名与本地分支名相同，则可以省略冒号后面的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote&gt; &lt;local branch&gt;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure><p>意思为将本地的<code>mian</code>分支推送到远程仓库，并于其中的<code>main</code>分支合并。</p><p>使用这个命令，我们还可以删除远程仓库中的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete testbranch</span><br></pre></td></tr></table></figure><p>意思是删除远程仓库中<code>testbranch</code>分支。</p>]]></content>
      
      
      <categories>
          
          <category> 新技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门笔记（一）：基本知识与基本操作</title>
      <link href="/2022/04/19/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/04/19/Git%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Git入门笔记（一）"><a href="#Git入门笔记（一）" class="headerlink" title="Git入门笔记（一）"></a>Git入门笔记（一）</h2><p>Git是一个非常常用的版本控制软件，很多被广泛使用的软件项目都是使用Git进行版本控制的。</p><p>本教程将不包括基础的安装流程。</p><h3 id="Git文件的三种状态"><a href="#Git文件的三种状态" class="headerlink" title="Git文件的三种状态"></a>Git文件的三种状态</h3><p>使用Git进行操作软件时，文件状态有三种：</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>已提交(committed)</td><td>表示文件已经保存在本地Git库中。</td></tr><tr><td>已修改(modifiled)</td><td>表示文件已修改，但暂未保存到Git库中。</td></tr><tr><td>已暂存(staged)</td><td>表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</td></tr></tbody></table><p>由于Git提交文件到Git库时，并不是直接从工作区直接到Git库的，中间存在一个暂存区(staging area)，这个过程的文件就被称之为<code>已暂存</code>。</p><h4 id="Git项目的三个工作区域"><a href="#Git项目的三个工作区域" class="headerlink" title="Git项目的三个工作区域"></a>Git项目的三个工作区域</h4><p>针对Git文件的三种状态，Git项目分为三个区域：</p><table><thead><tr><th>区域</th><th>描述</th></tr></thead><tbody><tr><td>工作区</td><td>简单来说就是本地看到的目录。</td></tr><tr><td>暂存区(stage &#x2F; index)</td><td>一般存放在<code>.git</code>目录下，里面包含了Git自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针<code>HEAD</code>。</td></tr><tr><td>Git仓库(版本库)</td><td>工作区下隐藏的目录<code>.git</code>，是Git的版本库（仓库）。</td></tr></tbody></table><h4 id="Git基本工作流程"><a href="#Git基本工作流程" class="headerlink" title="Git基本工作流程"></a>Git基本工作流程</h4><ul><li>工作区修改文件</li><li>对修改后的文件暂存</li><li>提交更新，将暂存的文件转储到Git仓库内</li></ul><h3 id="创建仓库与提交文件"><a href="#创建仓库与提交文件" class="headerlink" title="创建仓库与提交文件"></a>创建仓库与提交文件</h3><h4 id="初始化Git本地仓库"><a href="#初始化Git本地仓库" class="headerlink" title="初始化Git本地仓库"></a>初始化Git本地仓库</h4><p>在Git的命令行窗口，使用<code>git init</code>命令可以在本地初始化一个空仓库。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201215657.png" alt="image-20220420121506627" style="zoom:125%;" /><h4 id="提交文件至暂存区"><a href="#提交文件至暂存区" class="headerlink" title="提交文件至暂存区"></a>提交文件至暂存区</h4><p>我们可以使用<code>git add &lt;path&gt;</code>的命令，使一个位于<code>path</code>的文件或者目录添加至暂存区。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201221833.png" alt="image-20220420122135812" style="zoom:130%;" /><p>之后我们可以通过<code>git status</code>的命令，查看工作区与暂存区的文件状态。该命令可以查看到哪些修改被暂存，哪些修改没有，或是哪些文件没有被git追踪到（Untracked files）。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201222564.png" alt="image-20220420122243543"></p><h4 id="提交至本地仓库"><a href="#提交至本地仓库" class="headerlink" title="提交至本地仓库"></a>提交至本地仓库</h4><p>执行<code>git commit</code>命令可以提交暂存区的文件至本地仓库中。通常在使用该命令时，会选择加入<code>-m &lt;text&gt;</code>参数，我们可以在<code>&lt;text&gt;</code>处填入本次提交的说明。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201237212.png" alt="image-20220420123716186" style="zoom: 67%;" /><p>如果加入<code>-a &lt;file&gt;</code>参数，我们将不需要执行<code>git add</code>命令，直接将<code>file</code>提交至本地仓库。</p><p>我们也可以在<code>git commit</code>后加入<code>&lt;file1&gt; &lt;file2&gt; ....</code>文件参数，指定暂存区的某文件到本地仓库。</p><h4 id="查看提交日志信息"><a href="#查看提交日志信息" class="headerlink" title="查看提交日志信息"></a>查看提交日志信息</h4><p>使用<code>git log</code>命令，我们可以查看到提交日志信息。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201238061.png" alt="image-20220420123842023" style="zoom: 80%;" /><h4 id="修改文件并提交"><a href="#修改文件并提交" class="headerlink" title="修改文件并提交"></a>修改文件并提交</h4><p>实际上修改文件并提交的过程与上面新增一个文件并提交的过程并无太大差异。</p><p>首先我们可以用<code>git status</code>命令来查看我们已修改（modified）的文件。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201351883.png" alt="image-20220420135140855"></p><p>我们可以得知的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">On branch master 在主分支</span><br><span class="line">Changes not staged for commit: 更改没有被保存至暂存区</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) 使用git add命令保存更改至暂存区</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) 使用git restore放弃工作区的更改</span><br><span class="line">        modified:   git2.md 已更改文件： git2.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 没有要提交的更改（可以使用git add或git commit -a提交更改）</span><br></pre></td></tr></table></figure><p>通常的，我们会使用<code>git status -s</code>来获取简短的输出结果：</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201405965.png" alt="image-20220420140501938"></p><p>一个红色的M表示更改未保存至暂存区，一个绿色M表示更改已保存至暂存区，当同时出现一个红和一个绿M时候，则表示添加至暂存区后又发生了更改。</p><p>我们使用<code>git add</code>提交后，就可以执行<code>git commit -m</code>来使我们暂存区的更改保存到本地仓库中了。</p><h4 id="比较文件不同"><a href="#比较文件不同" class="headerlink" title="比较文件不同"></a>比较文件不同</h4><p>我们使用<code>git diff &lt;file&gt;</code>命令，可以比较文件的不同，当不加入额外参数时，它的作用是查看尚未保存至暂存区的更改。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201426753.png" alt="image-20220420142630702"></p><p>当我们加入<code>--cached</code>或是<code>--staged</code>参数时，作用是查看已保存至暂存区的更改。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201427778.png" alt="image-20220420142702736"></p><p>当我们加入<code>HEAD</code>参数时，我们将可以看到已保存至暂存区和未保存的全部更改。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201430943.png" alt="image-20220420143033890"></p><p>而<code>--stat</code>参数的加入，可以使其仅展示摘要，而不是完整的修改内容。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201432715.png" alt="image-20220420143210685"></p><h4 id="撤销暂存区更改"><a href="#撤销暂存区更改" class="headerlink" title="撤销暂存区更改"></a>撤销暂存区更改</h4><p>执行<code>git reset HEAD &lt;file&gt;</code>我们可以撤销已保存至暂存区的更改。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204201439223.png" alt="image-20220420143909172"></p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><p>在学习版本回退之前，先补充一下<code>git log</code>指令的相关参数详解。</p><p><code>--oneline </code>参数可以查看历史记录的简洁版本。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204211604452.png" alt="image-20220421160458412" style="zoom: 70%;" /><p><code>--graph</code>参数可以以拓扑图的形式，展示历史中出现的分支、合并。</p><p><code>--reverse</code>参数用于逆向显示日志。</p><p><code>--author=name</code>参数用于查询名为<code>name</code>这个人的提交日志。</p><p><code>-&lt;number&gt;</code>参数可以显示近<number>次数的提交日志。</p><h4 id="版本回退-1"><a href="#版本回退-1" class="headerlink" title="版本回退"></a>版本回退</h4><p>前面我们提及了一个撤销暂存区更改的命令<code>git reset HEAD &lt;file&gt;</code>，实际上这个命令是版本回退命令的一个使用，现在我们来详解这个命令。</p><p><code>--hard</code>参数撤销工作区所有未提交的修改内容，将工作区与暂存区都回退到上一个版本。</p><p><code>HEAD</code>参数：</p><ul><li><code>HEAD</code>表示当前版本</li><li><code>HEAD^</code>表示上版本，以此类推，<code>HEAD^^</code>表示上上个版本等等</li><li><code>HEAD~0</code>表示当前版本</li><li><code>HEAD~1</code>表示上个版本，以此类推，<code>HEAD~50</code>表示上50个版本</li></ul><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221627089.png" alt="image-20220422162741046" style="zoom:50%;" /><p><code>aabbcc</code>这个aabbcc代表的是版本唯一的标识码，我们可以用这个参数来指定回退到某以aabbcc作为版本唯一标识码的版本。</p><p>当我们后悔了，需要“回到未来”怎么办呢，我们可以用到<code>git reflog</code>的命令，来查看你每一次的操作，并且获得操作的标识码，这样就可以获得某个版本的<code>commit id</code>，也就是标识码了。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221632822.png" alt="image-20220422163214788" style="zoom: 67%;" /><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221627655.png" alt="image-20220422162701602" style="zoom: 50%;" /><h3 id="文件从本地仓库恢复"><a href="#文件从本地仓库恢复" class="headerlink" title="文件从本地仓库恢复"></a>文件从本地仓库恢复</h3><p>如果我们在工作区误删了文件，我们需要用到一个命令<code>git checkout -- &lt;file&gt;</code>，这个命令可以帮助我们从本地仓库中恢复<code>file</code>文件。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221648927.png" alt="image-20220422164852884" style="zoom: 50%;" /><h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><p>首先，我们可以在资源管理器中将工作区的文件删除，使用<code>git status</code>就可以看到我们确实删除了一个文件。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221656455.png" alt="image-20220422165616423" style="zoom: 67%;" /><p>然后我们可以使用<code>git rm &lt;file&gt; </code>的指令，确定删除该文件，接着我们用<code>git commit</code>将我们这个更改上传至本地仓库，这样文件就在本地仓库被删除了。</p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/202204221701131.png" alt="image-20220422170159105" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 新技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（七）：反射</title>
      <link href="/2022/03/31/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/03/31/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>据我们所知，Java是一种静态语言。但是Java却可以通过<code>Reflection（反射）</code>实现动态语言的特性，反射机制允许在执行期间借助<code>Reflection API</code>取得任何类的内部信息，并且能直接操作任意对象的内部属性及方法。</p><p>反射对象相当于是一面镜子，通过镜子，”反射”得到对象的信息：某个类的属性、方法、构造器、实现的接口。</p><h3 id="获得反射对象"><a href="#获得反射对象" class="headerlink" title="获得反射对象"></a>获得反射对象</h3><h4 id="通过对象获得"><a href="#通过对象获得" class="headerlink" title="通过对象获得"></a>通过对象获得</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> person.getClass();</span><br></pre></td></tr></table></figure><h4 id="通过forname获得"><a href="#通过forname获得" class="headerlink" title="通过forname获得"></a>通过<code>forname</code>获得</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.icewindy.test.Person&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="通过类名-class获得"><a href="#通过类名-class获得" class="headerlink" title="通过类名.class获得"></a>通过类名.class获得</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Person.class;</span><br></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;c1:%s,c2:%s,c3:%s\n&quot;</span>, c1.hashCode(), c2.hashCode(), c3.hashCode());<span class="comment">//output:c1:295530567,c2:295530567,c3:295530567</span></span><br></pre></td></tr></table></figure><h4 id="基本内置类型的包装类都有一个TYPE属性"><a href="#基本内置类型的包装类都有一个TYPE属性" class="headerlink" title="基本内置类型的包装类都有一个TYPE属性"></a>基本内置类型的包装类都有一个<code>TYPE</code>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> Integer.TYPE;</span><br></pre></td></tr></table></figure><h4 id="获得父类类型"><a href="#获得父类类型" class="headerlink" title="获得父类类型"></a>获得父类类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> student.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> c4.getSuperclass();</span><br><span class="line">System.out.printf(<span class="string">&quot;c5:%s\n&quot;</span>, c5.hashCode());<span class="comment">//output:c5:295530567</span></span><br></pre></td></tr></table></figure><h3 id="拥有Class对象的类型"><a href="#拥有Class对象的类型" class="headerlink" title="拥有Class对象的类型"></a>拥有Class对象的类型</h3><p>class 各种类、interface 接口、[] 数组、enum 枚举、annotation 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Object.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Comparable.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> String[].class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="type">int</span>[][].class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> Override.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c6</span> <span class="operator">=</span> ElementType.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c7</span> <span class="operator">=</span> Integer.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c8</span> <span class="operator">=</span> <span class="keyword">void</span>.class;<span class="comment">//小写v表示void基本数据类型，大写V表示void的自动装箱类型</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c9</span> <span class="operator">=</span> Class.class;</span><br><span class="line"></span><br><span class="line">System.out.println(c1);<span class="comment">//output:class java.lang.Object</span></span><br><span class="line">System.out.println(c2);<span class="comment">//output:class java.lang.Comparable</span></span><br><span class="line">System.out.println(c3);<span class="comment">//output:class [Ljava.lang.String; ,一维数组用一个[</span></span><br><span class="line">System.out.println(c4);<span class="comment">//output:class [[I ,二维数组用两个[</span></span><br><span class="line">System.out.println(c5);<span class="comment">//output:interface java.lang.Override</span></span><br><span class="line">System.out.println(c6);<span class="comment">//output:enum java.lang.annotation.ElementType</span></span><br><span class="line">System.out.println(c7);<span class="comment">//output:class java.lang.Integer</span></span><br><span class="line">System.out.println(c8);<span class="comment">//output:void</span></span><br><span class="line">System.out.println(c9);<span class="comment">//output:class java.lang.Class</span></span><br></pre></td></tr></table></figure><h3 id="类加载过程分析"><a href="#类加载过程分析" class="headerlink" title="类加载过程分析"></a>类加载过程分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">System.out.println(a.m);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.加载到内存，产生一个类对应的java.lang.Class对象</span></span><br><span class="line"><span class="comment"> * 2.链接JVM，为类变量（静态变量）分配内存并设置为默认初始化值</span></span><br><span class="line"><span class="comment"> * 3.初始化类，调用类构造器&lt;clinit&gt;()将代码块合并</span></span><br><span class="line"><span class="comment"> * &lt;clinit&gt;()&#123;</span></span><br><span class="line"><span class="comment"> * System.out.println(&quot;A静态代码块初始化&quot;);</span></span><br><span class="line"><span class="comment"> *    m = 300;</span></span><br><span class="line"><span class="comment"> * m = 100;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A静态代码块初始化&quot;</span>);</span><br><span class="line">m = <span class="number">300</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A构造函数初始化&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>out:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A静态代码块初始化</span><br><span class="line">A构造函数初始化</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h4 id="类的初始化发生"><a href="#类的初始化发生" class="headerlink" title="类的初始化发生"></a>类的初始化发生</h4><h5 id="类的主动引用（会发生初始化）"><a href="#类的主动引用（会发生初始化）" class="headerlink" title="类的主动引用（会发生初始化）"></a>类的主动引用（会发生初始化）</h5><ol><li>JVM启动，初始化main方法所在的类</li><li>new一个类的对象</li><li>调用类的静态成员（除了常量final）和静态方法</li><li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用</li><li>当初始化一个类，如果父类没有被初始化，则先初始化父类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Main类被加载&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="comment">/*out:</span></span><br><span class="line"><span class="comment"> * Main类被加载 --1</span></span><br><span class="line"><span class="comment"> * 父类被加载   --5</span></span><br><span class="line"><span class="comment"> * 子类被加载   --2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class.forName(<span class="string">&quot;cn.icewindy.test.Son&quot;</span>);</span><br><span class="line"><span class="comment">/*out: --4</span></span><br><span class="line"><span class="comment"> * Main类被加载</span></span><br><span class="line"><span class="comment"> * 父类被加载</span></span><br><span class="line"><span class="comment"> * 子类被加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;父类被加载&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;子类被加载&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类的被动引用（不会发生初始化）"><a href="#类的被动引用（不会发生初始化）" class="headerlink" title="类的被动引用（不会发生初始化）"></a>类的被动引用（不会发生初始化）</h5><ol><li>当访问一个静态域，只有真正申明这个域的类才会被初始化。如：通过子类引用父类的静态变量，不会导致子类初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Father.a);</span><br><span class="line">System.out.println(Son.a);</span><br><span class="line"><span class="comment">/* out:    --1</span></span><br><span class="line"><span class="comment"> * Main类被加载</span></span><br><span class="line"><span class="comment"> * 父类被加载</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过数组定义类的引用，不会发生此类初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Son[] arraySon = <span class="keyword">new</span> <span class="title class_">Son</span>[<span class="number">5</span>];<span class="comment">//out: Main类被加载</span></span><br></pre></td></tr></table></figure><ol start="3"><li>引用常量不会触发类的初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Son.b);</span><br><span class="line"><span class="comment">/* out:</span></span><br><span class="line"><span class="comment"> * Main类被加载</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="获取类的结构"><a href="#获取类的结构" class="headerlink" title="获取类的结构"></a>获取类的结构</h3><h4 id="获取类的名称"><a href="#获取类的名称" class="headerlink" title="获取类的名称"></a>获取类的名称</h4><ul><li><p><code>getName()</code>可以获取包名+类名；</p></li><li><p><code>getSimpleName()</code>可以获取类名。</p></li></ul><h4 id="获取类的属性"><a href="#获取类的属性" class="headerlink" title="获取类的属性"></a>获取类的属性</h4><ul><li><code>Field getField(name)</code>根据<code>name</code>获取某个<code>public</code>的属性（包括父类）；</li><li><code>Field getDeclaredField(name)</code>根据<code>name</code>获取某个属性（不包括父类）；</li><li><code>Field[] getFields()</code>获取所有<code>public</code>的属性（包括父类）；</li><li><code>Field[] getDeclaredFields()</code>获取所有属性（不包括父类）。</li></ul><h4 id="获得属性的值"><a href="#获得属性的值" class="headerlink" title="获得属性的值"></a>获得属性的值</h4><ul><li><code>Field.get(Object)</code>根据<code>Object</code>实例获取其对应属性的值。</li></ul><h4 id="获取类的方法"><a href="#获取类的方法" class="headerlink" title="获取类的方法"></a>获取类的方法</h4><ul><li><code>Method getMethod(name, Class...)</code>获取某个<code>public</code>的方法（包括父类）<code>Classs</code>代表参数类型；</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取某个方法（不包括父类）<code>Classs</code>代表参数类型；</li><li><code>Method[] getMethods()</code>获取所有<code>public</code>的方法（包括父类）；</li><li><code>Method[] getDeclaredMethods()</code>获取所有方法（不包括父类）。</li></ul><h4 id="获取类的构造器"><a href="#获取类的构造器" class="headerlink" title="获取类的构造器"></a>获取类的构造器</h4><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的构造器；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个构造器；</li><li><code>getConstructors()</code>：获取<code>public</code>的构造器；</li><li><code>getDeclaredConstructors()</code>：获取所有构造器。</li></ul><h4 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line">      <span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.icewindy.test.Student&quot;</span>);</span><br><span class="line">      <span class="comment">//获得类的名字</span></span><br><span class="line">      System.out.println(s.getName());      <span class="comment">//out:cn.icewindy.test.Student</span></span><br><span class="line">      System.out.println(s.getSimpleName());<span class="comment">//out:Student</span></span><br><span class="line">      <span class="comment">//获得类的属性</span></span><br><span class="line">      Field[] fields = s.getDeclaredFields();<span class="comment">//获取所有field（不包括父类）</span></span><br><span class="line">      <span class="keyword">for</span> (Field field : fields) &#123;           <span class="comment">//out:</span></span><br><span class="line">         System.out.println(field);         <span class="comment">//private int cn.icewindy.test.Student.ID</span></span><br><span class="line">      &#125;</span><br><span class="line">      Field[] fields2 = s.getFields();<span class="comment">//获取所有public的field（包括父类）</span></span><br><span class="line">      <span class="keyword">for</span> (Field field : fields2) &#123;  <span class="comment">//output:</span></span><br><span class="line">         System.out.println(field);  <span class="comment">//public java.lang.String cn.icewindy.test.Person.name</span></span><br><span class="line">      &#125;                       <span class="comment">//public int cn.icewindy.test.Person.age</span></span><br><span class="line">      <span class="comment">//获得属性的值</span></span><br><span class="line">      <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> s.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">      <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(<span class="keyword">new</span> <span class="title class_">Student</span>());<span class="comment">//多态</span></span><br><span class="line">      System.out.println(value);        <span class="comment">//out:icewindy</span></span><br><span class="line">      <span class="comment">//获得类的方法</span></span><br><span class="line">      Method[] methods = s.getMethods();<span class="comment">//获取所有public的method（包括父类）</span></span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;      <span class="comment">//output:太长了，省略，包括了Object的方法</span></span><br><span class="line">         System.out.println(method);</span><br><span class="line">      &#125;</span><br><span class="line">      Method[] methods2 = s.getDeclaredMethods();<span class="comment">//获取所有method（不包括父类）</span></span><br><span class="line">      <span class="keyword">for</span>(Method method : methods2)&#123;             <span class="comment">//output:</span></span><br><span class="line">         System.out.println(method);             <span class="comment">//public void cn.icewindy.test.Student.study()</span></span><br><span class="line">      &#125;                                <span class="comment">//private void cn.icewindy.test.Student.talk()</span></span><br><span class="line">      <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> s.getMethod(<span class="string">&quot;say&quot;</span>, String.class);<span class="comment">//获取指定method</span></span><br><span class="line">      System.out.println(method);                 <span class="comment">//output:public void cn.icewindy.test.Student.say(java.lang.String)</span></span><br><span class="line">      <span class="comment">//获取类的构造器</span></span><br><span class="line">      Constructor[] constructors = s.getConstructors();<span class="comment">//获取所有public的constructor（包括父类）</span></span><br><span class="line">      <span class="keyword">for</span>(Constructor constructor : constructors)&#123;<span class="comment">//output:public cn.icewindy.test.Student()</span></span><br><span class="line">         System.out.println(constructor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;icewindy&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;I am a Student&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ID</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Student is studying&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">talk</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String str)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Student is saying: &quot;</span>+str);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><h4 id="调用构造器"><a href="#调用构造器" class="headerlink" title="调用构造器"></a>调用构造器</h4><h4 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h4>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记零碎补充（一）：大数、用var声明局部变量、字符串</title>
      <link href="/2022/03/29/Java%E7%AC%94%E8%AE%B0%E9%9B%B6%E7%A2%8E%E8%A1%A5%E5%85%85%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%A4%A7%E6%95%B0%E3%80%81%E7%94%A8var%E5%A3%B0%E6%98%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/03/29/Java%E7%AC%94%E8%AE%B0%E9%9B%B6%E7%A2%8E%E8%A1%A5%E5%85%85%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%A4%A7%E6%95%B0%E3%80%81%E7%94%A8var%E5%A3%B0%E6%98%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h2><p>当基本的整数和浮点数精度不能够满足你的需求的时候，我们就可以引入在<code>java.math</code>包中的两个类——<code>BigInteger</code>和<code>BigDecimal</code>。这两个类可以处理任意长度的数值。</p><p><code>BigInteger</code>类可以处理任何精度的<code>整数运算</code>，而<code>BigDecimal</code>类可以处理任何精度的<code>浮点数运算</code>。</p><p>它们的使用方法非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;...&quot;</span>);<span class="comment">//大整数</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;...&quot;</span>);<span class="comment">//大浮点数</span></span><br></pre></td></tr></table></figure><p><code>bi / bd</code>处可以填入任意你想叫的名字，当然，最好还是尊重一下命名规则，除非你想让你的代码无人能够流畅阅读，甚至是刚睡了一觉的你。而<code>...</code>处是填入你想要的给<code>bi / bd</code>赋的数值。</p><p>我们也可以使用静态的<code>valueOf</code>方法将普通的数转换为大数，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">100</span>);<span class="comment">//100这里可以改成别的数或者是变量</span></span><br></pre></td></tr></table></figure><p>由于大数不是基础数据类型，我们就无法使用熟悉的算数运算符来处理大数，而是应该使用大数类型中的方法，下表列出最常见的运算：</p><p>BigInteger：</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>add(BigInteger other)</td><td>做加法运算</td></tr><tr><td>subtract(BigInteger other)</td><td>做减法运算</td></tr><tr><td>multiply(BigInteger other)</td><td>做乘法运算</td></tr><tr><td>divide(BigInteger other)</td><td>做除法运算</td></tr><tr><td>remainder(BigInteger other)</td><td>做取余数运算</td></tr><tr><td>pow(int n)</td><td>做n次方运算</td></tr><tr><td>mod(BigInteger other)</td><td>返回两个大数的和、差、积、商、余数</td></tr></tbody></table><p>BigDecimal：</p><p><code>BigDecimal</code>基本运算大致与<code>BigInteger</code>相同，但除法有所不同，因为需要考虑到除不尽末尾小数的处理方法。</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>add(BigDecimal other)</td><td>做加法运算</td></tr><tr><td>subtract(BigDecimal other)</td><td>做减法运算</td></tr><tr><td>multiply(BigDecimal other)</td><td>做乘法运算</td></tr><tr><td>divide(BigDecimal other)</td><td>做除法运算</td></tr><tr><td>divide(BigDecimal other，int scale,  roundingMode)</td><td>做除法运算，三个参数分别代表除数，商后的位数，近似值的处理模式</td></tr></tbody></table><p>近似值的处理模式有太多种了，这里只介绍一个，即最常见的四舍五入——<code>ROUND_HALF_UP</code>。</p><p>来个例子吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">BigDecimal</span> <span class="variable">bd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1234567890123456789012345678901234567890&quot;</span>);</span><br><span class="line">      <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;9876543210987654321098765432109876543210&quot;</span>);</span><br><span class="line">      <span class="type">BigDecimal</span> <span class="variable">bd3</span> <span class="operator">=</span> bd1.divide(bd2, <span class="number">10</span>, BigDecimal.ROUND_HALF_UP);</span><br><span class="line">      System.out.println(bd3);<span class="comment">//out:0.1249999989</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用var声明局部变量"><a href="#用var声明局部变量" class="headerlink" title="用var声明局部变量"></a>用var声明局部变量</h2><p>在Java10以上的版本，对于可以从变量初始值推导出他们的类型的，可以用<code>var</code>关键词声明局部变量。</p><p>注意，一定是在Java10以上的版本，<code>var</code>关键词是在该版本才引入的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;a&quot;</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure><p><code>var</code>关键词避免了重复写类型名，优化了写代码体验与观感，非常便利。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><p><code>String</code>类中的<code>substring</code>方法可以从字符串中提取出一个子串。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.substring(<span class="number">1</span>, <span class="number">3</span>);<span class="comment">//s2 = &quot;el&quot;</span></span><br></pre></td></tr></table></figure><p><code>1</code>处填入的是截取开始的位置，<code>3</code>截取结束的位置。（tips：字符串位置跟数组一样是从0开始的）</p><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p>有截取的方法，那自然有拼接的方法，使用<code>+</code>号就可以拼接起两个字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1+s1;<span class="comment">//s2 = &quot;HelloHello&quot;</span></span><br></pre></td></tr></table></figure><p>当一个字符串与非字符串拼接时，非字符串就会转换成字符串进行拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">233</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1 + i;<span class="comment">//s2 = &quot;Hello233&quot;</span></span><br></pre></td></tr></table></figure><p>这种用法我们就常常用在输出结果。</p><p>当我们希望多个字符串放在一起的时候，我们也可以使用<code>join</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> String.join(s1, <span class="string">&quot; &quot;</span>, s2);<span class="comment">//s3 = &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><p>在Java11以上的版本，还提供了一个重复某个字符串多次的方法<code>repeat</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.repeat(<span class="number">3</span>);<span class="comment">//s2 = &quot;HelloHelloHello&quot;</span></span><br></pre></td></tr></table></figure><h3 id="不可变字符串"><a href="#不可变字符串" class="headerlink" title="不可变字符串"></a>不可变字符串</h3><p>Java的字符串与C语言的字符串不太相同，Java字符串不是一个数组，它的字符串不可以修改里面的某一个字符，想修改字符串，只能通过截取字符串，再重新拼接方式来修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Helle&quot;</span>;</span><br><span class="line">s1 = s1.substring(<span class="number">0</span>, <span class="number">4</span>)+<span class="string">&quot;o!&quot;</span>;<span class="comment">//s1 = &quot;Hello!&quot; </span></span><br></pre></td></tr></table></figure><h3 id="判断字符串是否相等"><a href="#判断字符串是否相等" class="headerlink" title="判断字符串是否相等"></a>判断字符串是否相等</h3><p>虽然字符串不是一个数组，但是我们也不能通过<code>==</code>来判断是否相等，而是应该用<code>equals</code>方法来判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s1.equals(s2);<span class="comment">// false</span></span><br><span class="line">s1.equals(s3);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果我们想让判断不区分大小写，我们还可以用<code>equalsIgnoreCase</code>来判断。</p><p><code>==</code>判断符只能判断两个字符串是否在同一位置（地址）上，而不能真正判断是否相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(str.substring(<span class="number">0</span>, <span class="number">3</span>) == <span class="string">&quot;Hel&quot;</span>)&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;true&quot;</span>);<span class="comment">//</span></span><br><span class="line">&#125;<span class="comment">//none</span></span><br></pre></td></tr></table></figure><h3 id="构建字符串"><a href="#构建字符串" class="headerlink" title="构建字符串"></a>构建字符串</h3><p>如果我们遇到需要经常拼接的情况，例如读取按键的时候，我们采用上面那种字符串拼接方式，就会导致每次都要构建一个新的<code>String</code>对象，既耗时又浪费空间，效率低下，这时候，我们使用<code>StringBuilder</code>类就可以避免这个问题的发生。</p><p>首先我们需要构建一个空的字符串构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><p>然后就可以使用<code>StringBuilder</code>类的方法来构建字符串了，下面给出部分常用的方法：</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>append(String str &#x2F; char c)</td><td>添加一个字符串 &#x2F; 代码单元</td></tr><tr><td>setCharAt(int i, char c)</td><td>讲第 i 个代码单元替换为 c</td></tr><tr><td>insert(int i, String str &#x2F; char c)</td><td>在 i 的位置插入字符串str &#x2F; 代码单元 c</td></tr><tr><td>delete(int i, int j)</td><td>删除 i 到 j 的代码单元</td></tr></tbody></table><p>在构建完字符串之后就可以使用<code>toString</code>返回一个字符串了。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">builder.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">System.out.println(builder.toString());<span class="comment">//out:helloworld</span></span><br></pre></td></tr></table></figure><h2 id="文件的输入输出"><a href="#文件的输入输出" class="headerlink" title="文件的输入输出"></a>文件的输入输出</h2><p>当我们需要读取一个文件，需要构建一个<code>Scanner</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Path.of(<span class="string">&quot;test.txt&quot;</span>), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure><p><code>Path.of(&quot;...&quot;)</code>这里面填入的是文件的位置，当你填入像上面那种相对地址时，该相对地址是相对于Java虚拟机启动目录的位置，实际上我认为还是填入绝对地址比较方便，例如<code>c:\\testPath\\test.txt</code>、<code>/home/icewindy/testPath/test.txt</code>。</p><p><code>StandardCharsets.UTF_8</code>很容易看出，这里填入的是文件的编码格式，如果不指定文件的编码格式，则会使用运行该程序的机器的“默认编码”，或许会导致不同平台上运行效果的差异，不建议这样使用。</p>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（六）：注解</title>
      <link href="/2022/03/24/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/03/24/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解就是带有一定功能的注释。</p><h3 id="内置的注解"><a href="#内置的注解" class="headerlink" title="内置的注解"></a>内置的注解</h3><h4 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h4><p>该注解我们在前面的学习中也见到过多次了，这个注解是声明下面的方法重写了超类中的方法，如果注解下面的方法没有重写超类中的方法，则编译器报错。</p><h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h4><p>这个注解表示该程序元素是不鼓励使用的，因为通常的，它是危险的，或者是已经存在更好的替代方法。该注解会使编译器在出现该程序元素的代码处发出警告。</p><h4 id="SuppressWarnings-“…”"><a href="#SuppressWarnings-“…”" class="headerlink" title="@SuppressWarnings(“…”)"></a>@SuppressWarnings(“…”)</h4><p>镇压警告。</p><p>它与前面两种注解不太相同，这个注解需要一个参数。</p><p><code>SuppressWarnings</code>常用的参数的表格：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>deprecation</td><td>使用了不赞成使用的类或方法时的警告</td></tr><tr><td>unchecked</td><td>执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。</td></tr><tr><td>fallthrough</td><td>当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。</td></tr><tr><td>path</td><td>在类路径、源文件路径等中有不存在的路径时的警告。</td></tr><tr><td>serial</td><td>当在可序列化的类上缺少 serialVersionUID 定义时的警告。</td></tr><tr><td>finally</td><td>任何 finally 子句不能正常完成时的警告。</td></tr><tr><td>all</td><td>关于以上所有情况的警告。</td></tr></tbody></table><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解的作用是负责注解（定义）其他的注解。</p><h4 id="Target-value-x3D-…"><a href="#Target-value-x3D-…" class="headerlink" title="@Target(value &#x3D; …)"></a>@Target(value &#x3D; …)</h4><p>描述注解适用的范围（注解可以用在什么地方）。</p><p><code>...</code>处填入java.lang.annotation.ElementType 枚举类型，ElementType 常用的枚举常量在下表：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>CONSTRUCTOR</td><td>用于构造方法</td></tr><tr><td>FIELD</td><td>用于成员变量（包括枚举常量）</td></tr><tr><td>LOCAL_VARIABLE</td><td>用于局部变量</td></tr><tr><td>METHOD</td><td>用于方法</td></tr><tr><td>PACKAGE</td><td>用于包</td></tr><tr><td>PARAMETER</td><td>用于类型参数（JDK 1.8新增）</td></tr><tr><td>TYPE</td><td>用于类、接口（包括注解类型）或 enum 声明</td></tr></tbody></table><p>例：</p><p>TestAnnotation：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(value = &#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="meta">@TestAnnotation</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Retention-value-x3D-…"><a href="#Retention-value-x3D-…" class="headerlink" title="@Retention(value &#x3D; …)"></a>@Retention(value &#x3D; …)</h4><p>表示需要在什么级别保存该注释信息，用于描述注解的生命周期。</p><p><code>...</code>处填入java.lang.annotation.RetentionPolicy 枚举类型，RetentionPolicy 有 3 个枚举常量，如下所示：</p><p>SOURCE：在源代码时，该注解生效；</p><p>CLASS：在class文件时，该注解仍然生效；</p><p>RUNTIME：在运行的时候，该注解仍然生效；</p><p>生命周期：SOURCE &lt; CLASS &lt; <strong>RUNTIME（常用）</strong>。</p><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>说明该注解将会包含在javadoc中。</p><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>说明子类可以继承父类中的该注解。</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>使用<code>@interface</code>自定义注解时，自动继承了<code>java.lang.annotation</code>接口。</p><p>自定义注解一般以<code>public @interface ...</code>的格式，在类里生命一个注解时候，需去除<code>public</code>。</p><p>一般来说，当注解内参数只有一个值时，值的名字可以命名为<code>vlaue</code>。因为在注解内参数只有一个值且值的名字为<code>value</code>的时候，往往可以将<code>value</code>省略。</p><p>如果自定义注解里没有成员，则表明是一个标识作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="meta">@MyAnnotation(name = &quot;test&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@MyAnnotation2(&quot;test&quot;)</span><span class="comment">//只有一个参数可以省略value，而且省略只能省略以value命名的参数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><span class="comment">//指定注解的作用目标</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//指定注解的生命周期</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">   <span class="comment">//注解的参数：参数类型+参数名();</span></span><br><span class="line">   String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;<span class="comment">//default表示默认值参数</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;<span class="comment">//如果默认值是-1，则表示不存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><span class="comment">//指定注解的作用目标</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//指定注解的生命周期</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation2 &#123;</span><br><span class="line">   String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可重复注解"><a href="#可重复注解" class="headerlink" title="可重复注解"></a>可重复注解</h3><p>jdk8之前，当我们需要写两个相同的注解A但不同值得时，我们需要造多一个注解B，内部值设置为注解A数组，然后使用注解B包含两个注解A完成这个操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="meta">@BigTest(&#123;@Test(&quot;1&quot;), @Test(&quot;2&quot;)&#125;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface</span> Test&#123;</span><br><span class="line">   String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface</span> BigTest&#123;</span><br><span class="line">   Test[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在jdk8之后引入了一个新的元注解，使得我们可以重复注解——@Repeatable()：</p><ol><li>在注解A中声明@Repeatable()，成员值为注解B</li><li>注解A与注解B的Target、Retention需要相同</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="meta">@Test(&quot;1&quot;)</span></span><br><span class="line">   <span class="meta">@Test(&quot;2&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repeatable(BigTest.class)</span></span><br><span class="line"><span class="meta">@interface</span> Test&#123;</span><br><span class="line">   String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface</span> BigTest&#123;</span><br><span class="line">   Test[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（五）：抽象类、接口、内部类</title>
      <link href="/2022/03/23/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2022/03/23/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象（三）"><a href="#面向对象（三）" class="headerlink" title="面向对象（三）"></a>面向对象（三）</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类用<code>abstract</code>进行修饰。</p><p>在前面的学习我们知道，所有的对象都是通过类来描绘的，但是不是所有的类都是用来描述对象的，如果一个类中没有足够的成员来描绘一个具体的对象，那这个类就是抽象类。</p><p>简而言之，抽象类里面可以什么东西都不用去实现，只留有一个大概的框架，作为对后面继承的子类的约束。</p><p>抽象类里面可以有正常的方法，也可以有用<code>abstract</code>修饰的抽象方法，抽象方法也同样是可以不去实现的。</p><p>实际上受限于Java只能单继承，抽象类使用并不如接口常见。</p><p>总结一下，抽象类的特点：</p><ol><li>抽象类无法实例化，也就是无法new出来，它需要靠子类去实现它；</li><li>子类继承抽象类需要实现抽象类内的内容，除非子类也是个抽象类；</li><li>抽象类里可以写普通方法，但是抽象方法必须在抽象类中；静态方法，也就是被<code>static</code>修饰的方法，不能被声明为抽象方法；</li><li>抽象类含有构造器，是为了被子类继承，子类必须调用父类构造器。</li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">      student.run();<span class="comment">//out：I am running.</span></span><br><span class="line">      student.say();<span class="comment">//out：I am studying.</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person（抽象类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;I am running.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student（子类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;I am studying.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口与抽象类比较相似，但它并不是一个类，因此他并不是用<code>class</code>来声明，而是使用<code>interface</code>。抽象类和接口的区别在于，抽象类可以有具体实现和抽象方法，而接口只存在抽象方法。</p><p>接口是对类的实现进行一种约束，也就是一种<code>你是什么就应该做什么</code>的规范，也就是例如，人你就得会吃饭，汽车你就得会跑，但是你怎么吃饭，汽车怎么跑，这是类应该去描绘的内容。接口实现了约束和实现的分离。</p><h4 id="接口的特性"><a href="#接口的特性" class="headerlink" title="接口的特性"></a>接口的特性</h4><ol><li>接口中的方法都是<code>public abstract</code>的，而且只能是<code>public abstract</code>的；</li><li>接口中可以含有变量，但是变量都是<code>public static final</code>的，而且只能是<code>public</code>的；</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的来实现接口的方法。</li></ol><p>类用<code>implements</code>关键词来实现接口。跟抽象类一样，实现了接口的类，就需要重写接口中的方法。与只能继承一个抽象类不同，类可以实现多个接口。</p><p>接口和接口直接也是可以互相继承的，同样也是使用<code>extend</code>来继承。虽然他有继承关系，但是接口里是不存在构造器的。</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>PersonImple：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonImpl</span> <span class="keyword">implements</span> <span class="title class_">Person</span>,Clothes&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">color</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Animal：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Clothes：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Clothes</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">color</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类是在一个类的内部再定义一个类。</p><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>由于该内部类嵌套在外部类内，我们需要先实例化外部类，然后再通过外部类实例化的对象来实例化内部类。</p><p>内部类是可以访问到外部类的私有成员的。</p><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">inner.get();<span class="comment">//out:外部类</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Outer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;外部类&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类可以使用<code>private</code>或<code>protected</code>来修饰，如果你不希望内部类被外部类访问可以使用<code>private </code>修饰符。</p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类可以使用 static 关键字定义，静态内部类就不需要先实例化外部类再实例化内部类了，可以直接实例化内部类。</p><p>如果外部类是非静态的，而内部类是静态的，那么内部类就无法在外部类实例化之前调用外部类的成员了。</p><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br><span class="line">      System.out.println(inner.str2);<span class="comment">//out:内部类</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Outer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;外部类&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;内部类&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类与局部变量一样，不能使用访问控制修饰符和<code>static</code>修饰符，局部内部类仅在当前方法中有效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;&#125;<span class="comment">//内部类</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>这种类我们之前有所使用，我们来举一个例子，应该会很清楚。总所周知接口是不能实例化的，而这个例子却可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">test</span>()&#123;<span class="comment">//实际上这里的效果跟test test = new test()相同</span></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">test</span>&#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（四）：继承、多态</title>
      <link href="/2022/03/17/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/"/>
      <url>/2022/03/17/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象（二）"><a href="#面向对象（二）" class="headerlink" title="面向对象（二）"></a>面向对象（二）</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在前面的学习我们可以知道，类是对某一批对象的抽象，而继承的本质是对某一批类的抽象，类比于现实世界中对动植物进行界门纲目科属种的逐级分类。</p><p>子类（派生类）是父类（基类）的拓展，子类继承父类，我们用<code>extends</code>这个关键词表示继承的关系。（<code>extends v.拓展</code>）子类与父类之间具有一个<code>is</code>的关系，比如学生（子类）是人（父类）。</p><p>子类可以继承父类所有<code>public</code>的属性与方法，而父类<code>private</code>的属性与方法，子类是无法继承的。当我们需要让子类继承父类的属性与方法，且又不被继承关系以外的访问到的时候，我们就需要用到<code>protected</code>关键词，让子类能够继承父类使用<code>protected</code>的属性与方法。</p><p>在Java里，所有的类，都默认直接或者间接继承了<code>Object</code>类。</p><p>注意，在Java里，只有单继承，无多继承，一个子类只能有一个父类。</p><p>tips:在IDEA里，<code>ctrl+h</code>快捷键可以打开继承树，可以很直观看到继承关系。</p><p>例：</p><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">       </span><br><span class="line">      student1.setName(<span class="string">&quot;XiaoMing&quot;</span>);</span><br><span class="line">      student1.setAge(<span class="number">17</span>);</span><br><span class="line">      student1.setID(<span class="number">810</span>);</span><br><span class="line">      student1.setGrade(<span class="number">99</span>);<span class="comment">//无参构造</span></span><br><span class="line">       </span><br><span class="line">      <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;XiaoHong&quot;</span>, <span class="number">16</span>, <span class="number">114</span>, <span class="number">100</span>);<span class="comment">//有参构造</span></span><br><span class="line">      </span><br><span class="line">      System.out.println(student1.getName()+<span class="string">&quot; &quot;</span>+student1.getAge()+<span class="string">&quot; &quot;</span>+student1.getID()+<span class="string">&quot; &quot;</span>+student1.getGrade());<span class="comment">//out:XiaoMing 17 810 99</span></span><br><span class="line">      System.out.println(student2.getName()+<span class="string">&quot; &quot;</span>+student2.getAge()+<span class="string">&quot; &quot;</span>+student2.getID()+<span class="string">&quot; &quot;</span>+student2.getGrade());<span class="comment">//out:XiaoHong 16 114 100</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person:（父类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> String name;</span><br><span class="line">   <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student:（子类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> grade;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> ID;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String aName, <span class="type">int</span> aAge, <span class="type">int</span> aID, <span class="type">int</span> aGrade)</span>&#123;</span><br><span class="line">      name = aName;</span><br><span class="line">      age = aAge;<span class="comment">//子类继承了父类的属性</span></span><br><span class="line">      ID = aID;</span><br><span class="line">      grade = aGrade;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getGrade</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> grade;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGrade</span><span class="params">(<span class="type">int</span> grade)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.grade = grade;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getID</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ID;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setID</span><span class="params">(<span class="type">int</span> ID)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.ID = ID;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p><code>super</code>关键词可以调用父类的属性与方法，用来引用当前对象的父类。</p><p>直接进入例子：</p><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">      <span class="comment">/*out：</span></span><br><span class="line"><span class="comment">      父类无参构造被执行</span></span><br><span class="line"><span class="comment">      子类无参构造被执行</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      student.output();</span><br><span class="line">      <span class="comment">/*out：</span></span><br><span class="line"><span class="comment">      Student</span></span><br><span class="line"><span class="comment">      Student</span></span><br><span class="line"><span class="comment">      Person</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person（父类）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;父类无参构造被执行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student（子类）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//由于子类是不继承父类的构造器，所以这里隐藏着调用父类构造器:super();</span></span><br><span class="line">      <span class="comment">//注意：调用父类构造器时，必须写在子类构造器的第一行</span></span><br><span class="line">      System.out.println(<span class="string">&quot;子类无参构造被执行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span>&#123;</span><br><span class="line">      print();</span><br><span class="line">      <span class="built_in">this</span>.print();</span><br><span class="line">      <span class="built_in">super</span>.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点</strong>：</p><ol><li><code>super</code>只能出现在子类的方法或者构造器中</li><li>当父类没有无参构造时，子类就无法调用父类无参构造，也就是说必须要在子类构造器内写上父类的有参构造。</li></ol><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">super</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>子类可以重写父类的方法。</p><p>方法重写的特点：</p><ol><li>方法名必须相同</li><li>参数列表必须相同（与方法重载不同）</li><li>修饰符：范围可以扩大，不可以缩小。</li></ol><p>tips：在IDEA里，<code>ctrl+inside</code>快捷键可以快速调用方法重写功能。</p><p>不能重写的方法：</p><ol><li>static 方法；</li><li>private 方法；</li><li>final 常量；</li></ol><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">      b.output(); <span class="comment">//out:B-out</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A（父类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;A-out&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B（子类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;<span class="comment">//修饰符范围可以扩大</span></span><br><span class="line">      System.out.println(<span class="string">&quot;B-out&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h4><p>同一个行为具有多个不同表现形式或形态的能力。</p><p>比如在现实世界中，猫和狗（子类）都是动物（父类），他们都会吃（父类继承的方法），但是猫吃鱼，狗吃骨头（方法重写）。</p><h4 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h4><ol><li>继承</li><li>重写</li><li>父类引用指向子类对象<code>Person s2 = new Student();</code></li></ol><p>Demo1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">pet1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">pet2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      pet1.eat();<span class="comment">//Eat:bone</span></span><br><span class="line">      pet2.eat();<span class="comment">//out:Eat fish</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pet（父类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Eat All&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dog（子类1）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Eat bone&quot;</span>);;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cat（子类2）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Eat fish&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态的作用"><a href="#多态的作用" class="headerlink" title="多态的作用"></a>多态的作用</h4><p>提高了代码的拓展性，使用父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用。</p><p>听起来很难理解，我们来看例子就很容易理解这个意思的。</p><p>依然使用上面例子的三个类<code>Pet</code>、<code>Dog</code>、<code>Cat</code>。</p><p>Demo2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">      <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      petEat(dog);<span class="comment">//out:Eat bone</span></span><br><span class="line">      petEat(cat);<span class="comment">//out:Eat fish</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">petEat</span><span class="params">(Pet pet)</span>&#123;</span><br><span class="line">      pet.eat();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态的”局限”"><a href="#多态的”局限”" class="headerlink" title="多态的”局限”"></a>多态的”局限”</h4><p>当某个子类拥有独有的方法的时候，我们多态的写法就无法访问子类独有的方法了。</p><p>我们重写一下<code>Cat</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Eat fish&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playBall</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Cat is playing Ball&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      cat.eat();<span class="comment">//out:Eat fish</span></span><br><span class="line">      cat.playBall();<span class="comment">//error!这个编译是没法通过的</span></span><br><span class="line">      <span class="comment">//Pet类本身是没有playBall()这个方法的，因此是没法通过编译的。</span></span><br><span class="line">      <span class="comment">//在使用多态时，编译看左边，运行看右边。</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><code>instanceof</code>关键词可以用来测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p><p>这种比较需要两边存在关系，否则连编译都没法通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      System.out.println(object <span class="keyword">instanceof</span> Cat);<span class="comment">//out:true</span></span><br><span class="line">      System.out.println(object <span class="keyword">instanceof</span> Pet);<span class="comment">//out:true</span></span><br><span class="line">      System.out.println(object <span class="keyword">instanceof</span> Object);<span class="comment">//out:true</span></span><br><span class="line">      System.out.println(object <span class="keyword">instanceof</span> Dog);<span class="comment">//out:false</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在之前的学习中，我们知道，基本数据类型之间的转换，低转高可以自动转化，高转低需要强制转化，在多态的类型转化也是如此。</p><p>多态本身是子类向父类向上转换（自动转换）的过程，这个过程是默认的，因此上文提到的“局限”就出现了，所以我们需要一种强制转化的方法来是对象可以调用子类独有的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      <span class="comment">//将cat对象转化为Cat类型，就可以使用playBall()这个属于Cat类的方法了。</span></span><br><span class="line">      ((Cat) cat).playBall();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种强制转化的方法，也可以使得子转父，但是在子转父的时候，我们就会损失子类的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（三）：静态方法与非静态方法、参数传递、构造器、封装</title>
      <link href="/2022/03/11/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E3%80%81%E5%B0%81%E8%A3%85/"/>
      <url>/2022/03/11/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E3%80%81%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象（一）"><a href="#面向对象（一）" class="headerlink" title="面向对象（一）"></a>面向对象（一）</h2><p><strong>本质：</strong>以类的方式组织代码，以对象的方式封装数据。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><code>static</code>修饰词所修饰实际上是类的方法或属性，而无<code>static</code>关键词修饰的是在实例化类后，即对象出现后才出现的。</p><h4 id="静态方法-非静态方法"><a href="#静态方法-非静态方法" class="headerlink" title="静态方法   \ 非静态方法"></a>静态方法   \ 非静态方法</h4><p>非静态方法的调用需要先实例化这个类，再进行调用。</p><p>Demo1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Demo2</span> <span class="variable">demo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo2</span>();</span><br><span class="line">demo2.out1();<span class="comment">//非静态方法的调用1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Demo2</span>().out1();<span class="comment">//非静态方法的调用2</span></span><br><span class="line">Demo2.out2();<span class="comment">//这是静态方法的调用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out1</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是非静态方法调用&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">out2</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是静态方法的调用&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>在同一个类中，静态方法不可以直接调用非静态方法，需要先实例化类，非静态方法可以直接互相调用。这是因为静态方法是与类一起加载的，而非静态方法是在类实例化之后才存在的。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>我们先来看一下值传递和引用传递的定义；</p><p><strong>值传递(pass by value)：</strong>在调用函数时，将实际参数复制一份传递到函数中，这样在函数中对参数进行修改，就不会影响到原来的实际参数。</p><p><strong>引用传递(pass by reference)：</strong>在调用函数时，将实际参数的地址直接传递到函数中。这样在函数中对参数进行的修改，就会影响到实际参数。</p><p>在Java中，所有的传递都是值传递。如果参数是基本类型，传递的是基本类型的字面量值的拷贝。如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      System.out.println(a);<span class="comment">//out:1</span></span><br><span class="line">      test.change(a);</span><br><span class="line">      System.out.println(a);<span class="comment">//out:1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">      a = <span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看第二个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      System.out.println(person.name);<span class="comment">//out:null</span></span><br><span class="line">      test.change(person);</span><br><span class="line">      System.out.println(person.name);<span class="comment">//out:IceWindy</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(Person person)</span>&#123;</span><br><span class="line">      person.name = <span class="string">&quot;IceWindy&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>类中的构造器也称为构造方法，是在进行创建对象的时候必须调用的。</p><p>构造器有两个特点：</p><ol><li>必须与类的名字相同。</li><li>必须没有返回值，也不可以写<code>void</code>。</li></ol><p>构造器的作用：</p><ol><li>使用<code>new</code>关键词，实际上是在调用构造器。</li><li>一般用于初始化值。</li></ol><p>tip:在IDEA里使用alt+insert，可以快速生成构造器。</p><p>例子：</p><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">classDemo</span> <span class="variable">demo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">classDemo</span>();<span class="comment">//调用的是无参构造</span></span><br><span class="line">      System.out.println(demo1.str);<span class="comment">//out:null</span></span><br><span class="line">      <span class="type">classDemo</span> <span class="variable">demo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">classDemo</span>(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//调用的是有参构造</span></span><br><span class="line">      System.out.println(demo2.str);<span class="comment">//out:hello world</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">classDemo</span> &#123;</span><br><span class="line">   String str;</span><br><span class="line">   <span class="comment">//无参构造：若无有参构造，无参构造可以隐式</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">classDemo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//有参构造：一旦定义了有参构造，无参构造就必须显示定义</span></span><br><span class="line">   <span class="keyword">public</span>  <span class="title function_">classDemo</span><span class="params">(String aStr)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.str = aStr;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>通常的，我们会让类的内部数据操作细节自己完成，不允许外部干涉，仅留有少量的方法给外部使用。</p><p>这时，我们会使用<code>private</code>关键词对对象的属性进行隐藏，仅留下<code>public</code>关键词的方法可以对属性进行操作和查看。</p><p>封装之后有什么好处呢：</p><ol><li>提高了程序的安全性，保护数据</li><li>隐藏了代码的实现细节</li><li>统一了接口</li><li>增强了可维护性</li></ol><p>例子：</p><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">student</span> <span class="variable">Student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>();</span><br><span class="line">      Student1.setName(<span class="string">&quot;XiaoMing&quot;</span>);</span><br><span class="line">      Student1.setGrade(<span class="number">100</span>);</span><br><span class="line">       </span><br><span class="line">      System.out.println(Student1.getName()+<span class="string">&quot; &quot;</span>+Student1.getGrade());<span class="comment">//out:XiaoMing 100</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>student:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> grade;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getGrade</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> grade;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGrade</span><span class="params">(<span class="type">double</span> grade)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.grade = grade;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（二）：数组、三元运算符</title>
      <link href="/2022/03/09/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2022/03/09/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataType[] array;   <span class="comment">// 首选的方法</span></span><br><span class="line">dataType array[];  <span class="comment">// 效果相同，但不是首选方法</span></span><br></pre></td></tr></table></figure><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array = <span class="keyword">new</span> <span class="title class_">dataType</span>[arraySize];</span><br></pre></td></tr></table></figure><p>创建数组时做了两件事：</p><ol><li>使用<code>dataType[arraySize]</code>创建了一个数组。</li><li>把新创建的数组的引用赋值给变量 <code>array</code>。</li></ol><p>我们也可以讲声明与创建数组合二为一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] array = <span class="keyword">new</span> <span class="title class_">dataType</span>[arraySize];</span><br></pre></td></tr></table></figure><p>还可以使用下面方法来创建数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] array = &#123;value0, value1, ..., valuek&#125;; </span><br></pre></td></tr></table></figure><h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] firstArray = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] secondArray = firstArray;</span><br><span class="line">secondArray[<span class="number">1</span>] = <span class="number">10</span>;<span class="comment">//此时，firstArray[1]的值也变成了10</span></span><br></pre></td></tr></table></figure><p>这种拷贝方式会将两个变量引用到同一个数组。</p><p>如果我们希望的是将一个数组的所有值拷贝到一个新的数组中去，就要使用<code>Arrays</code>类的<code>copyOf</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] secondArray = Arrays.copy0f(firstArray, firstArray.length);</span><br></pre></td></tr></table></figure><p>第二个参数为新数组的长度，我们通常用此方法来增加数组大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] secondArray = Arrays.copy0f(firstArray, <span class="number">2</span> * firstArray.length);</span><br></pre></td></tr></table></figure><p>当新数组长度小于原数组时，则只拷贝前面的值，后面的值会被裁切丢弃。</p><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p><code>Arrays</code>类中给我们提供了一种排序的方法–快速排序<code>QuickSort</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">in</span>[<span class="number">10000</span>];</span><br><span class="line">...</span><br><span class="line">Arrays.sort(a);</span><br></pre></td></tr></table></figure><p>这种排序方法可以满足大部分排序的需求，当然你也可以选择自己写，那就不在本文的范畴之内了。</p><p>另外<code>Arrays</code>类中还提供了别的方法，有兴趣的可以自行查阅。</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>允许调用方法时传入不定长度的参数，实质上是基于数组的实现。</p><p>例：构造输出最大的数字的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoVarargs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoVarargs</span> <span class="variable">demoVarargs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoVarargs</span>();</span><br><span class="line">        demoVarargs.printMax(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMax</span><span class="params">(<span class="type">double</span>... nums)</span>&#123;<span class="comment">//可变参数</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No argument passed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">double</span> x: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; max)&#123;</span><br><span class="line">                max = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;max:&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x?y:z</span><br></pre></td></tr></table></figure><p>当<code>x==true</code>，则结果为<code>y</code>，否则结果为<code>z</code>。</p><p>注意点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o);<span class="comment">//out:1.0</span></span><br></pre></td></tr></table></figure><p>三元运算符运行的左右两边需要是同一类型，于是int的包装类就自动转换为double的包装类。这与<code>if else</code>有所区别，因此我们在使用三元运算符时需要注意。</p>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（一）：进制表示、Equals、For each循环、方法基础</title>
      <link href="/2022/03/07/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E3%80%81Equals%E3%80%81For%20each%E5%BE%AA%E7%8E%AF%E3%80%81%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/07/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E3%80%81Equals%E3%80%81For%20each%E5%BE%AA%E7%8E%AF%E3%80%81%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示"></a>进制表示</h2><p>二进制0b 十进制 八进制0 十六进制0x</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">010</span>;  <span class="comment">//八进制0 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0x10</span>; <span class="comment">//十六进制0x</span></span><br></pre></td></tr></table></figure><p>out:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 3 16</span><br></pre></td></tr></table></figure><h2 id="Equals"><a href="#Equals" class="headerlink" title="Equals"></a>Equals</h2><p><code>.equals</code>方法可以用来判断字符串是否相等。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(str.equals(<span class="string">&quot;Hello&quot;</span>))&#123; <span class="comment">//判断str是否与Hello相等</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="For-each循环"><a href="#For-each循环" class="headerlink" title="For each循环"></a>For each循环</h2><p>for each element in a：循环A中的每一个元素。</p><p>主要用于数组或集合的增强型for循环。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//For each</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x: nums)&#123;<span class="comment">//遍历数组元素</span></span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是用普通的for表示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    System.out.println(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法基础"><a href="#方法基础" class="headerlink" title="方法基础"></a>方法基础</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>Java的方法跟其他语言的函数类似。</p><p>方法的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">...</span><br><span class="line">方法体</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><p><strong>default</strong> (即默认，什么也不写）：在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br><strong>private</strong>：在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong><br><strong>public</strong>：对所有类可见。使用对象：类、接口、变量、方法<br><strong>protected</strong>：对同一包内的类和其所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。实际上<code>protected</code>的成员，有两种可见：</p><ol><li>父类的<code>protected</code>成员是包内可见的，并且对子类可见；</li><li>若子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的<code>protected</code>方法，而不能访问父类实例的<code>protected</code>方法。</li></ol><p>Father:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.base;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Son:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.icewindy.test;</span><br><span class="line"><span class="keyword">import</span> cn.icewindy.base.Father;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">      father.test();<span class="comment">//Compile Error</span></span><br><span class="line">      test2();<span class="comment">//Compile OK </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">super</span>.test();<span class="comment">//Compile OK ，在override可以调用父类的protected方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h4><p><strong>static</strong>：用来修饰类方法和类变量。详细请看笔记（三）<br><strong>final</strong>：用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。<br><strong>abstract</strong>：用来创建抽象类和抽象方法。<br><strong>synchronized、volatile</strong> ：主要用于线程的编程。</p><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>在同一个类中，有相同的函数名字，但形参不同的函数。</p><p>例：构建一个比较大小的方法<code>max</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(max(<span class="number">10</span>,<span class="number">20</span>));    <span class="comment">//调用的是第一个方法</span></span><br><span class="line">System.out.println(max(<span class="number">10.0</span>,<span class="number">20.0</span>));<span class="comment">//调用的是第二个方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> num1, <span class="type">double</span> num2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法重载的规则：</p><ol><li>方法名称必须相同。</li><li>参数列表必须不同。</li><li>返回值类型可以相同，也可以不同。</li><li>仅仅返回值不同不构成方法的重载。</li></ol><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>Java支持传递同类型的可变参数给一个方法。</p><p>使用方法：</p><p>在方法声明中，在指定参数类型后加一个省略号(…) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数类型... 参数名</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoVarargs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoVarargs</span> <span class="variable">demoVarargs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoVarargs</span>();</span><br><span class="line">        demoVarargs.printMax(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        demoVarargs.printMax(<span class="keyword">new</span> <span class="title class_">double</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMax</span><span class="params">(<span class="type">double</span>... nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No argument passed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">double</span> x: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; max)&#123;</span><br><span class="line">                max = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;max:&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux主要目录</title>
      <link href="/2022/03/06/Linux%E4%B8%BB%E8%A6%81%E7%9B%AE%E5%BD%95/"/>
      <url>/2022/03/06/Linux%E4%B8%BB%E8%A6%81%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>大部分Linux系统的主要目录和内容都遵循着FHS（文件系统层次结构标准）标准，但并不是所有的Linux系统都完全执行FHS标准。</p><p>在FHS中，所有的文件和目录都在跟目录“&#x2F;”下，无论他们是否在同一物理设备中（例如不在同一硬盘中）。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>图表来自维基百科：</p><table><thead><tr><th align="left">目录</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>/</code></td><td align="left"><em>第一层次结构</em> 的根、 整个文件系统层次结构的<a href="https://zh.m.wikipedia.org/wiki/%E6%A0%B9%E7%9B%AE%E5%BD%95">根目录</a>。</td></tr><tr><td align="left"><code>/bin/</code></td><td align="left">需要在<a href="https://zh.m.wikipedia.org/wiki/%E5%96%AE%E7%94%A8%E6%88%B6%E6%A8%A1%E5%BC%8F">单用户模式</a>可用的必要命令（<a href="https://zh.m.wikipedia.org/wiki/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">可执行文件</a>）；面向所有用户，<em>例如</em>： <a href="https://zh.m.wikipedia.org/wiki/Cat_(Unix)">cat</a>、 <a href="https://zh.m.wikipedia.org/wiki/Ls">ls</a>、 <a href="https://zh.m.wikipedia.org/wiki/Cp_(Unix)">cp</a>。</td></tr><tr><td align="left"><code>/boot/</code></td><td align="left"><a href="https://zh.m.wikipedia.org/wiki/%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F">引导程序</a>文件，<em>例如：</em> <a href="https://zh.m.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">kernel</a>、<a href="https://zh.m.wikipedia.org/wiki/Initrd">initrd</a>；时常是一个单独的分区[<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-8">8]</a></td></tr><tr><td align="left"><code>/dev/</code></td><td align="left">必要<a href="https://zh.m.wikipedia.org/wiki/%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">设备</a>, <em>例如：</em><code>/dev/null</code>.</td></tr><tr><td align="left"><code>/etc/</code></td><td align="left">特定主机，系统范围内的<a href="https://zh.m.wikipedia.org/wiki/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a>。关于这个名称目前有争议。在贝尔实验室关于UNIX实现文档的早期版本中，&#x2F;etc 被称为*<a href="https://zh.m.wikipedia.org/wiki/%E7%AD%89%E7%AD%89">etcetera</a>*， [<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-9">9]</a> 这是由于过去此目录中存放所有不属于别处的所有东西（然而，FHS限制&#x2F;etc只能存放静态配置文件，不能包含二进制文件）。 [<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-10">10]</a> 自从早期文档出版以来，目录名称已被以各种方式重新称呼。最近的解释包括<a href="https://zh.m.wikipedia.org/wiki/%E9%80%86%E5%90%91%E9%A6%96%E5%AD%97%E6%AF%8D%E7%BC%A9%E7%95%A5%E8%AF%8D">逆向首字母缩略词</a>如：”可编辑的文本配置”（英文 “Editable Text Configuration”）或”扩展工具箱”（英文 “Extended Tool Chest”）。 [<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-11">11]</a></td></tr><tr><td align="left"><code>/etc/opt/</code></td><td align="left"><code>/opt/</code>的配置文件</td></tr><tr><td align="left"><code>/etc/X11/</code></td><td align="left"><a href="https://zh.m.wikipedia.org/wiki/X_Window%E7%B3%BB%E7%BB%9F">X Window系统</a>(版本11)的配置文件</td></tr><tr><td align="left"><code>/etc/sgml/</code></td><td align="left"><a href="https://zh.m.wikipedia.org/wiki/SGML">SGML</a>的配置文件</td></tr><tr><td align="left"><code>/etc/xml/</code></td><td align="left"><a href="https://zh.m.wikipedia.org/wiki/XML">XML</a>的配置文件</td></tr><tr><td align="left"><code>/home/</code></td><td align="left">用户的<a href="https://zh.m.wikipedia.org/wiki/%E5%AE%B6%E7%9B%AE%E5%BD%95">家目录</a>，包含保存的文件、个人设置等，一般为单独的分区。</td></tr><tr><td align="left"><code>/lib/</code></td><td align="left"><code>/bin/</code> 和 <code>/sbin/</code>中二进制文件必要的<a href="https://zh.m.wikipedia.org/wiki/%E5%87%BD%E5%BC%8F%E5%BA%AB">库</a>文件。</td></tr><tr><td align="left"><code>/media/</code></td><td align="left">可移除媒体(如<a href="https://zh.m.wikipedia.org/wiki/CD-ROM">CD-ROM</a>)的挂载点 (在FHS-2.3中出现)。</td></tr><tr><td align="left"><code>/mnt/</code></td><td align="left">临时<a href="https://zh.m.wikipedia.org/wiki/%E6%8C%82%E8%BD%BD">挂载</a>的文件系统。</td></tr><tr><td align="left"><code>/opt/</code></td><td align="left">可选<a href="https://zh.m.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6">应用软件</a> <a href="https://zh.m.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8C%85">包</a>。[<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-12">12]</a></td></tr><tr><td align="left"><code>/proc/</code></td><td align="left">虚拟<a href="https://zh.m.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件系统</a>，将<a href="https://zh.m.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">内核</a>与<a href="https://zh.m.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B">进程</a>状态归档为文本文件。<em>例如：</em>uptime、 network。在Linux中，对应<a href="https://zh.m.wikipedia.org/wiki/Procfs">Procfs</a>格式挂载。</td></tr><tr><td align="left"><code>/root/</code></td><td align="left"><a href="https://zh.m.wikipedia.org/wiki/%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7">超级用户</a>的<a href="https://zh.m.wikipedia.org/wiki/%E5%AE%B6%E7%9B%AE%E5%BD%95">家目录</a></td></tr><tr><td align="left"><code>/sbin/</code></td><td align="left">必要的系统二进制文件，<em>例如：</em> init、 ip、 mount。</td></tr><tr><td align="left"><code>/srv/</code></td><td align="left">站点的具体<a href="https://zh.m.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE">数据</a>，由系统提供。</td></tr><tr><td align="left"><code>/tmp/</code></td><td align="left">临时文件(参见 <code>/var/tmp</code>)，在系统重启时目录中文件不会被保留。</td></tr><tr><td align="left"><code>/usr/</code></td><td align="left">用于存储只读用户数据的<em>第二层次</em>； 包含绝大多数的(<a href="https://zh.m.wikipedia.org/wiki/%E5%A4%9A%E7%94%A8%E6%88%B7">多</a>)用户工具和应用程序[<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-13">13]</a>，注意不是user的缩写，而是”Unix Software Resource”的缩写。</td></tr><tr><td align="left"><code>/usr/bin/</code></td><td align="left">非必要<a href="https://zh.m.wikipedia.org/wiki/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">可执行文件</a> (在<a href="https://zh.m.wikipedia.org/wiki/%E5%96%AE%E7%94%A8%E6%88%B6%E6%A8%A1%E5%BC%8F">单用户模式</a>中不需要)；面向所有用户。</td></tr><tr><td align="left"><code>/usr/include/</code></td><td align="left">标准<a href="https://zh.m.wikipedia.org/wiki/%E5%A4%B4%E6%96%87%E4%BB%B6">包含文件</a>。</td></tr><tr><td align="left"><code>/usr/lib/</code></td><td align="left"><code>/usr/bin/</code>和<code>/usr/sbin/</code>中二进制文件的<a href="https://zh.m.wikipedia.org/wiki/%E5%BA%93">库</a>。</td></tr><tr><td align="left"><code>/usr/sbin/</code></td><td align="left">非必要的系统二进制文件，<em>例如：</em>大量<a href="https://zh.m.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1">网络服务</a>的<a href="https://zh.m.wikipedia.org/wiki/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">守护进程</a>。</td></tr><tr><td align="left"><code>/usr/share/</code></td><td align="left"><a href="https://zh.m.wikipedia.org/wiki/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">体系结构</a>无关（共享）数据。</td></tr><tr><td align="left"><code>/usr/src/</code></td><td align="left"><a href="https://zh.m.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81">源代码</a>,*例如:*内核源代码及其头文件。</td></tr><tr><td align="left"><code>/usr/X11R6/</code></td><td align="left"><a href="https://zh.m.wikipedia.org/wiki/X_Window%E7%B3%BB%E7%BB%9F">X Window系统</a> 版本 11, Release 6.</td></tr><tr><td align="left"><code>/usr/local/</code></td><td align="left">本地数据的<em>第三层次</em>， 具体到本台主机。通常而言有进一步的子目录， <em>例如：</em><code>bin/</code>、<code>lib/</code>、<code>share/</code>.[<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-14">14]</a></td></tr><tr><td align="left"><code>/var/</code></td><td align="left">变量文件——在正常运行的系统中其内容不断变化的文件，如日志，脱机文件和临时电子邮件文件。有时是一个单独的分区。</td></tr><tr><td align="left"><code>/var/cache/</code></td><td align="left">应用程序缓存数据。这些数据是在本地生成的一个耗时的I&#x2F;O或计算结果。应用程序必须能够再生或恢复数据。缓存的文件可以被删除而不导致数据丢失。</td></tr><tr><td align="left"><code>/var/lib/</code></td><td align="left">状态信息。 由程序在运行时维护的持久性数据。 <em>例如：</em>数据库、包装的系统元数据等。</td></tr><tr><td align="left"><code>/var/lock/</code></td><td align="left">锁文件，一类跟踪当前使用中资源的文件。</td></tr><tr><td align="left"><code>/var/log/</code></td><td align="left">日志文件，包含大量日志文件，为了防止日志占满根分区，生产环境中一般是单独分区。</td></tr><tr><td align="left"><code>/var/mail/</code></td><td align="left">用户的<a href="https://zh.m.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1">电子邮箱</a>。</td></tr><tr><td align="left"><code>/var/run/</code></td><td align="left">自最后一次启动以来运行中的系统的信息，<em>例如：</em>当前登录的用户和运行中的<a href="https://zh.m.wikipedia.org/wiki/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">守护进程</a>、一些守护进程的pid文件、socket文件。现已经被&#x2F;run代替[<a href="https://zh.m.wikipedia.org/zh/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86#cite_note-15">15]</a>。</td></tr><tr><td align="left"><code>/var/spool/</code></td><td align="left">等待处理的任务的<a href="https://zh.m.wikipedia.org/w/index.php?title=%E8%84%B1%E6%9C%BA%E6%96%87%E4%BB%B6&action=edit&redlink=1">脱机文件</a>，<em>例如：</em>打印队列和未读的邮件。</td></tr><tr><td align="left"><code>/var/spool/mail/</code></td><td align="left">用户的邮箱(不鼓励的存储位置)</td></tr><tr><td align="left"><code>/var/tmp/</code></td><td align="left">在系统重启过程中可以保留的临时文件。</td></tr><tr><td align="left"><code>/run/</code></td><td align="left">代替&#x2F;var&#x2F;run目录。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC、GDB食用方法</title>
      <link href="/2022/03/06/GCC%E3%80%81GDB%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2022/03/06/GCC%E3%80%81GDB%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -o test test.c</span><br></pre></td></tr></table></figure><p><code>-o</code>自定义目标文件</p><p><code>-Wall</code>自动提示一些出错警告的信息</p><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><p>在GCC编译时需要添加一个参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -ggdb3 -Wall -o test test.c</span><br></pre></td></tr></table></figure><p>如无报错，即可启动GDB：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb test</span><br></pre></td></tr></table></figure><h3 id="GDB指令"><a href="#GDB指令" class="headerlink" title="GDB指令"></a>GDB指令</h3><p><code>break 10</code>在第十行设置断点。</p><p><code>break test</code>在<code>test</code>函数处设置断点</p><p><code>s / step</code>下一步</p><p><code>c / continue</code>当程序在某一断点处停止后，用该指令可以继续执行，直至遇到断点或者程序结束</p><p><code>u / until</code> 运行程序直到退出循环体</p><p><code>r / run</code>运行</p><p><code>q / quit</code>结束调试</p><p><code>p / print</code>显示某个变量的值</p><p><code>p *array@len</code> 输出数组</p><p><code>enable</code> 恢复失效的断点</p><p><code>disable </code>使断点失效</p><p><code>clear</code> 清除断点</p><p><code>bt / backtrace </code>查看堆栈信息</p><p><code>watch</code>监测某变量或表达式，当发生变化时停止</p>]]></content>
      
      
      <categories>
          
          <category> 新技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora借助Gitee+PicGo-Core实现云图床</title>
      <link href="/2022/03/06/Typora-Gitee-PicgoCore%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/06/Typora-Gitee-PicgoCore%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="云图床搭建"><a href="#云图床搭建" class="headerlink" title="云图床搭建"></a>云图床搭建</h2><p>2022.3.25更新：gitee搭的图床疑似寄了。已经改用阿里云oss。</p><p>这次我们选择的云图床的搭建是基于gitee。gitee服务器位于国内，避免了github被墙的等一系列问题。</p><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>（省略gitee账号创建的过程，如果这都不会，建议不要折腾了）我们看到gitee页面右上角那个加号，然后点击新建仓库。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112213354.png" alt="image-20220112213353460"></p><p>然后输入你自己想要的仓库名称，路径会自动生成跟你仓库名称一样的名称，当然你也可以自己自定义路径名称。</p><p>勾选上开源和设置模板、Readme文件，省去后面初始化的步骤，即可创建好你的仓库。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112213557.png" alt="image-20220112213556929"></p><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>点击你的头像，进入设置。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112214030.png" alt="image-20220112214029486"></p><p>看到安全设置&#x2F;私人密钥。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112214120.png" alt="image-20220112214119534"></p><p>点击“生成新令牌”</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112214157.png" alt="image-20220112214157037"></p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112214214.png" alt="image-20220112214213174"></p><p>填上上描述，勾选上“projects”，生成一串密钥。</p><p><strong>注意：该密钥只会显示一次，注意好保存！！！</strong></p><h2 id="PicGO-Core配置"><a href="#PicGO-Core配置" class="headerlink" title="PicGO-Core配置"></a>PicGO-Core配置</h2><p>接下来我们就来配置PicGo-Core，至于为什么使用Core这种命令行版本，而不使用app这种带ui，是因为我不想在后台开多一个软件。</p><h3 id="配置Typora"><a href="#配置Typora" class="headerlink" title="配置Typora"></a>配置Typora</h3><p>点击“文件” “偏好设置” “图像”。</p><p>将“插入图片时候…”修改为“上传图片”，接着将上传服务修改为”PicGO-Core (command line)”，然后点击下载或更新，等他进度条走完。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112214915.png" alt="image-20220112214914458"></p><p>接着点击验证图片上传选项，出现下面窗口。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112215312.png" alt="image-20220112215311393"></p><p>复制前面一长串类似于“ C:\Users\IceWindy\AppData\Roaming\Typora\picgo\win64\picgo.exe”。</p><h3 id="PicGo-Core插件安装与配置"><a href="#PicGo-Core插件安装与配置" class="headerlink" title="PicGo-Core插件安装与配置"></a>PicGo-Core插件安装与配置</h3><p>打开你的命令行（cmd)，运行如下命令：<strong>（注意：需要安装Node.js！）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Users\IceWindy\AppData\Roaming\Typora\picgo\win64\picgo.exe</span><br><span class="line">.\picgo.exe install gitee-uploader</span><br><span class="line">.\picgo.exe install super-prefix </span><br></pre></td></tr></table></figure><p>在Typora图像设置中，点击打开配置文件，我们就打开了一个json格式的文件，按照我下面的样式填写</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gitee&quot;</span><span class="punctuation">,</span><span class="comment">//当前上传的图床</span></span><br><span class="line">    <span class="attr">&quot;gitee&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icewindy/note-img&quot;</span><span class="punctuation">,</span><span class="comment">//仓库位置</span></span><br><span class="line">      <span class="attr">&quot;branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;master&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">//我们上文提到的生成的gitee密钥</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;note&quot;</span><span class="punctuation">,</span><span class="comment">//上传到你的仓库的文件夹</span></span><br><span class="line">      <span class="attr">&quot;customPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span><span class="comment">//默认即可</span></span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="comment">//插件的启用</span></span><br><span class="line">  <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fileFormat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YYYYMMDDHHmmss&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="comment">//这段是配置时间戳插件的</span></span><br><span class="line">  <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;lastSync&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2022-01-12 10:05:31&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>仓库的位置可以打开你仓库的链接，“icewindy&#x2F;note-img”这地方就是你的仓库位置。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112220530.png" alt="20220112220530"></p><h2 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h2><p>还是打开Typora的图像设置，点击验证图片上传选项，如图即成功。</p><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112222001.png" alt="image-20220112222000592"></p>]]></content>
      
      
      <categories>
          
          <category> 新技能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习笔记（一）：隐性转换、值与引用、for-in与for-of、数组</title>
      <link href="/2022/01/12/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%9A%90%E6%80%A7%E8%BD%AC%E6%8D%A2%E3%80%81%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E3%80%81for-in%E4%B8%8Efor-of%E3%80%81%E6%95%B0%E7%BB%84/"/>
      <url>/2022/01/12/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%9A%90%E6%80%A7%E8%BD%AC%E6%8D%A2%E3%80%81%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E3%80%81for-in%E4%B8%8Efor-of%E3%80%81%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="隐性转换"><a href="#隐性转换" class="headerlink" title="隐性转换"></a>隐性转换</h2><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li><p><code>NaN != NaN</code></p></li><li><p><code>boolean</code>值在比较时会变为<code>number</code></p></li><li><p><code>string</code>和<code>number</code>比较时会变为<code>number</code></p></li><li><p><code>null == undefined</code>，其余任何值与<code>null</code>&#x2F;<code>undefined</code>比较都为<code>false</code></p></li><li><p>原始类型与引用类型比较，会调用<code>toPrimitive</code>方法，具体做法就是先<code>valueOf</code>后<code>toString</code></p></li><li><p>我们在对各种非<code>Number</code>类型运用数学运算符(<code>- * /</code>)时，会先将非<code>Number</code>类型转换为<code>Number</code>类型</p></li><li><p>加法特殊：</p><p>当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</p><p>当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</p><p>当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</p><p><strong>该三点由上到下，优先级从高到低</strong></p></li><li></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123;&#125; + &#123;&#125;</span><br><span class="line"><span class="title class_">NaN</span></span><br></pre></td></tr></table></figure><p>这个问题的原因是，JavaScript 把第一个 <code>&#123;&#125; </code>解释成了一个空的代码块（code block）并忽略了它。<code>NaN</code>其实是表达式<code>+&#123;&#125;</code>计算的结果 (+ 加号以及第二个 {})。 你在这里看到的 <code>+ </code>加号并不是二元运算符「加法」，而是一个一元运算符，作用是将它后面的操作数转换成数字，和 <code>Number() </code>函数完全一样。</p><ol start="9"><li>转换表：</li></ol><p><img src="https://icewindy-blog.oss-cn-shenzhen.aliyuncs.com/20220112212233.png" alt="20220112212233"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>1. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1, 2, 3&#x27;</span> == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>   <strong>true</strong></p><p>2. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>   <strong>false</strong></p><p>3. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> == [<span class="string">&#x27;1&#x27;</span>]</span><br></pre></td></tr></table></figure><p>   <strong>true</strong></p><p>4. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>   <strong>false</strong></p><p>5. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>   <strong>true</strong></p><h2 id="值与引用"><a href="#值与引用" class="headerlink" title="值与引用"></a>值与引用</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ol><li>值类型</li></ol><p>​        数字，字符串，布尔，符号，未定义，空</p><ol start="2"><li>引用类型</li></ol><p>​        对象，函数，数组</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">value</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line">x.<span class="property">value</span> = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>控制台中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x</span><br><span class="line">&gt;&#123;<span class="attr">value</span>:<span class="number">20</span>&#125;</span><br><span class="line">y</span><br><span class="line">&gt;&#123;<span class="attr">value</span>:<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><p>对象不是存储在变量中，而是存储在内存中，变量保存的是对象的内存地址，因此y在复制x的时候，是复制x的内存地址，即x，y都指向同一内存地址，无论通过x还是y去修改这个对象的时候，修改的变化另外一个对象也能看到。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>值类型数据复制值</p><p>引用类型数据或对象复制引用（内存地址）</p><h2 id="for-in与for-of"><a href="#for-in与for-of" class="headerlink" title="for-in与for-of"></a>for-in与for-of</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> object)</span><br></pre></td></tr></table></figure><p>可以循环对象中的每一个成员，可以遍历一个数组，但最好使用<code>for-of</code>。</p><p><code>in</code>可以检查对象中是否包含给定的值</p><h3 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h3><p>从ES6开始，更好遍历数组的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> array)</span><br></pre></td></tr></table></figure><p>在<code>for-of</code>中<code>key</code>直接表示为数组内的一个元素。</p><p>该方法仅可用于可枚举的类型（数组和映射）。</p><h3 id="可用于for-of-的Object方法"><a href="#可用于for-of-的Object方法" class="headerlink" title="可用于for-of 的Object方法"></a>可用于for-of 的Object方法</h3><p><code>Object.key()</code>方法可获得输入对象的所有成员的键，并返回一个数组。</p><p><code>Object.entries()</code>方法可获得输入对象的所有成员的键值对，并返回一个数组。</p><h2 id="克隆一个Object的方法"><a href="#克隆一个Object的方法" class="headerlink" title="克隆一个Object的方法"></a>克隆一个Object的方法</h2><ol><li><pre><code class="javascript">const newObject = Object.assign(&#123;&#125;, oldObject);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   `&#123;&#125;`内不一定要为空，也可以为一个键值对，相当于是在`newObject`里新增一个键值对，然后再将`oldObject`中的成员克隆过来。</span><br><span class="line"></span><br><span class="line">2. 拆分操作符法</span><br><span class="line"></span><br><span class="line">   ```javascript</span><br><span class="line">   const newObject = &#123; ...oldObject &#125;;</span><br></pre></td></tr></table></figure>最简单的方法，该方法相当于是将使用`...`拆分操作符将`oldObject`内的成员读取并拆解出填入`&#123; &#125;`中。</code></pre></li><li><p>for-in法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObject = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> oldObject)</span><br><span class="line">    newObject[key] = oldObject[key];</span><br></pre></td></tr></table></figure><p>最朴素的方法。</p></li></ol><h2 id="JavaScript部分内置对象"><a href="#JavaScript部分内置对象" class="headerlink" title="JavaScript部分内置对象"></a>JavaScript部分内置对象</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p><code>Math</code>参考文档</p><p>[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math]">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math]</a>: </p><p><code>Math</code> 是一个内置对象，它拥有一些数学常数属性和数学函数方法。</p><p>注意:<code>Math</code>并不是一个函数对象</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>JavaScript中<code>string</code>分为两种，一种是值类型字符串，另外一种是<code>String</code>对象 。但在对值类型的字符串使用点操作符时,JavaScript会自动将值转换为对象，可以像操作对象一样操作它。</p><p><code>String</code>参考文档</p><p>[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String]">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String]</a>: </p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><h4 id="In-End"><a href="#In-End" class="headerlink" title="In End"></a>In End</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="title function_">push</span>(anyThings);</span><br></pre></td></tr></table></figure><p><code>anyThings</code>可填入任意元素（不止一个元素）。</p><h4 id="In-Beginning"><a href="#In-Beginning" class="headerlink" title="In Beginning"></a>In Beginning</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="title function_">unshift</span>(anyThings);</span><br></pre></td></tr></table></figure><p><code>anyThings</code>可填入任意元素（不止一个元素）。</p><h4 id="In-Middle"><a href="#In-Middle" class="headerlink" title="In Middle"></a>In Middle</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="title function_">splice</span>(startNumber, deleteCount, anyThings);</span><br></pre></td></tr></table></figure><p><code>startNumber</code>元素的位置。注意：数组从0开始计数。</p><p><code>deleteCount</code>想要删除的元素的个数。</p><p><code>anyThings</code>可填入任意元素（不止一个元素）。</p><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><h4 id="indexOF（查找值）"><a href="#indexOF（查找值）" class="headerlink" title="indexOF（查找值）"></a>indexOF（查找值）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="title function_">indexOF</span>(anyThings, startNumber);</span><br></pre></td></tr></table></figure><p>查找<code>numbers</code>内从<code>startNumber</code>开始（可选）是否存在<code>anyThings</code>元素，如果存在则返回所在位置，如果不存在则返回<code>-1</code>。</p><p>注意：该方法是严格对应类型的，字符类型的<code>&#39;1&#39;</code>与数字类型的<code>1</code>是不同的。</p><p>类似的方法<code>lastIndexOF</code>，返回最后一个匹配的元素。</p><p><code>includes</code>方法可以判断是否存在匹配元素，返回<code>true</code> or  <code>false</code></p><p>以上方法均可以加入第二参数<code>startNumber</code>设定开始查找的位置。</p><h2 id="一些实用技巧补充"><a href="#一些实用技巧补充" class="headerlink" title="一些实用技巧补充"></a>一些实用技巧补充</h2><ol><li><code>$&#123;&#125;</code>占位符用于一对反引号的模板语句中显示表达式或者变量。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Web三板斧 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
